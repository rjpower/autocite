<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="19" family="Times" color="#231f20"/>
	<fontspec id="1" size="15" family="Times" color="#231f20"/>
	<fontspec id="2" size="12" family="Times" color="#231f20"/>
	<fontspec id="3" size="11" family="Times" color="#231f20"/>
	<fontspec id="4" size="6" family="Times" color="#231f20"/>
<text top="173" left="252" width="419" height="22" font="0">Automatic Simpliﬁcation of Obfuscated</text>
<text top="198" left="375" width="173" height="22" font="0">JavaScript Code</text>
<text top="226" left="365" width="183" height="18" font="1">(Extended Abstract)</text>
<text top="225" left="549" width="9" height="13" font="2">⋆</text>
<text top="287" left="315" width="293" height="15" font="2">Gen Lu, Kevin Coogan, and Saumya Debray</text>
<text top="319" left="361" width="202" height="13" font="3">Department of Computer Science</text>
<text top="335" left="383" width="158" height="13" font="3">The University of Arizona</text>
<text top="350" left="388" width="146" height="13" font="3">Tucson, AZ 85721, USA</text>
<text top="366" left="320" width="281" height="14" font="3">{genlu, kpcoogan, debray}@cs.arizona.edu</text>
<text top="436" left="245" width="65" height="12" font="3">Abstract.</text>
<text top="435" left="318" width="361" height="13" font="3">Javascript is a scripting language that is commonly used to</text>
<text top="451" left="245" width="433" height="13" font="3">create sophisticated interactive client-side web applications. It can also</text>
<text top="466" left="245" width="434" height="13" font="3">be used to carry out browser-based attacks on users. Malicious JavaScript</text>
<text top="482" left="245" width="434" height="13" font="3">code is usually highly obfuscated, making detection a challenge. This</text>
<text top="498" left="245" width="434" height="13" font="3">paper describes a simple approach to deobfuscation of JavaScript code</text>
<text top="513" left="245" width="434" height="13" font="3">based on dynamic analysis and slicing. Experiments using a prototype</text>
<text top="529" left="245" width="434" height="13" font="3">implementation indicate that our approach is able to penetrate multiple</text>
<text top="545" left="245" width="434" height="13" font="3">layers of complex obfuscations and extract the core logic of the compu-</text>
<text top="560" left="245" width="40" height="13" font="3">tation.</text>
<text top="615" left="202" width="10" height="18" font="1">1</text>
<text top="615" left="232" width="111" height="18" font="1">Introduction</text>
<text top="660" left="202" width="519" height="15" font="2">A few years ago, most malware was delivered via infected email attachments.</text>
<text top="677" left="202" width="519" height="15" font="2">As email ﬁlters and spam detectors have improved, however, this delivery mech-</text>
<text top="694" left="202" width="519" height="15" font="2">anism has increasingly been replaced by web-based delivery mechanisms, e.g.,</text>
<text top="711" left="202" width="519" height="15" font="2">where a victim is lured to view an infected web page from a browser, which</text>
<text top="729" left="202" width="519" height="15" font="2">then causes malicious payload to be downloaded and executed. Very often, such</text>
<text top="746" left="202" width="519" height="15" font="2">“drive-by downloads” rely on JavaScript code; to avoid detection, the scripts</text>
<text top="763" left="202" width="519" height="15" font="2">are usually highly obfuscated [8]. For example, the Gumblar worm, which in</text>
<text top="780" left="202" width="519" height="15" font="2">mid-2009 was considered to be the fastest-growing threat on the Internet, uses</text>
<text top="797" left="202" width="519" height="15" font="2">Javascript code that is dynamically generated and heavily obfuscated to avoid</text>
<text top="814" left="202" width="211" height="15" font="2">detection and identiﬁcation [11].</text>
<text top="838" left="225" width="496" height="15" font="2">Of course, the simple fact that a web page contains dynamically generated</text>
<text top="855" left="202" width="519" height="15" font="2">and/or obfuscated JavaScript code does not, in itself, make it malicious [5]; to</text>
<text top="873" left="202" width="519" height="15" font="2">establish that we have to ﬁgure out what the code does. Moreover, the func-</text>
<text top="890" left="202" width="519" height="15" font="2">tionality of a piece of code can generally be expressed in many diﬀerent ways.</text>
<text top="907" left="202" width="380" height="15" font="2">For these reasons, simple syntactic rules (e.g., “search for ‘</text>
<text top="908" left="582" width="30" height="13" font="3">eval(</text>
<text top="907" left="612" width="42" height="14" font="2">’ and ‘</text>
<text top="908" left="654" width="62" height="13" font="3">unescape(</text>
<text top="907" left="716" width="5" height="14" font="2">’</text>
<text top="937" left="206" width="6" height="8" font="4">⋆</text>
<text top="937" left="217" width="504" height="13" font="3">This work was supported in part by the National Science Foundation via grant</text>
<text top="953" left="217" width="504" height="13" font="3">nos. CNS-1016058 and CNS-1115829, the Air Force Oﬃce of Scientiﬁc Research via</text>
<text top="969" left="217" width="504" height="13" font="3">grant no. FA9550-11-1-0191, and by a GAANN fellowship from the Department of</text>
<text top="984" left="217" width="215" height="13" font="3">Education award no. P200A070545.</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
<text top="178" left="202" width="186" height="14" font="2">within 15 bytes of each other</text>
<text top="177" left="388" width="333" height="15" font="2">” [11]) turn out to be of limited eﬃcacy when deal-</text>
<text top="195" left="202" width="519" height="15" font="2">ing with obfuscated JavaScript. Current tools that process JavaScript typically</text>
<text top="212" left="202" width="437" height="15" font="2">rely on such syntactic heuristics and so tend to be quite imprecise.</text>
<text top="236" left="225" width="496" height="15" font="2">A better solution would be to use semantics-based techniques that focus on</text>
<text top="253" left="202" width="519" height="15" font="2">the behavior of the code. This is also important and useful for making it pos-</text>
<text top="270" left="202" width="519" height="15" font="2">sible for human analysts to easily understand the inner workings of obfuscated</text>
<text top="287" left="202" width="519" height="15" font="2">JavaScript code so as to deal quickly and eﬀectively with new web-based mal-</text>
<text top="305" left="202" width="519" height="15" font="2">ware. Unfortunately, current techniques for behavioral analysis of obfuscated</text>
<text top="322" left="202" width="519" height="15" font="2">JavaScript typically require a signiﬁcant amount of manual intervention, e.g., to</text>
<text top="339" left="202" width="519" height="15" font="2">modify the JavaScript code in speciﬁc ways or to monitor its execution within a</text>
<text top="356" left="202" width="519" height="15" font="2">debugger [13, 17, 22]. Recently, some authors have begun investigating automated</text>
<text top="373" left="202" width="519" height="15" font="2">approaches to dealing with obfuscated JavaScript, e.g., using machine learning</text>
<text top="390" left="202" width="519" height="15" font="2">techniques [3] or symbolic execution of string operations [20]; Section 5 discusses</text>
<text top="407" left="202" width="519" height="15" font="2">these in more detail. This paper takes a diﬀerent approach to the problem: we use</text>
<text top="424" left="202" width="519" height="15" font="2">run-time monitoring to extract execution trace(s) from the obfuscated program,</text>
<text top="441" left="202" width="519" height="15" font="2">apply semantics-preserving code transformations to automatically simplify the</text>
<text top="458" left="202" width="519" height="15" font="2">trace, then reconstruct source code from the simpliﬁed trace. The program so</text>
<text top="475" left="202" width="519" height="15" font="2">obtained is observationally equivalent to the original program for the execution</text>
<text top="492" left="202" width="519" height="15" font="2">considered, but has the obfuscation simpliﬁed away, leaving only the core logic of</text>
<text top="509" left="202" width="519" height="15" font="2">the computation performed by the code. The resulting simpliﬁed code can then</text>
<text top="526" left="202" width="519" height="15" font="2">be examined either by humans or by other software. The removal of the obfus-</text>
<text top="544" left="202" width="519" height="15" font="2">cation results in code that is easier to analyze and understand than the original</text>
<text top="560" left="202" width="519" height="15" font="2">obfuscated program. Experiments using a prototype implementation indicate</text>
<text top="578" left="202" width="519" height="15" font="2">that this approach is able to penetrate multiple layers of complex obfuscations</text>
<text top="595" left="202" width="519" height="15" font="2">and extract the core logic of the underlying computation. Some of the details of</text>
<text top="612" left="202" width="519" height="15" font="2">this work have been omitted from this paper due to space constraints; interested</text>
<text top="629" left="202" width="519" height="15" font="2">readers are referred to the full version of the paper, which is available online [12].</text>
<text top="653" left="225" width="496" height="15" font="2">In addition to obfuscated JavaScript code, web-based malware may also use</text>
<text top="670" left="202" width="519" height="15" font="2">other techniques, such as DOM interactions, to hamper analysis [8]. In such</text>
<text top="688" left="202" width="519" height="15" font="2">situations, simpliﬁcation of obfuscated JavaScript code, while necessary, may not</text>
<text top="705" left="202" width="519" height="15" font="2">be suﬃcient to give a complete picture of what the malware is doing. This paper</text>
<text top="722" left="202" width="519" height="15" font="2">focuses on dealing with obfuscations involving dynamic constructs in JavaScript</text>
<text top="739" left="202" width="519" height="15" font="2">core language; additional issues, such as objects provided by DOM and the</text>
<text top="756" left="202" width="519" height="15" font="2">interactions between JavaScript and DOM, are beyond the scope of this paper</text>
<text top="773" left="202" width="246" height="15" font="2">and are considered to be future work.</text>
<text top="822" left="202" width="10" height="18" font="1">2</text>
<text top="822" left="232" width="105" height="18" font="1">Background</text>
<text top="865" left="202" width="22" height="13" font="2">2.1</text>
<text top="865" left="241" width="78" height="13" font="2">JavaScript</text>
<text top="898" left="202" width="519" height="15" font="2">Despite the similarity in their names and their object-orientation, JavaScript</text>
<text top="915" left="202" width="519" height="15" font="2">is a very diﬀerent language than Java. A JavaScript object consists of a series</text>
<text top="932" left="202" width="519" height="15" font="2">of name/value pairs, where the names are referred to as properties. Another</text>
<text top="949" left="202" width="519" height="15" font="2">signiﬁcant diﬀerence is that while Java is statically typed and has strong type</text>
<text top="966" left="202" width="519" height="15" font="2">checking, JavaScript is dynamically typed. This means that a variable can take</text>
<text top="983" left="202" width="519" height="15" font="2">on values of diﬀerent types at diﬀerent points in a JavaScript program. JavaScript</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
<text top="177" left="202" width="519" height="15" font="2">also makes it very convenient to extend the executing program. For example, one</text>
<text top="195" left="202" width="287" height="15" font="2">can “execute” a string s using the construct</text>
<text top="196" left="493" width="42" height="13" font="3">eval(s)</text>
<text top="195" left="536" width="185" height="15" font="2">. Since the string s can itself</text>
<text top="212" left="202" width="519" height="15" font="2">be constructed at runtime, this makes it possible for JavaScript code to be highly</text>
<text top="229" left="202" width="124" height="15" font="2">dynamic in nature.</text>
<text top="253" left="225" width="496" height="15" font="2">There are some superﬁcial similarities between the two languages at the</text>
<text top="270" left="202" width="519" height="15" font="2">implementation level as well: e.g., both typically use expression-stack-based</text>
<text top="287" left="202" width="519" height="15" font="2">byte-code interpreters, and in both cases modern implementations of these in-</text>
<text top="305" left="202" width="519" height="15" font="2">terpreters come with JIT compilers. However, the language-level diﬀerences</text>
<text top="322" left="202" width="519" height="15" font="2">sketched above are reﬂected in low-level characteristics of the implementations</text>
<text top="339" left="202" width="519" height="15" font="2">as well. For example, Java’s static typing means that the operand types of each</text>
<text top="356" left="202" width="519" height="15" font="2">operation in the program are known at compile time, allowing the compiler to</text>
<text top="373" left="202" width="258" height="15" font="2">generate type-speciﬁc instructions, e.g.,</text>
<text top="374" left="465" width="26" height="13" font="3">iadd</text>
<text top="373" left="495" width="130" height="15" font="2">for integer addition,</text>
<text top="374" left="630" width="30" height="13" font="3">dadd</text>
<text top="373" left="665" width="56" height="15" font="2">for addi-</text>
<text top="390" left="202" width="519" height="15" font="2">tion of double-precision values. In JavaScript, on the other hand, operand types</text>
<text top="407" left="202" width="519" height="15" font="2">are not statically available, which means that the byte code instructions are</text>
<text top="424" left="202" width="519" height="15" font="2">generic. Unlike Java, the code generated for JavaScript does not have an asso-</text>
<text top="441" left="202" width="519" height="15" font="2">ciated class ﬁle, which means that information about constants and strings is</text>
<text top="458" left="202" width="276" height="15" font="2">not readily available. Finally, JavaScript’s</text>
<text top="459" left="483" width="24" height="13" font="3">eval</text>
<text top="458" left="512" width="209" height="15" font="2">construct requires runtime code</text>
<text top="475" left="202" width="519" height="15" font="2">generation: in the SpiderMonkey implementation of JavaScript [15], for example,</text>
<text top="492" left="202" width="228" height="15" font="2">this causes code for the string being</text>
<text top="493" left="434" width="24" height="13" font="3">eval</text>
<text top="492" left="458" width="263" height="15" font="2">ed to be generated into a newly-allocated</text>
<text top="509" left="202" width="519" height="15" font="2">memory region and then executed, after which the memory region is reclaimed.</text>
<text top="534" left="225" width="496" height="15" font="2">The dynamic nature of Javascript code makes possible a variety of obfus-</text>
<text top="551" left="202" width="519" height="15" font="2">cation techniques. Particularly challenging is the combination of the ability to</text>
<text top="568" left="202" width="169" height="15" font="2">execute a string using the</text>
<text top="569" left="377" width="24" height="13" font="3">eval</text>
<text top="568" left="406" width="315" height="15" font="2">construct, as described above, and the fact that</text>
<text top="585" left="202" width="519" height="15" font="2">the string being executed may be obfuscated in a wide variety of ways. Howard</text>
<text top="602" left="202" width="519" height="15" font="2">discusses several such techniques in more detail [8]. Further, dynamic code gener-</text>
<text top="619" left="202" width="57" height="15" font="2">ation via</text>
<text top="620" left="263" width="24" height="13" font="3">eval</text>
<text top="619" left="291" width="264" height="15" font="2">can be multi-layered, e.g., a string that is</text>
<text top="620" left="559" width="24" height="13" font="3">eval</text>
<text top="619" left="583" width="138" height="15" font="2">-ed may itself contain</text>
<text top="636" left="202" width="46" height="15" font="2">calls to</text>
<text top="637" left="253" width="24" height="13" font="3">eval</text>
<text top="636" left="277" width="187" height="15" font="2">, and such embedded calls to</text>
<text top="637" left="469" width="24" height="13" font="3">eval</text>
<text top="636" left="497" width="224" height="15" font="2">can be stacked several layers deep.</text>
<text top="653" left="202" width="519" height="15" font="2">Such obfuscation techniques can make it diﬃcult to determine the intent of a</text>
<text top="670" left="202" width="440" height="15" font="2">JavaScript program from a static examination of the program text.</text>
<text top="720" left="202" width="22" height="13" font="2">2.2</text>
<text top="720" left="241" width="238" height="13" font="2">Semantics-Based Deobfuscation</text>
<text top="754" left="202" width="519" height="15" font="2">Deobfuscation refers to the process of simplifying a program to remove obfusca-</text>
<text top="771" left="202" width="519" height="15" font="2">tion code and produce a functionally equivalent program that is simpler (or, at</text>
<text top="788" left="202" width="519" height="15" font="2">least, no more complex) than the original program relative to some appropriate</text>
<text top="805" left="202" width="519" height="15" font="2">complexity metric. To motivate our approach to deobfuscation, consider the se-</text>
<text top="822" left="202" width="519" height="15" font="2">mantic intuition behind any deobfuscation process. In general, when we simplify</text>
<text top="839" left="202" width="519" height="15" font="2">an obfuscated program we cannot hope to recover the code for the original pro-</text>
<text top="856" left="202" width="519" height="15" font="2">gram, either because the source code is simply not be available, or due to code</text>
<text top="873" left="202" width="519" height="15" font="2">transformations applied during compilation. All we can require, then, is that</text>
<text top="890" left="202" width="519" height="15" font="2">the process of deobfuscation must be semantics-preserving: i.e., that the code</text>
<text top="907" left="202" width="519" height="15" font="2">resulting from deobfuscation be semantically equivalent to the original program.</text>
<text top="932" left="225" width="496" height="15" font="2">For the analysis of potentially-malicious code, a reasonable notion of seman-</text>
<text top="949" left="202" width="519" height="15" font="2">tic equivalence seems to be that of observational equivalence, where two pro-</text>
<text top="966" left="202" width="519" height="15" font="2">grams are considered equivalent if they behave—i.e., interact with their execu-</text>
<text top="983" left="202" width="519" height="15" font="2">tion environment—in the same way. Since a program’s runtime interactions with</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
<text top="177" left="202" width="519" height="15" font="2">the external environment are carried out through system calls, this means that</text>
<text top="195" left="202" width="519" height="15" font="2">two programs are observationally equivalent if they execute identical sequences</text>
<text top="212" left="202" width="437" height="15" font="2">of system calls (together with the argument vectors to these calls).</text>
<text top="236" left="225" width="496" height="15" font="2">This notion of program equivalence suggests a simple approach to deobfus-</text>
<text top="253" left="202" width="519" height="15" font="2">cation: identify all instructions that directly or indirectly aﬀect the values of</text>
<text top="270" left="202" width="519" height="15" font="2">the arguments to system calls. Any remaining instructions, which are by deﬁni-</text>
<text top="287" left="202" width="519" height="15" font="2">tion semantically irrelevant, may be discarded (examples of such semantically-</text>
<text top="305" left="202" width="519" height="15" font="2">irrelevant code include dead and unreachable code used by malware to change</text>
<text top="322" left="202" width="519" height="15" font="2">their byte-signatures in order to avoid detection). The crucial question then</text>
<text top="339" left="202" width="519" height="15" font="2">becomes that of identifying instructions that aﬀect the values of system call</text>
<text top="356" left="202" width="519" height="15" font="2">arguments: for the JavaScript code considered in this paper, we use dynamic</text>
<text top="373" left="202" width="303" height="15" font="2">slicing, applied at the byte-code level, for this.</text>
<text top="435" left="202" width="10" height="18" font="1">3</text>
<text top="435" left="232" width="223" height="18" font="1">JavaScript Deobfuscation</text>
<text top="490" left="202" width="22" height="13" font="2">3.1</text>
<text top="490" left="241" width="71" height="13" font="2">Overview</text>
<text top="687" left="202" width="519" height="15" font="2">Our approach to deobfuscating JavaScript code, shown above, consists of the</text>
<text top="704" left="202" width="100" height="15" font="2">following steps:</text>
<text top="748" left="208" width="523" height="15" font="2">1. Use an instrumented interpreter to obtain an execution trace for the JavaScript</text>
<text top="765" left="228" width="168" height="15" font="2">code under consideration.</text>
<text top="785" left="208" width="513" height="15" font="2">2. Construct a control ﬂow graph from this trace to determine the structure of</text>
<text top="802" left="228" width="169" height="15" font="2">the code that is executed.</text>
<text top="822" left="208" width="513" height="15" font="2">3. Use our dynamic slicing algorithm to identify instructions that are relevant</text>
<text top="839" left="228" width="493" height="15" font="2">to the observable behavior of the program. Ideally, we would like to compute</text>
<text top="856" left="228" width="494" height="15" font="2">slices for the arguments of the system calls made by the program. However,</text>
<text top="873" left="228" width="493" height="15" font="2">the actual system calls are typically made from external library routines that</text>
<text top="890" left="228" width="493" height="15" font="2">appear as native methods. As a proxy for system calls, therefore, our imple-</text>
<text top="907" left="228" width="493" height="15" font="2">mentation computes slices for the arguments passed to any native function.</text>
<text top="927" left="208" width="512" height="15" font="2">4. Decompile excution trace to an abstract syntax tree (AST), and label all the</text>
<text top="944" left="228" width="397" height="15" font="2">nodes constructed from resulting set of relevant instructions.</text>
<text top="963" left="208" width="82" height="15" font="2">5. Eliminate</text>
<text top="964" left="296" width="28" height="13" font="3">goto</text>
<text top="963" left="328" width="393" height="15" font="2">statements from the AST, then traverse it to generate deob-</text>
<text top="980" left="228" width="419" height="15" font="2">fuscated source code by printing only labeled syntax tree nodes.</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
<text top="178" left="202" width="22" height="13" font="2">3.2</text>
<text top="178" left="241" width="217" height="13" font="2">Instrumentation and Tracing</text>
<text top="215" left="202" width="519" height="15" font="2">We instrument the JavaScript interpreter to collect a trace of the program’s</text>
<text top="232" left="202" width="519" height="15" font="2">execution. Each byte-code instruction is instrumented to print out the instruc-</text>
<text top="249" left="202" width="519" height="15" font="2">tion’s address, operation mnemonic, and length (in bytes) together with any</text>
<text top="266" left="202" width="519" height="15" font="2">additional information about the instruction that may be relevant, including ex-</text>
<text top="283" left="202" width="519" height="15" font="2">pression stack usage, encoded constants, variable names/IDs, branch oﬀets and</text>
<text top="300" left="202" width="519" height="15" font="2">object related data. Due to the space constraints, detailed description of the</text>
<text top="317" left="202" width="404" height="15" font="2">format and processing of the execution trace is not presented.</text>
<text top="371" left="202" width="22" height="13" font="2">3.3</text>
<text top="371" left="241" width="256" height="13" font="2">Control Flow Graph Construction</text>
<text top="408" left="202" width="519" height="15" font="2">In principle, the (static) control ﬂow graph for a JavaScript program can be</text>
<text top="425" left="202" width="519" height="15" font="2">obtained fairly easily. The byte-code for each function in a JavaScript program</text>
<text top="442" left="202" width="519" height="15" font="2">can be obtained as a property of that function object, and it is straightforward to</text>
<text top="459" left="202" width="519" height="15" font="2">decompile this byte-code to an abstract syntax tree. In practice, the control ﬂow</text>
<text top="476" left="202" width="519" height="15" font="2">graph so obtained may not be very useful if the intent is to simplify obfuscations</text>
<text top="493" left="202" width="411" height="15" font="2">away. The reason for this is that dynamic constructs such as</text>
<text top="494" left="619" width="24" height="13" font="3">eval</text>
<text top="493" left="644" width="78" height="15" font="2">, commonly</text>
<text top="510" left="202" width="519" height="15" font="2">used to obfuscate JavaScript code, are essentially opaque in the static control ﬂow</text>
<text top="527" left="202" width="519" height="15" font="2">graph: their runtime behavior—which is what we are really interested in—cannot</text>
<text top="544" left="202" width="519" height="15" font="2">be easily determined from an inspection of the static control ﬂow graph. For this</text>
<text top="561" left="202" width="519" height="15" font="2">reason, we opt instead for a dynamic control ﬂow graph, which is obtained from</text>
<text top="578" left="202" width="519" height="15" font="2">an execution trace of the program. However, while the dynamic control ﬂow</text>
<text top="595" left="202" width="519" height="15" font="2">graph gives us more information about the runtime behavior of constructs such</text>
<text top="612" left="202" width="13" height="15" font="2">as</text>
<text top="614" left="220" width="24" height="13" font="3">eval</text>
<text top="612" left="245" width="318" height="15" font="2">, it does so at the cost of reduced code coverage.</text>
<text top="637" left="225" width="496" height="15" font="2">The algorithm for constructing a dynamic control ﬂow graph from an execu-</text>
<text top="654" left="202" width="519" height="15" font="2">tion trace is a straightforward adaptation of the algorithm for static control ﬂow</text>
<text top="671" left="202" width="519" height="15" font="2">graph construction, found in standard compiler texts [2, 16], modiﬁed to deal</text>
<text top="688" left="202" width="204" height="15" font="2">with dynamic execution traces.</text>
<text top="741" left="202" width="22" height="13" font="2">3.4</text>
<text top="741" left="241" width="162" height="13" font="2">Deobfuscation Slicing</text>
<text top="778" left="202" width="519" height="15" font="2">As mentioned in Section 2.2, we use dynamic slicing to identify instructions that</text>
<text top="795" left="202" width="519" height="15" font="2">directly or indirectly aﬀect arguments passed to native functions, which has been</text>
<text top="812" left="202" width="519" height="15" font="2">investigated by Wang and Roychoudhury in the context of slicing Java byte-code</text>
<text top="830" left="202" width="519" height="15" font="2">traces [21].We adapt the algorithm of Wang and Roychoudhury in two ways,</text>
<text top="847" left="202" width="519" height="15" font="2">both having to do with the dynamic features of JavaScript used extensively for</text>
<text top="864" left="202" width="519" height="15" font="2">obfuscation. The ﬁrst is that while Wang and Roychoudhury use a static control</text>
<text top="881" left="202" width="519" height="15" font="2">ﬂow graph, we use the dynamic control ﬂow graph discussed in Section 3.3. The</text>
<text top="898" left="202" width="519" height="15" font="2">reason for this is that in our case a static control ﬂow graph does not adequately</text>
<text top="915" left="202" width="487" height="15" font="2">capture the execution behavior of exactly those dynamic constructs, such as</text>
<text top="916" left="693" width="24" height="13" font="3">eval</text>
<text top="915" left="717" width="4" height="15" font="2">,</text>
<text top="932" left="202" width="519" height="15" font="2">that we need to handle when dealing with obfuscated JavaScript. The second is in</text>
<text top="949" left="202" width="132" height="15" font="2">the treatment of the</text>
<text top="950" left="339" width="24" height="13" font="3">eval</text>
<text top="949" left="368" width="302" height="15" font="2">construct during slicing. Consider a statement</text>
<text top="950" left="675" width="42" height="13" font="3">eval(s)</text>
<text top="949" left="717" width="4" height="15" font="2">:</text>
<text top="966" left="202" width="519" height="15" font="2">in the context of deobfuscation, we have to determine the behavior of the code</text>
<text top="983" left="202" width="519" height="15" font="2">obtained from the string s; the actual construction of the string s, however—for</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="5" size="8" family="Times" color="#231f20"/>
<text top="219" left="225" width="39" height="12" font="3">Input</text>
<text top="218" left="263" width="438" height="13" font="3">: A dynamic trace T; a slicing criterion C; a dynamic control ﬂow graph</text>
<text top="234" left="272" width="11" height="10" font="3">G</text>
<text top="233" left="283" width="4" height="13" font="3">;</text>
<text top="250" left="225" width="51" height="12" font="3">Output</text>
<text top="249" left="275" width="67" height="13" font="3">: A slice S;</text>
<text top="274" left="210" width="7" height="7" font="5">1</text>
<text top="271" left="225" width="8" height="10" font="3">S</text>
<text top="271" left="238" width="30" height="13" font="3">:= ∅;</text>
<text top="289" left="210" width="7" height="7" font="5">2</text>
<text top="286" left="225" width="211" height="13" font="3">currFrame := lastFrame := NULL;</text>
<text top="305" left="210" width="7" height="7" font="5">3</text>
<text top="302" left="225" width="79" height="13" font="3">LiveSet := ∅;</text>
<text top="321" left="210" width="7" height="7" font="5">4</text>
<text top="318" left="225" width="171" height="13" font="3">stack := a new empty stack;</text>
<text top="336" left="210" width="7" height="7" font="5">5</text>
<text top="334" left="225" width="6" height="10" font="3">I</text>
<text top="333" left="236" width="292" height="13" font="3">:= instruction instance at the last position in T;</text>
<text top="352" left="210" width="7" height="7" font="5">6</text>
<text top="350" left="225" width="37" height="12" font="3">while</text>
<text top="349" left="266" width="46" height="13" font="3">true do</text>
<text top="368" left="210" width="7" height="7" font="5">7</text>
<text top="364" left="247" width="94" height="13" font="3">inSlice := false;</text>
<text top="383" left="210" width="7" height="7" font="5">8</text>
<text top="380" left="247" width="333" height="13" font="3">Uses := memory addresses and property set used by I;</text>
<text top="399" left="210" width="7" height="7" font="5">9</text>
<text top="396" left="248" width="347" height="13" font="3">Defs := memory addresses and property set deﬁned by I;</text>
<text top="420" left="204" width="14" height="7" font="5">10</text>
<text top="417" left="248" width="106" height="13" font="3">inSlice := I ∈ C ;</text>
<text top="418" left="435" width="274" height="12" font="3">/* add all instructions in C into S */</text>
<text top="436" left="204" width="14" height="7" font="5">11</text>
<text top="434" left="248" width="22" height="12" font="3">if I</text>
<text top="433" left="275" width="171" height="13" font="3">is a return instruction then</text>
<text top="452" left="204" width="14" height="7" font="5">12</text>
<text top="449" left="271" width="166" height="13" font="3">push a new frame on stack;</text>
<text top="467" left="204" width="14" height="7" font="5">13</text>
<text top="465" left="248" width="52" height="12" font="3">else if I</text>
<text top="464" left="306" width="216" height="13" font="3">is an interpreted function call then</text>
<text top="483" left="204" width="14" height="7" font="5">14</text>
<text top="480" left="271" width="151" height="13" font="3">lastFrame := pop(stack);</text>
<text top="499" left="204" width="14" height="7" font="5">15</text>
<text top="496" left="248" width="25" height="12" font="3">else</text>
<text top="514" left="204" width="14" height="7" font="5">16</text>
<text top="511" left="271" width="121" height="13" font="3">lastFrame = NULL;</text>
<text top="530" left="204" width="14" height="7" font="5">17</text>
<text top="528" left="248" width="25" height="12" font="3">end</text>
<text top="546" left="204" width="14" height="7" font="5">18</text>
<text top="543" left="248" width="204" height="13" font="3">currFrame := top frame on stack;</text>
<text top="559" left="248" width="381" height="12" font="3">// inter-function dependence: ignore dependency due to</text>
<text top="558" left="636" width="24" height="13" font="3">eval</text>
<text top="577" left="204" width="14" height="7" font="5">19</text>
<text top="575" left="248" width="22" height="12" font="3">if I</text>
<text top="574" left="275" width="179" height="13" font="3">is an interpreted function call</text>
<text top="574" left="459" width="125" height="14" font="3">∧ I is not eval then</text>
<text top="592" left="204" width="14" height="7" font="5">20</text>
<text top="589" left="271" width="265" height="13" font="3">inSlice := inSlice ∨ lastFrame is not empty;</text>
<text top="608" left="204" width="14" height="7" font="5">21</text>
<text top="606" left="247" width="52" height="12" font="3">else if I</text>
<text top="605" left="306" width="226" height="13" font="3">is a control transfer instruction then</text>
<text top="621" left="271" width="254" height="12" font="3">// intra-function control dependency</text>
<text top="639" left="204" width="14" height="7" font="5">22</text>
<text top="637" left="271" width="19" height="12" font="3">for</text>
<text top="636" left="295" width="412" height="13" font="3">each instruction J in currFrame s.t. J is control-dependent on I do</text>
<text top="655" left="204" width="14" height="7" font="5">23</text>
<text top="652" left="294" width="91" height="13" font="3">inSlice := true;</text>
<text top="671" left="204" width="14" height="7" font="5">24</text>
<text top="668" left="294" width="160" height="13" font="3">remove J from currFrame;</text>
<text top="688" left="204" width="14" height="7" font="5">25</text>
<text top="685" left="271" width="25" height="12" font="3">end</text>
<text top="705" left="204" width="14" height="7" font="5">26</text>
<text top="703" left="248" width="25" height="12" font="3">end</text>
<text top="726" left="204" width="14" height="7" font="5">27</text>
<text top="723" left="248" width="255" height="13" font="3">inSlice := inSlice ∨ (LiveSet ∩ Defs = ∅) ;</text>
<text top="724" left="582" width="127" height="12" font="3">// data dependency</text>
<text top="742" left="204" width="14" height="7" font="5">28</text>
<text top="739" left="248" width="163" height="13" font="3">LiveSet := LiveSet − Defs;</text>
<text top="758" left="204" width="14" height="7" font="5">29</text>
<text top="755" left="248" width="9" height="12" font="3">if</text>
<text top="755" left="263" width="76" height="13" font="3">inSlice then</text>
<text top="755" left="547" width="162" height="12" font="3">// add I into the slice</text>
<text top="773" left="204" width="14" height="7" font="5">30</text>
<text top="770" left="271" width="78" height="13" font="3">add I into S;</text>
<text top="789" left="204" width="14" height="7" font="5">31</text>
<text top="786" left="271" width="133" height="13" font="3">add I into currFrame;</text>
<text top="805" left="204" width="14" height="7" font="5">32</text>
<text top="802" left="271" width="163" height="13" font="3">LiveSet := LiveSet ∪ Uses;</text>
<text top="822" left="204" width="14" height="7" font="5">33</text>
<text top="819" left="247" width="25" height="12" font="3">end</text>
<text top="843" left="204" width="14" height="7" font="5">34</text>
<text top="841" left="247" width="22" height="12" font="3">if I</text>
<text top="840" left="275" width="280" height="13" font="3">is not the ﬁrst instruction instance in T then</text>
<text top="859" left="204" width="14" height="7" font="5">35</text>
<text top="856" left="271" width="6" height="10" font="3">I</text>
<text top="856" left="282" width="228" height="13" font="3">:= previous instruction instance in T;</text>
<text top="875" left="204" width="14" height="7" font="5">36</text>
<text top="872" left="248" width="25" height="12" font="3">else</text>
<text top="890" left="204" width="14" height="7" font="5">37</text>
<text top="888" left="271" width="39" height="12" font="3">break</text>
<text top="887" left="309" width="4" height="13" font="3">;</text>
<text top="906" left="204" width="14" height="7" font="5">38</text>
<text top="904" left="248" width="25" height="12" font="3">end</text>
<text top="923" left="204" width="14" height="7" font="5">39</text>
<text top="921" left="225" width="25" height="12" font="3">end</text>
<text top="936" left="378" width="97" height="13" font="2">Algorithm 1:</text>
<text top="935" left="480" width="54" height="15" font="2">d-slicing</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1188" width="918">
<text top="177" left="202" width="519" height="15" font="2">example, by decryption of some other string or concatenation of a collection of</text>
<text top="195" left="202" width="519" height="15" font="2">string fragments—is simply part of the obfuscation process and is not directly</text>
<text top="212" left="202" width="519" height="15" font="2">relevant for the purpose of understanding the functionality of the program. When</text>
<text top="229" left="202" width="381" height="15" font="2">slicing, therefore, we do not follow dependencies through</text>
<text top="230" left="589" width="24" height="13" font="3">eval</text>
<text top="229" left="619" width="101" height="15" font="2">statements. We</text>
<text top="246" left="202" width="195" height="15" font="2">have to note that because an</text>
<text top="247" left="403" width="24" height="13" font="3">eval</text>
<text top="246" left="427" width="294" height="15" font="2">ed string s depends on some code v doesn’t</text>
<text top="263" left="202" width="519" height="15" font="2">automatically exclude v from the resulting slice; if the real workload depends</text>
<text top="280" left="202" width="466" height="15" font="2">on v, then v would be added to slice regardless of the connection with</text>
<text top="281" left="673" width="24" height="13" font="3">eval</text>
<text top="280" left="698" width="23" height="15" font="2">. In</text>
<text top="297" left="202" width="519" height="15" font="2">other words, only code which is solely used for obfuscation would be eliminated.</text>
<text top="314" left="202" width="298" height="15" font="2">Therefore, an obfuscator cannot simply insert</text>
<text top="315" left="505" width="24" height="13" font="3">eval</text>
<text top="314" left="529" width="192" height="15" font="2">s into the pragram’s dataﬂow</text>
<text top="331" left="202" width="519" height="15" font="2">to hide relevant code. We refer to this algorithm as deobfuscation-slicing, the</text>
<text top="348" left="202" width="241" height="15" font="2">pseudocode is shown in Algorithm 1.</text>
<text top="402" left="202" width="22" height="13" font="2">3.5</text>
<text top="402" left="241" width="307" height="13" font="2">Decompilation and Code Transformation</text>
<text top="439" left="202" width="519" height="15" font="2">The slicing step described in Section 3.4 identiﬁes instructions in the dynamic</text>
<text top="456" left="202" width="519" height="15" font="2">trace that directly or indirectly aﬀect arguments to native function calls, which</text>
<text top="473" left="202" width="519" height="15" font="2">includes functions that invoke system calls. This slice is used to transform the</text>
<text top="490" left="202" width="519" height="15" font="2">control ﬂow graph of the program to an abstract syntax tree (AST) representa-</text>
<text top="507" left="202" width="519" height="15" font="2">tion. We do this in two stages. In the ﬁrst stage, we construct an AST that may</text>
<text top="524" left="202" width="171" height="15" font="2">sometimes contain explicit</text>
<text top="525" left="377" width="28" height="13" font="3">goto</text>
<text top="524" left="409" width="312" height="15" font="2">nodes that capture lower-level control ﬂow. Such</text>
<text top="543" left="202" width="28" height="13" font="3">goto</text>
<text top="541" left="235" width="486" height="15" font="2">nodes are created in two situations: (i) at the end of basic blocks that do</text>
<text top="558" left="202" width="519" height="15" font="2">not end with a brach instruction, and (ii) when an explicit branch instruction</text>
<text top="576" left="202" width="440" height="15" font="2">is encountered. In addition to storing information of target block in</text>
<text top="577" left="647" width="28" height="13" font="3">goto</text>
<text top="576" left="680" width="41" height="15" font="2">nodes,</text>
<text top="593" left="202" width="262" height="15" font="2">we also keep track of a list of preceding</text>
<text top="594" left="469" width="28" height="13" font="3">goto</text>
<text top="593" left="502" width="219" height="15" font="2">nodes in each target node. Loops</text>
<text top="610" left="202" width="519" height="15" font="2">in the control ﬂow graph are identiﬁed using dominator analysis [2] and repre-</text>
<text top="627" left="202" width="415" height="15" font="2">sented in the AST as an indeﬁnite loop structure of the form</text>
<text top="628" left="623" width="93" height="13" font="3">while (1) {. . . }</text>
<text top="627" left="717" width="4" height="15" font="2">,</text>
<text top="644" left="202" width="403" height="15" font="2">with branches out of the loop body represented using explicit</text>
<text top="645" left="610" width="28" height="13" font="3">goto</text>
<text top="644" left="638" width="83" height="15" font="2">s that reﬂect</text>
<text top="661" left="202" width="519" height="15" font="2">the control ﬂow behavior of the low-level code. In the second stage, this AST is</text>
<text top="678" left="202" width="261" height="15" font="2">transformed using semantics-preserving</text>
<text top="679" left="470" width="28" height="13" font="3">goto</text>
<text top="678" left="497" width="224" height="15" font="2">-eliminating code transformations</text>
<text top="695" left="202" width="405" height="15" font="2">that generate valid JavaScript soure code, as described below.</text>
<text top="720" left="225" width="130" height="15" font="2">Joelsson proposed a</text>
<text top="721" left="360" width="28" height="13" font="3">goto</text>
<text top="720" left="393" width="328" height="15" font="2">removal algorithm for decompilation of Java byte-</text>
<text top="737" left="202" width="519" height="15" font="2">code with irreducible CFGs, the algorithm traverses the AST over and over and</text>
<text top="754" left="202" width="519" height="15" font="2">applies a set of transformations whenever possible [9]. We adapt this algorithm to</text>
<text top="771" left="202" width="519" height="15" font="2">handle JavaScript and the instruction set used by the SpiderMonkey JavaScript</text>
<text top="788" left="202" width="468" height="15" font="2">engine [15]. The basic idea is to transform the program so that each</text>
<text top="789" left="676" width="28" height="13" font="3">goto</text>
<text top="788" left="711" width="10" height="15" font="2">is</text>
<text top="805" left="202" width="309" height="15" font="2">either replaced by some other construct, or the</text>
<text top="806" left="517" width="28" height="13" font="3">goto</text>
<text top="805" left="550" width="171" height="15" font="2">and its target are brought</text>
<text top="822" left="202" width="519" height="15" font="2">closer together in a semantics-preserving transformation. Space constraints pre-</text>
<text top="839" left="202" width="519" height="15" font="2">clude a detailed description of our transformation rules; interested readers are</text>
<text top="856" left="202" width="519" height="15" font="2">referred to the full version of the paper [12]. The fact that SpiderMonkey always</text>
<text top="873" left="202" width="519" height="15" font="2">generates byte-code with reducible CFGs (due to the lack of an aggressive code</text>
<text top="890" left="202" width="519" height="15" font="2">optimization phase) and the diﬀerence between JavaScript byte-code and Java</text>
<text top="907" left="202" width="519" height="15" font="2">byte-code, makes it possible for our algorithm to have a smaller set of tranfor-</text>
<text top="924" left="202" width="519" height="15" font="2">mation rules. But it would be straightforward to add more rules, if necessary, to</text>
<text top="942" left="202" width="511" height="15" font="2">handle highly optimized JavaScript byte-code with possibly irreducible CFGs.</text>
<text top="966" left="225" width="496" height="15" font="2">After this transformation step, the syntax tree is traversed again, for each</text>
<text top="984" left="202" width="28" height="13" font="3">goto</text>
<text top="983" left="234" width="487" height="15" font="2">node n, we examine its target node t, if t is the node immediately following</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1188" width="918">
<text top="178" left="202" width="9" height="10" font="2">n</text>
<text top="177" left="211" width="510" height="15" font="2">, then n is removed from syntax tree. The resulting syntax tree is then traversed</text>
<text top="195" left="202" width="519" height="15" font="2">one last time and, for each node labeled by the decompiler described above, the</text>
<text top="212" left="202" width="269" height="15" font="2">corresponding source code is printed out.</text>
<text top="260" left="208" width="78" height="10" font="5">function f(n){</text>
<text top="271" left="219" width="133" height="10" font="5">var t1=n;var t2=n;var k;</text>
<text top="283" left="219" width="162" height="10" font="5">var s4 = &#34;eval(’k=t1+t2;’);&#34;;</text>
<text top="294" left="219" width="178" height="10" font="5">var s3 = &#34;t1=f(t1-1);eval(s4);&#34;;</text>
<text top="305" left="219" width="178" height="10" font="5">var s2 = &#34;t2=f(t2);eval(str3);&#34;;</text>
<text top="317" left="219" width="134" height="10" font="5">var s1 = &#34;if(n&lt;2){k=1;}\</text>
<text top="328" left="253" width="139" height="10" font="5">else{t2=t2-2;eval(s2);}&#34;;</text>
<text top="339" left="219" width="50" height="10" font="5">eval(s1);</text>
<text top="351" left="219" width="50" height="10" font="5">return k;</text>
<text top="362" left="208" width="6" height="10" font="5">}</text>
<text top="374" left="208" width="56" height="10" font="5">var x = 3;</text>
<text top="385" left="208" width="72" height="10" font="5">var y = f(x);</text>
<text top="396" left="208" width="50" height="10" font="5">print(y);</text>
<text top="260" left="502" width="89" height="10" font="5">function fib(i){</text>
<text top="271" left="513" width="178" height="10" font="5">var k;var x = 1;var f1 = &#34;fib(&#34;;</text>
<text top="283" left="513" width="150" height="10" font="5">var f2 = &#34;)&#34;;var s1 = &#34;i-&#34;;</text>
<text top="294" left="513" width="72" height="10" font="5">var s2 = &#34;x&#34;;</text>
<text top="305" left="513" width="39" height="10" font="5">if(i&lt;2)</text>
<text top="317" left="525" width="106" height="10" font="5">eval(&#34;k=&#34;+eval(&#34;s&#34;+</text>
<text top="328" left="552" width="106" height="10" font="5">(x*2).toString()));</text>
<text top="339" left="513" width="22" height="10" font="5">else</text>
<text top="351" left="525" width="162" height="10" font="5">eval(&#34;k=&#34;+f1+s1+x.toString()+</text>
<text top="362" left="552" width="162" height="10" font="5">f2+&#34;+&#34;+f1+s1+(x*2).toString()</text>
<text top="374" left="552" width="28" height="10" font="5">+f2);</text>
<text top="385" left="513" width="50" height="10" font="5">return k;</text>
<text top="396" left="502" width="6" height="10" font="5">}</text>
<text top="408" left="502" width="83" height="10" font="5">var y = fib(3);</text>
<text top="419" left="502" width="50" height="10" font="5">print(y);</text>
<text top="467" left="280" width="88" height="13" font="3">(a) Program P</text>
<text top="473" left="368" width="5" height="9" font="4">1</text>
<text top="467" left="540" width="89" height="13" font="3">(b) Program P</text>
<text top="473" left="629" width="5" height="9" font="4">2</text>
<text top="513" left="349" width="42" height="12" font="3">Fig. 1.</text>
<text top="513" left="396" width="125" height="13" font="3">The test programs P</text>
<text top="518" left="521" width="5" height="9" font="4">1</text>
<text top="513" left="532" width="36" height="13" font="3">and P</text>
<text top="518" left="567" width="5" height="9" font="4">2</text>
<text top="590" left="202" width="10" height="18" font="1">4</text>
<text top="590" left="232" width="190" height="18" font="1">Experimental Results</text>
<text top="634" left="202" width="519" height="15" font="2">We evaluated our ideas using a prototype implementation based on Mozilla’s</text>
<text top="651" left="202" width="519" height="15" font="2">open source JavaScript engine SpiderMonkey [15]. Here we present results for</text>
<text top="668" left="202" width="519" height="15" font="2">two versions of Fibonacci number computation program. We chose them for two</text>
<text top="685" left="202" width="519" height="15" font="2">reasons: ﬁrst, because it contains a variety of language constructs, including con-</text>
<text top="702" left="202" width="519" height="15" font="2">ditionals, recursive function calls, and arithmetic; and second, because it is small</text>
<text top="720" left="202" width="519" height="15" font="2">(which is important given the space constraints of this paper) and familiar (which</text>
<text top="737" left="202" width="492" height="15" font="2">makes it easy to assess the quality of deobfuscation). The ﬁrst of these, P</text>
<text top="743" left="694" width="6" height="11" font="5">1</text>
<text top="737" left="701" width="20" height="15" font="2">, is</text>
<text top="754" left="202" width="519" height="15" font="2">shown in Figure 1(a); this program was hand-obfuscated to incorporate multiple</text>
<text top="771" left="202" width="310" height="15" font="2">nested levels of dynamic code generation using</text>
<text top="772" left="517" width="24" height="13" font="3">eval</text>
<text top="771" left="547" width="174" height="15" font="2">for each level of recursion.</text>
<text top="788" left="202" width="156" height="15" font="2">The second program, P</text>
<text top="794" left="358" width="6" height="11" font="5">2</text>
<text top="788" left="364" width="356" height="15" font="2">, as shown in Figure 1(b), is also hand-obfuscated, in</text>
<text top="805" left="202" width="489" height="15" font="2">which we added dependency between real workload and the value used by</text>
<text top="806" left="697" width="24" height="13" font="3">eval</text>
<text top="822" left="202" width="93" height="15" font="2">(local variable</text>
<text top="823" left="301" width="7" height="13" font="3">x</text>
<text top="822" left="314" width="72" height="15" font="2">in function</text>
<text top="823" left="392" width="15" height="13" font="3">ﬁb</text>
<text top="822" left="407" width="314" height="15" font="2">). Three versions of each of these programs are</text>
<text top="839" left="202" width="519" height="15" font="2">used—the program as-is as well as two obfuscated versions—one using an obfus-</text>
<text top="856" left="202" width="519" height="15" font="2">cator we wrote ourselves that uses many of the obfuscation techniques described</text>
<text top="873" left="202" width="519" height="15" font="2">by Howard [8]; and an online obfuscator [1]. Figures 2 and 3 show the obfuscated</text>
<text top="890" left="202" width="295" height="15" font="2">programs corresponding to input programs P</text>
<text top="897" left="497" width="6" height="11" font="5">1</text>
<text top="890" left="509" width="39" height="15" font="2">and P</text>
<text top="897" left="548" width="6" height="11" font="5">2</text>
<text top="890" left="559" width="80" height="15" font="2">respectively.</text>
<text top="915" left="225" width="496" height="15" font="2">The output of our deobfuscator for these programs is shown in Figure 4.</text>
<text top="932" left="202" width="482" height="15" font="2">Figure 4(a) shows the deobfuscated code for all three versions of program P</text>
<text top="938" left="684" width="6" height="11" font="5">1</text>
<text top="932" left="694" width="26" height="15" font="2">(the</text>
<text top="949" left="202" width="519" height="15" font="2">original code, shown in Figure 1(a), as well as the two obfuscated versions shown</text>
<text top="966" left="202" width="519" height="15" font="2">in Figure 2). Figure 4(b) shows the deobfuscated code for all three versions of the</text>
<text top="983" left="202" width="68" height="15" font="2">program P</text>
<text top="990" left="270" width="6" height="11" font="5">2</text>
<text top="983" left="281" width="441" height="15" font="2">(the original, shown in Figure 1(b), as well as the obfuscated versions</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1188" width="918">
<text top="174" left="202" width="501" height="10" font="5">var cl=[168,183,176,165,182,171,177,176,98,168,171,164,106,176,107,189,184,163,180,98,182,</text>
<text top="185" left="213" width="479" height="10" font="5">115,127,176,125,184,163,180,98,182,116,127,176,125,184,163,180,98,173,125,184,163,180,</text>
<text top="197" left="213" width="496" height="10" font="5">98,181,182,180,118,98,127,98,100,167,184,163,174,106,105,173,127,182,115,109,182,116,125,</text>
<text top="208" left="213" width="496" height="10" font="5">105,107,125,100,125,184,163,180,98,181,182,180,117,98,127,98,100,182,115,127,168,171,164,</text>
<text top="219" left="213" width="490" height="10" font="5">106,182,115,111,115,107,125,167,184,163,174,106,181,182,180,118,107,125,100,125,184,163,</text>
<text top="231" left="213" width="496" height="10" font="5">180,98,181,182,180,116,98,127,98,100,182,116,127,168,171,164,106,182,116,107,125,167,184,</text>
<text top="242" left="213" width="496" height="10" font="5">163,174,106,181,182,180,117,107,125,100,125,184,163,180,98,181,182,180,115,98,127,98,100,</text>
<text top="253" left="213" width="490" height="10" font="5">171,168,106,176,126,116,107,189,173,127,115,125,191,167,174,181,167,189,182,116,127,182,</text>
<text top="265" left="213" width="507" height="10" font="5">116,111,116,125,167,184,163,174,106,181,182,180,116,107,125,191,100,125,75,167,184,163,174,</text>
<text top="276" left="213" width="496" height="10" font="5">106,181,182,180,115,107,125,75,180,167,182,183,180,176,98,173,125,191,184,163,180,98,186,</text>
<text top="288" left="213" width="485" height="10" font="5">98,127,98,117,125,184,163,180,98,187,98,127,98,168,171,164,106,186,107,125,178,180,171,</text>
<text top="299" left="213" width="139" height="10" font="5">176,182,106,187,107,125];</text>
<text top="310" left="202" width="50" height="10" font="5">var ii=0;</text>
<text top="322" left="202" width="67" height="10" font="5">var str=’;’;</text>
<text top="333" left="202" width="156" height="10" font="5">for(ii=0;ii&lt;cl.length;ii++){</text>
<text top="344" left="213" width="206" height="10" font="5">str+= String.fromCharCode(cl[ii]-66);</text>
<text top="356" left="202" width="6" height="10" font="5">}</text>
<text top="367" left="202" width="56" height="10" font="5">eval(str);</text>
<text top="380" left="334" width="254" height="13" font="3">(a) Obfuscated code using our obfuscator.</text>
<text top="409" left="202" width="262" height="10" font="5">eval(function(p,a,c,k,e,d){e=function(c){return</text>
<text top="421" left="213" width="423" height="10" font="5">c};if(!’’.replace(/^/,String)){while(c--){d[c]=k[c]||c}k=[function(e){return</text>
<text top="432" left="213" width="412" height="10" font="5">d[e]}];e=function(){return’\\w+’};c=1};while(c--){if(k[c]){p=p.replace(new</text>
<text top="443" left="213" width="400" height="10" font="5">RegExp(’\\b’+e(c)+’\\b’,’g’),k[c])}}return p}(’17 8(9){0 6=9;0 4=9;0 7;0</text>
<text top="455" left="213" width="362" height="10" font="5">11=&#34;5(\’7=6+4;\’);&#34;;0 10=&#34;6=8(6-1);5(11);&#34;;0 13=&#34;4=8(4);5(10);&#34;;0</text>
<text top="466" left="213" width="300" height="10" font="5">15=&#34;18(9&lt;2){7=1;}20{4=4-2;5(13);}&#34;;5(15);19 7}0 14=3;0</text>
<text top="477" left="213" width="401" height="10" font="5">12=8(14);16(12);’,10,21,’var||||t2|eval|t1|k|f|n|str3|str4|y|str2|x|str1</text>
<text top="489" left="213" width="273" height="10" font="5">|print|function|if|return|else’.split(’|’),0,{}))</text>
<text top="517" left="326" width="271" height="13" font="3">(b) Obfuscated code using online obfuscator.</text>
<text top="563" left="321" width="42" height="12" font="3">Fig. 2.</text>
<text top="562" left="367" width="229" height="13" font="3">Obfuscated versions of the program P</text>
<text top="568" left="596" width="5" height="9" font="4">1</text>
<text top="599" left="202" width="203" height="15" font="2">shown in Figure 3). For both P</text>
<text top="605" left="405" width="6" height="11" font="5">1</text>
<text top="599" left="416" width="39" height="15" font="2">and P</text>
<text top="605" left="455" width="6" height="11" font="5">2</text>
<text top="599" left="462" width="260" height="15" font="2">, the deobfuscator outputs are the same</text>
<text top="616" left="202" width="519" height="15" font="2">for each of the three versions. It can be seen that the recovered code is very close</text>
<text top="633" left="202" width="519" height="15" font="2">to the original, and expresses the same functionality. The results obtained show</text>
<text top="650" left="202" width="519" height="15" font="2">that the technique we have described is eﬀective in simplifying away obfuscation</text>
<text top="667" left="202" width="519" height="15" font="2">code and extracing the underlying logic of obfuscated JavaScript code. This</text>
<text top="684" left="202" width="519" height="15" font="2">holds even when the code is heavily obfuscated with multiple diﬀerent kinds</text>
<text top="701" left="202" width="519" height="15" font="2">of obfuscations, including runtime decryption of strings and multiple levels of</text>
<text top="719" left="202" width="519" height="15" font="2">dynamic code generation and execution, in particular, from simpliﬁed code of</text>
<text top="737" left="202" width="10" height="10" font="2">P</text>
<text top="742" left="212" width="6" height="11" font="5">2</text>
<text top="736" left="223" width="498" height="15" font="2">(Figure 4(b)), we could see that our approach handles those code intented to</text>
<text top="753" left="202" width="100" height="15" font="2">be “hidden” by</text>
<text top="754" left="307" width="24" height="13" font="3">eval</text>
<text top="753" left="336" width="60" height="15" font="2">correctly.</text>
<text top="812" left="202" width="10" height="18" font="1">5</text>
<text top="812" left="232" width="123" height="18" font="1">Related Work</text>
<text top="864" left="202" width="519" height="15" font="2">Most current approaches to dealing with obfuscated JavaScript typically require</text>
<text top="881" left="202" width="519" height="15" font="2">a signiﬁcant amount of manual intervention, e.g., to modify the JavaScript code</text>
<text top="898" left="202" width="519" height="15" font="2">in speciﬁc ways or to monitor its execution within a debugger [13, 17, 22]. There</text>
<text top="915" left="202" width="519" height="15" font="2">are also approaches, such as Caﬀeine Monkey [6], intended to assist with analyz-</text>
<text top="932" left="202" width="519" height="15" font="2">ing obfuscated JavaScript code, by instrumenting JavaScript engine and logging</text>
<text top="949" left="202" width="171" height="15" font="2">the actual string passed to</text>
<text top="950" left="377" width="24" height="13" font="3">eval</text>
<text top="949" left="401" width="320" height="15" font="2">. Similar tools include several browser extensions,</text>
<text top="966" left="202" width="519" height="15" font="2">such as the JavaScript Deobfuscator extension for Firefox [18]. The disadvantage</text>
<text top="983" left="202" width="519" height="15" font="2">of such approaches is that they show all the code that is executed and do not</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1188" width="918">
<text top="205" left="202" width="501" height="10" font="5">var cl=[168,183,176,165,182,171,177,176,98,168,171,164,106,171,107,189,184,163,180,98,173,</text>
<text top="216" left="213" width="501" height="10" font="5">125,184,163,180,98,186,98,127,98,115,125,184,163,180,98,168,115,98,127,98,100,168,171,164,</text>
<text top="228" left="213" width="507" height="10" font="5">106,100,125,184,163,180,98,168,116,98,127,98,100,107,100,125,184,163,180,98,181,115,98,127,</text>
<text top="239" left="213" width="490" height="10" font="5">98,100,171,111,100,125,184,163,180,98,181,116,98,127,98,100,186,100,125,171,168,106,171,</text>
<text top="250" left="213" width="490" height="10" font="5">126,116,107,167,184,163,174,106,100,173,127,100,109,167,184,163,174,106,100,181,100,109,</text>
<text top="262" left="213" width="490" height="10" font="5">106,186,108,116,107,112,182,177,149,182,180,171,176,169,106,107,107,107,125,167,174,181,</text>
<text top="273" left="213" width="490" height="10" font="5">167,189,167,184,163,174,106,100,173,127,100,109,168,115,109,181,115,109,186,112,182,177,</text>
<text top="285" left="213" width="490" height="10" font="5">149,182,180,171,176,169,106,107,109,168,116,109,100,109,100,109,168,115,109,181,115,109,</text>
<text top="296" left="213" width="512" height="10" font="5">106,186,108,116,107,112,182,177,149,182,180,171,176,169,106,107,109,168,116,107,125,191,180,</text>
<text top="307" left="213" width="512" height="10" font="5">167,182,183,180,176,98,173,125,191,184,163,180,98,187,98,127,98,168,171,164,106,117,107,125,</text>
<text top="319" left="213" width="206" height="10" font="5">178,180,171,176,182,106,187,107,125];</text>
<text top="330" left="202" width="50" height="10" font="5">var ii=0;</text>
<text top="341" left="202" width="67" height="10" font="5">var str=’;’;</text>
<text top="353" left="202" width="156" height="10" font="5">for(ii=0;ii&lt;cl.length;ii++){</text>
<text top="364" left="213" width="206" height="10" font="5">str+= String.fromCharCode(cl[ii]-66);</text>
<text top="376" left="202" width="6" height="10" font="5">}</text>
<text top="387" left="202" width="56" height="10" font="5">eval(str);</text>
<text top="415" left="334" width="254" height="13" font="3">(a) Obfuscated code using our obfuscator.</text>
<text top="445" left="202" width="262" height="10" font="5">eval(function(p,a,c,k,e,d){e=function(c){return</text>
<text top="456" left="213" width="301" height="10" font="5">c.toString(36)};if(!’’.replace(/^/,String)){while(c--)</text>
<text top="467" left="213" width="329" height="10" font="5">{d[c.toString(a)]=k[c]||c.toString(a)}k=[function(e){return</text>
<text top="479" left="208" width="323" height="10" font="5">d[e]}];e=function(){return’\\w+’};c=1};while(c--){if(k[c])</text>
<text top="490" left="208" width="344" height="10" font="5">{p=p.replace(new RegExp(’\\b’+e(c)+’\\b’,’g’),k[c])}}return p}</text>
<text top="502" left="208" width="373" height="10" font="5">(’f a(i){0 k;0 4=1;0 6=&#34;a(&#34;;0 8=&#34;)&#34;;0 9=&#34;i-&#34;;0 d=&#34;4&#34;;c(i&lt;2)7(&#34;k=&#34;+7</text>
<text top="513" left="208" width="356" height="10" font="5">(&#34;e&#34;+(4*2).5()));g 7(&#34;k=&#34;+6+9+4.5()+8+&#34;+&#34;+6+9+(4*2).5()+8);h k}0</text>
<text top="524" left="208" width="329" height="10" font="5">b=a(3);j(b);’,21,21,’var||||x|toString|f1|eval|f2|s1|fib|y|</text>
<text top="536" left="208" width="307" height="10" font="5">if|s2|s|function|else|return||print|’.split(’|’),0,{}))</text>
<text top="579" left="326" width="271" height="13" font="3">(b) Obfuscated code using online obfuscator.</text>
<text top="625" left="321" width="42" height="12" font="3">Fig. 3.</text>
<text top="625" left="367" width="229" height="13" font="3">Obfuscated versions of the program P</text>
<text top="630" left="596" width="5" height="9" font="4">2</text>
<text top="711" left="202" width="106" height="10" font="5">function f (arg0) {</text>
<text top="723" left="213" width="100" height="10" font="5">local_var0 = arg0;</text>
<text top="734" left="213" width="100" height="10" font="5">local_var1 = arg0;</text>
<text top="746" left="213" width="67" height="10" font="5">if((arg0&lt;2))</text>
<text top="757" left="224" width="83" height="10" font="5">local_var2 = 1;</text>
<text top="768" left="213" width="33" height="10" font="5">else {</text>
<text top="780" left="224" width="156" height="10" font="5">local_var1 = (local_var1-2);</text>
<text top="791" left="224" width="150" height="10" font="5">local_var1 = f(local_var1);</text>
<text top="803" left="224" width="173" height="10" font="5">local_var0 = f((local_var0-1));</text>
<text top="814" left="224" width="67" height="10" font="5">local_var2 =</text>
<text top="825" left="247" width="134" height="10" font="5">(local_var0+local_var1);</text>
<text top="837" left="213" width="6" height="10" font="5">}</text>
<text top="848" left="213" width="100" height="10" font="5">return local_var2;</text>
<text top="859" left="202" width="6" height="10" font="5">}</text>
<text top="871" left="202" width="44" height="10" font="5">(x = 3);</text>
<text top="882" left="202" width="61" height="10" font="5">(y = f(x));</text>
<text top="894" left="202" width="50" height="10" font="5">print(y);</text>
<text top="921" left="228" width="117" height="13" font="3">(a) Deobfuscated P</text>
<text top="927" left="344" width="5" height="9" font="4">1</text>
<text top="711" left="496" width="117" height="10" font="5">function fib (arg0) {</text>
<text top="723" left="507" width="84" height="10" font="5">(local_var1=1);</text>
<text top="734" left="507" width="67" height="10" font="5">if((arg0&lt;2))</text>
<text top="746" left="518" width="134" height="10" font="5">(local_var0=local_var1);</text>
<text top="757" left="507" width="22" height="10" font="5">else</text>
<text top="768" left="518" width="67" height="10" font="5">(local_var0=</text>
<text top="780" left="530" width="173" height="10" font="5">(fib((arg0-1))+fib((arg0-2))));</text>
<text top="791" left="507" width="100" height="10" font="5">return local_var0;</text>
<text top="803" left="496" width="6" height="10" font="5">}</text>
<text top="814" left="496" width="61" height="10" font="5">(y=fib(3));</text>
<text top="825" left="496" width="50" height="10" font="5">print(y);</text>
<text top="919" left="522" width="117" height="13" font="3">(a) Deobfuscated P</text>
<text top="925" left="638" width="5" height="9" font="4">2</text>
<text top="951" left="299" width="42" height="12" font="3">Fig. 4.</text>
<text top="951" left="346" width="226" height="13" font="3">Deobfuscator outputs for programs P</text>
<text top="956" left="571" width="5" height="9" font="4">1</text>
<text top="951" left="582" width="36" height="13" font="3">and P</text>
<text top="956" left="618" width="5" height="9" font="4">2</text>
</page>
<page number="11" position="absolute" top="0" left="0" height="1188" width="918">
<text top="177" left="202" width="519" height="15" font="2">separate out the code that pertains to the actual logic of the program from the</text>
<text top="195" left="202" width="345" height="15" font="2">code whose only purpose is to deal with obfuscation.</text>
<text top="219" left="225" width="496" height="15" font="2">Recently a few authors have begun looking at automatic analysis of obfus-</text>
<text top="236" left="202" width="519" height="15" font="2">cated and/or malicious JavaScript code. Cova at al. [3] and Curtsinger et al. [5]</text>
<text top="253" left="202" width="519" height="15" font="2">describe the use of machine learning techniques based on a variety of dynamic</text>
<text top="270" left="202" width="519" height="15" font="2">execution features to classify Javascript code as malicious or benign. Such tech-</text>
<text top="287" left="202" width="519" height="15" font="2">niques typically do not focus on automatic deobfuscation, relying instead on the</text>
<text top="305" left="202" width="519" height="15" font="2">heuristics based on behavioral characteristics. A problem with such approaches</text>
<text top="322" left="202" width="519" height="15" font="2">is that, given that obfuscation can also be found in benign code and really is</text>
<text top="339" left="202" width="519" height="15" font="2">simply an indicative of a desire to protect the code against casual inspection,</text>
<text top="356" left="202" width="519" height="15" font="2">classﬁers that rely on obfuscation-oriented features may not be reliable indicators</text>
<text top="373" left="202" width="519" height="15" font="2">of malicious intent. Our technique of automatic deobfuscation can potentially in-</text>
<text top="390" left="202" width="519" height="15" font="2">crease the accuracy of such machine learning techniques by exposing the actual</text>
<text top="407" left="202" width="519" height="15" font="2">logic of the code. Saxena et al. discuss dynamic symbolic execution of JavaScript</text>
<text top="424" left="202" width="519" height="15" font="2">code using constraint-solving over strings [20]. Hallaraker and Vigna describe an</text>
<text top="441" left="202" width="519" height="15" font="2">approach to detecting malicious JavaScript code by monitoring the execution of</text>
<text top="458" left="202" width="519" height="15" font="2">the program and comparing the execution to a set of high-level policies [7]. All</text>
<text top="475" left="202" width="493" height="15" font="2">of these works are very diﬀerent from the approach discussed in this paper.</text>
<text top="500" left="225" width="496" height="15" font="2">There is a rich body of literature dealing with dynamically generated (“un-</text>
<text top="517" left="202" width="519" height="15" font="2">packed”) code in the context of conventional native-code malware executables</text>
<text top="534" left="202" width="519" height="15" font="2">[14, 19, 4, 10]. Much of this work focuses on detecting the fact of unpacking and</text>
<text top="551" left="202" width="519" height="15" font="2">identifying the unpacked code; because of the nature of the code involved, the</text>
<text top="568" left="202" width="519" height="15" font="2">techniques used are necessarily low-level, typically relying on detecting the ex-</text>
<text top="585" left="202" width="519" height="15" font="2">ecution of a previously-modiﬁed memory locations (or pages). By contrast, the</text>
<text top="602" left="202" width="519" height="15" font="2">work described here is not concerned with the identiﬁcation and extraction of</text>
<text top="619" left="202" width="519" height="15" font="2">dynamically-generated code per se, but focuses instead on identifying instruc-</text>
<text top="636" left="202" width="500" height="15" font="2">tions that are relevant to the externally-observable behavior of the program.</text>
<text top="683" left="202" width="10" height="18" font="1">6</text>
<text top="683" left="232" width="104" height="18" font="1">Conclusions</text>
<text top="722" left="202" width="519" height="15" font="2">The prevalence of web-based malware delivery methods, and the common use</text>
<text top="739" left="202" width="519" height="15" font="2">of JavaScript code in infected web pages to download malicious code, makes</text>
<text top="756" left="202" width="519" height="15" font="2">it important to be able to analyze the behavior of JavaScript programs and,</text>
<text top="773" left="202" width="519" height="15" font="2">possibly, classify them as benign or malicious. For malicious JavaScript code,</text>
<text top="790" left="202" width="519" height="15" font="2">it is useful to have automated tools that can help identify the functionality of</text>
<text top="807" left="202" width="519" height="15" font="2">the code. However, such JavaScript code is usually highly obfuscated, and use</text>
<text top="824" left="202" width="519" height="15" font="2">dynamic language constructs that make program analysis diﬃcult. This paper</text>
<text top="841" left="202" width="519" height="15" font="2">describes an approach for dynamic analysis of JavaScript code to simplify away</text>
<text top="858" left="202" width="519" height="15" font="2">the obfuscation and expose the underlying logic of the code. Experiments using</text>
<text top="875" left="202" width="519" height="15" font="2">a prototype implementation indicate that our technique is eﬀective even against</text>
<text top="892" left="202" width="185" height="15" font="2">highly obfuscated programs.</text>
<text top="939" left="202" width="94" height="18" font="1">References</text>
<text top="969" left="209" width="58" height="13" font="3">1. Online</text>
<text top="969" left="282" width="61" height="13" font="3">Javascript</text>
<text top="969" left="359" width="66" height="13" font="3">obfuscator.</text>
<text top="969" left="463" width="257" height="13" font="3">http://www.daftlogic.com/projects-online-</text>
<text top="984" left="227" width="157" height="13" font="3">javascript-obfuscator.htm.</text>
</page>
<page number="12" position="absolute" top="0" left="0" height="1188" width="918">
<text top="179" left="209" width="512" height="13" font="3">2. A. V. Aho, R. Sethi, and J. D. Ullman. Compilers – Principles, Techniques, and</text>
<text top="194" left="227" width="277" height="13" font="3">Tools. Addison-Wesley, Reading, Mass., 1985.</text>
<text top="210" left="209" width="512" height="13" font="3">3. D. Canali, M. Cova, G. Vigna, and C. Kruegel. Prophiler: A fast ﬁlter for the large-</text>
<text top="226" left="227" width="493" height="13" font="3">scale detection of malicious web pages. In Proceedings of the 20th international</text>
<text top="241" left="227" width="358" height="13" font="3">conference on World wide web, pages 197–206. ACM, 2011.</text>
<text top="257" left="209" width="512" height="13" font="3">4. K. Coogan, S. Debray, T. Kaochar, and G. Townsend. Automatic static unpack-</text>
<text top="273" left="227" width="493" height="13" font="3">ing of malware binaries. In Proc. 16th. IEEE Working Conference on Reverse</text>
<text top="288" left="227" width="259" height="13" font="3">Engineering, pages 167–176, October 2009.</text>
<text top="304" left="209" width="512" height="13" font="3">5. C. Curtsinger, B. Livshits, B. Zorn, and C. Seifert. Zozzle: Fast and precise in-</text>
<text top="319" left="227" width="475" height="13" font="3">browser JavaScript malware detection. In USENIX Security Symposium, 2011.</text>
<text top="335" left="209" width="512" height="13" font="3">6. B. Feinstein, D. Peck, and I. SecureWorks. Caﬀeine monkey: Automated collection,</text>
<text top="351" left="227" width="457" height="13" font="3">detection and analysis of malicious JavaScript. Black Hat USA, 2007, 2007.</text>
<text top="366" left="209" width="512" height="13" font="3">7. O. Hallaraker and G. Vigna. Detecting malicious JavaScript code in mozilla. In</text>
<text top="382" left="227" width="493" height="13" font="3">Proc. 10th IEEE International Conference on Engineering of Complex Computer</text>
<text top="398" left="227" width="199" height="13" font="3">Systems, pages 85–94, june 2005.</text>
<text top="413" left="209" width="512" height="13" font="3">8. F. Howard. Malware with your mocha: Obfuscation and antiemulation tricks in-</text>
<text top="429" left="227" width="163" height="13" font="3">malicious JavaScript, 2010.</text>
<text top="445" left="209" width="460" height="13" font="3">9. E. Joelsson. Decompilation for visualization of code optimizations. 2003.</text>
<text top="460" left="202" width="519" height="13" font="3">10. M. G. Kang, P. Poosankam, and H. Yin. Renovo: A hidden code extractor for</text>
<text top="476" left="227" width="494" height="13" font="3">packed executables. In Proc. Fifth ACM Workshop on Recurring Malcode (WORM</text>
<text top="492" left="227" width="139" height="13" font="3">2007), November 2007.</text>
<text top="507" left="202" width="79" height="13" font="3">11. A. Kirk.</text>
<text top="507" left="298" width="295" height="13" font="3">Gumblar and more on Javascript obfuscation.</text>
<text top="507" left="609" width="112" height="13" font="3">Sourceﬁre Vulner-</text>
<text top="523" left="227" width="493" height="13" font="3">ability Research Team. http://vrt-blog.snort.org/2009/05/gumblar-and-more-on-</text>
<text top="539" left="227" width="183" height="13" font="3">javascript.html. May 22, 2009.</text>
<text top="554" left="202" width="50" height="13" font="3">12. Gen</text>
<text top="554" left="267" width="20" height="13" font="3">Lu,</text>
<text top="554" left="302" width="36" height="13" font="3">Kevin</text>
<text top="554" left="353" width="49" height="13" font="3">Coogan,</text>
<text top="554" left="418" width="22" height="13" font="3">and</text>
<text top="554" left="455" width="47" height="13" font="3">Saumya</text>
<text top="554" left="517" width="46" height="13" font="3">Debray.</text>
<text top="554" left="601" width="64" height="13" font="3">Automatic</text>
<text top="554" left="680" width="41" height="13" font="3">simpli-</text>
<text top="570" left="227" width="44" height="13" font="3">ﬁcation</text>
<text top="570" left="289" width="11" height="13" font="3">of</text>
<text top="570" left="318" width="64" height="13" font="3">obfuscated</text>
<text top="570" left="399" width="63" height="13" font="3">JavaScript</text>
<text top="570" left="480" width="31" height="13" font="3">code.</text>
<text top="570" left="555" width="57" height="13" font="3">Technical</text>
<text top="570" left="629" width="41" height="13" font="3">report,</text>
<text top="570" left="687" width="34" height="13" font="3">Dept.</text>
<text top="586" left="227" width="11" height="13" font="3">of</text>
<text top="586" left="257" width="61" height="13" font="3">Computer</text>
<text top="586" left="336" width="48" height="13" font="3">Science,</text>
<text top="586" left="401" width="24" height="13" font="3">The</text>
<text top="586" left="444" width="62" height="13" font="3">University</text>
<text top="586" left="524" width="11" height="13" font="3">of</text>
<text top="586" left="553" width="51" height="13" font="3">Arizona,</text>
<text top="586" left="622" width="49" height="13" font="3">October</text>
<text top="586" left="689" width="31" height="13" font="3">2011.</text>
<text top="602" left="227" width="451" height="12" font="3">http://www.cs.arizona.edu/~debray/Publications/js-deobf-full.pdf</text>
<text top="601" left="678" width="4" height="13" font="3">.</text>
<text top="617" left="202" width="113" height="13" font="3">13. P. Markowski.</text>
<text top="617" left="330" width="390" height="13" font="3">ISC’s four methods of decoding Javascript + 1, March 2010.</text>
<text top="633" left="227" width="409" height="13" font="3">http://blog.vodun.org/2010/03/iscs-four-methods-of-decoding.html.</text>
<text top="648" left="202" width="519" height="13" font="3">14. L. Martignoni, M. Christodorescu, and S. Jha. OmniUnpack: Fast, Generic, and</text>
<text top="664" left="227" width="493" height="13" font="3">Safe Unpacking of Malware. In Proc. 21st Annual Computer Security Applications</text>
<text top="679" left="227" width="171" height="13" font="3">Conference, December 2007.</text>
<text top="695" left="202" width="569" height="13" font="3">15. Mozilla. Spidermonkey JavaScript engine. https://developer.mozilla.org/en/SpiderMonkey.</text>
<text top="711" left="202" width="475" height="13" font="3">16. Steven S. Muchnick. Advanced compiler design and implementation. 1997.</text>
<text top="726" left="202" width="96" height="13" font="3">17. J. Nazario.</text>
<text top="726" left="319" width="265" height="13" font="3">Reverse engineering malicious Javascript.</text>
<text top="726" left="605" width="115" height="13" font="3">CanSecWest 2007,</text>
<text top="742" left="227" width="296" height="13" font="3">http://cansecwest.com/csw07/csw07-nazario.pdf.</text>
<text top="758" left="202" width="96" height="13" font="3">18. W. Palant.</text>
<text top="758" left="321" width="192" height="13" font="3">JavaScript deobfuscator 1.5.7.</text>
<text top="758" left="534" width="186" height="13" font="3">https://addons.mozilla.org/en-</text>
<text top="773" left="227" width="262" height="13" font="3">US/ﬁrefox/addon/javascript-deobfuscator/.</text>
<text top="789" left="202" width="519" height="13" font="3">19. P. Royal, M. Halpin, D. Dagon, R. Edmonds, and W. Lee. Polyunpack: Automating</text>
<text top="805" left="227" width="493" height="13" font="3">the hidden-code extraction of unpack-executing malware. In ACSAC ’06: Proceed-</text>
<text top="820" left="227" width="493" height="13" font="3">ings of the 22nd Annual Computer Security Applications Conference on Annual</text>
<text top="836" left="227" width="397" height="13" font="3">Computer Security Applications Conference, pages 289–300, 2006.</text>
<text top="852" left="202" width="519" height="13" font="3">20. P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song. A symbolic</text>
<text top="867" left="227" width="493" height="13" font="3">execution framework for JavaScript. In Proc. IEEE Symposium on Security and</text>
<text top="883" left="227" width="180" height="13" font="3">Privacy, pages 513–528, 2010.</text>
<text top="899" left="202" width="519" height="13" font="3">21. T. Wang and A. Roychoudhury. Dynamic slicing on java bytecode traces. ACM</text>
<text top="914" left="227" width="493" height="13" font="3">Transactions on Programming Languages and Systems (TOPLAS), 30(2):10, 2008.</text>
<text top="930" left="202" width="121" height="13" font="3">22. D. Wesemann.</text>
<text top="930" left="355" width="366" height="13" font="3">Advanced obfuscated JavaScript analysis, April 2008.</text>
<text top="945" left="227" width="270" height="13" font="3">http://isc.sans.org/diary.html?storyid=4246.</text>
</page>
</pdf2xml>
