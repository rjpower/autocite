<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="15" family="Times" color="#000000"/>
<text top="215" left="385" width="202" height="16" font="0">A Functional Approach to</text>
<text top="258" left="360" width="252" height="16" font="0">Memory-Safe Operating Systems</text>
<text top="371" left="477" width="19" height="16" font="0">by</text>
<text top="415" left="429" width="115" height="16" font="0">Rebekah Leslie</text>
<text top="528" left="285" width="402" height="16" font="0">A dissertation submitted in partial fulﬁllment of the</text>
<text top="552" left="371" width="230" height="16" font="0">requirements for the degree of</text>
<text top="629" left="405" width="163" height="16" font="0">Doctor of Philosophy</text>
<text top="653" left="479" width="15" height="16" font="0">in</text>
<text top="677" left="417" width="139" height="16" font="0">Computer Science</text>
<text top="743" left="392" width="188" height="16" font="0">Dissertation Committee:</text>
<text top="767" left="404" width="164" height="16" font="0">Mark P. Jones, Chair</text>
<text top="790" left="439" width="94" height="16" font="0">James Hook</text>
<text top="814" left="420" width="131" height="16" font="0">Andrew Tolmach</text>
<text top="838" left="416" width="139" height="16" font="0">Jonathan Walpole</text>
<text top="862" left="432" width="107" height="16" font="0">Gernot Heiser</text>
<text top="886" left="406" width="160" height="16" font="0">Jeanette R. Palmiter</text>
<text top="951" left="387" width="197" height="16" font="0">Portland State University</text>
<text top="975" left="462" width="53" height="16" font="0">c 2011</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="1" size="14" family="Helvetica" color="#000000"/>
<text top="203" left="386" width="132" height="19" font="1">All rights reserved</text>
<text top="241" left="333" width="238" height="19" font="1">INFORMATION TO ALL USERS</text>
<text top="260" left="156" width="593" height="19" font="1">The quality of this reproduction is dependent on the quality of the copy submitted.</text>
<text top="299" left="191" width="522" height="19" font="1">In the unlikely event that the author did not send a complete manuscript</text>
<text top="318" left="134" width="636" height="19" font="1">and there are missing pages, these will be noted.  Also,  if material had to be removed, </text>
<text top="337" left="338" width="229" height="19" font="1">a note will indicate the deletion.</text>
<text top="608" left="233" width="459" height="19" font="1">All rights reserved. This edition of the work is protected against</text>
<text top="627" left="253" width="419" height="19" font="1">unauthorized copying under Title 17, United States Code.</text>
<text top="851" left="398" width="109" height="19" font="1">ProQuest LLC.</text>
<text top="870" left="340" width="224" height="19" font="1">789 East Eisenhower Parkway</text>
<text top="889" left="399" width="107" height="19" font="1">P.O. Box 1346</text>
<text top="908" left="346" width="208" height="19" font="1">Ann Arbor,  MI 48106 - 1346</text>
<text top="554" left="401" width="104" height="19" font="1">UMI  3481882</text>
<text top="581" left="334" width="257" height="19" font="1">Copyright  2011  by ProQuest LLC.</text>
<text top="122" left="370" width="171" height="19" font="1">UMI Number:  3481882</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="751" width="5" height="16" font="0">i</text>
<text top="242" left="437" width="99" height="16" font="0">ABSTRACT</text>
<text top="334" left="173" width="626" height="16" font="0">Purely functional languages—with static type systems and dynamic memory man-</text>
<text top="367" left="173" width="626" height="16" font="0">agement using garbage collection—are a known tool for helping programmers to</text>
<text top="399" left="173" width="626" height="16" font="0">reduce the number of memory errors in programs. By using such languages, we</text>
<text top="432" left="173" width="626" height="16" font="0">can establish correctness properties relating to memory-safety through our choice</text>
<text top="464" left="173" width="626" height="16" font="0">of implementation language alone. Unfortunately, the language characteristics that</text>
<text top="497" left="173" width="626" height="16" font="0">make purely functional languages safe also make them more diﬃcult to apply in a</text>
<text top="529" left="173" width="626" height="16" font="0">low-level domain like operating systems construction. The low-level features that</text>
<text top="562" left="173" width="626" height="16" font="0">support the kinds of hardware manipulations required by operating systems are not</text>
<text top="594" left="173" width="626" height="16" font="0">typically available in memory-safe languages with garbage collection. Those that</text>
<text top="627" left="173" width="626" height="16" font="0">are provided may have the ability to violate memory- and type-safety, destroying</text>
<text top="659" left="173" width="525" height="16" font="0">the guarantees that motivate using such languages in the ﬁrst place.</text>
<text top="692" left="199" width="600" height="16" font="0">This work demonstrates that it is possible to bridge the gap between the require-</text>
<text top="724" left="173" width="626" height="16" font="0">ments of operating system implementations and the features of purely functional</text>
<text top="757" left="173" width="626" height="16" font="0">languages without sacriﬁcing type- and memory-safety. In particular, we show</text>
<text top="789" left="173" width="626" height="16" font="0">that this can be achieved by isolating the potentially unsafe memory operations</text>
<text top="822" left="173" width="626" height="16" font="0">required by operating systems in an abstraction layer that is well integrated with</text>
<text top="854" left="173" width="626" height="16" font="0">a purely functional language. The salient features of this abstraction layer are</text>
<text top="887" left="173" width="626" height="16" font="0">that the operations it exposes are memory-safe and yet suﬃciently expressive to</text>
<text top="919" left="173" width="626" height="16" font="0">support the implementation of realistic operating systems. The abstraction layer</text>
<text top="952" left="173" width="626" height="16" font="0">enables systems programmers to perform all of the low-level tasks necessary in</text>
<text top="984" left="173" width="626" height="16" font="0">an OS implementation, such as manipulating an MMU and executing user-level</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="746" width="10" height="16" font="0">ii</text>
<text top="163" left="173" width="626" height="16" font="0">programs, without compromising the static memory-safety guarantees of program-</text>
<text top="195" left="173" width="626" height="16" font="0">ming in a purely functional language. A speciﬁc contribution of this work is an</text>
<text top="228" left="173" width="626" height="16" font="0">analysis of memory-safety for the abstraction layer by formalizing a meaning for</text>
<text top="260" left="173" width="626" height="16" font="0">memory-safety in the presence of virtual-memory using a novel application of non-</text>
<text top="293" left="173" width="626" height="16" font="0">interference security policies. In addition, we evaluate the expressiveness of the</text>
<text top="325" left="173" width="626" height="16" font="0">abstraction layer by implementing the L4 microkernel API, which has a ﬂexible</text>
<text top="358" left="173" width="360" height="16" font="0">set of virtual memory management operations.</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="741" width="15" height="16" font="0">iii</text>
<text top="242" left="428" width="115" height="16" font="0">DEDICATION</text>
<text top="334" left="173" width="626" height="16" font="0">For Joe Hurd, who inspires me every day and without whose loving support this</text>
<text top="367" left="173" width="272" height="16" font="0">work would not have been possible.</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="741" width="14" height="16" font="0">iv</text>
<text top="242" left="387" width="197" height="16" font="0">ACKNOWLEDGMENTS</text>
<text top="334" left="173" width="626" height="16" font="0">This research could not have been accomplished without the help of countless</text>
<text top="367" left="173" width="626" height="16" font="0">others. First and foremost, I would like to thank my advisor, Mark Jones, for his</text>
<text top="399" left="173" width="626" height="16" font="0">unwavering support throughout my graduate school career. In my early days as a</text>
<text top="432" left="173" width="626" height="16" font="0">student his courses inspired and challenged me, and our initial projects together</text>
<text top="464" left="173" width="626" height="16" font="0">set the direction for my research career. In the years that followed, Mark has</text>
<text top="497" left="173" width="626" height="16" font="0">made every eﬀort to be involved with my work and to help me succeed. This work</text>
<text top="529" left="173" width="626" height="16" font="0">has beneﬁted immensely from his contributions, in both research content and in</text>
<text top="562" left="173" width="99" height="16" font="0">presentation.</text>
<text top="594" left="199" width="600" height="16" font="0">The members of the Hasp and Programatica research projects have always</text>
<text top="627" left="173" width="626" height="16" font="0">provided an intellectually stimulating and friendly climate in which to conduct</text>
<text top="659" left="173" width="626" height="16" font="0">research. Andrew Tolmach made signiﬁcant contributions to the design of the ab-</text>
<text top="692" left="173" width="626" height="16" font="0">straction layer presented here, including the memory-safety analysis, and directly</text>
<text top="724" left="173" width="626" height="16" font="0">inﬂuenced its implementation through his work on the House operating system</text>
<text top="757" left="173" width="626" height="16" font="0">and the original H interface. James Hook has also been extremely supportive,</text>
<text top="789" left="173" width="626" height="16" font="0">encouraging me to see the bigger picture and the broader connections of my work.</text>
<text top="822" left="173" width="626" height="16" font="0">My fellow students have provided me with many valuable discussions and pointers</text>
<text top="854" left="173" width="585" height="16" font="0">over the years. I am particularly grateful to Iavor Diatchki and Emir Pa˘sali´</text>
<text top="854" left="750" width="49" height="16" font="0">c, who</text>
<text top="887" left="173" width="626" height="16" font="0">befriended me in those early days when graduate school was a frightening and</text>
<text top="919" left="173" width="626" height="16" font="0">overwhelming place. I am also very grateful to Tim Chevalier and John Ochsner</text>
<text top="952" left="173" width="243" height="16" font="0">for proofreading this document.</text>
<text top="984" left="199" width="600" height="16" font="0">I owe a great debt to my colleagues upon whose work my abstraction layer</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="746" width="9" height="16" font="0">v</text>
<text top="163" left="173" width="626" height="16" font="0">is based, as well as the maintainers of the bare metal Haskell compiler. Thomas</text>
<text top="195" left="173" width="626" height="16" font="0">Hallgren made signiﬁcant contributions to the House operating system and the ﬁrst</text>
<text top="228" left="173" width="626" height="16" font="0">version of the H interface, and has always been available to answer questions and</text>
<text top="260" left="173" width="626" height="16" font="0">to help with debugging. Kenneth Graunke created the version of the Haskell run-</text>
<text top="293" left="173" width="626" height="16" font="0">time system that my implementation relies on, leveraging the work of Adam Wick.</text>
<text top="325" left="173" width="626" height="16" font="0">In addition to his technical contributions, Adam has been an excellent resource</text>
<text top="358" left="173" width="626" height="16" font="0">throughout the process of writing my dissertation, providing a rare example of</text>
<text top="390" left="173" width="626" height="16" font="0">person in the local functional programming community doing primarily low-level</text>
<text top="423" left="173" width="626" height="16" font="0">systems work. Don Stewart taught me about compiler pragmas in GHC and helped</text>
<text top="455" left="173" width="300" height="16" font="0">me to optimize my L4 implementation.</text>
<text top="488" left="199" width="600" height="16" font="0">I would also like to thank Rex Page at the University of Oklahoma. He gave</text>
<text top="520" left="173" width="626" height="16" font="0">me my ﬁrst start in research and functional programming as an undergraduate and</text>
<text top="553" left="173" width="423" height="16" font="0">without his guidance I would not be where I am today.</text>
<text top="585" left="199" width="600" height="16" font="0">Finally, I would like to thank Joe Hurd. There are not words to express how</text>
<text top="618" left="173" width="626" height="16" font="0">valuable his love and support have been in enabling me to complete this process.</text>
<text top="650" left="173" width="626" height="16" font="0">Moreover, the quality of this work has beneﬁted immeasurably from our countless</text>
<text top="683" left="173" width="347" height="16" font="0">discussions and from his proofreading eﬀorts.</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="741" width="14" height="16" font="0">vi</text>
<text top="233" left="436" width="100" height="16" font="0">CONTENTS</text>
<text top="331" left="173" width="591" height="16" font="0">Abstract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="331" left="794" width="6" height="16" font="0">i</text>
<text top="369" left="173" width="591" height="16" font="0">Dedication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="369" left="782" width="17" height="16" font="0">iii</text>
<text top="407" left="173" width="591" height="16" font="0">Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="407" left="783" width="16" height="16" font="0">iv</text>
<text top="444" left="173" width="591" height="16" font="0">List of Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="444" left="783" width="16" height="16" font="0">xi</text>
<text top="482" left="173" width="626" height="16" font="0">List of Figures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiv</text>
<text top="520" left="173" width="10" height="16" font="0">1</text>
<text top="520" left="199" width="564" height="16" font="0">Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="520" left="789" width="10" height="16" font="0">1</text>
<text top="544" left="199" width="22" height="16" font="0">1.1</text>
<text top="544" left="240" width="524" height="16" font="0">Correctness in Operating Systems . . . . . . . . . . . . . . . . . . .</text>
<text top="544" left="790" width="9" height="16" font="0">3</text>
<text top="568" left="199" width="22" height="16" font="0">1.2</text>
<text top="568" left="240" width="524" height="16" font="0">Purely Functional Languages for Memory-Safety . . . . . . . . . . .</text>
<text top="568" left="790" width="9" height="16" font="0">5</text>
<text top="592" left="199" width="22" height="16" font="0">1.3</text>
<text top="592" left="240" width="524" height="16" font="0">Example: Low-level Programming in Haskell . . . . . . . . . . . . .</text>
<text top="592" left="790" width="9" height="16" font="0">7</text>
<text top="616" left="199" width="22" height="16" font="0">1.4</text>
<text top="616" left="240" width="524" height="16" font="0">Assurance Through A Small Trusted Computing Base . . . . . . . .</text>
<text top="616" left="790" width="9" height="16" font="0">7</text>
<text top="639" left="199" width="22" height="16" font="0">1.5</text>
<text top="639" left="240" width="524" height="16" font="0">This Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="639" left="790" width="9" height="16" font="0">9</text>
<text top="677" left="173" width="10" height="16" font="0">2</text>
<text top="677" left="199" width="600" height="16" font="0">Background: Core Concepts of Intel IA32 Processors . . . . . . . 11</text>
<text top="701" left="199" width="22" height="16" font="0">2.1</text>
<text top="701" left="240" width="524" height="16" font="0">Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="701" left="782" width="18" height="16" font="0">12</text>
<text top="725" left="240" width="36" height="16" font="0">2.1.1</text>
<text top="725" left="296" width="468" height="16" font="0">Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="725" left="782" width="18" height="16" font="0">12</text>
<text top="749" left="240" width="36" height="16" font="0">2.1.2</text>
<text top="749" left="296" width="468" height="16" font="0">Modes of Execution . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="749" left="782" width="18" height="16" font="0">14</text>
<text top="773" left="240" width="36" height="16" font="0">2.1.3</text>
<text top="773" left="296" width="468" height="16" font="0">Faults and Interrupts . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="773" left="782" width="18" height="16" font="0">15</text>
<text top="796" left="240" width="36" height="16" font="0">2.1.4</text>
<text top="796" left="296" width="468" height="16" font="0">Input/Output . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="796" left="782" width="18" height="16" font="0">17</text>
<text top="820" left="199" width="22" height="16" font="0">2.2</text>
<text top="820" left="240" width="524" height="16" font="0">Virtual-Memory Management . . . . . . . . . . . . . . . . . . . . .</text>
<text top="820" left="782" width="18" height="16" font="0">18</text>
<text top="844" left="240" width="36" height="16" font="0">2.2.1</text>
<text top="844" left="296" width="239" height="16" font="0">Address Translation Structures</text>
<text top="844" left="551" width="213" height="16" font="0">. . . . . . . . . . . . . . . .</text>
<text top="844" left="782" width="18" height="16" font="0">18</text>
<text top="868" left="240" width="36" height="16" font="0">2.2.2</text>
<text top="868" left="296" width="468" height="16" font="0">Protection . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="868" left="782" width="18" height="16" font="0">21</text>
<text top="892" left="240" width="36" height="16" font="0">2.2.3</text>
<text top="892" left="296" width="468" height="16" font="0">Translation Table Formats . . . . . . . . . . . . . . . . . . .</text>
<text top="892" left="782" width="18" height="16" font="0">23</text>
<text top="916" left="240" width="36" height="16" font="0">2.2.4</text>
<text top="916" left="296" width="468" height="16" font="0">Example: Adding a Virtual-To-Physical Mapping . . . . . .</text>
<text top="916" left="782" width="18" height="16" font="0">25</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="737" width="19" height="16" font="0">vii</text>
<text top="163" left="173" width="10" height="16" font="0">3</text>
<text top="163" left="199" width="600" height="16" font="0">Background: Fundamentals of Haskell Programming . . . . . . . 27</text>
<text top="187" left="199" width="22" height="16" font="0">3.1</text>
<text top="187" left="240" width="524" height="16" font="0">Datatypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="187" left="782" width="18" height="16" font="0">29</text>
<text top="211" left="199" width="22" height="16" font="0">3.2</text>
<text top="211" left="240" width="524" height="16" font="0">Parameterized Datatypes . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="211" left="782" width="18" height="16" font="0">33</text>
<text top="234" left="199" width="22" height="16" font="0">3.3</text>
<text top="234" left="240" width="524" height="16" font="0">Type Classes and Qualiﬁed Types . . . . . . . . . . . . . . . . . . .</text>
<text top="234" left="782" width="18" height="16" font="0">36</text>
<text top="258" left="199" width="22" height="16" font="0">3.4</text>
<text top="258" left="240" width="60" height="16" font="0">Monads</text>
<text top="258" left="316" width="448" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="258" left="782" width="18" height="16" font="0">39</text>
<text top="282" left="199" width="22" height="16" font="0">3.5</text>
<text top="282" left="240" width="524" height="16" font="0">Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="282" left="782" width="18" height="16" font="0">46</text>
<text top="320" left="173" width="10" height="16" font="0">4</text>
<text top="320" left="199" width="573" height="16" font="0">A Memory-Safe Abstraction Layer for Operating System Con-</text>
<text top="344" left="199" width="600" height="16" font="0">struction in Haskell . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49</text>
<text top="368" left="199" width="22" height="16" font="0">4.1</text>
<text top="368" left="240" width="524" height="16" font="0">Characterizing Memory . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="368" left="782" width="18" height="16" font="0">53</text>
<text top="391" left="199" width="22" height="16" font="0">4.2</text>
<text top="391" left="240" width="524" height="16" font="0">Example: Adding a Memory Mapping in H . . . . . . . . . . . . . .</text>
<text top="391" left="782" width="18" height="16" font="0">56</text>
<text top="415" left="199" width="22" height="16" font="0">4.3</text>
<text top="415" left="240" width="524" height="16" font="0">System Conﬁguration . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="415" left="782" width="18" height="16" font="0">60</text>
<text top="439" left="240" width="36" height="16" font="0">4.3.1</text>
<text top="439" left="296" width="468" height="16" font="0">Physical Memory Conﬁguration . . . . . . . . . . . . . . . .</text>
<text top="439" left="782" width="18" height="16" font="0">60</text>
<text top="463" left="240" width="36" height="16" font="0">4.3.2</text>
<text top="463" left="296" width="468" height="16" font="0">User-Code Modules . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="463" left="782" width="18" height="16" font="0">66</text>
<text top="487" left="199" width="22" height="16" font="0">4.4</text>
<text top="487" left="240" width="524" height="16" font="0">Virtual-Memory Management . . . . . . . . . . . . . . . . . . . . .</text>
<text top="487" left="782" width="18" height="16" font="0">67</text>
<text top="511" left="240" width="36" height="16" font="0">4.4.1</text>
<text top="511" left="296" width="468" height="16" font="0">Address Spaces . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="511" left="782" width="18" height="16" font="0">68</text>
<text top="534" left="240" width="36" height="16" font="0">4.4.2</text>
<text top="534" left="296" width="468" height="16" font="0">User Memory . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="534" left="782" width="18" height="16" font="0">71</text>
<text top="558" left="240" width="36" height="16" font="0">4.4.3</text>
<text top="558" left="296" width="468" height="16" font="0">Kernel Memory . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="558" left="782" width="18" height="16" font="0">74</text>
<text top="582" left="199" width="22" height="16" font="0">4.5</text>
<text top="582" left="240" width="524" height="16" font="0">User Process Execution . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="582" left="782" width="18" height="16" font="0">77</text>
<text top="606" left="199" width="22" height="16" font="0">4.6</text>
<text top="606" left="240" width="524" height="16" font="0">Input/Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="606" left="782" width="18" height="16" font="0">80</text>
<text top="630" left="240" width="36" height="16" font="0">4.6.1</text>
<text top="630" left="296" width="468" height="16" font="0">Ports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="630" left="782" width="18" height="16" font="0">80</text>
<text top="654" left="240" width="36" height="16" font="0">4.6.2</text>
<text top="654" left="296" width="468" height="16" font="0">Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="654" left="782" width="18" height="16" font="0">81</text>
<text top="692" left="173" width="10" height="16" font="0">5</text>
<text top="692" left="199" width="573" height="16" font="0">Formalizing Operating System Memory-Safety as a Noninterfer-</text>
<text top="715" left="199" width="600" height="16" font="0">ence Property . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82</text>
<text top="739" left="199" width="22" height="16" font="0">5.1</text>
<text top="739" left="240" width="391" height="16" font="0">Background: Rushby’s Noninterference Framework</text>
<text top="739" left="648" width="116" height="16" font="0">. . . . . . . . .</text>
<text top="739" left="782" width="18" height="16" font="0">86</text>
<text top="763" left="240" width="36" height="16" font="0">5.1.1</text>
<text top="763" left="296" width="468" height="16" font="0">System Model . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="763" left="782" width="18" height="16" font="0">86</text>
<text top="787" left="240" width="36" height="16" font="0">5.1.2</text>
<text top="787" left="296" width="468" height="16" font="0">Characterizing Domain Interactions . . . . . . . . . . . . . .</text>
<text top="787" left="782" width="18" height="16" font="0">88</text>
<text top="811" left="240" width="36" height="16" font="0">5.1.3</text>
<text top="811" left="296" width="468" height="16" font="0">Establishing Security . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="811" left="782" width="18" height="16" font="0">91</text>
<text top="835" left="199" width="22" height="16" font="0">5.2</text>
<text top="835" left="240" width="524" height="16" font="0">Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="835" left="782" width="18" height="16" font="0">92</text>
<text top="858" left="199" width="22" height="16" font="0">5.3</text>
<text top="858" left="240" width="524" height="16" font="0">Machine Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="858" left="782" width="18" height="16" font="0">94</text>
<text top="882" left="240" width="36" height="16" font="0">5.3.1</text>
<text top="882" left="296" width="468" height="16" font="0">Virtual and Physical Memory . . . . . . . . . . . . . . . . .</text>
<text top="882" left="782" width="18" height="16" font="0">95</text>
<text top="906" left="240" width="36" height="16" font="0">5.3.2</text>
<text top="906" left="296" width="503" height="16" font="0">Memory Regions . . . . . . . . . . . . . . . . . . . . . . . . 100</text>
<text top="930" left="240" width="36" height="16" font="0">5.3.3</text>
<text top="930" left="296" width="503" height="16" font="0">Machine State . . . . . . . . . . . . . . . . . . . . . . . . . . 102</text>
<text top="954" left="199" width="22" height="16" font="0">5.4</text>
<text top="954" left="240" width="560" height="16" font="0">Protection Domains . . . . . . . . . . . . . . . . . . . . . . . . . . . 106</text>
<text top="978" left="240" width="36" height="16" font="0">5.4.1</text>
<text top="978" left="296" width="503" height="16" font="0">Domain Actions . . . . . . . . . . . . . . . . . . . . . . . . . 108</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="732" width="24" height="16" font="0">viii</text>
<text top="163" left="199" width="22" height="16" font="0">5.5</text>
<text top="163" left="240" width="560" height="16" font="0">Policy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117</text>
<text top="187" left="240" width="36" height="16" font="0">5.5.1</text>
<text top="187" left="296" width="503" height="16" font="0">Modeling Approach . . . . . . . . . . . . . . . . . . . . . . . 118</text>
<text top="211" left="240" width="36" height="16" font="0">5.5.2</text>
<text top="211" left="296" width="503" height="16" font="0">Interference Between Domains . . . . . . . . . . . . . . . . . 122</text>
<text top="234" left="199" width="22" height="16" font="0">5.6</text>
<text top="234" left="240" width="129" height="16" font="0">Well-Formedness</text>
<text top="234" left="385" width="414" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . . . . . 126</text>
<text top="258" left="240" width="36" height="16" font="0">5.6.1</text>
<text top="258" left="296" width="503" height="16" font="0">CR3 and Reference Page-Directory Are Page-Directories . . 127</text>
<text top="282" left="240" width="36" height="16" font="0">5.6.2</text>
<text top="282" left="296" width="503" height="16" font="0">Reference Page-Directory Maps Kernel-Space Addresses . . . 127</text>
<text top="306" left="240" width="36" height="16" font="0">5.6.3</text>
<text top="306" left="296" width="504" height="16" font="0">Reference Page-Directory Maps Every Environment Page . . 128</text>
<text top="330" left="240" width="36" height="16" font="0">5.6.4</text>
<text top="330" left="296" width="503" height="16" font="0">All Page-Directories Contain Reference Mappings . . . . . . 129</text>
<text top="354" left="240" width="36" height="16" font="0">5.6.5</text>
<text top="354" left="296" width="459" height="16" font="0">Environment Pages Are Only Mapped to Addresses That</text>
<text top="377" left="296" width="503" height="16" font="0">Are Mapped in the Reference Page-Directory . . . . . . . . . 130</text>
<text top="401" left="240" width="36" height="16" font="0">5.6.6</text>
<text top="401" left="296" width="503" height="16" font="0">Mapped Pages Are Available . . . . . . . . . . . . . . . . . . 131</text>
<text top="425" left="240" width="36" height="16" font="0">5.6.7</text>
<text top="425" left="296" width="503" height="16" font="0">Page-Table Pointers Are Page-Tables . . . . . . . . . . . . . 131</text>
<text top="449" left="240" width="36" height="16" font="0">5.6.8</text>
<text top="449" left="296" width="432" height="16" font="0">Regions Are Consistent and Disjoint From Environment</text>
<text top="449" left="745" width="54" height="16" font="0">. . 132</text>
<text top="473" left="240" width="36" height="16" font="0">5.6.9</text>
<text top="473" left="296" width="503" height="16" font="0">Putting It All Together . . . . . . . . . . . . . . . . . . . . . 133</text>
<text top="497" left="199" width="22" height="16" font="0">5.7</text>
<text top="497" left="240" width="560" height="16" font="0">Connecting the Model and Implementation . . . . . . . . . . . . . . 134</text>
<text top="520" left="240" width="36" height="16" font="0">5.7.1</text>
<text top="520" left="296" width="504" height="16" font="0">Speciﬁcation of WriteE . . . . . . . . . . . . . . . . . . . . . 136</text>
<text top="544" left="240" width="36" height="16" font="0">5.7.2</text>
<text top="544" left="296" width="239" height="16" font="0">Speciﬁcation of DeriveRegionH</text>
<text top="544" left="551" width="248" height="16" font="0">. . . . . . . . . . . . . . . . 137</text>
<text top="568" left="240" width="36" height="16" font="0">5.7.3</text>
<text top="568" left="296" width="504" height="16" font="0">Speciﬁcation of AllocatePageDirectoryH . . . . . . . . . . . 138</text>
<text top="592" left="240" width="36" height="16" font="0">5.7.4</text>
<text top="592" left="296" width="503" height="16" font="0">Speciﬁcation of FreePageDirectoryH . . . . . . . . . . . . . . 139</text>
<text top="616" left="240" width="36" height="16" font="0">5.7.5</text>
<text top="616" left="296" width="503" height="16" font="0">Speciﬁcation of AddMappingH . . . . . . . . . . . . . . . . . 140</text>
<text top="640" left="240" width="36" height="16" font="0">5.7.6</text>
<text top="640" left="296" width="503" height="16" font="0">Speciﬁcation of RemoveMappingH . . . . . . . . . . . . . . . 144</text>
<text top="663" left="240" width="36" height="16" font="0">5.7.7</text>
<text top="663" left="296" width="503" height="16" font="0">Speciﬁcation of AddKernelMappingH . . . . . . . . . . . . . 146</text>
<text top="687" left="240" width="36" height="16" font="0">5.7.8</text>
<text top="687" left="296" width="197" height="16" font="0">Speciﬁcation of ExecuteH</text>
<text top="687" left="510" width="290" height="16" font="0">. . . . . . . . . . . . . . . . . . . 147</text>
<text top="711" left="240" width="36" height="16" font="0">5.7.9</text>
<text top="711" left="296" width="504" height="16" font="0">Speciﬁcation of WriteK . . . . . . . . . . . . . . . . . . . . . 148</text>
<text top="735" left="240" width="560" height="16" font="0">5.7.10 Speciﬁcation of WriteU . . . . . . . . . . . . . . . . . . . . . 149</text>
<text top="759" left="199" width="22" height="16" font="0">5.8</text>
<text top="759" left="240" width="560" height="16" font="0">Verifying Memory-Safety . . . . . . . . . . . . . . . . . . . . . . . . 150</text>
<text top="783" left="240" width="36" height="16" font="0">5.8.1</text>
<text top="783" left="296" width="503" height="16" font="0">Completing the Rushby Instantiation . . . . . . . . . . . . . 150</text>
<text top="806" left="240" width="36" height="16" font="0">5.8.2</text>
<text top="806" left="296" width="503" height="16" font="0">Properties of the H Speciﬁcation and System Model . . . . . 152</text>
<text top="830" left="240" width="36" height="16" font="0">5.8.3</text>
<text top="830" left="296" width="503" height="16" font="0">Proving the Unwinding Conditions . . . . . . . . . . . . . . 156</text>
<text top="854" left="240" width="36" height="16" font="0">5.8.4</text>
<text top="854" left="296" width="503" height="16" font="0">Model Validation . . . . . . . . . . . . . . . . . . . . . . . . 165</text>
<text top="878" left="199" width="22" height="16" font="0">5.9</text>
<text top="878" left="240" width="74" height="16" font="0">Summary</text>
<text top="878" left="330" width="470" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167</text>
<text top="916" left="173" width="10" height="16" font="0">6</text>
<text top="916" left="199" width="600" height="16" font="0">Implementing the Abstraction Layer . . . . . . . . . . . . . . . . . 169</text>
<text top="940" left="199" width="22" height="16" font="0">6.1</text>
<text top="940" left="240" width="560" height="16" font="0">Safely Encapsulating the Abstraction Layer Operations . . . . . . . 169</text>
<text top="964" left="199" width="22" height="16" font="0">6.2</text>
<text top="964" left="240" width="560" height="16" font="0">Type Classes for Fine-Grained Eﬀect Tracking . . . . . . . . . . . . 172</text>
<text top="987" left="199" width="22" height="16" font="0">6.3</text>
<text top="987" left="240" width="560" height="16" font="0">Booting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176</text>
</page>
<page number="11" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="741" width="14" height="16" font="0">ix</text>
<text top="163" left="199" width="22" height="16" font="0">6.4</text>
<text top="163" left="240" width="560" height="16" font="0">Precise Kernel Control Over Page-Map Memory . . . . . . . . . . . 183</text>
<text top="187" left="199" width="22" height="16" font="0">6.5</text>
<text top="187" left="240" width="560" height="16" font="0">Enforcing Safe Page Status Transitions . . . . . . . . . . . . . . . . 187</text>
<text top="211" left="199" width="22" height="16" font="0">6.6</text>
<text top="211" left="240" width="560" height="16" font="0">Division of Code Between C and Haskell . . . . . . . . . . . . . . . 193</text>
<text top="234" left="199" width="22" height="16" font="0">6.7</text>
<text top="234" left="240" width="560" height="16" font="0">The Kernel Virtual-Address Space . . . . . . . . . . . . . . . . . . . 200</text>
<text top="258" left="199" width="22" height="16" font="0">6.8</text>
<text top="258" left="240" width="560" height="16" font="0">User-Program Execution . . . . . . . . . . . . . . . . . . . . . . . . 205</text>
<text top="282" left="199" width="22" height="16" font="0">6.9</text>
<text top="282" left="240" width="74" height="16" font="0">Summary</text>
<text top="282" left="330" width="470" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209</text>
<text top="320" left="173" width="10" height="16" font="0">7</text>
<text top="320" left="199" width="600" height="16" font="0">Case Study: Inter-Process Communication in L4 . . . . . . . . . . 210</text>
<text top="344" left="199" width="22" height="16" font="0">7.1</text>
<text top="344" left="240" width="560" height="16" font="0">Threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212</text>
<text top="368" left="199" width="22" height="16" font="0">7.2</text>
<text top="368" left="240" width="560" height="16" font="0">IPC Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215</text>
<text top="391" left="199" width="22" height="16" font="0">7.3</text>
<text top="391" left="240" width="560" height="16" font="0">The Mapping Database . . . . . . . . . . . . . . . . . . . . . . . . . 220</text>
<text top="415" left="199" width="22" height="16" font="0">7.4</text>
<text top="415" left="240" width="560" height="16" font="0">Managing State With The Kernel Monad . . . . . . . . . . . . . . . 224</text>
<text top="439" left="240" width="36" height="16" font="0">7.4.1</text>
<text top="439" left="296" width="197" height="16" font="0">Kernel Memory Allocator</text>
<text top="439" left="510" width="290" height="16" font="0">. . . . . . . . . . . . . . . . . . . 225</text>
<text top="463" left="240" width="36" height="16" font="0">7.4.2</text>
<text top="463" left="296" width="503" height="16" font="0">Kernel State . . . . . . . . . . . . . . . . . . . . . . . . . . . 227</text>
<text top="487" left="199" width="22" height="16" font="0">7.5</text>
<text top="487" left="240" width="560" height="16" font="0">Error Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227</text>
<text top="511" left="199" width="22" height="16" font="0">7.6</text>
<text top="511" left="240" width="560" height="16" font="0">Thread Rendezvous . . . . . . . . . . . . . . . . . . . . . . . . . . . 229</text>
<text top="534" left="199" width="22" height="16" font="0">7.7</text>
<text top="534" left="240" width="560" height="16" font="0">Message Transfer . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235</text>
<text top="558" left="199" width="22" height="16" font="0">7.8</text>
<text top="558" left="240" width="74" height="16" font="0">Summary</text>
<text top="558" left="330" width="470" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240</text>
<text top="596" left="173" width="10" height="16" font="0">8</text>
<text top="596" left="199" width="183" height="16" font="0">Performance Results</text>
<text top="596" left="399" width="400" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . . . . 243</text>
<text top="620" left="199" width="22" height="16" font="0">8.1</text>
<text top="620" left="240" width="281" height="16" font="0">Test Construction and Measurement</text>
<text top="644" left="240" width="560" height="16" font="0">Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245</text>
<text top="668" left="240" width="36" height="16" font="0">8.1.1</text>
<text top="668" left="296" width="503" height="16" font="0">Anatomy of an IPC Request . . . . . . . . . . . . . . . . . . 247</text>
<text top="692" left="240" width="36" height="16" font="0">8.1.2</text>
<text top="692" left="296" width="504" height="16" font="0">Haskell Proﬁling on Bare Metal . . . . . . . . . . . . . . . . 251</text>
<text top="715" left="199" width="22" height="16" font="0">8.2</text>
<text top="715" left="240" width="560" height="16" font="0">Initial Measurements . . . . . . . . . . . . . . . . . . . . . . . . . . 255</text>
<text top="739" left="240" width="36" height="16" font="0">8.2.1</text>
<text top="739" left="296" width="182" height="16" font="0">Ping-Pong Performance</text>
<text top="739" left="496" width="304" height="16" font="0">. . . . . . . . . . . . . . . . . . . . 255</text>
<text top="763" left="240" width="36" height="16" font="0">8.2.2</text>
<text top="763" left="296" width="503" height="16" font="0">Context-Switching Time . . . . . . . . . . . . . . . . . . . . 260</text>
<text top="787" left="240" width="36" height="16" font="0">8.2.3</text>
<text top="787" left="296" width="504" height="16" font="0">The Eﬀect of Garbage Collection . . . . . . . . . . . . . . . 261</text>
<text top="811" left="199" width="22" height="16" font="0">8.3</text>
<text top="811" left="240" width="560" height="16" font="0">Optimizing the Kernel . . . . . . . . . . . . . . . . . . . . . . . . . 266</text>
<text top="835" left="240" width="36" height="16" font="0">8.3.1</text>
<text top="835" left="296" width="503" height="16" font="0">Identifying Algorithmic Ineﬃciencies . . . . . . . . . . . . . 268</text>
<text top="858" left="240" width="36" height="16" font="0">8.3.2</text>
<text top="858" left="296" width="503" height="16" font="0">Role of H Primitive Design in Performance Results . . . . . 274</text>
<text top="882" left="240" width="36" height="16" font="0">8.3.3</text>
<text top="882" left="296" width="503" height="16" font="0">Using Compiler Pragmas to Fine-Tune Performance . . . . . 278</text>
<text top="906" left="199" width="22" height="16" font="0">8.4</text>
<text top="906" left="240" width="74" height="16" font="0">Summary</text>
<text top="906" left="330" width="470" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282</text>
<text top="944" left="173" width="10" height="16" font="0">9</text>
<text top="944" left="199" width="600" height="16" font="0">Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289</text>
<text top="968" left="199" width="22" height="16" font="0">9.1</text>
<text top="968" left="240" width="157" height="16" font="0">System Architecture</text>
<text top="968" left="413" width="387" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . . . 289</text>
<text top="992" left="199" width="22" height="16" font="0">9.2</text>
<text top="992" left="240" width="560" height="16" font="0">Functional Operating Systems . . . . . . . . . . . . . . . . . . . . . 290</text>
</page>
<page number="12" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="746" width="9" height="16" font="0">x</text>
<text top="163" left="199" width="22" height="16" font="0">9.3</text>
<text top="163" left="240" width="560" height="16" font="0">Programming Languages . . . . . . . . . . . . . . . . . . . . . . . . 291</text>
<text top="187" left="199" width="22" height="16" font="0">9.4</text>
<text top="187" left="240" width="560" height="16" font="0">Veriﬁed Operating Systems . . . . . . . . . . . . . . . . . . . . . . . 296</text>
<text top="211" left="199" width="22" height="16" font="0">9.5</text>
<text top="211" left="240" width="183" height="16" font="0">Safe Operating Systems</text>
<text top="211" left="440" width="359" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . 298</text>
<text top="234" left="199" width="22" height="16" font="0">9.6</text>
<text top="234" left="240" width="560" height="16" font="0">Virtualization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301</text>
<text top="272" left="173" width="626" height="16" font="0">10 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303</text>
<text top="310" left="173" width="626" height="16" font="0">References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310</text>
</page>
<page number="13" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="741" width="14" height="16" font="0">xi</text>
<text top="233" left="413" width="146" height="16" font="0">LIST OF TABLES</text>
<text top="332" left="199" width="22" height="16" font="0">5.1</text>
<text top="332" left="240" width="515" height="16" font="0">The primitive types of the model. We break virtual and physical ad-</text>
<text top="356" left="240" width="515" height="16" font="0">dresses into these ﬁne-grained components to capture the meaning</text>
<text top="379" left="240" width="515" height="16" font="0">of each element of an address in the types. This approach provides</text>
<text top="403" left="240" width="515" height="16" font="0">better documentation and reﬂects the alignment constraints of var-</text>
<text top="427" left="240" width="524" height="16" font="0">ious operations in the model. . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="427" left="782" width="18" height="16" font="0">96</text>
<text top="451" left="199" width="22" height="16" font="0">5.2</text>
<text top="451" left="240" width="515" height="16" font="0">The actions of each protection domain. None of the actions have</text>
<text top="475" left="240" width="515" height="16" font="0">outputs because their eﬀect is observed through the state. We in-</text>
<text top="499" left="240" width="515" height="16" font="0">clude write operations on memory but not reads, because the ability</text>
<text top="522" left="240" width="560" height="16" font="0">to read is implicit in observation. . . . . . . . . . . . . . . . . . . . 109</text>
<text top="561" left="199" width="22" height="16" font="0">6.1</text>
<text top="561" left="240" width="473" height="16" font="0">The division of the H interface functions into type classes.</text>
<text top="561" left="729" width="25" height="16" font="0">See</text>
<text top="585" left="240" width="560" height="16" font="0">Chapter 4 for the details of each of these functions. . . . . . . . . . 174</text>
<text top="609" left="199" width="22" height="16" font="0">6.2</text>
<text top="609" left="240" width="560" height="16" font="0">The C API for managing page-tables and page-directory entries. . . 195</text>
<text top="633" left="199" width="22" height="16" font="0">6.3</text>
<text top="633" left="240" width="515" height="16" font="0">The source lines of code for H in Haskell, C, and Assembly Language.</text>
<text top="657" left="240" width="515" height="16" font="0">We count the interface code (special modules to be imported by</text>
<text top="680" left="240" width="515" height="16" font="0">clients that include a restricted set of module exports and the H</text>
<text top="704" left="240" width="560" height="16" font="0">type class instances) separately from the implementation code. . . . 209</text>
<text top="743" left="199" width="22" height="16" font="0">7.1</text>
<text top="743" left="240" width="515" height="16" font="0">The source lines of code for our L4 implementation. Source lines of</text>
<text top="767" left="240" width="560" height="16" font="0">code do not include blank lines or comments. . . . . . . . . . . . . . 242</text>
<text top="806" left="199" width="22" height="16" font="0">8.1</text>
<text top="806" left="240" width="515" height="16" font="0">Result of running ping-pong on Pistachio in our experimental envi-</text>
<text top="829" left="240" width="515" height="16" font="0">ronment. Ping-pong tests the average number of cycles and average</text>
<text top="853" left="240" width="515" height="16" font="0">time in microseconds required to send various numbers of words over</text>
<text top="877" left="240" width="294" height="16" font="0">IPC (from 0 to 60 in increments of 4).</text>
<text top="877" left="551" width="248" height="16" font="0">. . . . . . . . . . . . . . . . 256</text>
</page>
<page number="14" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="737" width="19" height="16" font="0">xii</text>
<text top="163" left="199" width="22" height="16" font="0">8.2</text>
<text top="163" left="240" width="515" height="16" font="0">Initial results for our Haskell implementation of L4 on H. The table</text>
<text top="187" left="240" width="515" height="16" font="0">shows the number of words transferred over IPC, the average cycles</text>
<text top="211" left="240" width="515" height="16" font="0">taken per message, the average time in microseconds per message,</text>
<text top="234" left="240" width="515" height="16" font="0">and the total number of garbage collections that occurred during</text>
<text top="258" left="240" width="515" height="16" font="0">the test (not per IPC). The ﬁnal column is the ratio between the</text>
<text top="282" left="240" width="515" height="16" font="0">average cycles taken for a particular test and the equivalent result</text>
<text top="306" left="240" width="515" height="16" font="0">from Pistachio (see Table 8.1 for the full results). This number</text>
<text top="330" left="240" width="515" height="16" font="0">indicates how many times slower our implementation is than the</text>
<text top="354" left="240" width="141" height="16" font="0">Pistachio baseline.</text>
<text top="354" left="399" width="400" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . . . . 258</text>
<text top="377" left="199" width="22" height="16" font="0">8.3</text>
<text top="377" left="240" width="515" height="16" font="0">A breakdown of the cycles spent in each phase of the IPC imple-</text>
<text top="401" left="240" width="515" height="16" font="0">mentation. OH stands for overhead and includes the time spent to</text>
<text top="425" left="240" width="515" height="16" font="0">context-switch between the Haskell kernel and the C user program.</text>
<text top="449" left="240" width="515" height="16" font="0">Sch. is the time spent in the scheduling loop. SR stands for send</text>
<text top="473" left="240" width="515" height="16" font="0">rendezvous, TM stands for transfer message, and TU stands for</text>
<text top="497" left="240" width="515" height="16" font="0">transfer untyped. Rst. describes the phase of IPC spent restarting</text>
<text top="520" left="240" width="515" height="16" font="0">the thread. Rcv. is the time spent in the receive phase of the IPC</text>
<text top="544" left="240" width="560" height="16" font="0">operation. The phases are explained in detail in Section 8.1.1. . . . 259</text>
<text top="568" left="199" width="22" height="16" font="0">8.4</text>
<text top="568" left="240" width="515" height="16" font="0">Portion of time spent in garbage collection in our initial results. By</text>
<text top="592" left="240" width="515" height="16" font="0">comparing the average number of microseconds spent in garbage col-</text>
<text top="616" left="240" width="515" height="16" font="0">lection to the average number of microseconds spent in IPC overall,</text>
<text top="640" left="240" width="560" height="16" font="0">we see that garbage collection is only 1–2% of our total IPC cost. . 262</text>
<text top="663" left="199" width="22" height="16" font="0">8.5</text>
<text top="663" left="240" width="515" height="16" font="0">The result of inlining the read/write word functions from the H in-</text>
<text top="687" left="240" width="515" height="16" font="0">terface directly into our inner loop. The speedup column compares</text>
<text top="711" left="240" width="515" height="16" font="0">the cycles per message in the inlined implementation to the per-</text>
<text top="735" left="240" width="515" height="16" font="0">formance of the unoptimized version. As in Table 8.2, the “× P”</text>
<text top="759" left="240" width="515" height="16" font="0">column indicates how many times slower the algorithm under test</text>
<text top="783" left="240" width="560" height="16" font="0">is than Pistachio. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273</text>
<text top="806" left="199" width="22" height="16" font="0">8.6</text>
<text top="806" left="240" width="515" height="16" font="0">Performance of IPC when using a multi-word copy to transfer IPC</text>
<text top="830" left="240" width="520" height="16" font="0">messages instead of individual read/write word functions. The speed-</text>
<text top="854" left="240" width="515" height="16" font="0">up column compares these results to the inlined implementation in</text>
<text top="878" left="240" width="560" height="16" font="0">Section 8.3.1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277</text>
<text top="902" left="199" width="22" height="16" font="0">8.7</text>
<text top="902" left="240" width="515" height="16" font="0">Performance of IPC when using strictness annotations and compiler</text>
<text top="926" left="240" width="515" height="16" font="0">pragmas for datatype unpacking and inlining in the essential compo-</text>
<text top="949" left="240" width="515" height="16" font="0">nents that aﬀect IPC. The speedup column compares these results</text>
<text top="973" left="240" width="560" height="16" font="0">to the multi-word copy implementation in Section 8.3.2. . . . . . . . 281</text>
</page>
<page number="15" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="732" width="24" height="16" font="0">xiii</text>
<text top="163" left="199" width="22" height="16" font="0">8.8</text>
<text top="163" left="240" width="515" height="16" font="0">A breakdown of the cycles spent in each phase of the optimized</text>
<text top="187" left="240" width="515" height="16" font="0">IPC implementation. Our optimization eﬀorts targeted the trans-</text>
<text top="211" left="240" width="515" height="16" font="0">fer untyped (TU) phase of the algorithm, and we see a signiﬁcant</text>
<text top="234" left="240" width="515" height="16" font="0">reduction in the number of cycles as compared to the original break-</text>
<text top="258" left="240" width="515" height="16" font="0">down we saw in Table 8.3. OH stands for overhead and includes the</text>
<text top="282" left="240" width="515" height="16" font="0">time spent to context-switch between the Haskell kernel and the C</text>
<text top="306" left="240" width="515" height="16" font="0">user program. Sch. is the time spent in the scheduling loop. SR</text>
<text top="330" left="240" width="515" height="16" font="0">stands for send rendezvous, TM stands for transfer message, and</text>
<text top="354" left="240" width="515" height="16" font="0">TU stands for transfer untyped. Rst. describes the phase of IPC</text>
<text top="377" left="240" width="515" height="16" font="0">spent restarting the thread. Rcv. is the time spent in the receive</text>
<text top="401" left="240" width="515" height="16" font="0">phase of the IPC operation. The phases are explained in detail in</text>
<text top="425" left="240" width="560" height="16" font="0">Section 8.1.1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283</text>
</page>
<page number="16" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="732" width="23" height="16" font="0">xiv</text>
<text top="233" left="408" width="156" height="16" font="0">LIST OF FIGURES</text>
<text top="332" left="199" width="22" height="16" font="0">1.1</text>
<text top="332" left="240" width="515" height="16" font="0">The system organization when dividing an operating system into an</text>
<text top="356" left="240" width="524" height="16" font="0">unsafe abstraction layer and a purely functional layer. . . . . . . . .</text>
<text top="356" left="790" width="9" height="16" font="0">9</text>
<text top="394" left="199" width="22" height="16" font="0">2.1</text>
<text top="394" left="240" width="515" height="16" font="0">The registers of the IA32 architecture. This ﬁgure is a reproduc-</text>
<text top="418" left="240" width="515" height="16" font="0">tion of Figure 3-4 from the Intel Architectures Software Developer’s</text>
<text top="442" left="240" width="524" height="16" font="0">Manual [52]. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="442" left="782" width="18" height="16" font="0">13</text>
<text top="466" left="199" width="22" height="16" font="0">2.2</text>
<text top="466" left="240" width="515" height="16" font="0">A ﬂat memory model conﬁguration. Every segment overlaps and</text>
<text top="490" left="240" width="515" height="16" font="0">contains the entire address space of the machine. This ﬁgure is a</text>
<text top="514" left="240" width="515" height="16" font="0">reproduction of Figure 3-6 from the Intel Architectures Software</text>
<text top="537" left="240" width="524" height="16" font="0">Developer’s Manual [52]. . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="537" left="782" width="18" height="16" font="0">14</text>
<text top="561" left="199" width="22" height="16" font="0">2.3</text>
<text top="561" left="240" width="515" height="16" font="0">On the IA32, virtual-to-physical address translations are performed</text>
<text top="585" left="240" width="515" height="16" font="0">using a two-level data-structure that resides in memory. Each vir-</text>
<text top="609" left="240" width="515" height="16" font="0">tual address space has a single ﬁrst level table called a page direc-</text>
<text top="633" left="240" width="515" height="16" font="0">tory that points to potentially many second level tables called page</text>
<text top="657" left="240" width="515" height="16" font="0">tables. We identify address spaces using the address of the page di-</text>
<text top="680" left="240" width="515" height="16" font="0">rectory in memory (a physical address), which is stored in the CR3</text>
<text top="704" left="240" width="515" height="16" font="0">register. In the ﬁgure, arrows indicate a pointer from one structure</text>
<text top="728" left="240" width="524" height="16" font="0">to another. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="728" left="782" width="18" height="16" font="0">19</text>
<text top="752" left="199" width="22" height="16" font="0">2.4</text>
<text top="752" left="240" width="515" height="16" font="0">Virtual to physical address translation on the IA32 using 4 KB</text>
<text top="776" left="240" width="515" height="16" font="0">pages. The most signiﬁcant bits of the virtual address are used</text>
<text top="800" left="240" width="515" height="16" font="0">as an index into the current page-directory (found in the address</text>
<text top="823" left="240" width="515" height="16" font="0">speciﬁed by the CR3 register) to locate an appropriate page-table.</text>
<text top="847" left="240" width="515" height="16" font="0">The middle bits are then used as an index into that page-table to</text>
<text top="871" left="240" width="515" height="16" font="0">ﬁnd the physical page that the virtual address is mapped to. The</text>
<text top="895" left="240" width="515" height="16" font="0">complete physical address is then computed by using the low bits of</text>
<text top="919" left="240" width="524" height="16" font="0">the virtual address as an index into the physical page. . . . . . . . .</text>
<text top="919" left="782" width="18" height="16" font="0">21</text>
</page>
<page number="17" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="737" width="19" height="16" font="0">xv</text>
<text top="163" left="199" width="22" height="16" font="0">2.5</text>
<text top="163" left="240" width="515" height="16" font="0">Virtual to physical address translation on the IA32 using 4 MB</text>
<text top="187" left="240" width="515" height="16" font="0">pages. As with 4 KB mappings, the high bits of the virtual address</text>
<text top="211" left="240" width="515" height="16" font="0">are used as an index into the current page-directory (speciﬁed by</text>
<text top="234" left="240" width="515" height="16" font="0">the CR3 register). However, in this case, the page-directory entry</text>
<text top="258" left="240" width="515" height="16" font="0">stores a physical address, rather than a page-table location. The</text>
<text top="282" left="240" width="515" height="16" font="0">remainder of the virtual address (what was the page-table index</text>
<text top="306" left="240" width="515" height="16" font="0">and the oﬀset) is treated as the oﬀset from that physical address.</text>
<text top="330" left="240" width="515" height="16" font="0">The result of the translation is value of the physical address stored</text>
<text top="354" left="240" width="524" height="16" font="0">in the page-directory entry added to the oﬀset. . . . . . . . . . . . .</text>
<text top="354" left="782" width="18" height="16" font="0">22</text>
<text top="377" left="199" width="22" height="16" font="0">2.6</text>
<text top="377" left="240" width="515" height="16" font="0">Format for page-directory entries and page-table entries (when us-</text>
<text top="401" left="240" width="515" height="16" font="0">ing 4 KB pages). The top twenty bits contain the aligned address of</text>
<text top="425" left="240" width="515" height="16" font="0">the memory being mapped. The low bits contain conﬁguration in-</text>
<text top="449" left="240" width="515" height="16" font="0">formation, including permissions and mode restrictions. This ﬁgure</text>
<text top="473" left="240" width="515" height="16" font="0">is a reproduction of Figure 3-14 from the Intel Architecture Software</text>
<text top="497" left="240" width="524" height="16" font="0">Developer’s Manual [51]. . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="497" left="782" width="18" height="16" font="0">24</text>
<text top="535" left="199" width="22" height="16" font="0">4.1</text>
<text top="535" left="240" width="515" height="16" font="0">The basic architecture of H. H runs on bare metal, using support</text>
<text top="559" left="240" width="515" height="16" font="0">from the GHC run-time system for the portions that are written</text>
<text top="583" left="240" width="84" height="16" font="0">in Haskell.</text>
<text top="583" left="341" width="414" height="16" font="0">Client kernels—operating systems written using the</text>
<text top="607" left="240" width="515" height="16" font="0">primitives of the H interface design—run with the support of the</text>
<text top="631" left="240" width="515" height="16" font="0">H implementation and the GHC run-time system (because they are</text>
<text top="655" left="240" width="515" height="16" font="0">written in Haskell). Client kernels are allowed to access the safe</text>
<text top="678" left="240" width="515" height="16" font="0">facilities of the run-time system, but only the H implementation my</text>
<text top="702" left="240" width="515" height="16" font="0">use the potentially unsafe primitives. Applications run on top of</text>
<text top="726" left="240" width="515" height="16" font="0">the client, making use of the operating system API and, indirectly,</text>
<text top="750" left="240" width="524" height="16" font="0">H’s facilities for executing arbitrary user binaries. . . . . . . . . . .</text>
<text top="750" left="782" width="18" height="16" font="0">50</text>
<text top="774" left="199" width="22" height="16" font="0">4.2</text>
<text top="774" left="240" width="515" height="16" font="0">The allowable transitions that memory pages may make between</text>
<text top="798" left="240" width="515" height="16" font="0">diﬀerent status assignments. A free page—a normal page that is not</text>
<text top="821" left="240" width="515" height="16" font="0">mapped in any page-directory—may be turned into a page-table or a</text>
<text top="845" left="240" width="515" height="16" font="0">page-directory page. H manages page-table memory, automatically</text>
<text top="869" left="240" width="515" height="16" font="0">freeing a page-table page when it no longer contains any entries.</text>
<text top="893" left="240" width="515" height="16" font="0">The client explicitly allocates and frees page-directories using the</text>
<text top="917" left="240" width="515" height="16" font="0">H API functions that we will cover in Section 4.4.1. Environment</text>
<text top="941" left="240" width="524" height="16" font="0">pages never change status. . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="941" left="782" width="18" height="16" font="0">56</text>
</page>
<page number="18" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="2" size="9" family="Times" color="#000000"/>
<text top="111" left="732" width="23" height="16" font="0">xvi</text>
<text top="163" left="199" width="22" height="16" font="0">4.3</text>
<text top="163" left="240" width="515" height="16" font="0">Illustrating the relationship between initialRegions and derive-</text>
<text top="188" left="240" width="515" height="15" font="0">Region. initalRegions exposes the portion of physical memory</text>
<text top="211" left="240" width="515" height="16" font="0">that is not in use for environment pages. In the diagram, avail-</text>
<text top="234" left="240" width="515" height="16" font="0">able memory is shown in gray while protected environment mem-</text>
<text top="258" left="240" width="515" height="16" font="0">ory (that cannot have handles constructed to it) is shown in white.</text>
<text top="284" left="240" width="515" height="15" font="0">deriveRegion creates new handles to sub-regions of existing re-</text>
<text top="306" left="240" width="515" height="16" font="0">gions, but will not create a handle to any memory that lies outside</text>
<text top="330" left="240" width="515" height="16" font="0">of the initial regions. In the diagram, unadorned arrows indicate</text>
<text top="354" left="240" width="515" height="16" font="0">a region that can successfully be derived from an existing region,</text>
<text top="377" left="240" width="515" height="16" font="0">while arrows with a cross through them indicate a region that can-</text>
<text top="401" left="240" width="515" height="16" font="0">not be derived because it combines multiple existing regions or it</text>
<text top="425" left="240" width="524" height="16" font="0">includes environment pages. . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="425" left="782" width="18" height="16" font="0">58</text>
<text top="449" left="199" width="22" height="16" font="0">4.4</text>
<text top="449" left="240" width="515" height="16" font="0">During the bootstrapping process, H reserves a portion of physi-</text>
<text top="473" left="240" width="515" height="16" font="0">cal memory for the kernel’s execution environment. The remain-</text>
<text top="497" left="240" width="515" height="16" font="0">ing memory becomes available to the client for use as page-tables,</text>
<text top="520" left="240" width="515" height="16" font="0">page-directories, user memory, and communication pages for sharing</text>
<text top="544" left="240" width="391" height="16" font="0">information between the kernel and user processes.</text>
<text top="544" left="648" width="116" height="16" font="0">. . . . . . . . .</text>
<text top="544" left="782" width="18" height="16" font="0">64</text>
<text top="583" left="199" width="22" height="16" font="0">5.1</text>
<text top="583" left="240" width="515" height="16" font="0">Intervening actions allow indirect interference between domains. A,</text>
<text top="607" left="240" width="468" height="16" font="0">B , and C are domains in a system. The policy contains A</text>
<text top="607" left="740" width="12" height="16" font="0">B</text>
<text top="631" left="240" width="48" height="16" font="0">and B</text>
<text top="631" left="322" width="432" height="16" font="0">C . In the diagram, columns represent execution steps,</text>
<text top="655" left="240" width="515" height="16" font="0">where the numeric label corresponds to the state an action executes</text>
<text top="678" left="240" width="78" height="16" font="0">in (e.g., a</text>
<text top="685" left="318" width="6" height="11" font="2">1</text>
<text top="678" left="333" width="102" height="16" font="0">executes in s</text>
<text top="685" left="435" width="6" height="11" font="2">0</text>
<text top="678" left="450" width="92" height="16" font="0">producing s</text>
<text top="685" left="542" width="6" height="11" font="2">1</text>
<text top="678" left="549" width="206" height="16" font="0">). An arrow between two</text>
<text top="702" left="240" width="301" height="16" font="0">actions indicates potential interference.</text>
<text top="702" left="565" width="199" height="16" font="0">. . . . . . . . . . . . . . .</text>
<text top="702" left="782" width="18" height="16" font="0">88</text>
<text top="726" left="199" width="22" height="16" font="0">5.2</text>
<text top="726" left="240" width="515" height="16" font="0">The security policy of our system. The environment interferes with</text>
<text top="750" left="240" width="515" height="16" font="0">H and the kernel because they depend on the environment to run.</text>
<text top="774" left="240" width="515" height="16" font="0">H interferes with the kernel and the users by the same reasoning.</text>
<text top="798" left="240" width="515" height="16" font="0">The kernel and the user domains interfere freely with each other in</text>
<text top="821" left="240" width="515" height="16" font="0">our model because we do not put any restrictions on their commu-</text>
<text top="845" left="240" width="501" height="16" font="0">nication through memory. All domains interfere with themselves.</text>
<text top="845" left="759" width="40" height="16" font="0">. 125</text>
</page>
<page number="19" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="727" width="28" height="16" font="0">xvii</text>
<text top="163" left="199" width="22" height="16" font="0">5.3</text>
<text top="163" left="240" width="513" height="16" font="0">An illustration of the intuition behind weak step consistency. S</text>
<text top="187" left="240" width="223" height="16" font="0">represents the set of states, V</text>
<text top="194" left="462" width="42" height="11" font="2">dom(a)</text>
<text top="187" left="510" width="245" height="16" font="0">represents the view of the acting</text>
<text top="211" left="240" width="119" height="16" font="0">domain, and V</text>
<text top="217" left="358" width="7" height="11" font="2">u</text>
<text top="211" left="375" width="380" height="16" font="0">represents the view of the domain u. With our</text>
<text top="234" left="240" width="515" height="16" font="0">relational speciﬁcation, a single before state will be related to a set</text>
<text top="258" left="240" width="515" height="16" font="0">of after states by an action, a. For weak step consistency to hold,</text>
<text top="282" left="240" width="515" height="16" font="0">there must exist a function (represented by the dotted line) from</text>
<text top="306" left="240" width="13" height="16" font="0">V</text>
<text top="313" left="253" width="42" height="11" font="2">dom(a)</text>
<text top="305" left="299" width="31" height="17" font="0">× V</text>
<text top="313" left="330" width="7" height="11" font="2">u</text>
<text top="306" left="345" width="55" height="16" font="0">to P(V</text>
<text top="313" left="400" width="7" height="11" font="2">u</text>
<text top="306" left="409" width="12" height="16" font="0">).</text>
<text top="306" left="440" width="359" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . 163</text>
<text top="330" left="199" width="22" height="16" font="0">5.4</text>
<text top="330" left="240" width="515" height="16" font="0">Motivation for reference counts in the views of the environment,</text>
<text top="354" left="240" width="515" height="16" font="0">kernel, and user domains. A domain can observe the fact that a</text>
<text top="377" left="240" width="515" height="16" font="0">particular physical page is multiply mapped because a single write</text>
<text top="401" left="240" width="515" height="16" font="0">will change the value of more than one location. However, with-</text>
<text top="425" left="240" width="515" height="16" font="0">out reference counts, the domain will not be able to distinguish two</text>
<text top="449" left="240" width="515" height="16" font="0">states with diﬀerent multiple mapping conﬁgurations. This is a vi-</text>
<text top="473" left="240" width="515" height="16" font="0">olation of weak step consistency, because executing the same action</text>
<text top="497" left="240" width="515" height="16" font="0">in (seemingly) equivalent before states will not produce equivalent</text>
<text top="520" left="240" width="560" height="16" font="0">after states. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166</text>
<text top="559" left="199" width="22" height="16" font="0">6.1</text>
<text top="559" left="240" width="515" height="16" font="0">The H monad interface. Though we implement the H monad using</text>
<text top="583" left="240" width="515" height="16" font="0">the potentially unsafe features of the IO monad, the Haskell compiler</text>
<text top="607" left="240" width="487" height="16" font="0">ensures that client kernels only access the H monad operations.</text>
<text top="607" left="745" width="54" height="16" font="0">. . 170</text>
<text top="631" left="199" width="22" height="16" font="0">6.2</text>
<text top="631" left="240" width="515" height="16" font="0">The low-level architecture of H. A custom run-time system library</text>
<text top="655" left="240" width="515" height="16" font="0">provides GHC with bare metal implementations of important system</text>
<text top="678" left="240" width="515" height="16" font="0">services, such as timers. The C portion of H conﬁgures the system</text>
<text top="702" left="240" width="515" height="16" font="0">and provides the GHC run-time system with memory for the Haskell</text>
<text top="726" left="240" width="515" height="16" font="0">heap. Once the bootstrapping process is complete, H invokes the</text>
<text top="751" left="240" width="515" height="15" font="0">main function of the client kernel and we begin executing Haskell</text>
<text top="774" left="240" width="560" height="16" font="0">code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178</text>
<text top="798" left="199" width="22" height="16" font="0">6.3</text>
<text top="798" left="240" width="515" height="16" font="0">The modules function. This function processes the module con-</text>
<text top="821" left="240" width="515" height="16" font="0">ﬁguration information supplied by the bootstrapping code in C to</text>
<text top="845" left="240" width="560" height="16" font="0">produce a list of Haskell Module structures. . . . . . . . . . . . . . . 181</text>
<text top="869" left="199" width="22" height="16" font="0">6.4</text>
<text top="869" left="240" width="515" height="16" font="0">The initialRegions procedure. The bootstrapping code produces</text>
<text top="893" left="240" width="515" height="16" font="0">an array of ﬂexpages that describe the free memory on the machine</text>
<text top="917" left="240" width="515" height="16" font="0">that has not been claimed for kernel purposes. The initialRegions</text>
<text top="941" left="240" width="515" height="16" font="0">procedure processes this array to create physical region handles that</text>
<text top="964" left="240" width="560" height="16" font="0">cannot be forged by the client. . . . . . . . . . . . . . . . . . . . . . 183</text>
</page>
<page number="20" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="722" width="33" height="16" font="0">xviii</text>
<text top="163" left="199" width="22" height="16" font="0">6.5</text>
<text top="163" left="240" width="515" height="16" font="0">Utilities for validating and installing a PageMapPage. The addH-</text>
<text top="188" left="240" width="515" height="15" font="0">Mapping function adds an entry to the HMap dictionary for a par-</text>
<text top="211" left="240" width="515" height="16" font="0">ticular page-map page after making sure that the virtual address</text>
<text top="234" left="240" width="515" height="16" font="0">component is free. The installPageMapPage function adds a map-</text>
<text top="258" left="240" width="515" height="16" font="0">ping in kernel space from the virtual address component of a page-</text>
<text top="282" left="240" width="515" height="16" font="0">map page to the physical page component. The address-space ma-</text>
<text top="306" left="240" width="515" height="16" font="0">nipulations are done with the help of the C functions c find pt</text>
<text top="330" left="240" width="515" height="16" font="0">and c add table entries—these functions will be covered in more</text>
<text top="354" left="240" width="515" height="16" font="0">depth in Section 6.6. systemPageMapMappedAddress is a pointer</text>
<text top="377" left="240" width="515" height="16" font="0">to our implementation of the reference page-directory presented in</text>
<text top="401" left="240" width="560" height="16" font="0">Chapter 5. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186</text>
<text top="425" left="199" width="22" height="16" font="0">6.6</text>
<text top="425" left="240" width="515" height="16" font="0">Implementing a consistent view of kernel-space across every address-</text>
<text top="449" left="240" width="515" height="16" font="0">space. The mappings in the H-controlled portion of kernel-space</text>
<text top="473" left="240" width="515" height="16" font="0">(all kernel-space addresses not in the client-controlled area) do not</text>
<text top="497" left="240" width="515" height="16" font="0">change over time, so we can simply install these entries in every new</text>
<text top="520" left="240" width="515" height="16" font="0">page-directory that we create. The mappings for client-controlled</text>
<text top="544" left="240" width="515" height="16" font="0">addresses may change, but they will always be mapped via the same</text>
<text top="568" left="240" width="515" height="16" font="0">set of page-tables. We initialize a page-directory by installing the</text>
<text top="592" left="240" width="515" height="16" font="0">page-table addresses for the shared kernel-space tables. Thus, when</text>
<text top="616" left="240" width="515" height="16" font="0">any of the page-table entries is modiﬁed, the eﬀect will be seen in</text>
<text top="640" left="240" width="155" height="16" font="0">every address-space.</text>
<text top="640" left="413" width="387" height="16" font="0">. . . . . . . . . . . . . . . . . . . . . . . . . . 203</text>
<text top="663" left="199" width="22" height="16" font="0">6.7</text>
<text top="663" left="240" width="515" height="16" font="0">The implementation of the addKernelMapping function. The algo-</text>
<text top="687" left="240" width="515" height="16" font="0">rithm is similar to addMapping, but we avoid the complexity of page-</text>
<text top="711" left="240" width="515" height="16" font="0">table allocation because we pre-allocate all of the tables for kernel-</text>
<text top="735" left="240" width="515" height="16" font="0">space during start-up. Unlike addMapping, addKernelMapping may</text>
<text top="759" left="240" width="515" height="16" font="0">only map regions using page-tables, so the implementation splits</text>
<text top="783" left="240" width="515" height="16" font="0">large regions into a collection of 4 MB-sized regions before invoking</text>
<text top="806" left="240" width="515" height="16" font="0">the standard page-table modiﬁcation function (using a function for</text>
<text top="830" left="240" width="560" height="16" font="0">splitting ﬂexpages called split). . . . . . . . . . . . . . . . . . . . . 204</text>
</page>
<page number="21" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="732" width="23" height="16" font="0">xix</text>
<text top="163" left="199" width="22" height="16" font="0">6.8</text>
<text top="163" left="240" width="515" height="16" font="0">The H mechanism for executing a user program. We split the deﬁni-</text>
<text top="187" left="240" width="515" height="16" font="0">tion of the H function execute into Haskell and assembly-language</text>
<text top="211" left="240" width="515" height="16" font="0">portions. The assembly-language function is in turn split into a</text>
<text top="234" left="240" width="515" height="16" font="0">“start” component that performs the context switch to user code</text>
<text top="258" left="240" width="515" height="16" font="0">and a “return” component that resumes Haskell execution as if we</text>
<text top="282" left="240" width="515" height="16" font="0">were returning from a normal function. An interrupt handler writ-</text>
<text top="306" left="240" width="515" height="16" font="0">ten in assembly is responsible for saving the register state of the</text>
<text top="330" left="240" width="560" height="16" font="0">user-program before returning to Haskell. . . . . . . . . . . . . . . . 206</text>
<text top="369" left="199" width="22" height="16" font="0">7.1</text>
<text top="369" left="240" width="515" height="16" font="0">The send phase of an IPC operation. This function locates the spec-</text>
<text top="392" left="240" width="515" height="16" font="0">iﬁed receiver and saves any errors that occur to the sender’s message</text>
<text top="416" left="240" width="515" height="16" font="0">registers. Message transfer, which we will cover in Section 7.7, is</text>
<text top="440" left="240" width="515" height="16" font="0">handled by transferMessage. The nextPhase utility restarts the</text>
<text top="464" left="240" width="560" height="16" font="0">sending thread or initiates a receive phase, as appropriate. . . . . . 231</text>
<text top="488" left="199" width="22" height="16" font="0">7.2</text>
<text top="488" left="240" width="515" height="16" font="0">Restart a sending thread by initiating a receive phase or resuming</text>
<text top="512" left="240" width="515" height="16" font="0">the thread’s execution. The steps to take are determined by the type</text>
<text top="535" left="240" width="515" height="16" font="0">of the message that was just sent and whether or not the sending</text>
<text top="559" left="240" width="560" height="16" font="0">thread was running at the time the message was processed. . . . . . 233</text>
<text top="583" left="199" width="22" height="16" font="0">7.3</text>
<text top="583" left="240" width="515" height="16" font="0">The receive phase of an IPC operation. This function locates a</text>
<text top="607" left="240" width="515" height="16" font="0">sender by looking up a speciﬁed thread or searching the receiver’s</text>
<text top="631" left="240" width="515" height="16" font="0">waiting queue. When a sender can be found, checkPartner trans-</text>
<text top="655" left="240" width="515" height="16" font="0">fers a message from the sender and stores any errors that occur in</text>
<text top="678" left="240" width="560" height="16" font="0">both threads’ message registers. . . . . . . . . . . . . . . . . . . . . 234</text>
<text top="702" left="199" width="22" height="16" font="0">7.4</text>
<text top="702" left="240" width="515" height="16" font="0">Process a single map or grant item. This function uses the opera-</text>
<text top="726" left="240" width="515" height="16" font="0">tions of the mapping database (and in turn H) to modify the address</text>
<text top="750" left="240" width="515" height="16" font="0">space of the receiving thread (in the case of map and grant) and the</text>
<text top="774" left="240" width="515" height="16" font="0">address space of the sender (in the case of grant). The result is an</text>
<text top="798" left="240" width="515" height="16" font="0">updated typed item that reﬂects any changes made to the mapping</text>
<text top="821" left="240" width="515" height="16" font="0">area due to a mismatch between the sent ﬂexpage and the receiver’s</text>
<text top="845" left="240" width="560" height="16" font="0">acceptor. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241</text>
<text top="884" left="199" width="22" height="16" font="0">8.1</text>
<text top="884" left="240" width="515" height="16" font="0">The ﬂow of execution through the kernel when a user program issues</text>
<text top="908" left="240" width="515" height="16" font="0">an IPC request. The interrupt handler passes control back to H</text>
<text top="932" left="240" width="515" height="16" font="0">which then returns to the client kernel. The client kernel handles</text>
<text top="956" left="240" width="515" height="16" font="0">the IPC request, invokes the scheduler to restart the user program,</text>
<text top="979" left="240" width="560" height="16" font="0">and calls H to switch the processor back to user-mode. . . . . . . . 248</text>
</page>
<page number="22" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="737" width="19" height="16" font="0">xx</text>
<text top="163" left="199" width="22" height="16" font="0">8.2</text>
<text top="163" left="240" width="515" height="16" font="0">The eﬀect of garbage collector allocation area size and number of</text>
<text top="187" left="240" width="515" height="16" font="0">generations on IPC. These tests measure the base-line cost, where</text>
<text top="211" left="240" width="515" height="16" font="0">no data is transferred (a 0 word IPC). For a best-ﬁt line of the form</text>
<text top="234" left="240" width="515" height="16" font="0">a +bn found using linear regression, this ﬁgure represents the impact</text>
<text top="258" left="240" width="560" height="16" font="0">of the parameter settings on the base number of cycles per IPC, a. . 264</text>
<text top="282" left="199" width="22" height="16" font="0">8.3</text>
<text top="282" left="240" width="515" height="16" font="0">The eﬀect of garbage collector allocation area size and number of</text>
<text top="306" left="240" width="515" height="16" font="0">generations on IPC. For a best-ﬁt line of the form a + bn, this ﬁgure</text>
<text top="330" left="240" width="515" height="16" font="0">represents the impact of the parameter settings on the additional</text>
<text top="354" left="240" width="560" height="16" font="0">cycles needed per word of data transferred, b. . . . . . . . . . . . . 265</text>
<text top="377" left="199" width="22" height="16" font="0">8.4</text>
<text top="377" left="240" width="515" height="16" font="0">The eﬀects of each optimization presented in this chapter on the</text>
<text top="401" left="240" width="515" height="16" font="0">overall performance of IPC as measured by the ping-pong bench-</text>
<text top="425" left="240" width="44" height="16" font="0">mark.</text>
<text top="425" left="301" width="453" height="16" font="0">Figure 8.4(a) demonstrates that all of our optimizations</text>
<text top="449" left="240" width="515" height="16" font="0">achieve an improvement over the initial, unoptimized implemen-</text>
<text top="473" left="240" width="515" height="16" font="0">tation. Figure 8.4(b) focuses on the optimizations alone to more</text>
<text top="497" left="240" width="560" height="16" font="0">clearly demonstrate the eﬀects of each modiﬁcation. . . . . . . . . . 284</text>
<text top="520" left="199" width="22" height="16" font="0">8.5</text>
<text top="520" left="240" width="515" height="16" font="0">The overall eﬀect of optimization on each phase of the IPC algo-</text>
<text top="544" left="240" width="515" height="16" font="0">rithm. Figure 8.5(a) illustrates the ratio between the cycles taken</text>
<text top="568" left="240" width="515" height="16" font="0">per IPC in the ﬁnal implementation and the original implementa-</text>
<text top="592" left="240" width="515" height="16" font="0">tion. Transfer untyped—the function where we focused our opti-</text>
<text top="616" left="240" width="515" height="16" font="0">mization energy—improves dramatically while the impact on other</text>
<text top="640" left="240" width="519" height="16" font="0">phases varies (some perform slightly better and some perform slightly</text>
<text top="663" left="240" width="515" height="16" font="0">worse). Figure 8.5(b) focuses on the phases of IPC other than trans-</text>
<text top="687" left="240" width="515" height="16" font="0">fer untyped. We see the most improvement in the number of cycles</text>
<text top="711" left="240" width="560" height="16" font="0">taken for overhead and garbage collection. . . . . . . . . . . . . . . 286</text>
</page>
<page number="23" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="747" width="9" height="16" font="0">1</text>
<text top="236" left="447" width="77" height="16" font="0">Chapter 1</text>
<text top="287" left="414" width="143" height="16" font="0">INTRODUCTION</text>
<text top="379" left="173" width="626" height="16" font="0">Software correctness is a persistent challenge that is increasingly relevant as com-</text>
<text top="412" left="173" width="626" height="16" font="0">puters become more seamlessly integrated with every aspect of modern life. Soft-</text>
<text top="444" left="173" width="626" height="16" font="0">ware controls the ﬂight systems in planes and the brake systems in cars; a single</text>
<text top="477" left="173" width="626" height="16" font="0">failure could have a catastrophic eﬀect. Software protects our private health infor-</text>
<text top="509" left="173" width="626" height="16" font="0">mation and sensitive ﬁnancial data; identity theft is as simple as a software breach.</text>
<text top="542" left="173" width="626" height="16" font="0">We rely on software for so much, yet we still do not have suﬃcient techniques for</text>
<text top="574" left="173" width="626" height="16" font="0">assuring that it will not go wrong. In 1996, the Ariane 5 rocket exploded less</text>
<text top="607" left="173" width="626" height="16" font="0">than 40 seconds after lift-oﬀ due to an incorrect conversion of a 64-bit ﬂoating</text>
<text top="639" left="173" width="626" height="16" font="0">point number into a 16-bit integer [72]. More recently, undisclosed software prob-</text>
<text top="672" left="173" width="626" height="16" font="0">lems with the braking system of the Toyota Prius automobile led to a recall of</text>
<text top="704" left="173" width="626" height="16" font="0">more than 125,000 cars [1]. Huge public failures like these show that mistakes can</text>
<text top="737" left="173" width="626" height="16" font="0">get through, even in well tested and widely deployed systems. Despite all of the</text>
<text top="769" left="173" width="626" height="16" font="0">software engineering and validation techniques that have been developed over the</text>
<text top="802" left="173" width="546" height="16" font="0">years, it is still not easy to produce software that is correct and secure.</text>
<text top="834" left="199" width="600" height="16" font="0">One source of diﬃculty is that many real-world systems are written in low-</text>
<text top="867" left="173" width="626" height="16" font="0">level programming languages like C or assembly language. Any complex program</text>
<text top="899" left="173" width="626" height="16" font="0">is likely to contain bugs during development, but these languages lack strong static</text>
<text top="932" left="173" width="626" height="16" font="0">typing and memory-safety guarantees that can protect against common program-</text>
<text top="964" left="173" width="626" height="16" font="0">ming errors. Memory-safety violations—such as dereferencing a null pointer, writ-</text>
<text top="997" left="173" width="626" height="16" font="0">ing beyond the bounds of an array, failing to free memory, or freeing memory more</text>
</page>
<page number="24" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="747" width="9" height="16" font="0">2</text>
<text top="163" left="173" width="626" height="16" font="0">than once—are particularly prevalent in programs written in these languages due</text>
<text top="195" left="173" width="430" height="16" font="0">to the direct and manual way that memory is managed.</text>
<text top="228" left="199" width="600" height="16" font="0">Over the past few years, Coverity’s Scan project [15] has embarked on mas-</text>
<text top="260" left="173" width="626" height="16" font="0">sive studies using static analysis tools to catalog the number and kind of errors</text>
<text top="293" left="173" width="626" height="16" font="0">that exist in large, real-world, open source programs. Their 2009 study, for ex-</text>
<text top="325" left="173" width="626" height="16" font="0">ample, covered 11.5 billion lines of code from 280 open source projects including</text>
<text top="358" left="173" width="626" height="16" font="0">the Linux, FreeBSD, and NetBSD operating systems [14]. According to the Scan</text>
<text top="390" left="173" width="626" height="16" font="0">project data, null pointer dereferences and resource leaks together make up roughly</text>
<text top="423" left="173" width="626" height="16" font="0">50% of the errors found in open source software in both the 2008 and 2009 studies</text>
<text top="455" left="173" width="626" height="16" font="0">(out of 27,752 defects found in the 2008 study and 38,453 defects found in the 2009</text>
<text top="488" left="173" width="626" height="16" font="0">study). We classify both null pointer dereferences and resource leaks as memory-</text>
<text top="520" left="173" width="626" height="16" font="0">safety violations. Other memory-safety violations—such as using memory after</text>
<text top="553" left="173" width="626" height="16" font="0">it has been freed, accessing beyond the end of an array (buﬀer overﬂows), and</text>
<text top="585" left="173" width="626" height="16" font="0">casting a value to a type with a larger representation (allowing the programmer</text>
<text top="618" left="173" width="626" height="16" font="0">to inadvertently overwrite an adjacent value)—are also prevalent in the code stud-</text>
<text top="650" left="173" width="626" height="16" font="0">ied by Coverity; these errors account for more than 10% of the remaining bugs.</text>
<text top="683" left="173" width="626" height="16" font="0">Buﬀer overﬂows and failure to release resources properly also made it into the</text>
<text top="715" left="173" width="626" height="16" font="0">2009 CWE/SANS Top 25 Most Dangerous Programming Errors list, a collabora-</text>
<text top="748" left="173" width="626" height="16" font="0">tion between the SANS Institute and MITRE to identify the worst security risks</text>
<text top="780" left="173" width="626" height="16" font="0">in software today [83]. Clearly, mistakes stemming from memory-safety violations</text>
<text top="813" left="173" width="266" height="16" font="0">are a serious issue in real software.</text>
<text top="845" left="199" width="600" height="16" font="0">With software failures becoming so common, even in widely deployed systems,</text>
<text top="878" left="173" width="626" height="16" font="0">it is obvious that current techniques for implementing and vetting software are</text>
<text top="910" left="173" width="626" height="16" font="0">not suﬃcient for preventing errors. The hardware industry faced a similar cross-</text>
<text top="943" left="173" width="626" height="16" font="0">roads after the famously expensive Intel ﬂoating-point division bug in 1994 [50].</text>
<text top="975" left="173" width="626" height="16" font="0">Since then, formal veriﬁcation has become a major component of the hardware</text>
<text top="1008" left="173" width="626" height="16" font="0">development process at Intel and other major manufacturers [42]. After proving</text>
<text top="1040" left="173" width="626" height="16" font="0">that the hardware designs and implementations are correct, there is less that can</text>
</page>
<page number="25" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="747" width="9" height="16" font="0">3</text>
<text top="163" left="173" width="626" height="16" font="0">go wrong when the systems are deployed to end users. Formal veriﬁcation is a</text>
<text top="195" left="173" width="626" height="16" font="0">powerful technique for increasing assurance and reducing bugs that can be applied</text>
<text top="228" left="173" width="626" height="16" font="0">to components of the software stack to increase reliability in that domain as well.</text>
<text top="287" left="173" width="26" height="16" font="0">1.1</text>
<text top="287" left="219" width="416" height="16" font="0">CORRECTNESS IN OPERATING SYSTEMS</text>
<text top="338" left="173" width="626" height="16" font="0">Operating systems are a particularly important category of software because of</text>
<text top="370" left="173" width="626" height="16" font="0">their role at the base of a typical software stack. An operating system performs</text>
<text top="403" left="173" width="626" height="16" font="0">privileged, low-level manipulations of hardware that higher level software compo-</text>
<text top="435" left="173" width="626" height="16" font="0">nents depend on for their functionality. If the operating system goes wrong in</text>
<text top="468" left="173" width="626" height="16" font="0">some way that results in a system crash, then every application running in the</text>
<text top="500" left="173" width="626" height="16" font="0">system will be aﬀected. Even if the operating system does not crash, it can still</text>
<text top="533" left="173" width="626" height="16" font="0">leak information to the wrong place if it does not manage protection boundaries</text>
<text top="565" left="173" width="626" height="16" font="0">between applications correctly. The degree of centralized control that an operating</text>
<text top="598" left="173" width="626" height="16" font="0">system typically has in such a software stack creates a huge incentive to establish</text>
<text top="630" left="173" width="626" height="16" font="0">the correctness of the OS implementation. All applications that run on top of</text>
<text top="663" left="173" width="626" height="16" font="0">the operating system beneﬁt from the correctness of the underlying layer, no mat-</text>
<text top="695" left="173" width="626" height="16" font="0">ter what their ultimate function is, and operating system correctness provides a</text>
<text top="728" left="173" width="626" height="16" font="0">foundation for reasoning about the correctness of the application layer. For these</text>
<text top="760" left="173" width="626" height="16" font="0">reasons, correctness in the operating systems domain is a particularly important</text>
<text top="793" left="173" width="67" height="16" font="0">problem.</text>
<text top="825" left="199" width="600" height="16" font="0">The seL4 project—a joint work by researchers at NICTA, Open Kernel Labs,</text>
<text top="858" left="173" width="626" height="16" font="0">and the University of New South Wales—veriﬁed the functional correctness of their</text>
<text top="890" left="173" width="626" height="16" font="0">microkernel design and implementation, the ﬁrst time that such a feat has been</text>
<text top="923" left="173" width="626" height="16" font="0">accomplished for a general-purpose operating system [60]. Speciﬁcally, the team</text>
<text top="955" left="173" width="626" height="16" font="0">proved a reﬁnement of an abstract functional speciﬁcation to a high-performance</text>
<text top="988" left="173" width="626" height="16" font="0">C implementation via an executable model (derived from a Haskell prototype). In</text>
<text top="1020" left="173" width="599" height="16" font="0">their veriﬁcation eﬀort, they focused on the following four types of properties.</text>
</page>
<page number="26" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="747" width="9" height="16" font="0">4</text>
<text top="162" left="199" width="600" height="17" font="0">• Low-level invariants that establish the memory-safety of the implementation,</text>
<text top="195" left="217" width="510" height="16" font="0">including, for example, that there are no null pointer dereferences.</text>
<text top="242" left="199" width="600" height="17" font="0">• Typing invariants that establish the type-safety of the implementation be-</text>
<text top="275" left="217" width="410" height="16" font="0">yond what is provided by the weak type system of C.</text>
<text top="322" left="199" width="600" height="17" font="0">• Data structure invariants that establish correctness properties for data struc-</text>
<text top="355" left="217" width="582" height="16" font="0">ture usage, for example, that a particular structure is accessed with consistent</text>
<text top="388" left="217" width="561" height="16" font="0">assumptions about the structure’s layout throughout the entire program.</text>
<text top="434" left="199" width="600" height="17" font="0">• Algorithmic invariants that describe kernel-speciﬁc properties of the imple-</text>
<text top="468" left="217" width="82" height="16" font="0">mentation.</text>
<text top="515" left="173" width="626" height="16" font="0">A key result of their proof is that the kernel is guaranteed to be free from all of</text>
<text top="548" left="173" width="626" height="16" font="0">the common memory-safety violations that the Coverity project typically ﬁnds in</text>
<text top="580" left="173" width="626" height="16" font="0">open source software: buﬀer overﬂows, null pointer dereferences, uses of pointers</text>
<text top="613" left="173" width="626" height="16" font="0">at the wrong type, and memory leaks. Note, however, that the project required</text>
<text top="645" left="173" width="626" height="16" font="0">considerable human eﬀort: the executable model (written in Haskell) and the</text>
<text top="678" left="173" width="626" height="16" font="0">associated C implementation are small, containing 5,700 lines of code and 8,700</text>
<text top="710" left="173" width="626" height="16" font="0">lines of code, respectively, but the veriﬁcation required roughly 160,000 lines of</text>
<text top="743" left="173" width="224" height="16" font="0">Isabelle/HOL [76] script [60].</text>
<text top="775" left="199" width="600" height="16" font="0">While this veriﬁcation eﬀort is impressive, it also demonstrates just how much</text>
<text top="808" left="173" width="626" height="16" font="0">work is required to verify a piece of software as complex as an operating system.</text>
<text top="840" left="173" width="626" height="16" font="0">The project took place over four years with at least a dozen participants, all of</text>
<text top="873" left="173" width="626" height="16" font="0">whom are highly trained. The project members estimate that the veriﬁcation ef-</text>
<text top="905" left="173" width="626" height="16" font="0">fort alone (not including the implementation of the kernel or the design eﬀort)</text>
<text top="938" left="173" width="626" height="16" font="0">required 20 person years of eﬀort [60]. Some of that work was invested in reusable</text>
<text top="970" left="173" width="626" height="16" font="0">infrastructure building activities, but they still estimate that a similar veriﬁcation</text>
<text top="1003" left="173" width="626" height="16" font="0">for a new kernel using the same methodology would require an additional 6 person</text>
<text top="1035" left="173" width="626" height="16" font="0">years, and probably more for someone without the expertise and knowledge built</text>
</page>
<page number="27" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="3" size="8" family="Times" color="#000000"/>
	<fontspec id="4" size="12" family="Times" color="#000000"/>
<text top="111" left="747" width="9" height="16" font="0">5</text>
<text top="163" left="173" width="626" height="16" font="0">up during the course of the seL4 veriﬁcation. The veriﬁcation is not something</text>
<text top="195" left="173" width="626" height="16" font="0">that can easily be repeated by a typical programmer, nor are the proofs directly</text>
<text top="228" left="173" width="626" height="16" font="0">reusable. If we design a new kernel, or even modify the current seL4 implementa-</text>
<text top="260" left="173" width="626" height="16" font="0">tion, then a signiﬁcant fraction of the veriﬁcation eﬀort will need to be repeated</text>
<text top="293" left="173" width="626" height="16" font="0">for the new software artifact. The seL4 team have veriﬁed their ARM implementa-</text>
<text top="325" left="173" width="626" height="16" font="0">tion, but not their port to the x86 [60]. Certainly these artifacts could be veriﬁed</text>
<text top="358" left="173" width="626" height="16" font="0">as well, but this shows that, even for relatively minor implementation diﬀerences,</text>
<text top="390" left="173" width="537" height="16" font="0">the veriﬁcation changes are time consuming enough to be a deterrent.</text>
<text top="450" left="173" width="26" height="16" font="0">1.2</text>
<text top="450" left="219" width="595" height="16" font="0">PURELY FUNCTIONAL LANGUAGES FOR MEMORY-SAFETY</text>
<text top="500" left="173" width="626" height="16" font="0">We would like to obtain some of the assurance of a project like seL4 in a way that is</text>
<text top="533" left="173" width="626" height="16" font="0">more scalable and reusable, without paying such a high cost for veriﬁcation again</text>
<text top="565" left="173" width="479" height="16" font="0">and again. One approach is to use a purely functional language</text>
<text top="563" left="652" width="6" height="11" font="2">1</text>
<text top="565" left="664" width="135" height="16" font="0">for the implemen-</text>
<text top="598" left="173" width="626" height="16" font="0">tation, rather than a low-level language like C. Purely functional languages oﬀer</text>
<text top="630" left="173" width="626" height="16" font="0">many language features with software engineering beneﬁts, such as expressive type</text>
<text top="663" left="173" width="626" height="16" font="0">systems, higher-order functions, polymorphism, abstract datatypes, and powerful</text>
<text top="695" left="173" width="626" height="16" font="0">module systems. These mechanisms facilitate compile-time bug detection and the</text>
<text top="728" left="173" width="626" height="16" font="0">development of clear, concise, and modular programs with a high degree of reuse.</text>
<text top="760" left="173" width="626" height="16" font="0">Such beneﬁts alone might be enough to recommend pure languages for operating</text>
<text top="793" left="173" width="626" height="16" font="0">system implementations, but we are particularly interested in the fact that pure</text>
<text top="825" left="173" width="626" height="16" font="0">functional languages provide memory-safety, garbage collection, and ﬁne-grained</text>
<text top="858" left="173" width="626" height="16" font="0">eﬀect tracking in the type system. By implementing operating systems in a purely</text>
<text top="890" left="173" width="626" height="16" font="0">functional language, it is possible to leverage these properties to automatically ob-</text>
<text top="923" left="173" width="626" height="16" font="0">tain many of the guarantees that the seL4 team worked so hard to prove—the type</text>
<text top="968" left="193" width="6" height="9" font="3">1</text>
<text top="971" left="200" width="600" height="13" font="4">Throughout this document we will use the terms purely functional languages and pure lan-</text>
<text top="998" left="173" width="626" height="13" font="4">guages synonymously to refer to typed functional languages with pure semantics and dynamic</text>
<text top="1025" left="173" width="626" height="13" font="4">memory management using garbage collection. This feature set is typical for functional languages</text>
<text top="1051" left="173" width="324" height="13" font="4">with pure semantics, and is assumed in our work.</text>
</page>
<page number="28" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="747" width="9" height="16" font="0">6</text>
<text top="163" left="173" width="626" height="16" font="0">system enforces them. For example, in the purely functional language Haskell [78],</text>
<text top="195" left="173" width="626" height="16" font="0">it is impossible, in principle, to dereference a null pointer, so we know without any</text>
<text top="228" left="173" width="509" height="16" font="0">testing or proofs that any code written in Haskell avoids such bugs</text>
<text top="226" left="682" width="6" height="11" font="2">2</text>
<text top="228" left="689" width="110" height="16" font="0">. Writing soft-</text>
<text top="260" left="173" width="626" height="16" font="0">ware in a purely functional language has further beneﬁts for reasoning because the</text>
<text top="293" left="173" width="626" height="16" font="0">semantics are close to those of mathematical functions, so programs are amenable</text>
<text top="325" left="173" width="626" height="16" font="0">to formal reasoning for establishing any properties that cannot be derived from</text>
<text top="358" left="173" width="91" height="16" font="0">types alone.</text>
<text top="390" left="199" width="600" height="16" font="0">In practice, however, it is often assumed that we cannot utilize the beneﬁts of</text>
<text top="423" left="173" width="626" height="16" font="0">purely functional languages in operating systems development because of a gap</text>
<text top="455" left="173" width="626" height="16" font="0">between the requirements of operating systems implementations and the facilities</text>
<text top="488" left="173" width="626" height="16" font="0">provided by standard purely functional languages. For example, these languages</text>
<text top="520" left="173" width="626" height="16" font="0">provide strong safety guarantees—like memory-safety—by relying on a run-time</text>
<text top="553" left="173" width="626" height="16" font="0">system that controls the layout and conﬁguration of memory (with a garbage col-</text>
<text top="585" left="173" width="626" height="16" font="0">lector to manage storage usage). However, a primary function of an operating</text>
<text top="618" left="173" width="626" height="16" font="0">system is to manage the memory of the machine. Most language run-times do not</text>
<text top="650" left="173" width="626" height="16" font="0">support the ability to access hardware memory-management facilities directly, in-</text>
<text top="683" left="173" width="626" height="16" font="0">stead, the programmer must access these hardware features through foreign calls.</text>
<text top="715" left="173" width="626" height="16" font="0">Foreign function interfaces allow programmers to work with low-level (and poten-</text>
<text top="748" left="173" width="626" height="16" font="0">tially unsafe) functions and values in an otherwise pure language. Declarations</text>
<text top="780" left="173" width="626" height="16" font="0">in the language introduce assumptions about the type of an externally deﬁned</text>
<text top="813" left="173" width="626" height="16" font="0">value or function, and everything is assumed to be used in a safe way. As we</text>
<text top="845" left="173" width="626" height="16" font="0">will illustrate in the next section, an approach based on foreign function interface</text>
<text top="878" left="173" width="626" height="16" font="0">deﬁnitions enables one to write powerful programs in pure languages with limited</text>
<text top="910" left="173" width="626" height="16" font="0">restrictions due to the type system, at the cost of signiﬁcantly weakening the safety</text>
<text top="943" left="173" width="626" height="16" font="0">argument for the entire program. A mistake in the foreign code can destroy the</text>
<text top="989" left="193" width="6" height="9" font="3">2</text>
<text top="991" left="200" width="600" height="13" font="4">The Foreign Function Interface extension to Haskell [12] does make it possible to dereference</text>
<text top="1018" left="173" width="626" height="13" font="4">a null pointer. In this case, we refer to Haskell 98 without extensions, but will cover the impact</text>
<text top="1045" left="173" width="280" height="13" font="4">of the foreign function interface separately.</text>
</page>
<page number="29" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="747" width="9" height="16" font="0">7</text>
<text top="163" left="173" width="257" height="16" font="0">safety of the program completely.</text>
<text top="222" left="173" width="26" height="16" font="0">1.3</text>
<text top="222" left="219" width="540" height="16" font="0">EXAMPLE: LOW-LEVEL PROGRAMMING IN HASKELL</text>
<text top="273" left="173" width="626" height="16" font="0">As a concrete example, let us examine the Foreign Function Interface (FFI) exten-</text>
<text top="305" left="173" width="626" height="16" font="0">sion of the Haskell language [12], which enables Haskell programmers to perform a</text>
<text top="338" left="173" width="626" height="16" font="0">variety of low-level programming tasks. For example, the FFI provides the ability</text>
<text top="370" left="173" width="626" height="16" font="0">to call C functions, extending Haskell with new behaviors by adding new primitives.</text>
<text top="403" left="173" width="626" height="16" font="0">Of course, there is no static typing or guaranteed memory-safety for the extensions</text>
<text top="435" left="173" width="626" height="16" font="0">written in C, so using the FFI introduces proof obligations that must be satisﬁed</text>
<text top="468" left="173" width="626" height="16" font="0">to avoid compromising the type- and memory-safety of the language. In addition</text>
<text top="500" left="173" width="626" height="16" font="0">to the ability to call C functions, the FFI extension includes support libraries that</text>
<text top="533" left="173" width="626" height="16" font="0">introduce unchecked pointer types, pointer arithmetic operations, and assignments</text>
<text top="565" left="173" width="626" height="16" font="0">to memory through pointers, all within Haskell and with Haskell types. But if these</text>
<text top="598" left="173" width="626" height="16" font="0">primitives are used incorrectly, they can corrupt the Haskell heap, invalidating all</text>
<text top="630" left="173" width="626" height="16" font="0">of the Haskell type- and memory-safety properties! Essentially, the FFI extension</text>
<text top="663" left="173" width="626" height="16" font="0">introduces the power of manual and direct memory management that we have in C,</text>
<text top="695" left="173" width="626" height="16" font="0">along with all of its problems and potential for mistakes. The rationale for writing</text>
<text top="728" left="173" width="626" height="16" font="0">operating systems in a purely functional language was to obtain the strong safety</text>
<text top="760" left="173" width="626" height="16" font="0">beneﬁts of the language, yet the facilities available for writing low-level software</text>
<text top="793" left="173" width="312" height="16" font="0">break those very same strong properties.</text>
<text top="852" left="173" width="26" height="16" font="0">1.4</text>
<text top="852" left="219" width="580" height="16" font="0">ASSURANCE THROUGH A SMALL TRUSTED COMPUTING</text>
<text top="885" left="219" width="54" height="16" font="0">BASE</text>
<text top="935" left="173" width="626" height="16" font="0">To deal with the dangers of low-level memory manipulation, we consider an op-</text>
<text top="968" left="173" width="626" height="16" font="0">erating system implementation in a purely functional language based on the idea</text>
<text top="1000" left="173" width="626" height="16" font="0">of a small trusted computing base (TCB). Lampson et al. [64] deﬁne the TCB of</text>
<text top="1033" left="173" width="626" height="16" font="0">a system as a “small amount of software and hardware that security depends on</text>
</page>
<page number="30" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="747" width="9" height="16" font="0">8</text>
<text top="163" left="173" width="626" height="16" font="0">and that we distinguish from a much larger amount that can misbehave with-</text>
<text top="195" left="173" width="626" height="16" font="0">out aﬀecting security.” The basic idea is to isolate the essential services of the</text>
<text top="228" left="173" width="626" height="16" font="0">system behind a small, well-deﬁned software component. This component must</text>
<text top="260" left="173" width="626" height="16" font="0">only be accessed through a restricted interface because the code in the TCB has</text>
<text top="293" left="173" width="626" height="16" font="0">more privileges and therefore more potential to wreak havoc if an error occurs.</text>
<text top="325" left="173" width="626" height="16" font="0">By keeping the TCB small and its interface well-deﬁned, there is more hope of</text>
<text top="358" left="173" width="626" height="16" font="0">constructing a system that is correct overall than with a monolithic design, partic-</text>
<text top="390" left="173" width="626" height="16" font="0">ularly when the behavior of higher-level layers is limited to a set of safe lower level</text>
<text top="423" left="173" width="626" height="16" font="0">operations. Many types of operating system kernels exist based on diﬀerent TCB</text>
<text top="455" left="173" width="626" height="16" font="0">design principles, including separation kernels [81, 21], microkernels [11, 2, 70], and</text>
<text top="488" left="173" width="173" height="16" font="0">hypervisors [16, 29, 5].</text>
<text top="520" left="199" width="600" height="16" font="0">In our work, we apply the trusted computing base approach to safe operating</text>
<text top="553" left="173" width="626" height="16" font="0">systems programming in a purely functional language. The trusted computing</text>
<text top="585" left="173" width="626" height="16" font="0">base should be a small set of essential services that are speciﬁcally designed for</text>
<text top="618" left="173" width="626" height="16" font="0">writing operating systems. These services must be written in a low-level language</text>
<text top="650" left="173" width="626" height="16" font="0">like C or in the unsafe portion of a purely functional language in order to perform</text>
<text top="683" left="173" width="626" height="16" font="0">their function. However, these services can be added to the language run-time</text>
<text top="715" left="173" width="626" height="16" font="0">system or packaged up as an abstraction layer that can be integrated with pro-</text>
<text top="748" left="173" width="626" height="16" font="0">grams in the purely functional language, with the expectation that no code above</text>
<text top="780" left="173" width="626" height="16" font="0">the abstraction layer will access the unsafe facilities of the language. Purity pro-</text>
<text top="813" left="173" width="626" height="16" font="0">vides the ability to distinguish contexts that rely on the safe abstraction layer from</text>
<text top="845" left="173" width="626" height="16" font="0">contexts that rely on unsafe language features using the type system. Figure 1.1</text>
<text top="878" left="173" width="626" height="16" font="0">illustrates how the pieces ﬁt together. For this approach to work, the operations</text>
<text top="910" left="173" width="626" height="16" font="0">of the abstraction layer must be suﬃciently expressive to support the implementa-</text>
<text top="943" left="173" width="626" height="16" font="0">tion of real operating systems in the pure functional language, with no additional</text>
<text top="975" left="173" width="626" height="16" font="0">reliance on a foreign function interface or other unsafe primitives. In addition, the</text>
<text top="1008" left="173" width="626" height="16" font="0">operations themselves must be memory-safe, even though their implementations</text>
<text top="1040" left="173" width="626" height="16" font="0">may use potentially unsafe operations on the underlying hardware. The client will</text>
</page>
<page number="31" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="5" size="18" family="Times" color="#000000"/>
<text top="111" left="747" width="9" height="16" font="0">9</text>
<text top="331" left="385" width="83" height="23" font="5">Hardware</text>
<text top="269" left="270" width="313" height="23" font="5">Potentially Unsafe Abstraction Layer</text>
<text top="294" left="360" width="133" height="23" font="5">Implementation</text>
<text top="169" left="273" width="306" height="23" font="5">Purely Functional Operating System</text>
<text top="195" left="360" width="133" height="23" font="5">Implementation</text>
<text top="232" left="329" width="195" height="23" font="5">Memory Safe Interface</text>
<text top="238" left="651" width="98" height="23" font="5">Abstraction</text>
<text top="263" left="675" width="49" height="23" font="5">Layer</text>
<text top="421" left="173" width="626" height="16" font="0">Figure 1.1: The system organization when dividing an operating system into an</text>
<text top="454" left="173" width="415" height="16" font="0">unsafe abstraction layer and a purely functional layer.</text>
<text top="505" left="173" width="626" height="16" font="0">not have access to pointers or direct memory writes or any of the other hazardous</text>
<text top="538" left="173" width="607" height="16" font="0">facilities, just those operations that are essential for writing operating systems.</text>
<text top="597" left="173" width="26" height="16" font="0">1.5</text>
<text top="597" left="219" width="122" height="16" font="0">THIS WORK</text>
<text top="647" left="173" width="626" height="16" font="0">The primary focus of this work is to design a set of operations that is memory-safe</text>
<text top="680" left="173" width="494" height="16" font="0">and suﬃciently expressive to support writing operating systems.</text>
<text top="732" left="217" width="539" height="16" font="0">Thesis Statement: The gap between the requirements of operating</text>
<text top="764" left="217" width="539" height="16" font="0">system implementations and the features of purely functional languages</text>
<text top="797" left="217" width="539" height="16" font="0">can be bridged by isolating potentially unsafe memory operations in a</text>
<text top="829" left="217" width="539" height="16" font="0">memory-safe abstraction layer that is well integrated with the func-</text>
<text top="862" left="217" width="122" height="16" font="0">tional language.</text>
<text top="914" left="199" width="600" height="16" font="0">In this dissertation, we work speciﬁcally with Haskell as the primary implemen-</text>
<text top="946" left="173" width="626" height="16" font="0">tation language, though the main techniques should work for any purely functional</text>
<text top="979" left="173" width="626" height="16" font="0">language and, in many respects, would even apply to the broader class of memory-</text>
<text top="1011" left="173" width="626" height="16" font="0">safe languages, such as Java. The primary contributions of this dissertation are as</text>
<text top="1044" left="173" width="57" height="16" font="0">follows:</text>
</page>
<page number="32" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">10</text>
<text top="162" left="199" width="600" height="17" font="0">• A design of a functional, memory-safe abstraction layer that is suﬃciently</text>
<text top="195" left="217" width="583" height="16" font="0">expressive to support the implementation of real operating systems using</text>
<text top="228" left="217" width="434" height="16" font="0">only the operations of the abstraction layer (Chapter 4).</text>
<text top="274" left="199" width="520" height="17" font="0">• A formal deﬁnition of memory-safety for our system (Chapter 5).</text>
<text top="322" left="199" width="600" height="17" font="0">• A formal model of the internal operation of the abstraction layer that pro-</text>
<text top="355" left="217" width="583" height="16" font="0">vides a speciﬁcation of the behavior for each function in the API and connects</text>
<text top="388" left="217" width="552" height="16" font="0">the formal notion of memory-safety to our implementation (Chapter 5).</text>
<text top="434" left="199" width="600" height="17" font="0">• An implementation of the abstraction layer design that is integrated with</text>
<text top="468" left="217" width="397" height="16" font="0">the purely functional language Haskell (Chapter 6).</text>
<text top="514" left="199" width="600" height="17" font="0">• An implementation of the L4 microkernel API [62] in Haskell, based on the</text>
<text top="548" left="217" width="583" height="16" font="0">abstraction layer implementation (and without additional use of the Haskell</text>
<text top="580" left="217" width="583" height="16" font="0">FFI), as a demonstration that the interface is suﬃciently expressive to sup-</text>
<text top="613" left="217" width="519" height="16" font="0">port the implementation of realistic operating systems (Chapter 7).</text>
<text top="659" left="199" width="600" height="17" font="0">• An analysis of the cost of our approach through a targeted analysis of the</text>
<text top="693" left="217" width="583" height="16" font="0">inter-process communication performance of the L4 implementation (Chap-</text>
<text top="725" left="217" width="48" height="16" font="0">ter 8).</text>
<text top="773" left="173" width="626" height="16" font="0">In the remainder of this dissertation, we will elaborate on each of these contribu-</text>
<text top="805" left="173" width="626" height="16" font="0">tions in turn. Chapters 2 and 3 review relevant background material on operating</text>
<text top="838" left="173" width="443" height="16" font="0">systems and Haskell programming. Chapters 4, 5, and</text>
<text top="838" left="632" width="167" height="16" font="0">6 present the design,</text>
<text top="870" left="173" width="626" height="16" font="0">formal model, and implementation of the abstraction layer, respectively. Chap-</text>
<text top="903" left="173" width="626" height="16" font="0">ter 7 describes the L4 case study. Chapter 8 discusses the performance results</text>
<text top="935" left="173" width="626" height="16" font="0">and demonstrates our approach to optimizing the L4 implementation. In the re-</text>
<text top="968" left="173" width="626" height="16" font="0">maining chapters, we review related work (Chapter 9) and present conclusions</text>
<text top="1000" left="173" width="104" height="16" font="0">(Chapter 10).</text>
</page>
<page number="33" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">11</text>
<text top="236" left="447" width="77" height="16" font="0">Chapter 2</text>
<text top="287" left="208" width="556" height="16" font="0">BACKGROUND: CORE CONCEPTS OF INTEL IA32 PROCESSORS</text>
<text top="379" left="173" width="626" height="16" font="0">In the design of our abstraction layer, we would prefer to remain as architec-</text>
<text top="412" left="173" width="626" height="16" font="0">ture neutral as possible, but it is inevitable that certain hardware features will</text>
<text top="444" left="173" width="626" height="16" font="0">be exposed when constructing an abstraction that is so close to the hardware.</text>
<text top="477" left="173" width="626" height="16" font="0">CPU mechanisms such as registers, privileged mode execution, interrupts, and</text>
<text top="509" left="173" width="626" height="16" font="0">hardware-supported virtual-address translation are important features that sup-</text>
<text top="542" left="173" width="626" height="16" font="0">port operating systems development. Interrupt handling plays an important role</text>
<text top="574" left="173" width="626" height="16" font="0">in our implementation of user program execution; we expose architecture-speciﬁc</text>
<text top="607" left="173" width="626" height="16" font="0">details about interrupts and registers to support client-level interrupt handlers.</text>
<text top="639" left="173" width="626" height="16" font="0">Memory management is an essential part of the design and memory-safety anal-</text>
<text top="672" left="173" width="626" height="16" font="0">ysis for the abstraction layer; we abstract over some details in the API, but the</text>
<text top="704" left="173" width="626" height="16" font="0">speciﬁcation and implementation rely heavily on the speciﬁc features of the un-</text>
<text top="737" left="173" width="626" height="16" font="0">derlying hardware. In this chapter, we present background material about our</text>
<text top="769" left="173" width="626" height="16" font="0">target architecture, the Intel IA32 platform [52], that is necessary to understand</text>
<text top="802" left="173" width="626" height="16" font="0">the abstraction layer design and implementation. We examine the fundamentals</text>
<text top="834" left="173" width="626" height="16" font="0">of the execution environment, including the register set and interrupt-handling</text>
<text top="867" left="173" width="626" height="16" font="0">mechanism, in Section 2.1 and review the virtual-to-physical address translation</text>
<text top="899" left="173" width="626" height="16" font="0">mechanism in Section 2.2. Readers already familiar with these details may skip</text>
<text top="932" left="173" width="204" height="16" font="0">ahead to the next chapter.</text>
</page>
<page number="34" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">12</text>
<text top="163" left="173" width="26" height="16" font="0">2.1</text>
<text top="163" left="219" width="290" height="16" font="0">EXECUTION ENVIRONMENT</text>
<text top="213" left="173" width="626" height="16" font="0">In this section, we explain the essential concepts of the execution environment</text>
<text top="246" left="173" width="626" height="16" font="0">available on the IA32 architecture. These facilities strongly inﬂuence the design</text>
<text top="278" left="173" width="626" height="16" font="0">of the lowest levels of the abstraction layer. The goal of this section is to help</text>
<text top="311" left="173" width="626" height="16" font="0">the reader develop enough familiarity with the hardware platform to understand</text>
<text top="343" left="173" width="626" height="16" font="0">the abstraction layer design and the techniques used to execute user programs</text>
<text top="376" left="173" width="626" height="16" font="0">in our implementation. Section 2.1.1 explains the register set of the platform;</text>
<text top="408" left="173" width="626" height="16" font="0">Section 2.1.2 describes the modes of execution; Section 2.1.3 discusses faults and</text>
<text top="441" left="173" width="626" height="16" font="0">interrupt handling; and Section 2.1.4 provides a brief introduction to port I/O. We</text>
<text top="473" left="173" width="626" height="16" font="0">will present the abstraction layer mechanisms for exposing these concepts to client</text>
<text top="506" left="173" width="591" height="16" font="0">kernels in Section 4.5, and address the implementation details in Section 6.8.</text>
<text top="563" left="173" width="41" height="16" font="0">2.1.1</text>
<text top="563" left="234" width="81" height="16" font="0">Registers</text>
<text top="607" left="173" width="626" height="16" font="0">The registers of the machine store the execution state of the running program. The</text>
<text top="640" left="173" width="626" height="16" font="0">IA32 architecture has eight general purpose registers, six segment registers, a ﬂags</text>
<text top="672" left="173" width="626" height="16" font="0">register that stores information about the state of the machine, and an instruction</text>
<text top="705" left="173" width="626" height="16" font="0">pointer that stores the location of the next instruction to execute. Figure 2.1 shows</text>
<text top="737" left="173" width="626" height="16" font="0">the names and sizes of these registers. Intuitively, the CPU can be programmed</text>
<text top="770" left="173" width="626" height="16" font="0">to switch to a new program by loading a new set of values into these registers. If</text>
<text top="802" left="173" width="626" height="16" font="0">we want an opportunity to return to the original program at a later stage, then</text>
<text top="835" left="173" width="538" height="16" font="0">we must save the register values in memory before making the switch.</text>
<text top="867" left="199" width="600" height="16" font="0">General purpose registers are available to store operands to computations, re-</text>
<text top="900" left="173" width="626" height="16" font="0">sults of operations, and pointers into memory. The machine associates a special</text>
<text top="932" left="173" width="626" height="16" font="0">semantics with the ESP register, though it is referred to as general purpose, which</text>
<text top="965" left="173" width="426" height="16" font="0">is designated for holding the stack pointer of programs.</text>
<text top="997" left="199" width="600" height="16" font="0">The segment registers each hold a segment selector that serves as an index</text>
<text top="1030" left="173" width="626" height="16" font="0">into the global descriptor table. The entries of the global descriptor table describe</text>
</page>
<page number="35" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">13</text>
<text top="716" left="243" width="486" height="16" font="0">Figure 2.1: The registers of the IA32 architecture. This ﬁg-</text>
<text top="748" left="243" width="486" height="16" font="0">ure is a reproduction of Figure 3-4 from the Intel Architectures</text>
<text top="781" left="243" width="261" height="16" font="0">Software Developer’s Manual [52].</text>
<text top="838" left="173" width="626" height="16" font="0">areas of memory, called segments, that may be used in programs to control access</text>
<text top="871" left="173" width="626" height="16" font="0">to the linear address-space. At any given point, the CPU has access to up to</text>
<text top="903" left="173" width="626" height="16" font="0">six distinct segments via the six segment registers. The access rights available on</text>
<text top="936" left="173" width="626" height="16" font="0">each segment are deﬁned by the corresponding entry in the global descriptor table.</text>
<text top="968" left="173" width="626" height="16" font="0">There is a code segment for storing instructions (pointed to by the CS register) a</text>
<text top="1001" left="173" width="626" height="16" font="0">stack segment for storing the program stack (pointed to by the SS register), and</text>
<text top="1033" left="173" width="626" height="16" font="0">four data segments (pointed to by the DS, ES, FS, and GS registers). In our work,</text>
</page>
<page number="36" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">14</text>
<text top="163" left="173" width="626" height="16" font="0">we use a ﬂat memory model : all of the segments overlap and contain the entire</text>
<text top="195" left="173" width="288" height="16" font="0">address space, as shown in Figure 2.2</text>
<text top="193" left="460" width="6" height="11" font="2">1</text>
<text top="195" left="467" width="5" height="16" font="0">.</text>
<text top="645" left="243" width="486" height="16" font="0">Figure 2.2: A ﬂat memory model conﬁguration. Every segment</text>
<text top="678" left="243" width="486" height="16" font="0">overlaps and contains the entire address space of the machine.</text>
<text top="710" left="243" width="486" height="16" font="0">This ﬁgure is a reproduction of Figure 3-6 from the Intel Archi-</text>
<text top="743" left="243" width="328" height="16" font="0">tectures Software Developer’s Manual [52].</text>
<text top="827" left="173" width="41" height="16" font="0">2.1.2</text>
<text top="827" left="234" width="176" height="16" font="0">Modes of Execution</text>
<text top="871" left="173" width="626" height="16" font="0">The IA32 has four modes of execution, called rings, that correspond to diﬀerent</text>
<text top="904" left="173" width="626" height="16" font="0">privilege levels. Lower numbered rings aﬀord the executing code greater access to</text>
<text top="936" left="173" width="626" height="16" font="0">hardware features. If software attempts to access functionality that is forbidden</text>
<text top="982" left="193" width="6" height="9" font="3">1</text>
<text top="984" left="200" width="600" height="13" font="4">Our L4 implementation requires a special conﬁguration of the GS register that does not ﬁt</text>
<text top="1011" left="173" width="626" height="13" font="4">the ﬂat memory model to satisfy a detail of the L4 speciﬁcation. Special uses of the segment</text>
<text top="1038" left="173" width="517" height="13" font="4">registers like this can be incorporated into the implementation when necessary.</text>
</page>
<page number="37" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">15</text>
<text top="163" left="173" width="626" height="16" font="0">in the current ring, the hardware faults and the execution of the oﬀending code</text>
<text top="195" left="173" width="626" height="16" font="0">is suspended (faults will be covered in Section 2.1.3). Ring 0 is typically used</text>
<text top="228" left="173" width="626" height="16" font="0">for kernel code, while applications typically run in Ring 3. Rings 1 and 2 are</text>
<text top="260" left="173" width="626" height="16" font="0">designed for operating system services like device drivers. Our abstraction layer</text>
<text top="293" left="173" width="626" height="16" font="0">implementation, like many systems, only uses two privilege levels: kernel code runs</text>
<text top="325" left="173" width="626" height="16" font="0">in Ring 0 (also called kernel-mode or supervisor mode) and all other code runs in</text>
<text top="358" left="173" width="279" height="16" font="0">Ring 3 (also called user-level mode).</text>
<text top="416" left="173" width="41" height="16" font="0">2.1.3</text>
<text top="416" left="234" width="189" height="16" font="0">Faults and Interrupts</text>
<text top="460" left="173" width="626" height="16" font="0">During the course of execution, running software may encounter an interrupt or</text>
<text top="492" left="173" width="626" height="16" font="0">exception. There are three sources of interrupts and exceptions: external inter-</text>
<text top="525" left="173" width="626" height="16" font="0">rupts from hardware devices, programmable software interrupts (triggered using</text>
<text top="557" left="173" width="626" height="16" font="0">the INT n instruction), and faults due to program error conditions (such as division</text>
<text top="590" left="173" width="626" height="16" font="0">by zero or attempts to access to supervisor-level hardware features from user-level).</text>
<text top="622" left="173" width="626" height="16" font="0">For the purposes of this thesis, we will ignore the distinction between interrupts</text>
<text top="655" left="173" width="568" height="16" font="0">and exceptions and will refer to both kinds of events simply as interrupts.</text>
<text top="687" left="199" width="600" height="16" font="0">When an interrupt occurs, the CPU branches out of the currently executing</text>
<text top="720" left="173" width="626" height="16" font="0">program to the handler for that particular event. A special data-structure called</text>
<text top="752" left="173" width="626" height="16" font="0">the interrupt descriptor table (IDT) speciﬁes the mapping between interrupts and</text>
<text top="785" left="173" width="626" height="16" font="0">their associated handlers. Each interrupt is identiﬁed by a unique number called</text>
<text top="817" left="173" width="626" height="16" font="0">an interrupt vector. When an interrupt with a particular vector number occurs,</text>
<text top="850" left="173" width="548" height="16" font="0">control transfers to the handler associated with that vector in the IDT.</text>
<text top="882" left="199" width="600" height="16" font="0">For code executing in user-mode, the occurrence of an interrupt causes the</text>
<text top="915" left="173" width="626" height="16" font="0">processor to switch privilege level and begin executing in kernel-mode. The hard-</text>
<text top="947" left="173" width="626" height="16" font="0">ware sets a new stack segment value and stack pointer so that the kernel-mode</text>
<text top="980" left="173" width="626" height="16" font="0">interrupt handler does not need to share a stack with user programs. The values</text>
<text top="1012" left="173" width="626" height="16" font="0">describing the handler stack come from the task-state segment (TSS), which is</text>
<text top="1045" left="173" width="626" height="16" font="0">a special segment on IA32 that supports hardware-assisted task-switching. The</text>
</page>
<page number="38" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">16</text>
<text top="163" left="173" width="626" height="16" font="0">abstraction layer implements task management in software, but we make funda-</text>
<text top="195" left="173" width="626" height="16" font="0">mental use of the ability to install an interrupt-handler stack via the TSS. As we</text>
<text top="228" left="173" width="626" height="16" font="0">will see in Section 6.8, we use the interrupt-handler stack for saving the register</text>
<text top="260" left="173" width="626" height="16" font="0">state of user programs between executions. The client kernel may save the state</text>
<text top="293" left="173" width="626" height="16" font="0">of multiple user programs simultaneously by creating multiple interrupt-handler</text>
<text top="325" left="173" width="626" height="16" font="0">stacks (called fault-contexts in our design). These interrupt-handler stacks are only</text>
<text top="358" left="173" width="626" height="16" font="0">used for saving the state of user programs—the Haskell code runs using a separate</text>
<text top="390" left="173" width="96" height="16" font="0">kernel stack.</text>
<text top="423" left="199" width="600" height="16" font="0">At the start of an interrupt handler, the hardware automatically pushes certain</text>
<text top="455" left="173" width="626" height="16" font="0">parts of the register-state onto the stack. For user-mode interrupts, this state</text>
<text top="488" left="173" width="626" height="16" font="0">contains the values of the instruction pointer, stack pointer, ﬂags register, code</text>
<text top="520" left="173" width="626" height="16" font="0">segment register, and stack segment register of the executing process. For kernel-</text>
<text top="553" left="173" width="626" height="16" font="0">mode interrupts, the handler runs on the same stack as the original code, so the</text>
<text top="585" left="173" width="626" height="16" font="0">hardware does not save the stack segment or stack pointer. In our abstraction</text>
<text top="618" left="173" width="626" height="16" font="0">layer implementation, we save additional information about the state of user-mode</text>
<text top="650" left="173" width="626" height="16" font="0">programs so that we have enough information to resume the program after handling</text>
<text top="683" left="173" width="626" height="16" font="0">the interrupt. This information includes the general purpose registers, the data</text>
<text top="715" left="173" width="626" height="16" font="0">segment registers, and the error code value for the interrupt (for faults that include</text>
<text top="748" left="173" width="626" height="16" font="0">supplemental information about the nature of the exception in the form of an error</text>
<text top="780" left="173" width="626" height="16" font="0">code). The hardware supports the ability to suppress interrupts using the CLI</text>
<text top="813" left="173" width="545" height="16" font="0">instruction; we use this capability to disable interrupts in kernel-mode.</text>
<text top="845" left="199" width="600" height="16" font="0">Interrupts are the mechanism that enable user-level code to transfer control</text>
<text top="878" left="173" width="626" height="16" font="0">back to the kernel. For program-error exceptions, the kernel will typically repair</text>
<text top="910" left="173" width="626" height="16" font="0">the fault and resume the original process (possibly with the help of an external</text>
<text top="943" left="173" width="626" height="16" font="0">interrupt handler). For unrecoverable faults, the kernel may choose a new user-</text>
<text top="975" left="173" width="626" height="16" font="0">level program to run after suspending or killing the faulting process. User-level</text>
<text top="1008" left="173" width="626" height="16" font="0">code may also request operations from the kernel using interrupts: system calls can</text>
<text top="1040" left="173" width="626" height="16" font="0">be implemented using software interrupts whose handlers invoke the appropriate</text>
</page>
<page number="39" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">17</text>
<text top="163" left="173" width="626" height="16" font="0">routines within the kernel. Operating system developers can ensure that control</text>
<text top="195" left="173" width="626" height="16" font="0">always returns to the kernel by conﬁguring a recurring timer interrupt that trans-</text>
<text top="228" left="173" width="626" height="16" font="0">fers control to the kernel at regular intervals. If timer interrupts are conﬁgured and</text>
<text top="260" left="173" width="626" height="16" font="0">handled appropriately, then a user-process cannot take over the machine, even if it</text>
<text top="293" left="173" width="626" height="16" font="0">never faults or issues a system call—the kernel will get an opportunity to execute</text>
<text top="325" left="173" width="529" height="16" font="0">and make scheduling decisions when the next timer interrupt occurs.</text>
<text top="383" left="173" width="41" height="16" font="0">2.1.4</text>
<text top="383" left="234" width="124" height="16" font="0">Input/Output</text>
<text top="427" left="173" width="626" height="16" font="0">Many PC devices (including timers, serial ports, the keyboard, mouse, and network</text>
<text top="460" left="173" width="626" height="16" font="0">interfaces) are controlled by reading and writing data and control information to</text>
<text top="492" left="173" width="626" height="16" font="0">speciﬁed ports through special in and out instructions. The CPU communicates</text>
<text top="525" left="173" width="626" height="16" font="0">with these devices via one of sixteen interrupt lines available on the hardware.</text>
<text top="557" left="173" width="626" height="16" font="0">These interrupt lines deliver interrupt requests (IRQs) to the processor via a multi-</text>
<text top="590" left="173" width="626" height="16" font="0">plexer called the programmable interrupt controller (PIC). On the PC architecture,</text>
<text top="622" left="173" width="626" height="16" font="0">the multiplexing behavior is divided between two circuits: a master PIC handles</text>
<text top="655" left="173" width="626" height="16" font="0">IRQ 0 through IRQ 7 and a slave PIC handles IRQ 8 through IRQ 15. The ker-</text>
<text top="687" left="173" width="626" height="16" font="0">nel enables, disables, or acknowledges interrupts on a particular line by writing</text>
<text top="720" left="173" width="626" height="16" font="0">to the registers of the programmable interrupt controllers, which are connected to</text>
<text top="752" left="173" width="626" height="16" font="0">speciﬁc ports. Only the master PIC communicates with the processor, so one of</text>
<text top="785" left="173" width="626" height="16" font="0">its interrupt lines must be used for the slave to communicate interrupt requests</text>
<text top="817" left="173" width="626" height="16" font="0">to the master. Many of the remaining lines have a standardized role on the PC</text>
<text top="850" left="173" width="614" height="16" font="0">architecture. For example, the timer interrupt is usually associated with IRQ 0.</text>
</page>
<page number="40" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">18</text>
<text top="163" left="173" width="26" height="16" font="0">2.2</text>
<text top="163" left="219" width="358" height="16" font="0">VIRTUAL-MEMORY MANAGEMENT</text>
<text top="213" left="173" width="626" height="16" font="0">Virtual memory enables diﬀerent user-level processes to have independent views</text>
<text top="246" left="173" width="626" height="16" font="0">of memory. Each view of memory contains a diﬀerent mapping from virtual ad-</text>
<text top="278" left="173" width="626" height="16" font="0">dresses—the addresses that a process reads and writes—to physical addresses—</text>
<text top="311" left="173" width="626" height="16" font="0">addresses into the physical memory installed on the underlying machine. We refer</text>
<text top="343" left="173" width="626" height="16" font="0">to the collection of mappings as an address-space and the set of mapped virtual</text>
<text top="376" left="173" width="626" height="16" font="0">addresses as a virtual address-space. A process can only access memory locations</text>
<text top="408" left="173" width="626" height="16" font="0">that are mapped in its virtual address-space. Any attempt to access an address</text>
<text top="441" left="173" width="540" height="16" font="0">that is not mapped will cause a program exception called a page fault.</text>
<text top="473" left="199" width="600" height="16" font="0">In this section, we provide an overview of the virtual-memory management</text>
<text top="506" left="173" width="626" height="16" font="0">facilities available on IA32, including an in-depth look at the data structures</text>
<text top="538" left="173" width="626" height="16" font="0">for translating virtual-addresses to physical-addresses. Section 2.2.1 introduces</text>
<text top="571" left="173" width="626" height="16" font="0">the virtual-to-physical address translation structures; Section 2.2.2 discusses the</text>
<text top="603" left="173" width="626" height="16" font="0">protection mechanisms available for controlling access to mappings; Section 2.2.3</text>
<text top="636" left="173" width="626" height="16" font="0">presents detailed representation information about the data structures; and Sec-</text>
<text top="668" left="173" width="535" height="16" font="0">tion 2.2.4 provides an example of updating the translation structures.</text>
<text top="726" left="173" width="41" height="16" font="0">2.2.1</text>
<text top="726" left="234" width="276" height="16" font="0">Address Translation Structures</text>
<text top="770" left="173" width="626" height="16" font="0">Mappings are added to the virtual address space at the granularity of a memory</text>
<text top="802" left="173" width="626" height="16" font="0">page, the size of which varies depending on the architecture of the machine. The</text>
<text top="835" left="173" width="626" height="16" font="0">IA32 supports two sizes of physical page: four kilobytes and four megabytes. The</text>
<text top="867" left="173" width="626" height="16" font="0">mechanism for accessing physical memory via a virtual address also varies depend-</text>
<text top="900" left="173" width="626" height="16" font="0">ing on the architecture. On the IA32, the hardware supports virtual address spaces</text>
<text top="932" left="173" width="626" height="16" font="0">by performing a translation between virtual and physical addresses in hardware by</text>
<text top="965" left="173" width="626" height="16" font="0">reading translation tables that are themselves stored in physical memory pages.</text>
<text top="997" left="173" width="626" height="16" font="0">Concretely, these tables are organized into a two-level data-structure. The ﬁrst</text>
<text top="1030" left="173" width="626" height="16" font="0">level of the structure is a single table called the page-directory. Entries in the</text>
</page>
<page number="41" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="6" size="16" family="Times" color="#000000"/>
<text top="111" left="738" width="18" height="16" font="0">19</text>
<text top="163" left="173" width="626" height="16" font="0">page-directory point to second level tables called page-tables. Page-tables store</text>
<text top="195" left="173" width="626" height="16" font="0">the physical addresses of 4 KB physical pages (the target of a mapping). Each</text>
<text top="228" left="173" width="626" height="16" font="0">page-directory and page-table is itself stored in a single 4 KB physical page. An</text>
<text top="260" left="173" width="626" height="16" font="0">address-space is represented by a pointer to the beginning of a page-directory. The</text>
<text top="293" left="173" width="626" height="16" font="0">hardware has a special register, called CR3, that stores the currently active ad-</text>
<text top="325" left="173" width="626" height="16" font="0">dress space pointer. The value of this register determines the memory map that the</text>
<text top="358" left="173" width="626" height="16" font="0">hardware will use to perform address translation. Figure 2.3 shows the two-level</text>
<text top="390" left="173" width="392" height="16" font="0">page-table structure of the IA32 translation tables.</text>
<text top="444" left="405" width="33" height="20" font="6">CR3</text>
<text top="510" left="549" width="40" height="20" font="6">page-</text>
<text top="532" left="537" width="65" height="20" font="6">directory</text>
<text top="652" left="363" width="40" height="20" font="6">page-</text>
<text top="674" left="365" width="35" height="20" font="6">table</text>
<text top="652" left="569" width="40" height="20" font="6">page-</text>
<text top="674" left="571" width="35" height="20" font="6">table</text>
<text top="652" left="466" width="40" height="20" font="6">page-</text>
<text top="674" left="468" width="35" height="20" font="6">table</text>
<text top="756" left="243" width="486" height="16" font="0">Figure 2.3: On the IA32, virtual-to-physical address translations</text>
<text top="789" left="243" width="486" height="16" font="0">are performed using a two-level data-structure that resides in</text>
<text top="821" left="243" width="486" height="16" font="0">memory. Each virtual address space has a single ﬁrst level table</text>
<text top="854" left="243" width="486" height="16" font="0">called a page directory that points to potentially many second</text>
<text top="886" left="243" width="486" height="16" font="0">level tables called page tables. We identify address spaces using</text>
<text top="919" left="243" width="486" height="16" font="0">the address of the page directory in memory (a physical address),</text>
<text top="951" left="243" width="486" height="16" font="0">which is stored in the CR3 register. In the ﬁgure, arrows indicate</text>
<text top="984" left="243" width="309" height="16" font="0">a pointer from one structure to another.</text>
<text top="1042" left="199" width="600" height="16" font="0">The actual translation from virtual to physical addresses is performed by using</text>
</page>
<page number="42" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">20</text>
<text top="163" left="173" width="626" height="16" font="0">the virtual address to access information in the two-level structure. Conceptually,</text>
<text top="195" left="173" width="626" height="16" font="0">a virtual address consists of three distinct components: the page-directory index,</text>
<text top="228" left="173" width="626" height="16" font="0">the page-table index, and the oﬀset, as shown in Figure 2.4. The page-directory</text>
<text top="260" left="173" width="626" height="16" font="0">index identiﬁes the appropriate entry in the page-directory for this virtual address.</text>
<text top="293" left="173" width="626" height="16" font="0">The page-directory entry tells us which page-table we should use for the next step</text>
<text top="325" left="173" width="626" height="16" font="0">in the translation. The page-table index allows us to look up the page-table entry in</text>
<text top="358" left="173" width="626" height="16" font="0">this particular page-table. The page-table entry stores the address of the physical</text>
<text top="390" left="173" width="626" height="16" font="0">page that the virtual address in question maps to, if any. Combining the oﬀset</text>
<text top="423" left="173" width="626" height="16" font="0">(which can be thought of as an index into a memory page) and the address of the</text>
<text top="455" left="173" width="626" height="16" font="0">physical page gives the ﬁnal result: the physical address mapped to by a particular</text>
<text top="488" left="173" width="471" height="16" font="0">virtual address. Figure 2.4 illustrates the translation process.</text>
<text top="520" left="199" width="600" height="16" font="0">It is not always necessary to include the page-table step in a virtual-to-physical</text>
<text top="553" left="173" width="626" height="16" font="0">address translation. When a large enough set of contiguous virtual addresses are</text>
<text top="585" left="173" width="626" height="16" font="0">mapped to a contiguous set of physical addresses, we can store the physical address</text>
<text top="618" left="173" width="626" height="16" font="0">in the page-directory entry instead of the page-table entry. Each page-directory</text>
<text top="650" left="173" width="626" height="16" font="0">addresses 4 MB of memory, so such mappings have a size that is a multiple of</text>
<text top="683" left="173" width="626" height="16" font="0">4 MB and must be aligned to a 4 MB boundary as well. Mappings made with</text>
<text top="715" left="173" width="626" height="16" font="0">page-directory entries are said to be implemented with 4 MB pages, which are also</text>
<text top="748" left="173" width="626" height="16" font="0">called superpages. Mappings made with page-tables are said to be implemented</text>
<text top="780" left="173" width="626" height="16" font="0">with 4 KB pages, because this is the amount of memory addressed by a page-table</text>
<text top="813" left="173" width="626" height="16" font="0">entry. Using superpages reduces the number of translation lookaside buﬀer (TLB)</text>
<text top="845" left="173" width="626" height="16" font="0">entries occupied by a mapping. The TLB provides a cache of virtual-to-physical</text>
<text top="878" left="173" width="626" height="16" font="0">address translations, which avoids the need for a page-directory look-up on every</text>
<text top="910" left="173" width="626" height="16" font="0">memory access. Using fewer TLB slots on a large mapping reduces the frequency</text>
<text top="943" left="173" width="626" height="16" font="0">with which entries must be invalidated to make room for new cached translations.</text>
<text top="975" left="173" width="626" height="16" font="0">Superpages also save memory because they avoid the need for allocating page-</text>
<text top="1008" left="173" width="626" height="16" font="0">table storage. Figure 2.5 illustrates a virtual-to-physical address translation using</text>
<text top="1040" left="173" width="289" height="16" font="0">a superpage rather than a page-table.</text>
</page>
<page number="43" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">21</text>
<text top="451" left="344" width="160" height="20" font="6">current page-directory</text>
<text top="167" left="249" width="47" height="20" font="6">virtual</text>
<text top="189" left="245" width="54" height="20" font="6">address</text>
<text top="178" left="573" width="41" height="20" font="6">offset</text>
<text top="178" left="448" width="75" height="20" font="6">page-table</text>
<text top="178" left="310" width="105" height="20" font="6">page-directory</text>
<text top="398" left="496" width="134" height="20" font="6">table pointed to by</text>
<text top="419" left="490" width="146" height="20" font="6">page-directory entry</text>
<text top="438" left="290" width="33" height="20" font="6">CR3</text>
<text top="279" left="268" width="73" height="20" font="6">index into</text>
<text top="301" left="252" width="105" height="20" font="6">page-directory</text>
<text top="254" left="406" width="73" height="20" font="6">index into</text>
<text top="276" left="405" width="75" height="20" font="6">page-table</text>
<text top="356" left="637" width="98" height="20" font="6">physical page</text>
<text top="224" left="512" width="73" height="20" font="6">index into</text>
<text top="245" left="509" width="79" height="20" font="6">target page</text>
<text top="513" left="243" width="486" height="16" font="0">Figure 2.4: Virtual to physical address translation on the IA32</text>
<text top="546" left="243" width="486" height="16" font="0">using 4 KB pages. The most signiﬁcant bits of the virtual ad-</text>
<text top="578" left="243" width="486" height="16" font="0">dress are used as an index into the current page-directory (found</text>
<text top="611" left="243" width="486" height="16" font="0">in the address speciﬁed by the CR3 register) to locate an appro-</text>
<text top="643" left="243" width="486" height="16" font="0">priate page-table. The middle bits are then used as an index into</text>
<text top="676" left="243" width="486" height="16" font="0">that page-table to ﬁnd the physical page that the virtual address</text>
<text top="708" left="243" width="486" height="16" font="0">is mapped to. The complete physical address is then computed</text>
<text top="741" left="243" width="486" height="16" font="0">by using the low bits of the virtual address as an index into the</text>
<text top="773" left="243" width="107" height="16" font="0">physical page.</text>
<text top="829" left="173" width="41" height="16" font="0">2.2.2</text>
<text top="829" left="234" width="93" height="16" font="0">Protection</text>
<text top="874" left="173" width="626" height="16" font="0">The IA32 architecture supports process separation and access control through per-</text>
<text top="906" left="173" width="626" height="16" font="0">page memory protection mechanisms. These protection mechanisms allow access</text>
<text top="939" left="173" width="384" height="16" font="0">to be restricted based on the following conditions:</text>
<text top="985" left="199" width="600" height="17" font="0">• Privilege level: Privilege level protection controls the privilege required to</text>
<text top="1019" left="217" width="583" height="16" font="0">access a mapping; the two possible values are user and supervisor. Proper</text>
</page>
<page number="44" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">22</text>
<text top="454" left="374" width="160" height="20" font="6">current page-directory</text>
<text top="170" left="279" width="47" height="20" font="6">virtual</text>
<text top="192" left="276" width="54" height="20" font="6">address</text>
<text top="181" left="546" width="41" height="20" font="6">offset</text>
<text top="181" left="341" width="105" height="20" font="6">page-directory</text>
<text top="441" left="320" width="33" height="20" font="6">CR3</text>
<text top="282" left="298" width="73" height="20" font="6">index into</text>
<text top="304" left="282" width="105" height="20" font="6">page-directory</text>
<text top="401" left="565" width="130" height="20" font="6">region of physical</text>
<text top="423" left="600" width="60" height="20" font="6">memory</text>
<text top="227" left="482" width="73" height="20" font="6">index into</text>
<text top="248" left="497" width="41" height="20" font="6">target</text>
<text top="270" left="488" width="60" height="20" font="6">physical</text>
<text top="291" left="488" width="60" height="20" font="6">memory</text>
<text top="520" left="243" width="486" height="16" font="0">Figure 2.5: Virtual to physical address translation on the IA32</text>
<text top="553" left="243" width="486" height="16" font="0">using 4 MB pages. As with 4 KB mappings, the high bits of</text>
<text top="585" left="243" width="486" height="16" font="0">the virtual address are used as an index into the current page-</text>
<text top="618" left="243" width="486" height="16" font="0">directory (speciﬁed by the CR3 register). However, in this case,</text>
<text top="650" left="243" width="486" height="16" font="0">the page-directory entry stores a physical address, rather than a</text>
<text top="683" left="243" width="486" height="16" font="0">page-table location. The remainder of the virtual address (what</text>
<text top="715" left="243" width="486" height="16" font="0">was the page-table index and the oﬀset) is treated as the oﬀset</text>
<text top="748" left="243" width="486" height="16" font="0">from that physical address. The result of the translation is value</text>
<text top="780" left="243" width="486" height="16" font="0">of the physical address stored in the page-directory entry added</text>
<text top="813" left="243" width="97" height="16" font="0">to the oﬀset.</text>
<text top="865" left="217" width="583" height="16" font="0">conﬁguration of privilege level permissions is essential for enforcing separa-</text>
<text top="898" left="217" width="583" height="16" font="0">tion between the kernel and user programs. In our abstraction layer, we map</text>
<text top="930" left="217" width="583" height="16" font="0">the kernel code and data in every address-space with supervisor permissions</text>
<text top="963" left="217" width="582" height="16" font="0">so that the kernel can run in any space without any risk that a user program</text>
<text top="995" left="217" width="583" height="16" font="0">will access or overwrite the kernel data. Any attempt by a user program to</text>
<text top="1028" left="217" width="583" height="16" font="0">access memory that is mapped with supervisor permissions causes a program</text>
</page>
<page number="45" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">23</text>
<text top="163" left="217" width="228" height="16" font="0">error called a protection fault.</text>
<text top="209" left="199" width="600" height="17" font="0">• Access Type: Protection based on access type allows us to set particular</text>
<text top="243" left="217" width="582" height="16" font="0">areas of memory as read-only. Writing to a read-only mapping fails and</text>
<text top="275" left="217" width="160" height="16" font="0">triggers a page fault.</text>
<text top="323" left="173" width="626" height="16" font="0">Memory protection based on privilege and access type both play an important role</text>
<text top="355" left="173" width="309" height="16" font="0">in the abstraction layer implementation.</text>
<text top="413" left="173" width="41" height="16" font="0">2.2.3</text>
<text top="413" left="234" width="233" height="16" font="0">Translation Table Formats</text>
<text top="457" left="173" width="626" height="16" font="0">Figure 2.6 shows a detailed look at the format of each entry in a page-directory.</text>
<text top="489" left="173" width="626" height="16" font="0">The top twenty bits contain a pointer to a 4 KB or 4 MB page; this enforces the</text>
<text top="522" left="173" width="626" height="16" font="0">minimum alignment of the pointer and leaves the remaining twelve bits for extra</text>
<text top="554" left="173" width="626" height="16" font="0">conﬁguration information. Figure 2.6 also shows the format for page-table entries.</text>
<text top="587" left="173" width="626" height="16" font="0">The formats of the two entry types are identical except that a page-table entry</text>
<text top="620" left="173" width="626" height="16" font="0">will always contain a page base address pointing to a 4 KB page. A page-directory</text>
<text top="652" left="173" width="626" height="16" font="0">entry may point to a 4 MB page or a 4 KB page; the expected format of the page</text>
<text top="685" left="173" width="532" height="16" font="0">base address is indicated by Bit 7 of the page-directory entry format.</text>
<text top="717" left="199" width="600" height="16" font="0">These formats also illustrate the protection mechanisms for controlling access</text>
<text top="750" left="173" width="626" height="16" font="0">to installed memory mappings. Bit 0 indicates whether or not a particular page is</text>
<text top="782" left="173" width="626" height="16" font="0">present ; the memory mapped by the entry can only be accessed when this bit is</text>
<text top="815" left="173" width="626" height="16" font="0">set. Otherwise this memory cannot be read or written by the user or the kernel,</text>
<text top="847" left="173" width="626" height="16" font="0">and any attempt to do so will cause a page fault. Bit 1 of each entry speciﬁes</text>
<text top="880" left="173" width="626" height="16" font="0">the read/write privilege for a page or set of pages. When this bit is set to zero</text>
<text top="912" left="173" width="626" height="16" font="0">the corresponding memory is read-only, but when the bit is set, the memory can</text>
<text top="945" left="173" width="626" height="16" font="0">be read and written. Bit 2 of each entry is called the user/supervisor bit. This</text>
<text top="977" left="173" width="626" height="16" font="0">bit controls the privilege level protection for the mapping. If the bit is set, then</text>
<text top="1010" left="173" width="626" height="16" font="0">the memory mapped by the entry is accessible in both user- and kernel-mode;</text>
<text top="1042" left="173" width="430" height="16" font="0">otherwise the memory is accessible only in kernel-mode.</text>
</page>
<page number="46" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">24</text>
<text top="766" left="243" width="486" height="16" font="0">Figure 2.6: Format for page-directory entries and page-table en-</text>
<text top="799" left="243" width="486" height="16" font="0">tries (when using 4 KB pages). The top twenty bits contain the</text>
<text top="831" left="243" width="486" height="16" font="0">aligned address of the memory being mapped. The low bits con-</text>
<text top="864" left="243" width="486" height="16" font="0">tain conﬁguration information, including permissions and mode</text>
<text top="896" left="243" width="486" height="16" font="0">restrictions. This ﬁgure is a reproduction of Figure 3-14 from</text>
<text top="929" left="243" width="434" height="16" font="0">the Intel Architecture Software Developer’s Manual [51].</text>
<text top="986" left="199" width="600" height="16" font="0">In addition to dictating how a memory mapping may be accessed, the page-</text>
<text top="1019" left="173" width="626" height="16" font="0">directory and page-table entries also provide feedback about how the memory</text>
<text top="1051" left="173" width="346" height="16" font="0">described by a mapping has been accessed.</text>
<text top="1051" left="535" width="264" height="16" font="0">This information is stored in the</text>
</page>
<page number="47" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">25</text>
<text top="163" left="173" width="626" height="16" font="0">accessed and dirty bits (Bits 5 and 6 of the entries, respectively). The accessed bit</text>
<text top="195" left="173" width="626" height="16" font="0">is set by the MMU when the page (or group of pages) has been read. The dirty bit</text>
<text top="228" left="173" width="626" height="16" font="0">is set when the page has been written. The dirty bit is not used for page-directory</text>
<text top="260" left="173" width="626" height="16" font="0">entries that point to page-tables, so it always corresponds to a single page of data.</text>
<text top="318" left="173" width="41" height="16" font="0">2.2.4</text>
<text top="318" left="234" width="436" height="16" font="0">Example: Adding a Virtual-To-Physical Mapping</text>
<text top="362" left="173" width="626" height="16" font="0">As an example of address-space management in a typical IA32-based operating</text>
<text top="395" left="173" width="626" height="16" font="0">system, consider the steps required to add a new virtual-to-physical mapping. To</text>
<text top="427" left="173" width="626" height="16" font="0">make additional physical memory visible in an address-space, the operating system</text>
<text top="460" left="173" width="626" height="16" font="0">must set up the relevant translation table entries to point to this physical memory.</text>
<text top="492" left="173" width="626" height="16" font="0">The entries to modify are determined based on the location in the virtual address-</text>
<text top="525" left="173" width="626" height="16" font="0">space where the physical memory will be mapped. The mapping procedure will be</text>
<text top="557" left="173" width="626" height="16" font="0">diﬀerent depending on the size of the memory area being mapped and whether or</text>
<text top="590" left="173" width="626" height="16" font="0">not 4 MB superpages will be used. Assuming that we wish to add a mapping that</text>
<text top="622" left="173" width="613" height="16" font="0">will use a single page-table, the operating system must take the following steps:</text>
<text top="670" left="194" width="605" height="16" font="0">1. Find the appropriate page-directory entry. This entry can be found by using</text>
<text top="702" left="217" width="582" height="16" font="0">the page-directory index bits from the virtual address where we would like</text>
<text top="735" left="217" width="583" height="16" font="0">to add the mapping. Because we assume that the mapping will ﬁt in a single</text>
<text top="767" left="217" width="583" height="16" font="0">page-table, we know that we will only need to modify the memory pointed</text>
<text top="800" left="217" width="268" height="16" font="0">to by a single page-directory entry.</text>
<text top="847" left="194" width="605" height="16" font="0">2. Determine whether or not the page-directory entry already points to a page-</text>
<text top="880" left="217" width="43" height="16" font="0">table.</text>
<text top="927" left="194" width="605" height="16" font="0">3. If necessary, create a new page-table out of a free page of memory and update</text>
<text top="959" left="217" width="454" height="16" font="0">the page-directory entry with the address of the new table.</text>
<text top="1007" left="194" width="605" height="16" font="0">4. Modify the appropriate entries of the page-table. The entries to modify are</text>
<text top="1039" left="217" width="583" height="16" font="0">determined by the page-table indexes of the virtual addresses for which we</text>
</page>
<page number="48" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">26</text>
<text top="163" left="217" width="583" height="16" font="0">are adding mappings. We will modify one page-table entry per 4 KB page</text>
<text top="195" left="217" width="201" height="16" font="0">of memory being mapped.</text>
<text top="243" left="173" width="626" height="16" font="0">The procedure for mappings that are implemented with superpages is similar. The</text>
<text top="275" left="173" width="626" height="16" font="0">key diﬀerences are that we will never need to allocate a page-table (Step 3) and</text>
<text top="308" left="173" width="602" height="16" font="0">we will only modify page-directory entries and not page-table entries (Step 4).</text>
</page>
<page number="49" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">27</text>
<text top="227" left="447" width="77" height="16" font="0">Chapter 3</text>
<text top="277" left="205" width="561" height="16" font="0">BACKGROUND: FUNDAMENTALS OF HASKELL PROGRAMMING</text>
<text top="370" left="173" width="626" height="16" font="0">Haskell is a strongly typed, purely functional programming language that origi-</text>
<text top="402" left="173" width="626" height="16" font="0">nated in the late 1980s as an attempt to unify the many lazy, purely functional</text>
<text top="435" left="173" width="626" height="16" font="0">languages that existed at that time [47]. Laziness and a pure semantics are key</text>
<text top="467" left="173" width="626" height="16" font="0">deﬁning features of Haskell. The term laziness indicates a non-strict, call-by-need</text>
<text top="500" left="173" width="626" height="16" font="0">evaluation order, where the value of an expression will not be computed until that</text>
<text top="532" left="173" width="626" height="16" font="0">value is actually needed by another part of the computation. Expressions with val-</text>
<text top="565" left="173" width="626" height="16" font="0">ues that are not required are never evaluated. This characteristic of Haskell frees</text>
<text top="597" left="173" width="626" height="16" font="0">the programmer from having to worry about execution order and wasted compu-</text>
<text top="630" left="173" width="626" height="16" font="0">tation, but can have a surprising impact on performance and space usage when a</text>
<text top="662" left="173" width="626" height="16" font="0">seemingly simple expression triggers the evaluation of many delayed computations.</text>
<text top="695" left="173" width="626" height="16" font="0">Laziness ﬁts naturally with a pure semantics—where functions do not perform any</text>
<text top="727" left="173" width="626" height="16" font="0">side-eﬀects—because the programmer will not be able to observe evaluation order</text>
<text top="760" left="173" width="626" height="16" font="0">through the ordering of eﬀects. The Haskell language provides a special mechanism</text>
<text top="792" left="173" width="626" height="16" font="0">for tracking the use of eﬀects in the type system so that side-eﬀecting programs</text>
<text top="825" left="173" width="427" height="16" font="0">can remain pure; we will cover this topic in Section 3.4.</text>
<text top="857" left="199" width="600" height="16" font="0">In addition to laziness and purity, Haskell supports many of the standard func-</text>
<text top="890" left="173" width="626" height="16" font="0">tional language mechanisms for abstraction and reuse, including a module system,</text>
<text top="922" left="173" width="626" height="16" font="0">higher-order functions, polymorphism, and abstract datatypes. Memory-safety is</text>
<text top="955" left="173" width="626" height="16" font="0">guaranteed with the help of dynamic memory management using garbage collec-</text>
<text top="987" left="173" width="626" height="16" font="0">tion. The language is deﬁned by the Haskell 98 Report [78], but there are numerous</text>
<text top="1020" left="173" width="626" height="16" font="0">extensions in common use, including the foreign function interface [12] (which is</text>
<text top="1052" left="173" width="626" height="16" font="0">essential for the abstraction layer implementation). Extensions supported by the</text>
</page>
<page number="50" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="7" size="14" family="Times" color="#000000"/>
<text top="111" left="738" width="18" height="16" font="0">28</text>
<text top="163" left="173" width="626" height="16" font="0">Glasgow Haskell Compiler (GHC) [31] have become de facto standards and are</text>
<text top="195" left="173" width="310" height="16" font="0">described in the GHC User’s Guide [91].</text>
<text top="228" left="199" width="600" height="16" font="0">To illustrate the basic language features available in Haskell, consider the def-</text>
<text top="260" left="173" width="143" height="16" font="0">inition of factorial:</text>
<text top="304" left="190" width="198" height="14" font="7">factorial :: Int -&gt; Int</text>
<text top="331" left="190" width="490" height="14" font="7">factorial n = if n == 0 then 1 else n * factorial (n - 1)</text>
<text top="376" left="173" width="626" height="16" font="0">This function takes a single integer argument and returns an integer result, as</text>
<text top="408" left="173" width="626" height="16" font="0">speciﬁed by the type declaration on the ﬁrst line. The code for factorial is a</text>
<text top="441" left="173" width="626" height="16" font="0">single equation that names the argument n on the left-hand side of the deﬁnition.</text>
<text top="473" left="173" width="626" height="16" font="0">Haskell supports pattern-patching in the left-hand side of deﬁnitions, but name</text>
<text top="506" left="173" width="626" height="16" font="0">patterns like n match any value. The right-hand side deﬁnes the behavior of the</text>
<text top="538" left="173" width="626" height="16" font="0">function. In this case, we multiply the value of n by the result of a recursive call</text>
<text top="571" left="173" width="429" height="16" font="0">to factorial on n-1 unless n has already reached zero.</text>
<text top="603" left="199" width="600" height="16" font="0">To illustrate the pattern matching facilities available in Haskell functions, we</text>
<text top="636" left="173" width="626" height="16" font="0">can rewrite the deﬁnition of factorial as two equations that encode the stopping</text>
<text top="668" left="173" width="435" height="16" font="0">condition n == 0 as a pattern rather than a conditional.</text>
<text top="712" left="190" width="198" height="14" font="7">factorial :: Int -&gt; Int</text>
<text top="738" left="190" width="129" height="14" font="7">factorial 0 = 1</text>
<text top="765" left="190" width="301" height="14" font="7">factorial n = n * factorial (n - 1)</text>
<text top="810" left="173" width="626" height="16" font="0">This deﬁnition implements exactly the same behavior as before. We now have</text>
<text top="842" left="173" width="626" height="16" font="0">two equations: one for the base case and one for the recursive case. In the ﬁrst</text>
<text top="875" left="173" width="626" height="16" font="0">equation, we use the pattern 0 as an implicit test for whether or not the argument</text>
<text top="907" left="173" width="626" height="16" font="0">to factorial equals zero. If the argument does equal zero, then the pattern</text>
<text top="940" left="173" width="626" height="16" font="0">matches and the result that is returned from the function will be 1, the right-</text>
<text top="972" left="173" width="626" height="16" font="0">hand side of the equation. If the argument is not zero, the pattern will not match</text>
<text top="1005" left="173" width="626" height="16" font="0">and the second equation will be used. The pattern n matches any value, so the</text>
<text top="1037" left="173" width="607" height="16" font="0">computation proceeds by executing the right-hand side of the second equation.</text>
</page>
<page number="51" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">29</text>
<text top="163" left="199" width="600" height="16" font="0">The factorial example illustrates some basic elements of functional program-</text>
<text top="195" left="173" width="626" height="16" font="0">ming in Haskell. In the remainder of this chapter, we will introduce other essential</text>
<text top="228" left="173" width="626" height="16" font="0">concepts of Haskell that will appear in the code samples throughout the rest of</text>
<text top="260" left="173" width="626" height="16" font="0">this dissertation. For a more comprehensive overview of Haskell, the reader is en-</text>
<text top="293" left="173" width="626" height="16" font="0">couraged to seek out one of the textbooks on the subject [77, 49, 46]. Section 3.1</text>
<text top="325" left="173" width="626" height="16" font="0">introduces datatypes and more sophisticated pattern matching constructs. Sec-</text>
<text top="358" left="173" width="626" height="16" font="0">tion 3.2 demonstrates the use of parameterized datatypes such as lists. Section 3.3</text>
<text top="390" left="173" width="626" height="16" font="0">describes a mechanism for deﬁning predicates on types using type classes and qual-</text>
<text top="423" left="173" width="626" height="16" font="0">iﬁed types. Finally, Section 3.4 discusses the relationship between side-eﬀects and</text>
<text top="455" left="173" width="626" height="16" font="0">purity in Haskell. The concepts that we describe here are standard; readers already</text>
<text top="488" left="173" width="516" height="16" font="0">familiar with Haskell may prefer to skip ahead to the next chapter.</text>
<text top="550" left="173" width="26" height="16" font="0">3.1</text>
<text top="550" left="219" width="122" height="16" font="0">DATATYPES</text>
<text top="600" left="173" width="626" height="16" font="0">Algebraic datatypes are a fundamental abstraction mechanism in Haskell. The</text>
<text top="632" left="173" width="626" height="16" font="0">language deﬁnes the most commonly used structures like pairs and lists (see Sec-</text>
<text top="665" left="173" width="626" height="16" font="0">tion 3.2 for an in-depth look at lists) as well as a powerful mechanism for declaring</text>
<text top="697" left="173" width="626" height="16" font="0">user-deﬁned types. As a simple example, consider the deﬁnition of a basic binary</text>
<text top="730" left="173" width="116" height="16" font="0">tree in Haskell.</text>
<text top="774" left="190" width="275" height="14" font="7">data Tree = Branch Int Tree Tree</text>
<text top="800" left="276" width="52" height="14" font="7">| Leaf</text>
<text top="845" left="173" width="626" height="16" font="0">New datatypes are introduced by the keyword data. The left-hand side of the</text>
<text top="878" left="173" width="626" height="16" font="0">deﬁnition provides a name for the new type; this is called the type constructor. The</text>
<text top="910" left="173" width="626" height="16" font="0">right-hand side describes the values of the type with one or more value constructors</text>
<text top="943" left="173" width="626" height="16" font="0">(referred to throughout the dissertation simply as constructors). Each of these</text>
<text top="975" left="173" width="626" height="16" font="0">constructors takes zero or more arguments as necessary to produce a value of the</text>
<text top="1008" left="173" width="626" height="16" font="0">type. In our example, there are two constructors for values of type Tree: Branch</text>
<text top="1040" left="173" width="626" height="16" font="0">and Leaf. A Branch contains an integer describing the value stored at that node, a</text>
</page>
<page number="52" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">30</text>
<text top="163" left="173" width="626" height="16" font="0">left subtree, and a right subtree, while a Leaf caries no data. We construct values</text>
<text top="195" left="173" width="626" height="16" font="0">of type Tree by applying the value constructors to arguments of the appropriate</text>
<text top="228" left="173" width="146" height="16" font="0">type. For example,</text>
<text top="272" left="190" width="34" height="14" font="7">Leaf</text>
<text top="298" left="190" width="155" height="14" font="7">Branch 5 Leaf Leaf</text>
<text top="325" left="190" width="430" height="14" font="7">Branch 5 (Branch 4 Leaf Leaf) (Branch 6 Leaf Leaf)</text>
<text top="370" left="173" width="254" height="16" font="0">all represent values of type Tree.</text>
<text top="402" left="199" width="600" height="16" font="0">Functions over the Tree datatype can be deﬁned using pattern matching to</text>
<text top="435" left="173" width="626" height="16" font="0">distinguish the diﬀerent kinds of values. The following function computes the</text>
<text top="467" left="173" width="346" height="16" font="0">number of data values in a given binary tree.</text>
<text top="511" left="190" width="163" height="14" font="7">size :: Tree -&gt; Int</text>
<text top="537" left="190" width="473" height="14" font="7">size (Branch v left right) = 1 + size left + size right</text>
<text top="564" left="190" width="112" height="14" font="7">size Leaf = 0</text>
<text top="609" left="173" width="626" height="16" font="0">As we saw in the factorial example, we can write functions using multiple equa-</text>
<text top="641" left="173" width="626" height="16" font="0">tions where the cases are distinguished by pattern matching. The ﬁrst equation</text>
<text top="674" left="173" width="626" height="16" font="0">checks whether or not the Tree argument was produced with a Branch construc-</text>
<text top="706" left="173" width="626" height="16" font="0">tor. If so, we call the function recursively on both of the branch’s subtrees and</text>
<text top="739" left="173" width="626" height="16" font="0">increment the result. The second equation covers the case where the Tree is a</text>
<text top="773" left="173" width="626" height="15" font="0">Leaf, though pattern matching on Leaf is not strictly necessary because there are</text>
<text top="804" left="173" width="626" height="16" font="0">only two constructors. Leaf nodes do not carry data values, so we return zero in</text>
<text top="836" left="173" width="105" height="16" font="0">this equation.</text>
<text top="869" left="199" width="600" height="16" font="0">In fact, we can rewrite size using a wildcard pattern to avoid the unnecessary</text>
<text top="901" left="173" width="626" height="16" font="0">binding of v and to avoid testing whether the value in the second equation is a</text>
<text top="935" left="173" width="462" height="15" font="0">Leaf (we know by a process of elimination that it must be).</text>
<text top="978" left="190" width="163" height="14" font="7">size :: Tree -&gt; Int</text>
<text top="1004" left="190" width="473" height="14" font="7">size (Branch _ left right) = 1 + size left + size right</text>
<text top="1030" left="190" width="86" height="14" font="7">size _ = 0</text>
</page>
<page number="53" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">31</text>
<text top="163" left="173" width="626" height="16" font="0">The deﬁnition is exactly the same as the one we examined previously, but with v</text>
<text top="195" left="173" width="353" height="16" font="0">and Leaf replaced by the wildcard pattern, _.</text>
<text top="228" left="199" width="600" height="16" font="0">An unsatisfying aspect of algebraic datatype deﬁnitions, like our binary tree</text>
<text top="260" left="173" width="626" height="16" font="0">example, is that we have to remember the order of the constructor arguments when</text>
<text top="293" left="173" width="626" height="16" font="0">pattern matching or constructing new values. The Haskell type-checker helps when</text>
<text top="325" left="173" width="626" height="16" font="0">the arguments have diﬀerent types (by signaling an error if we make a mistake),</text>
<text top="358" left="173" width="626" height="16" font="0">but types alone do not always capture the semantics of the argument. For example,</text>
<text top="390" left="173" width="626" height="16" font="0">the Branch constructor for the binary tree datatype takes two trees as arguments:</text>
<text top="423" left="173" width="626" height="16" font="0">one for the left subtree and one for the right. If we accidentally confuse these two</text>
<text top="455" left="173" width="626" height="16" font="0">parameters, there is nothing in the types that will help us. Particularly in larger</text>
<text top="488" left="173" width="626" height="16" font="0">datatypes that are used in complicated programs, maintaining this mental state</text>
<text top="520" left="173" width="255" height="16" font="0">can be unwieldy and error prone.</text>
<text top="553" left="199" width="600" height="16" font="0">As an alternative to the previous datatype deﬁnition, we can use Haskell’s</text>
<text top="585" left="173" width="626" height="16" font="0">record syntax to associate names with each of the arguments of a given value con-</text>
<text top="618" left="173" width="626" height="16" font="0">structor. If we recast our binary tree deﬁnition using record syntax, for example,</text>
<text top="650" left="173" width="119" height="16" font="0">then we obtain:</text>
<text top="687" left="190" width="172" height="14" font="7">data Tree = Branch {</text>
<text top="714" left="310" width="112" height="14" font="7">value :: Int,</text>
<text top="740" left="310" width="34" height="14" font="7">left</text>
<text top="740" left="362" width="69" height="14" font="7">:: Tree,</text>
<text top="766" left="310" width="112" height="14" font="7">right :: Tree</text>
<text top="793" left="293" width="9" height="14" font="7">}</text>
<text top="819" left="276" width="52" height="14" font="7">| Leaf</text>
<text top="857" left="173" width="626" height="16" font="0">Given this deﬁnition, we can extract the left subtree of a branch b by writing</text>
<text top="891" left="173" width="60" height="15" font="0">left b.</text>
<text top="890" left="249" width="550" height="16" font="0">Records allow us to create new values concisely as well, providing a</text>
<text top="922" left="173" width="626" height="16" font="0">mechanism to deﬁne new values in terms of existing ones. For example, to replace</text>
<text top="955" left="173" width="626" height="16" font="0">the integer stored in a binary tree branch record, b, with the number 40, we would</text>
<text top="987" left="173" width="188" height="16" font="0">write b{ value = 40 }.</text>
<text top="1020" left="199" width="600" height="16" font="0">The deﬁnition of Tree as a record still permits us to deﬁne size in exactly the</text>
<text top="1052" left="173" width="626" height="16" font="0">same manner that we did previously, but we can also rewrite the deﬁnition to use</text>
</page>
<page number="54" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">32</text>
<text top="163" left="173" width="416" height="16" font="0">the accessor names instead of using pattern matching.</text>
<text top="207" left="190" width="163" height="14" font="7">size :: Tree -&gt; Int</text>
<text top="233" left="190" width="112" height="14" font="7">size Leaf = 0</text>
<text top="260" left="190" width="369" height="14" font="7">size b = 1 + size (left b) + size (right b)</text>
<text top="305" left="173" width="626" height="16" font="0">In this case, the named pattern b matches an entire branch, rather than just one</text>
<text top="337" left="173" width="626" height="16" font="0">of its arguments. We reorder the equations so that the Leaf case appears ﬁrst;</text>
<text top="370" left="173" width="626" height="16" font="0">in this way we guarantee that every argument to the second equation is actually</text>
<text top="402" left="173" width="626" height="16" font="0">a Branch. Applying the function left or right to a Leaf value would cause a</text>
<text top="435" left="173" width="114" height="16" font="0">run-time error.</text>
<text top="467" left="199" width="600" height="16" font="0">The data keyword is the primary mechanism for introducing new types in</text>
<text top="500" left="173" width="626" height="16" font="0">Haskell, but the language does provide two additional mechanisms that are useful</text>
<text top="532" left="173" width="182" height="16" font="0">in some circumstances.</text>
<text top="532" left="371" width="428" height="16" font="0">A datatype deﬁned using the newtype keyword takes</text>
<text top="565" left="173" width="626" height="16" font="0">exactly the same form as one deﬁned using data; the diﬀerence is that a newtype</text>
<text top="597" left="173" width="626" height="16" font="0">must have exactly one constructor with exactly one argument. Programmers use</text>
<text top="631" left="173" width="626" height="15" font="0">newtype to create a wrapper for an existing type, be it a built-in type or a user-</text>
<text top="662" left="173" width="626" height="16" font="0">deﬁned type, with a new constructor that the programmer controls. For example,</text>
<text top="695" left="173" width="626" height="16" font="0">we can make our binary tree example more abstract by hiding the fact that values</text>
<text top="727" left="173" width="626" height="16" font="0">stored in the tree are integers. We create a type synonym for Int called TreeValue</text>
<text top="760" left="173" width="265" height="16" font="0">that we will use to deﬁne our tree.</text>
<text top="803" left="190" width="284" height="14" font="7">newtype TreeValue = TreeValue Int</text>
<text top="848" left="173" width="626" height="16" font="0">Using the same name for the type constructor and the value constructor, as shown</text>
<text top="881" left="173" width="626" height="16" font="0">in the deﬁnition of TreeValue, is common practice in datatype deﬁnitions with</text>
<text top="913" left="173" width="626" height="16" font="0">only one constructor. This is possible because type and value constructors have</text>
<text top="946" left="173" width="626" height="16" font="0">separate name-spaces. The datatype deﬁnition for Tree can now be written to use</text>
<text top="980" left="173" width="207" height="15" font="0">TreeValue in place of Int.</text>
<text top="1022" left="190" width="326" height="14" font="7">data Tree = Branch TreeValue Tree Tree</text>
<text top="1049" left="276" width="52" height="14" font="7">| Leaf</text>
</page>
<page number="55" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">33</text>
<text top="163" left="173" width="626" height="16" font="0">Declarations of this sort are very useful when designing an abstraction layer or</text>
<text top="195" left="173" width="626" height="16" font="0">library, because they allow the programmer to use standard types without exposing</text>
<text top="228" left="173" width="385" height="16" font="0">the library’s internal representations to its clients.</text>
<text top="260" left="199" width="600" height="16" font="0">Types constructed with the newtype keyword are not type synonyms in the</text>
<text top="293" left="173" width="626" height="16" font="0">truest sense of the word, because the two types involved in the deﬁnition are</text>
<text top="325" left="173" width="626" height="16" font="0">not interchangeable. Haskell does provide a mechanism for deﬁning actual type</text>
<text top="358" left="173" width="626" height="16" font="0">synonyms using the type keyword. With type, the connection between the two</text>
<text top="390" left="173" width="626" height="16" font="0">types is always visible—they are the same type. A type deﬁnition looks similar to</text>
<text top="423" left="173" width="626" height="16" font="0">the other type declarations, but the right-hand side may only contain an existing</text>
<text top="455" left="173" width="203" height="16" font="0">type with no constructors.</text>
<text top="499" left="190" width="172" height="14" font="7">type TreeValue = Int</text>
<text top="544" left="173" width="626" height="16" font="0">With this version of TreeValue, we can use the name TreeValue in place of Int</text>
<text top="577" left="173" width="626" height="16" font="0">as documentation in a type signature, but the values of the two types are indistin-</text>
<text top="609" left="173" width="626" height="16" font="0">guishable. This mechanism avoids the overhead of creating an extra constructor,</text>
<text top="642" left="173" width="517" height="16" font="0">but it does not provide the strong guarantees of a true abstraction.</text>
<text top="703" left="173" width="26" height="16" font="0">3.2</text>
<text top="703" left="219" width="309" height="16" font="0">PARAMETERIZED DATATYPES</text>
<text top="754" left="173" width="626" height="16" font="0">In addition to the simple kinds of datatypes that we saw in Section 3.1, Haskell</text>
<text top="786" left="173" width="626" height="16" font="0">supports parameterized datatypes for capturing common structural patterns that</text>
<text top="819" left="173" width="626" height="16" font="0">can be applied to any type (analogous to void pointers in C, templates in C++,</text>
<text top="851" left="173" width="626" height="16" font="0">or generics in Java). A parameterized datatype deﬁnition takes the same form as</text>
<text top="884" left="173" width="626" height="16" font="0">any other datatype declaration, but the type constructor takes one or more type</text>
<text top="916" left="173" width="626" height="16" font="0">variable arguments that may be instantiated to any type. As an example, the tree</text>
<text top="949" left="173" width="626" height="16" font="0">datatype from Section 3.1 can be deﬁned to store values of any type, rather than</text>
<text top="981" left="173" width="99" height="16" font="0">just integers.</text>
<text top="1025" left="190" width="378" height="14" font="7">data PTree a = PBranch a (PTree a) (PTree a)</text>
<text top="1051" left="302" width="60" height="14" font="7">| PLeaf</text>
</page>
<page number="56" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">34</text>
<text top="163" left="173" width="626" height="16" font="0">The type of the value PLeaf is PTree a; there is nothing about this value that</text>
<text top="195" left="173" width="626" height="16" font="0">constrains the type of a. In contrast, the type of PBranch 5 PLeaf PLeaf is</text>
<text top="229" left="173" width="626" height="15" font="0">PTree Int; using the integer 5 in the value slot of the PTree specializes the</text>
<text top="260" left="173" width="626" height="16" font="0">type variable a to Int. As another example, we could create the PTree value</text>
<text top="294" left="173" width="535" height="15" font="0">PBranch &#34;george&#34; PLeaf PLeaf; this value has type PTree String.</text>
<text top="325" left="199" width="600" height="16" font="0">Strings themselves illustrate the use of a very common parameterized datatype</text>
<text top="358" left="173" width="578" height="16" font="0">in Haskell: lists. Strings are simply a type synonym for a list of characters.</text>
<text top="402" left="190" width="172" height="14" font="7">type String = [Char]</text>
<text top="447" left="173" width="626" height="16" font="0">Square brackets are the Haskell syntax for lists. A list that contains any kind of</text>
<text top="479" left="173" width="626" height="16" font="0">value would have a type of the form [a] (where a is a type variable) while a list</text>
<text top="512" left="173" width="626" height="16" font="0">that has been instantiated to a speciﬁc type would have a type of the form [Type].</text>
<text top="544" left="173" width="626" height="16" font="0">Type variables always begin with a lower-case letter while type names always begin</text>
<text top="577" left="173" width="626" height="16" font="0">with an upper case letter. We write list values using the square bracket syntax as</text>
<text top="609" left="173" width="35" height="16" font="0">well:</text>
<text top="653" left="173" width="17" height="14" font="7">[]</text>
<text top="653" left="379" width="206" height="14" font="7">-- the empty list :: [a]</text>
<text top="679" left="173" width="43" height="14" font="7">[’z’]</text>
<text top="679" left="379" width="335" height="14" font="7">-- a singleton character list :: [Char]</text>
<text top="706" left="173" width="103" height="14" font="7">[11, 40, 19]</text>
<text top="706" left="379" width="344" height="14" font="7">-- a three element integer list :: [Int]</text>
<text top="732" left="173" width="77" height="14" font="7">[[1],[2]]</text>
<text top="732" left="379" width="318" height="14" font="7">-- a list of integer lists :: [[Int]]</text>
<text top="777" left="173" width="626" height="16" font="0">The square brackets and commas are syntactic sugar for the actual list construc-</text>
<text top="810" left="173" width="626" height="16" font="0">tors. We have already seen the empty list constructor, []. The other value con-</text>
<text top="842" left="173" width="626" height="16" font="0">structor for lists is called cons; it adds a new element to the front of an existing</text>
<text top="875" left="173" width="626" height="16" font="0">list and is written using an inﬁx colon operator. The deﬁnition of cons involves a</text>
<text top="907" left="173" width="147" height="16" font="0">recursive use of [].</text>
<text top="951" left="190" width="69" height="14" font="7">data [a]</text>
<text top="951" left="276" width="120" height="14" font="7">= [] | a : [a]</text>
<text top="996" left="173" width="626" height="16" font="0">Rewriting our examples using the constructors explicitly, instead of the syntactic</text>
<text top="1029" left="173" width="116" height="16" font="0">sugar, gives us:</text>
</page>
<page number="57" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">35</text>
<text top="165" left="173" width="17" height="14" font="7">[]</text>
<text top="192" left="173" width="69" height="14" font="7">’z’ : []</text>
<text top="218" left="173" width="180" height="14" font="7">11 : (40 : (19 : []))</text>
<text top="245" left="173" width="223" height="14" font="7">(1 : []) : ((2 : []) : [])</text>
<text top="290" left="173" width="626" height="16" font="0">Lists are a common datatype in Haskell that appear frequently in the code for our</text>
<text top="322" left="173" width="626" height="16" font="0">abstraction layer in later chapters. Another common parameterized type is pairs</text>
<text top="355" left="173" width="626" height="16" font="0">(also called tuples). Although we will not cover this datatype deeply here, it is</text>
<text top="387" left="173" width="626" height="16" font="0">important to note that Haskell supports n-element tuples, for example, (a,b) and</text>
<text top="421" left="173" width="626" height="15" font="0">(a, b, c, d). This syntax works at both the type and value level. There is no</text>
<text top="452" left="173" width="626" height="16" font="0">single element pair, but there is a zero element pair, written () and pronounced</text>
<text top="485" left="173" width="54" height="16" font="0">“unit”.</text>
<text top="517" left="199" width="600" height="16" font="0">Deﬁning functions on parameterized datatypes works in much the same as any</text>
<text top="550" left="173" width="626" height="16" font="0">other declaration. Some functions are speciﬁc to a particular instantiation of a</text>
<text top="582" left="173" width="626" height="16" font="0">parameterized type, but often there are interesting polymorphic functions as well.</text>
<text top="615" left="173" width="626" height="16" font="0">The Haskell libraries include a multitude of functions on lists, many of which are</text>
<text top="647" left="173" width="626" height="16" font="0">completely generic. An example that we use frequently in the abstraction layer</text>
<text top="680" left="173" width="626" height="16" font="0">source code is the map function for applying a given function to every element of a</text>
<text top="712" left="173" width="28" height="16" font="0">list.</text>
<text top="756" left="190" width="249" height="14" font="7">map :: (a -&gt; b) -&gt; [a] -&gt; [b]</text>
<text top="782" left="190" width="69" height="14" font="7">map _ []</text>
<text top="782" left="302" width="34" height="14" font="7">= []</text>
<text top="809" left="190" width="266" height="14" font="7">map f (a:as) = f a : (map f as)</text>
<text top="855" left="173" width="626" height="15" font="0">map takes two arguments: a higher-order function that turns values of type a into</text>
<text top="886" left="173" width="626" height="16" font="0">values of type b and a list of values of type a. The deﬁnition of map will apply the</text>
<text top="919" left="173" width="626" height="16" font="0">function to each element of the argument list, producing a list with elements of</text>
<text top="951" left="173" width="626" height="16" font="0">type b. Functions are ﬁrst class values that may be passed as arguments to other</text>
<text top="984" left="173" width="626" height="16" font="0">functions by name; they are distinguished in the type by the parentheses around</text>
<text top="1016" left="173" width="297" height="16" font="0">the type of the higher-order argument.</text>
</page>
<page number="58" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">36</text>
<text top="163" left="199" width="600" height="16" font="0">Container types like list and pair are an obvious use of polymorphism, but there</text>
<text top="195" left="173" width="626" height="16" font="0">are many other programming patterns that we can capture using polymorphism.</text>
<text top="228" left="173" width="626" height="16" font="0">A pattern that we see frequently in programming is the use of special values to</text>
<text top="260" left="173" width="626" height="16" font="0">indicate failure. For example, the malloc function in C returns a pointer to a newly</text>
<text top="293" left="173" width="626" height="16" font="0">allocated area of memory—unless the request fails, in which case it returns a null</text>
<text top="325" left="173" width="626" height="16" font="0">pointer. The potential for error is not documented by the type, so you have to rely</text>
<text top="358" left="173" width="626" height="16" font="0">on intuition and the library documentation to realize that the function might fail.</text>
<text top="390" left="173" width="626" height="16" font="0">Worse yet, the null pointer is easily confused with a normal pointer to memory</text>
<text top="423" left="173" width="626" height="16" font="0">(as evidenced by how frequently null pointer dereferences occur in practice). In</text>
<text top="455" left="173" width="626" height="16" font="0">Haskell, we can encapsulate this pattern of an optional value (malloc either returns</text>
<text top="488" left="173" width="477" height="16" font="0">a pointer or nothing) with a parameterized type called Maybe.</text>
<text top="532" left="190" width="180" height="14" font="7">data Maybe a = Just a</text>
<text top="558" left="302" width="77" height="14" font="7">| Nothing</text>
<text top="603" left="173" width="626" height="16" font="0">Values produced with the Just constructor are equivalent to the values expressible</text>
<text top="636" left="173" width="626" height="16" font="0">in the type a, but with an extra wrapper to lift them into the Maybe type. Nothing</text>
<text top="668" left="173" width="626" height="16" font="0">is a special value that cannot be confused with a normal value of type a; it can be</text>
<text top="701" left="173" width="626" height="16" font="0">interpreted as the absence of a valid value. If we were to deﬁne malloc in Haskell,</text>
<text top="733" left="173" width="626" height="16" font="0">we might declare the result type of the function to be Maybe (Ptr a) (where</text>
<text top="767" left="173" width="626" height="15" font="0">Ptr is another parameterized type), returning Nothing if the memory cannot be</text>
<text top="798" left="173" width="74" height="16" font="0">allocated.</text>
<text top="860" left="173" width="26" height="16" font="0">3.3</text>
<text top="860" left="219" width="400" height="16" font="0">TYPE CLASSES AND QUALIFIED TYPES</text>
<text top="910" left="173" width="626" height="16" font="0">Polymorphic functions on arbitrary types are extremely useful, but often in prac-</text>
<text top="943" left="173" width="626" height="16" font="0">tice, we want to deﬁne polymorphic functions over a class of types that are con-</text>
<text top="975" left="173" width="626" height="16" font="0">strained in some way. Consider the function for testing if a particular value is a</text>
<text top="1008" left="173" width="593" height="16" font="0">member of a list. We might be tempted to write the type for this function as</text>
<text top="1051" left="190" width="206" height="14" font="7">elem :: a -&gt; [a] -&gt; Bool</text>
</page>
<page number="59" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">37</text>
<text top="163" left="173" width="626" height="16" font="0">because the function can operate on lists of any type. The problem is that elem as</text>
<text top="195" left="173" width="626" height="16" font="0">declared must perform the same way on all types; how can elem determine if the</text>
<text top="228" left="173" width="626" height="16" font="0">value is in the list when the equality comparison that is necessary to make that</text>
<text top="260" left="173" width="402" height="16" font="0">determination might be diﬀerent for diﬀerent types?</text>
<text top="293" left="199" width="600" height="16" font="0">Implementing elem in a polymorphic way requires the ability to deﬁne over-</text>
<text top="325" left="173" width="626" height="16" font="0">loaded operators, like an equality test, that may have diﬀerent implementations</text>
<text top="358" left="173" width="626" height="16" font="0">on diﬀerent types. This overloading is called ad hoc polymorphism, in contrast to</text>
<text top="390" left="173" width="626" height="16" font="0">the parametric polymorphism that we examined in the previous section. Haskell</text>
<text top="423" left="173" width="626" height="16" font="0">provides a mechanism to support ad hoc polymorphism called type classes; each</text>
<text top="455" left="173" width="626" height="16" font="0">type class is associated with a set of overloadable functions [96, 55, 56]. There</text>
<text top="488" left="173" width="626" height="16" font="0">are many standard classes in Haskell to support common operations such as com-</text>
<text top="520" left="173" width="626" height="16" font="0">parison, numeric operations like addition, and displaying the values of a type. In</text>
<text top="553" left="173" width="626" height="16" font="0">particular, the built-in class for equality comparisons that we need in elem is called</text>
<text top="587" left="173" width="220" height="15" font="0">Eq, and is deﬁned as follows:</text>
<text top="628" left="190" width="43" height="14" font="7">class</text>
<text top="628" left="250" width="34" height="14" font="7">Eq a</text>
<text top="628" left="302" width="43" height="14" font="7">where</text>
<text top="654" left="207" width="189" height="14" font="7">(==) :: a -&gt; a -&gt; Bool</text>
<text top="681" left="207" width="189" height="14" font="7">(/=) :: a -&gt; a -&gt; Bool</text>
<text top="724" left="173" width="626" height="16" font="0">The Eq class deﬁnes two methods: == for testing equality and /= for testing in-</text>
<text top="757" left="173" width="626" height="16" font="0">equality. We deﬁne implementations of these functions for a particular type by</text>
<text top="789" left="173" width="626" height="16" font="0">declaring it as an instance of Eq. The instance declaration for the Boolean type,</text>
<text top="823" left="173" width="316" height="15" font="0">Bool, provides an example of the syntax.</text>
<text top="864" left="190" width="189" height="14" font="7">instance Eq Bool where</text>
<text top="891" left="207" width="77" height="14" font="7">(==) True</text>
<text top="891" left="302" width="34" height="14" font="7">True</text>
<text top="891" left="353" width="52" height="14" font="7">= True</text>
<text top="917" left="207" width="198" height="14" font="7">(==) False False = True</text>
<text top="944" left="207" width="52" height="14" font="7">(==) _</text>
<text top="944" left="302" width="9" height="14" font="7">_</text>
<text top="944" left="353" width="60" height="14" font="7">= False</text>
<text top="987" left="173" width="626" height="16" font="0">Type class declarations may provide default deﬁnitions for overloaded functions in</text>
<text top="1020" left="173" width="626" height="16" font="0">addition to declaring their types. Though our example deﬁnition of Eq only shows</text>
<text top="1052" left="173" width="626" height="16" font="0">the type signatures for the equality comparisons, the built-in deﬁnition of Eq does</text>
</page>
<page number="60" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">38</text>
<text top="163" left="173" width="626" height="16" font="0">provide a default deﬁnition of /= in terms of ==. Thus, the instance declaration</text>
<text top="195" left="173" width="376" height="16" font="0">for Bool only needs to provide a deﬁnition of ==.</text>
<text top="228" left="199" width="600" height="16" font="0">Standard Haskell libraries deﬁne type class instances for many standard types,</text>
<text top="260" left="173" width="626" height="16" font="0">but when we deﬁne our own types we might also wish to add instances for standard</text>
<text top="293" left="173" width="626" height="16" font="0">type classes. We can declare an instance of Eq for our ﬁrst version of binary trees</text>
<text top="325" left="173" width="273" height="16" font="0">using the same pattern as for Bool.</text>
<text top="361" left="190" width="189" height="14" font="7">instance Eq Tree where</text>
<text top="388" left="207" width="180" height="14" font="7">(==) Leaf Leaf = True</text>
<text top="414" left="207" width="344" height="14" font="7">(==) (Branch v1 l1 r1) (Branch v2 l2 r2)</text>
<text top="441" left="224" width="292" height="14" font="7">= v1 == v2 &amp;&amp; l1 == l2 &amp;&amp; r1 == r2</text>
<text top="467" left="207" width="137" height="14" font="7">(==) _ _ = False</text>
<text top="504" left="173" width="626" height="16" font="0">The ﬁrst equation states that two Leaf values are equal. The second equation</text>
<text top="536" left="173" width="626" height="16" font="0">states that two Branch values are equal if all of the arguments to the constructor</text>
<text top="569" left="173" width="626" height="16" font="0">are equal; here we rely on the instance of Eq on integers and on recursive calls to</text>
<text top="601" left="173" width="626" height="16" font="0">the == function on trees that we are currently deﬁning. The ﬁnal equation is a</text>
<text top="634" left="173" width="626" height="16" font="0">catch all for the two cases where the constructors are not the same; these values</text>
<text top="666" left="173" width="235" height="16" font="0">will never be considered equal.</text>
<text top="699" left="199" width="600" height="16" font="0">Now that we have an overloaded equality test, we are able to deﬁne the elem</text>
<text top="731" left="173" width="239" height="16" font="0">function in a polymorphic way.</text>
<text top="767" left="190" width="275" height="14" font="7">elem :: Eq a =&gt; a -&gt; [a] -&gt; Bool</text>
<text top="794" left="190" width="146" height="14" font="7">elem _ [] = False</text>
<text top="820" left="190" width="301" height="14" font="7">elem x (y:ys) = x == y || elem x ys</text>
<text top="857" left="173" width="626" height="16" font="0">Note that the type signature includes some extra information. The clause Eq a is</text>
<text top="890" left="173" width="626" height="16" font="0">a constraint on the type variable a indicating that the type a must be an instance</text>
<text top="922" left="173" width="626" height="16" font="0">of the type class Eq. This reﬂects the use of the == method from the Eq class to</text>
<text top="955" left="173" width="626" height="16" font="0">compare values of type a. A type containing such a constraint is called a qualiﬁed</text>
<text top="987" left="173" width="626" height="16" font="0">type and it restricts the polymorphism of the elem function to the set of types</text>
<text top="1020" left="173" width="626" height="16" font="0">on which Eq is deﬁned [55, 54]. A function may rely on multiple classes in its</text>
<text top="1052" left="173" width="479" height="16" font="0">deﬁnition; these constraints are all added to the left of the =&gt;.</text>
</page>
<page number="61" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">39</text>
<text top="165" left="190" width="352" height="14" font="7">example :: (C a, D b, E a) =&gt; a -&gt; b -&gt; c</text>
<text top="208" left="173" width="626" height="16" font="0">In this example, there are two constraints on the type variable a—it should be an</text>
<text top="241" left="173" width="454" height="16" font="0">instance of both C and E—and just one—D—on the type b.</text>
<text top="273" left="199" width="600" height="16" font="0">As mentioned previously, there are several standard classes deﬁned by the</text>
<text top="306" left="173" width="286" height="16" font="0">Haskell libraries. Some examples are:</text>
<text top="350" left="199" width="600" height="17" font="0">• Ord: Deﬁnes operations on totally ordered types. This class provides the</text>
<text top="383" left="217" width="583" height="16" font="0">usual comparison operators (&lt;, &lt;=, &gt;, and &gt;=) as well as minimum and max-</text>
<text top="416" left="217" width="126" height="16" font="0">imum operators.</text>
<text top="462" left="199" width="600" height="17" font="0">• Show: Supports the conversion of values of the instance type into strings</text>
<text top="495" left="217" width="582" height="16" font="0">(typically for printing to the screen). The most frequently used function from</text>
<text top="528" left="217" width="312" height="16" font="0">the Show class is show :: a -&gt; String.</text>
<text top="573" left="199" width="600" height="17" font="0">• Storable: Allows values of the instance type to be transferred to and from</text>
<text top="607" left="217" width="583" height="16" font="0">memory. This class is part of the foreign function interface, and includes</text>
<text top="639" left="217" width="302" height="16" font="0">methods for directly accessing memory.</text>
<text top="685" left="199" width="600" height="17" font="0">• Num: Supplies basic operations on numeric types like addition, subtraction,</text>
<text top="719" left="217" width="146" height="16" font="0">and multiplication.</text>
<text top="764" left="199" width="600" height="17" font="0">• Bounded: Provides operations that name the upper and lower bounds of a</text>
<text top="798" left="217" width="237" height="16" font="0">type, maxBound and minBound.</text>
<text top="843" left="173" width="626" height="16" font="0">For the full list, see the Haskell library documentation [32]. In addition to these</text>
<text top="876" left="173" width="626" height="16" font="0">predeﬁned classes, Haskell also allows the deﬁnition of new classes using the same</text>
<text top="908" left="173" width="333" height="16" font="0">syntax that we saw in the earlier examples.</text>
<text top="969" left="173" width="26" height="16" font="0">3.4</text>
<text top="969" left="219" width="92" height="16" font="0">MONADS</text>
<text top="1020" left="173" width="626" height="16" font="0">Purity is one of the primary motivations for implementing operating systems in</text>
<text top="1052" left="173" width="626" height="16" font="0">Haskell. With a pure semantics, every function is a function in the mathematical</text>
</page>
<page number="62" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">40</text>
<text top="163" left="173" width="626" height="16" font="0">sense: the same set of inputs always produce the same output. Programs are easier</text>
<text top="195" left="173" width="626" height="16" font="0">to reason about and debug because there is no hidden data ﬂow. To develop an</text>
<text top="228" left="173" width="626" height="16" font="0">understanding of purity in practice, consider the deﬁnition of a simple mathemat-</text>
<text top="260" left="173" width="626" height="16" font="0">ical function like align. The align function takes an unsigned word argument</text>
<text top="293" left="173" width="595" height="16" font="0">and zeros out the low n bits, where n is an integer parameter to the function.</text>
<text top="335" left="173" width="275" height="14" font="7">align :: Word32 -&gt; Int -&gt; Word32</text>
<text top="362" left="173" width="318" height="14" font="7">align w n = (w ‘shiftR‘ n) ‘shiftL‘ n</text>
<text top="405" left="173" width="626" height="16" font="0">One technique for aligning a word is to shift the word right by the number of bits</text>
<text top="438" left="173" width="626" height="16" font="0">to be cleared, then left, relying on the fact that the bits shifted in from the right</text>
<text top="470" left="173" width="626" height="16" font="0">will be zeros. We deﬁne align with a straightforward application of the right- and</text>
<text top="503" left="173" width="626" height="16" font="0">left-shift functions from the Haskell library for bit-level manipulation (Data.Bits).</text>
<text top="537" left="173" width="626" height="15" font="0">Word32 is the name for the Haskell type of unsigned 32-bit words and is equivalent</text>
<text top="568" left="173" width="225" height="16" font="0">to the C type unsigned int.</text>
<text top="600" left="199" width="600" height="16" font="0">Comparing the Haskell deﬁnition to an equivalent deﬁnition in C illustrates a</text>
<text top="633" left="173" width="159" height="16" font="0">superﬁcial similarity.</text>
<text top="675" left="173" width="369" height="14" font="7">unsigned int align(unsigned int w, int n) {</text>
<text top="701" left="190" width="180" height="14" font="7">return (w &gt;&gt; n) &lt;&lt; n;</text>
<text top="728" left="173" width="9" height="14" font="7">}</text>
<text top="771" left="173" width="626" height="16" font="0">The substantial part of both functions can be written in a single line using built-in</text>
<text top="804" left="173" width="626" height="16" font="0">shift operators. Both contain a type signature indicating that the function takes</text>
<text top="836" left="173" width="507" height="16" font="0">an unsigned word and an integer and returns an unsigned integer.</text>
<text top="869" left="199" width="600" height="16" font="0">If we write the type for the two functions in a common syntax, then it would</text>
<text top="901" left="173" width="298" height="16" font="0">appear exactly the same in both cases:</text>
<text top="944" left="173" width="275" height="14" font="7">align :: Word32 -&gt; Int -&gt; Word32</text>
<text top="987" left="173" width="626" height="16" font="0">The essential diﬀerence between the two deﬁnitions is that the C type of this form</text>
<text top="1020" left="173" width="626" height="16" font="0">and the Haskell type of this form do not mean the same thing. In C, a function</text>
<text top="1052" left="173" width="626" height="16" font="0">with this type may perform arbitrary side-eﬀects, such as direct memory accesses,</text>
</page>
<page number="63" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">41</text>
<text top="163" left="173" width="626" height="16" font="0">global variable manipulations, ﬁle I/O, and printing to the screen. The language</text>
<text top="195" left="173" width="626" height="16" font="0">allows direct and unchecked access to any of the facilities available on the machine</text>
<text top="228" left="173" width="626" height="16" font="0">from any point in any program. None of this information is reﬂected in the type.</text>
<text top="260" left="173" width="626" height="16" font="0">In contrast, functions in Haskell do not perform any visible side-eﬀects. A pure</text>
<text top="293" left="173" width="626" height="16" font="0">Haskell function can never dereference a null pointer because we know from its</text>
<text top="325" left="173" width="347" height="16" font="0">type that it does not access memory directly.</text>
<text top="358" left="199" width="600" height="16" font="0">Purity in Haskell helps to identify bugs and prevents certain classes of error</text>
<text top="390" left="173" width="626" height="16" font="0">from ever occurring. However, to deal with systems applications and many other</text>
<text top="423" left="173" width="626" height="16" font="0">real-world tasks, our programs must somehow be allowed to perform side-eﬀects.</text>
<text top="455" left="173" width="626" height="16" font="0">In Haskell, this is accomplished using a special mechanism called a monad [94]. In</text>
<text top="488" left="173" width="626" height="16" font="0">general, a monad consists of two parts: a parameterized datatype that names the</text>
<text top="520" left="173" width="626" height="16" font="0">monad and a set of operations that deﬁne the side-eﬀects supported by the monad.</text>
<text top="553" left="173" width="626" height="16" font="0">For example, the IO monad captures interactions between Haskell and the outside</text>
<text top="585" left="173" width="626" height="16" font="0">world, and deﬁnes operations for tasks such as printing to the screen or reading</text>
<text top="618" left="173" width="626" height="16" font="0">from a ﬁle. A function that uses an operation deﬁned in the IO monad will have</text>
<text top="650" left="173" width="626" height="16" font="0">the monadic type IO a where a is a type variable representing the result of the</text>
<text top="683" left="173" width="558" height="16" font="0">computation (as with the other parameterized types we have examined).</text>
<text top="717" left="199" width="600" height="15" font="0">IO is the most pervasive eﬀect in Haskell because so many programs rely on</text>
<text top="748" left="173" width="626" height="16" font="0">interactions with the outside world in some capacity, whether it is a user interacting</text>
<text top="780" left="173" width="626" height="16" font="0">with the program or a device that the program controls. In fact, every Haskell</text>
<text top="813" left="173" width="626" height="16" font="0">program runs in the IO monad at some level, even if the program contains mostly</text>
<text top="845" left="173" width="626" height="16" font="0">pure computation, because the entry point to a Haskell program is ﬁxed to be</text>
<text top="878" left="173" width="626" height="16" font="0">a function called main of type IO () (indicating that the function runs in the</text>
<text top="912" left="173" width="626" height="15" font="0">IO monad and returns no data in the result). Still, there are many other useful</text>
<text top="943" left="173" width="626" height="16" font="0">monads that are common in Haskell programs. The following examples of monads</text>
<text top="975" left="173" width="626" height="16" font="0">deﬁned by the standard Haskell libraries illustrate the kinds of side-eﬀects that we</text>
<text top="1008" left="173" width="626" height="16" font="0">can capture using monads. Unlike the IO monad, the side-eﬀects represented by</text>
<text top="1040" left="173" width="626" height="16" font="0">these monads are not persistent; they model side-eﬀects in a pure way that does</text>
</page>
<page number="64" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">42</text>
<text top="163" left="173" width="217" height="16" font="0">not aﬀect the outside world.</text>
<text top="209" left="199" width="600" height="17" font="0">• State: There are no global variables or stateful computations in pure Haskell.</text>
<text top="243" left="217" width="583" height="16" font="0">We can model state by passing around any stateful components of our com-</text>
<text top="275" left="217" width="583" height="16" font="0">putation as explicit parameters to every function, but this is clumsy and</text>
<text top="308" left="217" width="582" height="16" font="0">error prone in practice. The State monad allows us to add state to our</text>
<text top="340" left="217" width="583" height="16" font="0">Haskell programs without explicit parameters by encoding the state-passing</text>
<text top="373" left="217" width="117" height="16" font="0">style implicitly.</text>
<text top="419" left="199" width="600" height="17" font="0">• Read-Only State: A function might depend on environment data, supplied</text>
<text top="453" left="217" width="583" height="16" font="0">by the calling context, that remains constant within the function but may</text>
<text top="485" left="217" width="583" height="16" font="0">be extended or modiﬁed for functions it calls. As with state, we can address</text>
<text top="518" left="217" width="583" height="16" font="0">this need by passing the environment as a parameter to every function or we</text>
<text top="550" left="217" width="538" height="16" font="0">can use the Reader monad to pass around the environment implicitly.</text>
<text top="597" left="199" width="600" height="17" font="0">• Failure: We saw in Section 3.2 that the Maybe datatype allows us to augment</text>
<text top="630" left="217" width="583" height="16" font="0">any type with a special failure value called Nothing. In fact, the Maybe type is</text>
<text top="663" left="217" width="583" height="16" font="0">also a monad that can be used to handle errors or exceptions. Computations</text>
<text top="695" left="217" width="583" height="16" font="0">in the Maybe monad may produce the value Nothing, at which point the</text>
<text top="728" left="217" width="582" height="16" font="0">monad will skip the remainder of the computation and return the value</text>
<text top="762" left="217" width="69" height="15" font="0">Nothing.</text>
<text top="807" left="199" width="600" height="17" font="0">• Exceptions: The Haskell libraries also provide a more traditional interface</text>
<text top="840" left="217" width="583" height="16" font="0">that allows the programmer to try, catch, and throw named exceptions. This</text>
<text top="873" left="217" width="344" height="16" font="0">functionality is deﬁned by the Error monad.</text>
<text top="920" left="173" width="626" height="16" font="0">These are just a few of the common eﬀect patterns expressible as monads. See the</text>
<text top="953" left="173" width="543" height="16" font="0">literature for more details about these and other examples [95, 65, 79].</text>
<text top="985" left="199" width="600" height="16" font="0">Now that we have introduced monads, we can demonstrate how the obligatory</text>
<text top="1018" left="173" width="346" height="16" font="0">“Hello World” program is written in Haskell.</text>
</page>
<page number="65" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">43</text>
<text top="165" left="190" width="163" height="14" font="7">helloWorld :: IO ()</text>
<text top="192" left="190" width="309" height="14" font="7">helloWorld = putStrLn &#34;Hello World!&#34;</text>
<text top="232" left="173" width="626" height="16" font="0">The helloWorld function runs in the IO monad so that it may print a line to</text>
<text top="264" left="173" width="626" height="16" font="0">the standard output device using the Haskell library function putStrLn of type</text>
<text top="298" left="173" width="626" height="15" font="0">String -&gt; IO (). The function putStrLn is one of the many side-eﬀecting oper-</text>
<text top="329" left="173" width="270" height="16" font="0">ations supported by the IO monad.</text>
<text top="362" left="199" width="600" height="16" font="0">Every monad contains some number of custom operations, like putStrLn, that</text>
<text top="394" left="173" width="626" height="16" font="0">deﬁne the unique behavior of that monad. In addition to these custom operations,</text>
<text top="427" left="173" width="626" height="16" font="0">there are two standard functions that must be deﬁned for every monad. These</text>
<text top="459" left="173" width="296" height="16" font="0">functions are called return and bind.</text>
<text top="459" left="485" width="314" height="16" font="0">The bind function, typically written as</text>
<text top="493" left="173" width="626" height="15" font="0">&gt;&gt;=, allows us to sequence monadic expressions; execution order is important for</text>
<text top="524" left="173" width="626" height="16" font="0">monadic computations because the side-eﬀects in one monadic operation can aﬀect</text>
<text top="557" left="173" width="626" height="16" font="0">the outcome of later operations. The return function lifts pure values into the</text>
<text top="589" left="173" width="626" height="16" font="0">monad so that we can use the entire pure subset of Haskell within our monadic</text>
<text top="622" left="173" width="108" height="16" font="0">computations.</text>
<text top="654" left="199" width="600" height="16" font="0">The type of the return function is simple: for each monad m, the associated</text>
<text top="688" left="173" width="536" height="15" font="0">return function takes a value of any type and lifts it into the monad.</text>
<text top="725" left="190" width="155" height="14" font="7">return :: a -&gt; m a</text>
<text top="765" left="173" width="626" height="16" font="0">For example, the return function for the IO monad would be a polymorphic function</text>
<text top="798" left="173" width="183" height="16" font="0">with the following type:</text>
<text top="836" left="190" width="163" height="14" font="7">return :: a -&gt; IO a</text>
<text top="876" left="173" width="626" height="16" font="0">The bind function connects the output of one monadic computation to the input</text>
<text top="909" left="173" width="626" height="16" font="0">of the next, thus sequencing the two computations together. The type for bind</text>
<text top="941" left="173" width="181" height="16" font="0">reﬂects this sequencing.</text>
<text top="980" left="190" width="284" height="14" font="7">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</text>
<text top="1020" left="173" width="626" height="16" font="0">The second argument to bind is a function; the deﬁnition of bind will apply the</text>
<text top="1052" left="173" width="435" height="16" font="0">function to the value produced by the ﬁrst computation.</text>
</page>
<page number="66" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">44</text>
<text top="163" left="199" width="600" height="16" font="0">As an example of how we might use bind in a real program, consider the function</text>
<text top="195" left="173" width="574" height="16" font="0">for reading a line that is part of the standard IO monad library in Haskell.</text>
<text top="238" left="190" width="60" height="14" font="7">getLine</text>
<text top="238" left="267" width="103" height="14" font="7">:: IO String</text>
<text top="281" left="173" width="626" height="16" font="0">Executing the getLine function reads a line from the standard input device. We</text>
<text top="314" left="173" width="626" height="16" font="0">can combine this function with putStrLn using bind to deﬁne a program that reads</text>
<text top="346" left="173" width="547" height="16" font="0">a string supplied by the user and echoes that string back to the screen:</text>
<text top="389" left="190" width="146" height="14" font="7">echoLine :: IO ()</text>
<text top="415" left="190" width="266" height="14" font="7">echoLine = getLine &gt;&gt;= putStrLn</text>
<text top="458" left="173" width="626" height="16" font="0">This function reads a line from standard in and prints the result using the putStrLn</text>
<text top="491" left="173" width="78" height="16" font="0">operation.</text>
<text top="523" left="199" width="600" height="16" font="0">The ability to sequence computations together allows us to deﬁne interesting</text>
<text top="556" left="173" width="626" height="16" font="0">monadic functions, but connecting operations using explicit calls to bind is cum-</text>
<text top="588" left="173" width="626" height="16" font="0">bersome when writing large programs. Haskell provides syntactic sugar known as</text>
<text top="621" left="173" width="626" height="16" font="0">do-notation to enable seamless sequencing of monadic operations. We can rewrite</text>
<text top="653" left="173" width="357" height="16" font="0">the echo example using do-notation as follows:</text>
<text top="696" left="190" width="146" height="14" font="7">echoLine :: IO ()</text>
<text top="722" left="190" width="249" height="14" font="7">echoLine = do line &lt;- getLine</text>
<text top="749" left="310" width="112" height="14" font="7">putStrLn line</text>
<text top="792" left="173" width="626" height="16" font="0">Here we have the opportunity to give our intermediate result a name using the</text>
<text top="825" left="173" width="626" height="16" font="0">syntax name &lt;- ...; this name can be used to refer to that result at any later</text>
<text top="857" left="173" width="626" height="16" font="0">point in the computation. We will use do-notation when writing monadic code</text>
<text top="890" left="173" width="445" height="16" font="0">almost exclusively throughout the rest of the dissertation.</text>
<text top="922" left="199" width="600" height="16" font="0">We can use do-notation in any monad that provides deﬁnitions for the standard</text>
<text top="955" left="173" width="626" height="16" font="0">functions return and bind. For example, the Maybe monad allows us to string</text>
<text top="987" left="173" width="626" height="16" font="0">together computations that might fail without explicitly checking the results of</text>
<text top="1020" left="173" width="626" height="16" font="0">the intermediate steps. Once a failure is encountered, the remaining computation</text>
<text top="1052" left="173" width="626" height="16" font="0">is abandoned and the result of the computation is Nothing. These failures can</text>
</page>
<page number="67" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">45</text>
<text top="163" left="173" width="626" height="16" font="0">include explicit exceptions that occur when a step in the computation returns</text>
<text top="197" left="173" width="626" height="15" font="0">Nothing, or implicit failures, like a non-exhaustive pattern match in a do-notation</text>
<text top="228" left="173" width="626" height="16" font="0">pattern binding. If none of the steps fail, then the computation runs to completion</text>
<text top="260" left="173" width="626" height="16" font="0">and produces a result wrapped in a Just constructor. The standard deﬁnitions of</text>
<text top="293" left="173" width="518" height="16" font="0">the return and bind operations for the Maybe monad are as follows:</text>
<text top="337" left="190" width="189" height="14" font="7">return :: a -&gt; Maybe a</text>
<text top="363" left="190" width="146" height="14" font="7">return x = Just x</text>
<text top="416" left="190" width="387" height="14" font="7">(&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b</text>
<text top="442" left="190" width="112" height="14" font="7">(&gt;&gt;=) Nothing</text>
<text top="442" left="319" width="95" height="14" font="7">_ = Nothing</text>
<text top="469" left="190" width="189" height="14" font="7">(&gt;&gt;=) (Just x) f = f x</text>
<text top="514" left="173" width="626" height="16" font="0">The deﬁnition of bind illustrates how the threading process works: sequencing an</text>
<text top="546" left="173" width="626" height="16" font="0">operation with a previous operation that failed produces Nothing. Just values are</text>
<text top="579" left="173" width="626" height="16" font="0">threaded through the computation without modifying the value of the underlying</text>
<text top="611" left="173" width="39" height="16" font="0">type.</text>
<text top="644" left="199" width="600" height="16" font="0">As a simple example of using the Maybe monad, rather than just the type, let</text>
<text top="676" left="173" width="626" height="16" font="0">us consider a function on binary trees that might fail: projecting the left subtree</text>
<text top="709" left="173" width="626" height="16" font="0">of a branch. For a tree made with the Branch constructor, leftTree will return</text>
<text top="741" left="173" width="626" height="16" font="0">the left subtree, but for a Leaf node, there will be no subtree to return. We can</text>
<text top="774" left="173" width="626" height="16" font="0">write this function using the Maybe type to capture failure without making use of</text>
<text top="806" left="173" width="139" height="16" font="0">monadic notation:</text>
<text top="850" left="190" width="258" height="14" font="7">leftTree :: Tree -&gt; Maybe Tree</text>
<text top="877" left="190" width="189" height="14" font="7">leftTree t = case t of</text>
<text top="903" left="319" width="189" height="14" font="7">Branch _ l _ -&gt; Just l</text>
<text top="929" left="319" width="34" height="14" font="7">Leaf</text>
<text top="929" left="431" width="86" height="14" font="7">-&gt; Nothing</text>
<text top="974" left="173" width="626" height="16" font="0">This deﬁnition checks the value t using a case expression instead of using multiple</text>
<text top="1007" left="173" width="626" height="16" font="0">equations; the two forms are equivalent. Using do-notation, we can write this same</text>
<text top="1039" left="173" width="89" height="16" font="0">function as:</text>
</page>
<page number="68" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">46</text>
<text top="165" left="190" width="258" height="14" font="7">leftTree :: Tree -&gt; Maybe Tree</text>
<text top="192" left="190" width="361" height="14" font="7">leftTree t = do (Branch _ l _) &lt;- return t</text>
<text top="218" left="327" width="69" height="14" font="7">return l</text>
<text top="263" left="173" width="626" height="16" font="0">We must use return twice: once to lift the pure tree value into the maybe monad</text>
<text top="296" left="173" width="626" height="16" font="0">and once to lift the result of the computation (the left subtree). If t is a Leaf,</text>
<text top="328" left="173" width="149" height="16" font="0">then the expression</text>
<text top="372" left="173" width="223" height="14" font="7">(Branch _ l _) &lt;- return t</text>
<text top="417" left="173" width="626" height="16" font="0">will cause a pattern match failure, but this will be caught and the result of</text>
<text top="451" left="173" width="626" height="15" font="0">leftTree will be Nothing. In this case, the use of do-notation does not make</text>
<text top="482" left="173" width="626" height="16" font="0">the deﬁnition any clearer, but in larger examples where multiple functions with a</text>
<text top="516" left="173" width="592" height="15" font="0">Maybe type are strung together this syntax can avoid a lot of syntactic noise.</text>
<text top="547" left="199" width="600" height="16" font="0">Haskell does not limit us to the standard set of eﬀects; programmers can easily</text>
<text top="580" left="173" width="626" height="16" font="0">deﬁne new monads to capture their own eﬀect patterns or side-eﬀecting operations.</text>
<text top="612" left="173" width="626" height="16" font="0">To create a new monad, the programmer must supply implementations for return</text>
<text top="645" left="173" width="626" height="16" font="0">and bind that are appropriate for the new monad and deﬁne any non-standard</text>
<text top="677" left="173" width="626" height="16" font="0">operations that implement the eﬀects of the new monad. New monads may also</text>
<text top="710" left="173" width="626" height="16" font="0">be created with monad building blocks called monad transformers. Most of the</text>
<text top="742" left="173" width="626" height="16" font="0">standard monads have an associated monad transformer deﬁnition that adds the</text>
<text top="775" left="173" width="626" height="16" font="0">functionality of that monad to another monad [69]. This allows us to combine the</text>
<text top="807" left="173" width="626" height="16" font="0">eﬀects of standard monads to produce custom monads that capture the necessary</text>
<text top="840" left="173" width="626" height="16" font="0">eﬀects for a particular program. For example, we can use monad transformers to</text>
<text top="872" left="173" width="514" height="16" font="0">construct a monad that supports both exceptions and global state.</text>
<text top="934" left="173" width="26" height="16" font="0">3.5</text>
<text top="934" left="219" width="102" height="16" font="0">MODULES</text>
<text top="984" left="173" width="626" height="16" font="0">The Haskell module system enables programmers to precisely control the types</text>
<text top="1017" left="173" width="626" height="16" font="0">and functions that are exported from one module to another. Type constructors</text>
<text top="1049" left="173" width="626" height="16" font="0">can be exported without making the value constructors for that type visible, and</text>
</page>
<page number="69" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">47</text>
<text top="163" left="173" width="626" height="16" font="0">speciﬁc value constructors for a type might be exported while others remain hidden.</text>
<text top="195" left="173" width="626" height="16" font="0">Our abstraction layer implementation relies on the precise control aﬀorded by the</text>
<text top="228" left="173" width="626" height="16" font="0">module system to enforce a strong abstraction boundary between the abstraction</text>
<text top="260" left="173" width="154" height="16" font="0">layer and its clients.</text>
<text top="293" left="199" width="600" height="16" font="0">A module deﬁnition gives a name to a Haskell module and optionally may</text>
<text top="325" left="173" width="626" height="16" font="0">declare the list of types and functions that the module exports. Every deﬁnition</text>
<text top="358" left="173" width="567" height="16" font="0">in the module will be exported when a speciﬁc export list is not supplied.</text>
<text top="400" left="190" width="155" height="14" font="7">module M where ...</text>
<text top="400" left="362" width="189" height="14" font="7">-- everything exported</text>
<text top="427" left="190" width="550" height="14" font="7">module M (f, g) where ... -- only functions f and g are exported</text>
<text top="470" left="173" width="626" height="16" font="0">Recall our original deﬁnition of a binary tree, with a type constructor called Tree</text>
<text top="503" left="173" width="626" height="16" font="0">and two value constructors called Branch and Leaf. If we wish to make the entire</text>
<text top="535" left="173" width="626" height="16" font="0">datatype deﬁnition visible through a module, we use the following notation in the</text>
<text top="568" left="173" width="84" height="16" font="0">export list:</text>
<text top="610" left="190" width="249" height="14" font="7">module M (Tree(..)) where ...</text>
<text top="653" left="173" width="626" height="16" font="0">Clients of this module will be able to construct arbitrary values of the Tree type.</text>
<text top="686" left="173" width="588" height="16" font="0">Alternatively, we can export just the type constructor by omitting the (..).</text>
<text top="728" left="190" width="215" height="14" font="7">module M (Tree) where ...</text>
<text top="771" left="173" width="626" height="16" font="0">Now, other modules can refer to the type Tree but cannot make any values of</text>
<text top="804" left="173" width="626" height="16" font="0">that type. M can guarantee properties of Tree values, for example, that every tree</text>
<text top="836" left="173" width="626" height="16" font="0">is balanced, because it controls the production of every value. A middle ground,</text>
<text top="869" left="173" width="626" height="16" font="0">which is less useful in this particular example, is to export just some of the value</text>
<text top="901" left="173" width="287" height="16" font="0">constructors for a type. For example,</text>
<text top="944" left="190" width="266" height="14" font="7">module M (Tree, Leaf) where ...</text>
<text top="987" left="173" width="552" height="16" font="0">allows modules other than M to construct Leaf values but not branches.</text>
<text top="1020" left="199" width="600" height="16" font="0">We will not show many module deﬁnitions in the code samples throughout the</text>
<text top="1052" left="173" width="626" height="16" font="0">dissertation, but the abstraction mechanisms provided by the module system are</text>
</page>
<page number="70" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">48</text>
<text top="163" left="173" width="626" height="16" font="0">essential for memory-safety enforcement in our implementation. The ability to</text>
<text top="195" left="173" width="626" height="16" font="0">hide the functions and datatype representations used within the implementation is</text>
<text top="228" left="173" width="626" height="16" font="0">crucial. Hiding value constructors for visible types allows us to use normal Haskell</text>
<text top="260" left="173" width="626" height="16" font="0">values as capabilities when requesting restricted abstraction layer operations, be-</text>
<text top="293" left="173" width="626" height="16" font="0">cause the key safety properties for the operation are already guaranteed at value</text>
<text top="325" left="173" width="140" height="16" font="0">construction time.</text>
</page>
<page number="71" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">49</text>
<text top="227" left="447" width="77" height="16" font="0">Chapter 4</text>
<text top="277" left="189" width="595" height="16" font="0">A MEMORY-SAFE ABSTRACTION LAYER FOR OPERATING SYSTEM</text>
<text top="310" left="356" width="261" height="16" font="0">CONSTRUCTION IN HASKELL</text>
<text top="402" left="173" width="626" height="16" font="0">A major focus of this dissertation is the deﬁnition of a memory-safe abstraction</text>
<text top="435" left="173" width="626" height="16" font="0">layer that is suﬃciently expressive to support the implementation of real operat-</text>
<text top="467" left="173" width="626" height="16" font="0">ing systems. To demonstrate the feasibility of the design, and to show that the</text>
<text top="500" left="173" width="626" height="16" font="0">abstraction layer can be integrated with a purely functional language, we will also</text>
<text top="532" left="173" width="626" height="16" font="0">provide an implementation of the abstraction layer as a Haskell library (see Chap-</text>
<text top="565" left="173" width="626" height="16" font="0">ter 6). We call this Haskell library the H interface, and will use the term H as a</text>
<text top="597" left="173" width="626" height="16" font="0">shorthand for both the design of the interface (indicating the types and functions</text>
<text top="630" left="173" width="626" height="16" font="0">that make up our abstraction layer) and its implementation. The H interface is a</text>
<text top="662" left="173" width="626" height="16" font="0">direct descendant of the abstraction layer of the same name from the House op-</text>
<text top="695" left="173" width="626" height="16" font="0">erating system [39], although there are many diﬀerences between the original and</text>
<text top="727" left="173" width="374" height="16" font="0">current versions of the API and implementation.</text>
<text top="760" left="199" width="600" height="16" font="0">Figure 4.1 illustrates the relationship between the Haskell run-time system, the</text>
<text top="792" left="173" width="626" height="16" font="0">H interface, and a Haskell operating system implementation. The H implementa-</text>
<text top="825" left="173" width="626" height="16" font="0">tion runs on bare metal with support from the GHC run-time system; we will cover</text>
<text top="857" left="173" width="626" height="16" font="0">this implementation in more detail in Section 6.3. A Haskell operating system may</text>
<text top="890" left="173" width="626" height="16" font="0">access the types and operations of the H interface design, but not the details of the</text>
<text top="922" left="173" width="626" height="16" font="0">implementation. We refer to the operating systems that run on top of H as client</text>
<text top="955" left="173" width="626" height="16" font="0">kernels because they are clients of the H interface. Client kernels also have access</text>
<text top="987" left="173" width="626" height="16" font="0">to the standard facilities of the Haskell run-time system, but we can only guarantee</text>
<text top="1020" left="173" width="626" height="16" font="0">memory-safety for clients that avoid calling the potentially unsafe primitives of the</text>
<text top="1052" left="173" width="626" height="16" font="0">Foreign Function Interface [12]. Applications run on top of a client kernel by using</text>
</page>
<page number="72" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="8" size="13" family="Times" color="#000000"/>
<text top="111" left="738" width="18" height="16" font="0">50</text>
<text top="306" left="482" width="75" height="20" font="6">hardware</text>
<text top="213" left="498" width="42" height="20" font="6">client</text>
<text top="170" left="467" width="30" height="20" font="6">app</text>
<text top="265" left="535" width="13" height="20" font="6">H</text>
<text top="170" left="541" width="30" height="20" font="6">app</text>
<text top="279" left="465" width="36" height="20" font="6">RTS</text>
<text top="237" left="622" width="58" height="17" font="8">interface</text>
<text top="264" left="623" width="102" height="17" font="8">implementation</text>
<text top="257" left="277" width="131" height="17" font="8">safe RTS primitives</text>
<text top="224" left="245" width="148" height="17" font="8">unsafe RTS primitives</text>
<text top="368" left="243" width="486" height="16" font="0">Figure 4.1: The basic architecture of H. H runs on bare metal,</text>
<text top="403" left="243" width="486" height="16" font="0">using support from the GHC run-time system for the portions</text>
<text top="438" left="243" width="486" height="16" font="0">that are written in Haskell. Client kernels—operating systems</text>
<text top="472" left="243" width="486" height="16" font="0">written using the primitives of the H interface design—run with</text>
<text top="507" left="243" width="486" height="16" font="0">the support of the H implementation and the GHC run-time</text>
<text top="542" left="243" width="486" height="16" font="0">system (because they are written in Haskell). Client kernels</text>
<text top="576" left="243" width="486" height="16" font="0">are allowed to access the safe facilities of the run-time system,</text>
<text top="611" left="243" width="486" height="16" font="0">but only the H implementation my use the potentially unsafe</text>
<text top="646" left="243" width="486" height="16" font="0">primitives. Applications run on top of the client, making use</text>
<text top="680" left="243" width="486" height="16" font="0">of the operating system API and, indirectly, H’s facilities for</text>
<text top="715" left="243" width="255" height="16" font="0">executing arbitrary user binaries.</text>
<text top="771" left="173" width="606" height="16" font="0">the operations for running user programs that are provided by the H interface.</text>
<text top="804" left="199" width="600" height="16" font="0">In this chapter, we will introduce the operations of the H interface. This pre-</text>
<text top="836" left="173" width="626" height="16" font="0">sentation will include a discussion of every type and function that is accessible to</text>
<text top="869" left="173" width="626" height="16" font="0">clients through the public API. For the most part, details of the private imple-</text>
<text top="901" left="173" width="626" height="16" font="0">mentation are left until Chapter 6. Details of the implementation that are directly</text>
<text top="934" left="173" width="626" height="16" font="0">visible through the API—for example, the conditions necessary for a function to</text>
<text top="966" left="173" width="626" height="16" font="0">succeed—or that aﬀect the high-level memory-safety analysis of the design will be</text>
<text top="999" left="173" width="187" height="16" font="0">included in this chapter.</text>
</page>
<page number="73" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">51</text>
<text top="163" left="199" width="600" height="16" font="0">The memory management facilities of the abstraction layer are the distinguish-</text>
<text top="195" left="173" width="626" height="16" font="0">ing feature of the H interface and are a core contribution of this dissertation. The</text>
<text top="228" left="173" width="626" height="16" font="0">choices made in the design of the memory management primitives have a signiﬁ-</text>
<text top="260" left="173" width="626" height="16" font="0">cant impact on our ability to demonstrate memory-safety for our system and on</text>
<text top="293" left="173" width="626" height="16" font="0">our potential ability to implement a variety of operating systems on top of the ab-</text>
<text top="325" left="173" width="626" height="16" font="0">straction layer. This chapter introduces the essential abstraction layer operations</text>
<text top="358" left="173" width="626" height="16" font="0">for managing physical and virtual memory and outlines the concepts that will form</text>
<text top="390" left="173" width="626" height="16" font="0">the basis of our memory safety analysis (presented in Chapter 5). Though our fo-</text>
<text top="423" left="173" width="626" height="16" font="0">cus is on memory management, we present every aspect of the abstraction layer</text>
<text top="455" left="173" width="626" height="16" font="0">design for completeness. The H interface supports the following essential services</text>
<text top="488" left="173" width="352" height="16" font="0">for constructing operating systems in Haskell:</text>
<text top="534" left="199" width="600" height="17" font="0">• Memory management: H provides facilities for working with the virtual</text>
<text top="568" left="217" width="583" height="16" font="0">memory management data structures described in Chapter 2. Clients of the</text>
<text top="600" left="217" width="583" height="16" font="0">interface may modify the virtual address space seen by user-level programs</text>
<text top="633" left="217" width="583" height="16" font="0">by adding a mapping, modifying the permissions on a mapping, or removing</text>
<text top="665" left="217" width="583" height="16" font="0">an existing mapping. Clients may also add mappings to the kernel virtual</text>
<text top="698" left="217" width="582" height="16" font="0">address space (the virtual-to-physical address translations that are accessible</text>
<text top="730" left="217" width="583" height="16" font="0">within the operating system). H supports virtual memory management by</text>
<text top="763" left="217" width="583" height="16" font="0">providing mechanisms for allocating and freeing virtual memory translation</text>
<text top="795" left="217" width="583" height="16" font="0">tables that live in memory (including both page-directories and page-tables).</text>
<text top="828" left="217" width="583" height="16" font="0">Correct and safe physical memory management is an essential component of</text>
<text top="860" left="217" width="102" height="16" font="0">the H design.</text>
<text top="907" left="199" width="600" height="17" font="0">• Protected execution of arbitrary user binaries: H supports user-mode</text>
<text top="940" left="217" width="583" height="16" font="0">execution of programs written in any language. Our current implementation</text>
<text top="973" left="217" width="583" height="16" font="0">assumes that user-level object ﬁles are stored in the ELF binary format [13].</text>
<text top="1005" left="217" width="583" height="16" font="0">Execution of a running user-level program is automatically paused when a</text>
<text top="1038" left="217" width="583" height="16" font="0">fault or interrupt occurs. Interrupt handlers within the H implementation</text>
</page>
<page number="74" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">52</text>
<text top="163" left="217" width="583" height="16" font="0">save the state of that program so that it can be resumed again later. The</text>
<text top="195" left="217" width="583" height="16" font="0">operating system that is written on top of H may access the register state</text>
<text top="228" left="217" width="583" height="16" font="0">of suspended programs and use this information to respond appropriately to</text>
<text top="260" left="217" width="336" height="16" font="0">system call requests, faults, or other events.</text>
<text top="307" left="199" width="600" height="17" font="0">• Program module loading: The H interface passes bootloader modules</text>
<text top="340" left="217" width="582" height="16" font="0">through to the operating system so that, for example, the OS can execute</text>
<text top="373" left="217" width="583" height="16" font="0">programs that are loaded by the bootloader. H provides facilities that sup-</text>
<text top="405" left="217" width="583" height="16" font="0">port mapping memory pages within an executable module to user-level pro-</text>
<text top="438" left="217" width="51" height="16" font="0">grams.</text>
<text top="484" left="199" width="600" height="17" font="0">• Low-level I/O operations: H allows unrestricted access to the I/O ports</text>
<text top="518" left="217" width="582" height="16" font="0">on the underlying machine (IA32 in our implementation), following the orig-</text>
<text top="550" left="217" width="583" height="16" font="0">inal design and implementation [39]. Allowing unrestricted access prevents</text>
<text top="583" left="217" width="583" height="16" font="0">client kernels from enforcing resource management policies on I/O devices.</text>
<text top="615" left="217" width="583" height="16" font="0">In this work we focus on safety with respect to virtual memory management,</text>
<text top="648" left="217" width="517" height="16" font="0">but control over I/O devices is an interesting topic for future work.</text>
<text top="694" left="199" width="600" height="17" font="0">• Debugging: H provides basic screen printing utilities for debugging during</text>
<text top="728" left="217" width="192" height="16" font="0">the development process.</text>
<text top="775" left="173" width="626" height="16" font="0">Many of the services are very similar to those that were available in earlier versions</text>
<text top="808" left="173" width="626" height="16" font="0">of the H interface [39], particularly the aspects of the design that relate to user</text>
<text top="840" left="173" width="310" height="16" font="0">program execution, I/O, and debugging.</text>
<text top="873" left="199" width="600" height="16" font="0">The remainder of this chapter describes the design of the H interface in detail.</text>
<text top="905" left="173" width="626" height="16" font="0">Section 4.1 describes the fundamental concepts that shape our memory-safety argu-</text>
<text top="938" left="173" width="626" height="16" font="0">ment for the interface primitives. Section 4.2 provides an example that illustrates</text>
<text top="970" left="173" width="626" height="16" font="0">the combination of static and dynamic checking that we employ to guarantee safety</text>
<text top="1003" left="173" width="626" height="16" font="0">in our implementation. Section 4.3 presents the basic data structures that we use</text>
<text top="1035" left="173" width="626" height="16" font="0">to describe memory and executable modules. Section 4.4 explains the facilities for</text>
</page>
<page number="75" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">53</text>
<text top="163" left="173" width="626" height="16" font="0">managing virtual address-spaces. Section 4.5 covers user-process execution and</text>
<text top="195" left="173" width="266" height="16" font="0">Section 4.6 covers I/O port access.</text>
<text top="256" left="173" width="26" height="16" font="0">4.1</text>
<text top="256" left="219" width="293" height="16" font="0">CHARACTERIZING MEMORY</text>
<text top="306" left="173" width="626" height="16" font="0">Memory serves various purposes within a kernel implementation. Some pages store</text>
<text top="338" left="173" width="626" height="16" font="0">kernel code and data, some are mapped to user processes for their code and data,</text>
<text top="371" left="173" width="626" height="16" font="0">and—on the IA32—some store tables describing the translation from virtual to</text>
<text top="403" left="173" width="626" height="16" font="0">physical addresses (see Section 2.2). From a correctness and safety perspective,</text>
<text top="436" left="173" width="626" height="16" font="0">diﬀerent operations are valid on a page of memory depending on its function in the</text>
<text top="468" left="173" width="626" height="16" font="0">system at a particular moment in time. Kernel code pages, for example, should</text>
<text top="501" left="173" width="626" height="16" font="0">never be mapped to a user thread, and in many cases should not be written to</text>
<text top="533" left="173" width="626" height="16" font="0">by anyone once the boot process is complete. User code and data pages, on the</text>
<text top="566" left="173" width="626" height="16" font="0">other hand, may be mapped freely and might even be shared among multiple user</text>
<text top="598" left="173" width="626" height="16" font="0">processes. Finally, page-tables and page-directories need to be written to by the</text>
<text top="631" left="173" width="430" height="16" font="0">client kernel, but only in very speciﬁc and limited ways.</text>
<text top="663" left="199" width="600" height="16" font="0">We reﬂect the diﬀerent roles of memory into our design by associating a dynamic</text>
<text top="696" left="173" width="626" height="16" font="0">status value with each physical page of memory. The dynamic status reﬂects each</text>
<text top="728" left="173" width="549" height="16" font="0">page’s current use in the system, which falls into one of four categories:</text>
<text top="768" left="182" width="618" height="16" font="0">Normal Page: A page of memory that does not have any special semantics</text>
<text top="800" left="217" width="583" height="16" font="0">associated with it by the kernel. Normal pages may contain user or kernel</text>
<text top="833" left="217" width="583" height="16" font="0">data; they may also be shared between multiple user processes or between a</text>
<text top="865" left="217" width="528" height="16" font="0">user process and the kernel if the client kernel requests such sharing.</text>
<text top="910" left="182" width="618" height="16" font="0">Page-Directory Page: A page that is in use as a page-directory. In our model,</text>
<text top="942" left="217" width="583" height="16" font="0">we assume that page-directory pages may be dynamically created from unal-</text>
<text top="975" left="217" width="581" height="16" font="0">located normal memory pages during the execution of an operating system.</text>
<text top="1020" left="182" width="618" height="16" font="0">Page-Table Page: A page that is in use as a page-table. We distinguish page-</text>
<text top="1052" left="217" width="583" height="16" font="0">tables from page-directories because certain operations are only valid on</text>
</page>
<page number="76" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">54</text>
<text top="163" left="217" width="583" height="16" font="0">page-directory pages. As with page-directories, page-tables can be dynami-</text>
<text top="195" left="217" width="319" height="16" font="0">cally created from normal memory pages.</text>
<text top="243" left="182" width="618" height="16" font="0">Environment Page: Any page that must be present for the kernel code to run.</text>
<text top="275" left="217" width="583" height="16" font="0">This might include the code and heap for the run-time system as well as the</text>
<text top="308" left="217" width="583" height="16" font="0">kernel code itself. In our implementation, this set includes the C and Haskell</text>
<text top="340" left="217" width="204" height="16" font="0">heaps and the kernel code.</text>
<text top="388" left="173" width="626" height="16" font="0">Status information plays an important role in protecting memory-safety for an</text>
<text top="420" left="173" width="626" height="16" font="0">H-based system. Separating environment memory and translation table memory</text>
<text top="453" left="173" width="626" height="16" font="0">(page-directories and page-tables) from user memory (allocated normal pages) is a</text>
<text top="485" left="173" width="626" height="16" font="0">fundamental requirement for memory-safety in operating systems. We must ensure</text>
<text top="518" left="173" width="626" height="16" font="0">that no user program can interfere with the virtual-to-physical memory mappings</text>
<text top="550" left="173" width="614" height="16" font="0">of the kernel or other users and that no one can corrupt the execution environment</text>
<text top="548" left="787" width="6" height="11" font="2">1</text>
<text top="550" left="794" width="5" height="16" font="0">.</text>
<text top="583" left="173" width="626" height="16" font="0">We will formally deﬁne this memory-safety property in Chapter 5. Tracking the</text>
<text top="615" left="173" width="626" height="16" font="0">current usage of each memory page allows the interface implementation to enforce</text>
<text top="648" left="173" width="626" height="16" font="0">memory-safety through dynamic checks that guarantee that a client of H never</text>
<text top="680" left="173" width="355" height="16" font="0">changes the status of a page in an unsafe way.</text>
<text top="713" left="199" width="600" height="16" font="0">Client kernels cannot subvert the intended scheme for protecting status tran-</text>
<text top="745" left="173" width="626" height="16" font="0">sitions because H does not provide them with direct memory access. Instead,</text>
<text top="778" left="173" width="626" height="16" font="0">client kernels control memory indirectly through the operations of the H interface.</text>
<text top="810" left="173" width="626" height="16" font="0">In a sense, this splits the two hardware privilege levels that we traditionally rely</text>
<text top="843" left="173" width="626" height="16" font="0">on for kernel implementations into three, with the third level being implemented</text>
<text top="875" left="173" width="626" height="16" font="0">purely in software. An H client has the full power necessary to conﬁgure and run</text>
<text top="908" left="173" width="626" height="16" font="0">the system—including setting the policies for how user programs will interact—</text>
<text top="940" left="173" width="626" height="16" font="0">but every operation is checked for safety violations. The strong type system and</text>
<text top="986" left="193" width="6" height="9" font="3">1</text>
<text top="988" left="200" width="600" height="13" font="4">We use the term execution environment to refer to the collection of services that have an</text>
<text top="1017" left="173" width="626" height="13" font="4">implicit role in the execution of user programs. This includes the run-time system, the C and</text>
<text top="1046" left="173" width="445" height="13" font="4">Haskell heaps, the code and data for H, and the code for the kernel.</text>
</page>
<page number="77" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">55</text>
<text top="163" left="173" width="626" height="16" font="0">module system of Haskell give us conﬁdence that the restrictions in place in the</text>
<text top="195" left="173" width="626" height="16" font="0">software privilege level are eﬀectively enforced. A client will never accidentally</text>
<text top="228" left="173" width="626" height="16" font="0">circumvent the protections without a type error or other compile time warning.</text>
<text top="260" left="173" width="626" height="16" font="0">A similar notion of reduced privilege through software controls also appears in</text>
<text top="293" left="173" width="626" height="16" font="0">hardware virtualization systems where every hardware operation must go through</text>
<text top="325" left="173" width="626" height="16" font="0">a virtual machine monitor [5]. The primary focus of the checking in virtual ma-</text>
<text top="358" left="173" width="626" height="16" font="0">chine monitors is to ensure fair multiplexing of the machine resources rather than</text>
<text top="390" left="173" width="626" height="16" font="0">memory-safety in the individual kernels, but the mechanisms for achieving resource</text>
<text top="423" left="173" width="170" height="16" font="0">protection are similar.</text>
<text top="455" left="199" width="600" height="16" font="0">We encode memory-safety properties in terms of page status values by re-</text>
<text top="488" left="173" width="626" height="16" font="0">stricting the states in which certain status transitions may take place. Figure 4.2</text>
<text top="520" left="173" width="626" height="16" font="0">illustrates the allowable transitions between status values. The safety of a partic-</text>
<text top="553" left="173" width="626" height="16" font="0">ular transition typically depends on the current state of the page. For example,</text>
<text top="585" left="173" width="626" height="16" font="0">a normal memory page can only be converted into a page-table or page-directory</text>
<text top="618" left="173" width="626" height="16" font="0">if it is not currently mapped to any users. Some transitions are never allowed:</text>
<text top="650" left="173" width="626" height="16" font="0">the set of environment pages is constant so no page can ever become or be con-</text>
<text top="683" left="173" width="626" height="16" font="0">verted from such a page. This allows us to enforce strong separation between the</text>
<text top="715" left="173" width="626" height="16" font="0">kernel (including H) and the execution environment without a complicated set of</text>
<text top="748" left="173" width="121" height="16" font="0">run-time checks</text>
<text top="746" left="293" width="6" height="11" font="2">2</text>
<text top="748" left="300" width="5" height="16" font="0">.</text>
<text top="790" left="193" width="6" height="9" font="3">2</text>
<text top="792" left="200" width="600" height="13" font="4">For the purposes of reasoning about memory-safety, we ignore the indirect eﬀect that the</text>
<text top="821" left="173" width="626" height="13" font="4">kernel has on the environment pages by executing. During the course of execution, the Haskell</text>
<text top="850" left="173" width="626" height="13" font="4">run-time system will allocate and manipulate memory on the kernel’s behalf within the protected</text>
<text top="879" left="173" width="626" height="13" font="4">environment pages. We assume that the run-time system functions correctly. Verifying that</text>
<text top="907" left="173" width="626" height="13" font="4">GHC maintains a well-formed and memory-safe heap, where updates within client kernel data</text>
<text top="936" left="173" width="626" height="13" font="4">structures do not aﬀect the contents of H data structures, is an interesting but separate problem.</text>
</page>
<page number="78" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="9" size="17" family="Times" color="#000000"/>
<text top="111" left="738" width="18" height="16" font="0">56</text>
<text top="407" left="603" width="52" height="22" font="9">Page-</text>
<text top="431" left="589" width="79" height="22" font="9">Directory</text>
<text top="196" left="277" width="110" height="22" font="9">Environment</text>
<text top="407" left="351" width="52" height="22" font="9">Page-</text>
<text top="431" left="352" width="49" height="22" font="9">Table</text>
<text top="277" left="475" width="63" height="22" font="9">Normal</text>
<text top="348" left="465" width="90" height="16" font="4">If page is free</text>
<text top="366" left="465" width="87" height="16" font="4">(not mapped)</text>
<text top="301" left="612" width="81" height="16" font="4">When page-</text>
<text top="318" left="598" width="109" height="16" font="4">directory is freed</text>
<text top="336" left="625" width="54" height="16" font="4">by client</text>
<text top="300" left="297" width="104" height="16" font="4">When H notices</text>
<text top="317" left="293" width="110" height="16" font="4">that a page-table</text>
<text top="335" left="304" width="89" height="16" font="4">becomes free</text>
<text top="510" left="188" width="595" height="16" font="0">Figure 4.2: The allowable transitions that memory pages may make between</text>
<text top="545" left="188" width="595" height="16" font="0">diﬀerent status assignments. A free page—a normal page that is not mapped</text>
<text top="580" left="188" width="595" height="16" font="0">in any page-directory—may be turned into a page-table or a page-directory</text>
<text top="614" left="188" width="595" height="16" font="0">page. H manages page-table memory, automatically freeing a page-table page</text>
<text top="649" left="188" width="595" height="16" font="0">when it no longer contains any entries. The client explicitly allocates and frees</text>
<text top="684" left="188" width="595" height="16" font="0">page-directories using the H API functions that we will cover in Section 4.4.1.</text>
<text top="718" left="188" width="309" height="16" font="0">Environment pages never change status.</text>
<text top="775" left="173" width="26" height="16" font="0">4.2</text>
<text top="775" left="219" width="484" height="16" font="0">EXAMPLE: ADDING A MEMORY MAPPING IN H</text>
<text top="825" left="173" width="626" height="16" font="0">Recall from Section 4.1 that an environment page is any page that is required for</text>
<text top="858" left="173" width="626" height="16" font="0">the kernel to run, such as the implementation language heap or a page of the kernel</text>
<text top="890" left="173" width="626" height="16" font="0">code. In the implementation of H, we ensure that such a page is never mapped to</text>
<text top="923" left="173" width="626" height="16" font="0">a user process by making sure that the clients of H are never given a mechanism</text>
<text top="955" left="173" width="626" height="16" font="0">for accessing those pages. Clients access memory through a memory handle, which</text>
<text top="988" left="173" width="626" height="16" font="0">is a tightly controlled datatype for describing regions of physical memory. The</text>
<text top="1020" left="173" width="626" height="16" font="0">datatype, called PhysicalRegion, contains a description of the physical-address</text>
</page>
<page number="79" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">57</text>
<text top="163" left="173" width="626" height="16" font="0">range it represents and a type that indicates whether the region represents normal</text>
<text top="195" left="173" width="626" height="16" font="0">memory (RAM) or I/O memory (like the video RAM). We use the Haskell module</text>
<text top="228" left="173" width="626" height="16" font="0">system to restrict client access to memory handles: when we export the datatype</text>
<text top="260" left="173" width="626" height="16" font="0">from the module where it is deﬁned, we export the type name, so that programmers</text>
<text top="293" left="173" width="626" height="16" font="0">can refer to the type PhysicalRegion, but not the value constructor. By using</text>
<text top="325" left="173" width="626" height="16" font="0">this approach, we can treat memory handles like an unforgeable capability, even</text>
<text top="358" left="173" width="274" height="16" font="0">though they are just regular values.</text>
<text top="390" left="199" width="600" height="16" font="0">H constructs PhysicalRegion handles that precisely describe the memory</text>
<text top="423" left="173" width="626" height="16" font="0">available to the client—the physical memory on the machine that is not being used</text>
<text top="455" left="173" width="597" height="16" font="0">for environment pages. The initialRegions primitive returns these handles.</text>
<text top="498" left="181" width="309" height="14" font="7">initialRegions :: H [PhysicalRegion]</text>
<text top="543" left="173" width="626" height="16" font="0">An essential requirement of the H implementation is that initialRegions con-</text>
<text top="575" left="173" width="626" height="16" font="0">structs handles to the correct set of pages: no environment pages should be in-</text>
<text top="608" left="173" width="626" height="16" font="0">cluded in the regions referenced by the handles and every other usable page of</text>
<text top="640" left="173" width="626" height="16" font="0">memory should be included in exactly one region. The absence of environment</text>
<text top="673" left="173" width="626" height="16" font="0">pages from the set of initial regions helps us to establish the correctness of the H im-</text>
<text top="705" left="173" width="626" height="16" font="0">plementation overall: to be memory-safe, H should never construct a handle to any</text>
<text top="738" left="173" width="626" height="16" font="0">environment page. The client generates new handles through the deriveRegion</text>
<text top="770" left="173" width="626" height="16" font="0">primitive, which creates a PhysicalRegion handle to a sub-region of an existing</text>
<text top="803" left="173" width="287" height="16" font="0">region (with the same physical type).</text>
<text top="846" left="181" width="619" height="14" font="7">deriveRegion :: PhysicalRegion -&gt; Fpage Physical -&gt; Maybe PhysicalRegion</text>
<text top="890" left="173" width="626" height="16" font="0">The key property of deriveRegion is that it never creates a handle to mem-</text>
<text top="922" left="173" width="626" height="16" font="0">ory that is not contained in a PhysicalRegion that was returned by a call to</text>
<text top="956" left="173" width="626" height="15" font="0">initialRegions. In this way, we establish an inductive argument in support of</text>
<text top="987" left="173" width="626" height="16" font="0">the property that H does not create handles to environment pages. If the re-</text>
<text top="1020" left="173" width="626" height="16" font="0">gions exposed by initialRegions do not include any environment pages, and if</text>
<text top="1054" left="173" width="626" height="15" font="0">deriveRegion is implemented correctly, then deriveRegion will never return a</text>
</page>
<page number="80" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="10" size="21" family="Times" color="#000000"/>
<text top="111" left="738" width="18" height="16" font="0">58</text>
<text top="163" left="173" width="626" height="16" font="0">handle to an environment page. Figure 4.3 illustrates the relationship between</text>
<text top="195" left="173" width="159" height="16" font="0">these two primitives.</text>
<text top="233" left="490" width="178" height="26" font="10">Physical Memory</text>
<text top="296" left="189" width="153" height="26" font="10">Initial Regions:</text>
<text top="406" left="189" width="155" height="26" font="10">Derive Region:</text>
<text top="622" left="188" width="595" height="16" font="0">Figure 4.3: Illustrating the relationship between initialRegions and derive-</text>
<text top="658" left="188" width="595" height="15" font="0">Region. initalRegions exposes the portion of physical memory that is not in</text>
<text top="691" left="188" width="595" height="16" font="0">use for environment pages. In the diagram, available memory is shown in gray</text>
<text top="726" left="188" width="595" height="16" font="0">while protected environment memory (that cannot have handles constructed</text>
<text top="760" left="188" width="595" height="16" font="0">to it) is shown in white. deriveRegion creates new handles to sub-regions of</text>
<text top="795" left="188" width="595" height="16" font="0">existing regions, but will not create a handle to any memory that lies outside</text>
<text top="830" left="188" width="595" height="16" font="0">of the initial regions. In the diagram, unadorned arrows indicate a region that</text>
<text top="864" left="188" width="595" height="16" font="0">can successfully be derived from an existing region, while arrows with a cross</text>
<text top="899" left="188" width="595" height="16" font="0">through them indicate a region that cannot be derived because it combines</text>
<text top="934" left="188" width="448" height="16" font="0">multiple existing regions or it includes environment pages.</text>
<text top="987" left="199" width="600" height="16" font="0">To add a mapping to a virtual address-space, the client must supply H with</text>
<text top="1020" left="173" width="626" height="16" font="0">the handle for the physical memory to be mapped. This design ensures that the</text>
<text top="1052" left="173" width="626" height="16" font="0">client can never map any environment pages to a user process. We present the full</text>
</page>
<page number="81" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">59</text>
<text top="163" left="173" width="626" height="16" font="0">design of the user-level memory management facilities in Section 4.4.2. Abstracting</text>
<text top="195" left="173" width="626" height="16" font="0">over the details and datatypes that we have not covered yet gives the type for the</text>
<text top="228" left="173" width="270" height="16" font="0">function that adds a new mapping:</text>
<text top="272" left="181" width="619" height="14" font="7">addMapping :: PageMap -&gt; VirtualAddressRange -&gt; PhysicalRegion -&gt; H Bool</text>
<text top="318" left="173" width="626" height="15" font="0">PageMap is an abstraction for an address space. In the IA32 implementation of H,</text>
<text top="349" left="173" width="626" height="16" font="0">the term page-map refers to the collection of mappings reachable through a page-</text>
<text top="382" left="173" width="626" height="16" font="0">directory (see Chapter 2.2). We use this terminology to avoid over-specializing the</text>
<text top="414" left="173" width="626" height="16" font="0">interface design to two-level tables. We sometimes refer to page-directories and</text>
<text top="447" left="173" width="626" height="16" font="0">page-tables generically as page-map pages, but only in cases where the distinction</text>
<text top="479" left="173" width="626" height="16" font="0">is not important. The VirtualAddressRange describes a range of virtual addresses</text>
<text top="512" left="173" width="626" height="16" font="0">to be mapped—in general this range can be as small as a physical page and as</text>
<text top="544" left="173" width="626" height="16" font="0">large as the amount of the available memory. The PhysicalRegion parameter is</text>
<text top="577" left="173" width="626" height="16" font="0">a handle to physical memory. The result, of type Bool, indicates whether or not</text>
<text top="609" left="173" width="499" height="16" font="0">the mapping was successfully added to the virtual address space.</text>
<text top="642" left="199" width="600" height="16" font="0">Other properties discussed in Section 4.1—such as the requirement that a page-</text>
<text top="674" left="173" width="626" height="16" font="0">table page is never mapped to a user process—cannot be expressed using types</text>
<text top="707" left="173" width="626" height="16" font="0">alone because the role of each page may change over time. For these properties,</text>
<text top="739" left="173" width="626" height="16" font="0">we rely on dynamic checks based on page status values at the time of a requested</text>
<text top="772" left="173" width="626" height="16" font="0">operation. As an example of dynamic safety checks in the H interface, consider</text>
<text top="804" left="173" width="626" height="16" font="0">the internal implementation of the addMapping function whose signature was given</text>
<text top="837" left="173" width="626" height="16" font="0">earlier. This function must perform checking to ensure that the parameters are</text>
<text top="869" left="173" width="626" height="16" font="0">valid and to ensure that the desired page-type properties hold. A physical region</text>
<text top="902" left="173" width="626" height="16" font="0">can only be mapped if all of the pages that make up the region are normal pages—</text>
<text top="934" left="173" width="626" height="16" font="0">mapping a page with page-table or page-directory status to a user program will</text>
<text top="967" left="173" width="626" height="16" font="0">violate our desired memory-safety property. The addMapping function will only</text>
<text top="999" left="173" width="626" height="16" font="0">add new memory mappings when the page status checks indicate that the operation</text>
<text top="1032" left="173" width="51" height="16" font="0">is safe.</text>
</page>
<page number="82" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">60</text>
<text top="163" left="173" width="26" height="16" font="0">4.3</text>
<text top="163" left="219" width="269" height="16" font="0">SYSTEM CONFIGURATION</text>
<text top="213" left="173" width="626" height="16" font="0">In this section, we examine the low-level structures that are provided by H for</text>
<text top="246" left="173" width="626" height="16" font="0">communicating information about the hardware conﬁguration to a client kernel.</text>
<text top="278" left="173" width="626" height="16" font="0">Section 4.3.1 presents the basic structures that H uses to represent memory, in-</text>
<text top="311" left="173" width="626" height="16" font="0">cluding more speciﬁcs about the initialRegions and deriveRegion primitives.</text>
<text top="343" left="173" width="626" height="16" font="0">Section 4.3.2 explains the mechanisms available in H for loading executable mod-</text>
<text top="376" left="173" width="474" height="16" font="0">ules through a bootloader and mapping them into user space.</text>
<text top="435" left="173" width="41" height="16" font="0">4.3.1</text>
<text top="435" left="234" width="282" height="16" font="0">Physical Memory Conﬁguration</text>
<text top="479" left="173" width="626" height="16" font="0">The foundation of our correctness argument for H centers around the correct man-</text>
<text top="512" left="173" width="626" height="16" font="0">agement of physical memory. One mechanism for controlling physical memory is to</text>
<text top="544" left="173" width="626" height="16" font="0">statically restrict the set of memory pages that the client may access. We achieve</text>
<text top="577" left="173" width="626" height="16" font="0">this by encapsulating the representation of memory pages as abstract types, im-</text>
<text top="609" left="173" width="341" height="16" font="0">plemented using the Haskell module system.</text>
<text top="669" left="173" width="218" height="16" font="0">Flexible Address Ranges</text>
<text top="713" left="173" width="626" height="16" font="0">We introduce the notion of ﬂexible address ranges for describing areas of memory.</text>
<text top="746" left="173" width="626" height="16" font="0">In general, an area of memory is a range of addresses described by an arbitrary</text>
<text top="778" left="173" width="626" height="16" font="0">start address and an arbitrary length. In practice, not all start addresses or lengths</text>
<text top="811" left="173" width="626" height="16" font="0">are useful. For example, an operating system running on the IA32 architecture can</text>
<text top="843" left="173" width="626" height="16" font="0">never map 512 bytes because the architecture does not allow memory mappings</text>
<text top="876" left="173" width="324" height="16" font="0">that are smaller than a page (4096 bytes).</text>
<text top="908" left="199" width="600" height="16" font="0">Following the example of L4 [62], we describe areas of memory with a type that</text>
<text top="941" left="173" width="626" height="16" font="0">captures the implicit practical restrictions on area sizes and locations as explicit</text>
<text top="973" left="173" width="626" height="16" font="0">restrictions on the values of that type. The restrictions on these ﬂexible pages</text>
<text top="1006" left="173" width="342" height="16" font="0">(ﬂexpages or fpages for short) are as follows:</text>
<text top="1051" left="199" width="213" height="17" font="0">• The size of a ﬂexpage is 2</text>
<text top="1050" left="412" width="7" height="11" font="2">n</text>
<text top="1052" left="426" width="347" height="16" font="0">bytes for some natural number n, such that 2</text>
<text top="1050" left="773" width="7" height="11" font="2">n</text>
<text top="1052" left="787" width="12" height="16" font="0">is</text>
</page>
<page number="83" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">61</text>
<text top="163" left="217" width="583" height="16" font="0">greater than or equal to the minimum page size on the target architecture.</text>
<text top="195" left="217" width="583" height="16" font="0">This means that every byte in the ﬂexpage is uniquely identiﬁed by an n-bit</text>
<text top="228" left="217" width="45" height="16" font="0">oﬀset.</text>
<text top="274" left="199" width="600" height="17" font="0">• The start address of a ﬂexpage is aligned to its size. This means that the</text>
<text top="308" left="217" width="395" height="16" font="0">start address will be a multiple of the ﬂexpage size.</text>
<text top="355" left="173" width="626" height="16" font="0">Though the ﬂexpage scheme does rule out some potentially useful address ranges</text>
<text top="388" left="173" width="626" height="16" font="0">(e.g., some structures used in graphics programming take up an odd number of</text>
<text top="420" left="173" width="626" height="16" font="0">pages), we have not encountered a case in practice where the size and alignment</text>
<text top="453" left="173" width="626" height="16" font="0">requirements are overly restrictive. If necessary, the client can round up to the</text>
<text top="485" left="173" width="626" height="16" font="0">next valid ﬂexpage or use multiple ﬂexpages to precisely describe a memory area</text>
<text top="518" left="173" width="626" height="16" font="0">of interest. Flexpages can be used to describe both virtual and physical regions of</text>
<text top="550" left="173" width="65" height="16" font="0">memory.</text>
<text top="583" left="199" width="600" height="16" font="0">We deﬁne a new type for describing ﬂexpage sizes called LogSize. The client</text>
<text top="615" left="173" width="626" height="16" font="0">may freely construct values of this type, but the semantics of the type capture</text>
<text top="648" left="173" width="626" height="16" font="0">the ﬂexpage size requirements: LogSize represents the base-2 logarithm of the</text>
<text top="680" left="173" width="626" height="16" font="0">total size in bytes. For example, a LogSize value of 12 corresponds to a region</text>
<text top="713" left="173" width="63" height="16" font="0">of size 2</text>
<text top="710" left="236" width="13" height="11" font="2">12</text>
<text top="713" left="256" width="544" height="16" font="0">bytes. The only exception is that the LogSize value zero is special; it</text>
<text top="745" left="173" width="626" height="16" font="0">encodes the zero-size ﬂexpage, rather than a ﬂexpage of length one. Some values</text>
<text top="778" left="173" width="626" height="16" font="0">of LogSize are invalid on a particular architecture by the ﬂexpage rules because</text>
<text top="810" left="173" width="626" height="16" font="0">they correspond to region lengths that are less than a physical page. Such values</text>
<text top="843" left="173" width="548" height="16" font="0">are treated as zero when they are used in the construction of ﬂexpages.</text>
<text top="875" left="199" width="600" height="16" font="0">Every ﬂexpage is guaranteed to obey the size and alignment requirements be-</text>
<text top="908" left="173" width="626" height="16" font="0">cause we hide the representation behind the private type Fpage a. The type</text>
<text top="940" left="173" width="626" height="16" font="0">parameter a is meant to be either Physical or Virtual to distinguish the kind of</text>
<text top="973" left="173" width="626" height="16" font="0">memory referred to by the ﬂexpage. Thus, a ﬂexpage describing a range of virtual</text>
<text top="1005" left="173" width="364" height="16" font="0">addresses would have the type Fpage Virtual.</text>
<text top="1049" left="190" width="112" height="14" font="7">data Physical</text>
</page>
<page number="84" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">62</text>
<text top="165" left="190" width="103" height="14" font="7">data Virtual</text>
<text top="212" left="173" width="626" height="15" font="0">Physical and Virtual are phantom types whose sole purpose is to reﬁne the type</text>
<text top="243" left="173" width="626" height="16" font="0">we give to address ranges. We cannot construct values of these types. We choose</text>
<text top="275" left="173" width="626" height="16" font="0">this representation for ﬂexpages to provide better documentation in the types and</text>
<text top="308" left="173" width="626" height="16" font="0">to help avoid confusion between ﬂexpages used for diﬀerent purposes. We use the</text>
<text top="340" left="173" width="626" height="16" font="0">same technique for addresses, representing both virtual and physical addresses as</text>
<text top="373" left="173" width="514" height="16" font="0">32-bit words but using a phantom type to improve documentation.</text>
<text top="417" left="190" width="163" height="14" font="7">type Addr a = HWord</text>
<text top="462" left="173" width="626" height="16" font="0">As with ﬂexpages, Physical and Virtual are the only intended instantiations of</text>
<text top="494" left="173" width="272" height="16" font="0">the type parameter a for addresses.</text>
<text top="527" left="199" width="600" height="16" font="0">With a private constructor, the client must create ﬂexpages through the inter-</text>
<text top="559" left="173" width="626" height="16" font="0">face function for making ﬂexpages, called fpage. The arguments to fpage are the</text>
<text top="592" left="173" width="414" height="16" font="0">base address of the memory area and the desired size.</text>
<text top="636" left="190" width="318" height="14" font="7">fpage :: Addr a -&gt; LogSize -&gt; Fpage a</text>
<text top="681" left="173" width="626" height="16" font="0">The constructor always returns a valid ﬂexpage by aligning the base address to the</text>
<text top="713" left="173" width="626" height="16" font="0">size. If the size is too small (less than the page size on the target architecture),</text>
<text top="746" left="173" width="626" height="16" font="0">then the result will be a zero-size ﬂexpage. We could make better use of the types</text>
<text top="778" left="173" width="626" height="16" font="0">by returning a Maybe (Flexpage a) instead of the zero value of the ﬂexpage type.</text>
<text top="811" left="173" width="626" height="16" font="0">The choice does not impact safety. We choose the C-style failure model in this</text>
<text top="843" left="173" width="626" height="16" font="0">case to provide a better match with the typical uses of the primitive in our L4</text>
<text top="876" left="173" width="124" height="16" font="0">implementation.</text>
<text top="935" left="173" width="122" height="16" font="0">Access Rights</text>
<text top="979" left="173" width="626" height="16" font="0">Access rights control whether or not the contents of a particular region of memory</text>
<text top="1012" left="173" width="626" height="16" font="0">may be read, written, or executed. Every memory mapping has an independent</text>
<text top="1044" left="173" width="626" height="16" font="0">set of access rights associated with it, represented by the type Perms, so a single</text>
</page>
<page number="85" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">63</text>
<text top="163" left="173" width="626" height="16" font="0">physical page might be mapped with diﬀerent permissions in two distinct address-</text>
<text top="195" left="173" width="626" height="16" font="0">spaces. A client controls the assignment of access rights to memory regions through</text>
<text top="228" left="173" width="626" height="16" font="0">the mapping management functions of the interface, which we will cover in Sec-</text>
<text top="260" left="173" width="77" height="16" font="0">tion 4.4.2.</text>
<text top="320" left="173" width="253" height="16" font="0">Regions of Physical Memory</text>
<text top="364" left="173" width="626" height="16" font="0">At start-up, the H implementation reserves a portion of the physical memory</text>
<text top="397" left="173" width="626" height="16" font="0">installed in the machine to use as environment pages. The rest of the available</text>
<text top="429" left="173" width="626" height="16" font="0">memory on the machine is given to the client kernel to use for any purpose—for</text>
<text top="462" left="173" width="626" height="16" font="0">page-table memory, for user-processes, or for its own kernel-speciﬁc data structures.</text>
<text top="494" left="173" width="626" height="16" font="0">Some environment pages, such as the memory that stores the kernel code, have</text>
<text top="527" left="173" width="626" height="16" font="0">the same location in any run of the system. Other protected areas of memory</text>
<text top="559" left="173" width="626" height="16" font="0">are dynamically conﬁgured by H. For example, H chooses the size and location</text>
<text top="592" left="173" width="626" height="16" font="0">of the Haskell heap based on the available memory of the machine. As we saw in</text>
<text top="624" left="173" width="626" height="16" font="0">Section 4.1, these pages cannot be safely mapped to a user-process. Any remaining</text>
<text top="657" left="173" width="626" height="16" font="0">memory becomes available to the client through initialRegions. Figure 4.4</text>
<text top="689" left="173" width="574" height="16" font="0">illustrates the division of memory between the environment and the client.</text>
<text top="722" left="199" width="600" height="16" font="0">We use ﬂexible address ranges to describe the regions of physical memory that</text>
<text top="754" left="173" width="626" height="16" font="0">are available to the client. Accordingly, the size and alignment restrictions on</text>
<text top="787" left="173" width="626" height="16" font="0">ﬂexpages also apply to regions: the size of a region must be a whole number of</text>
<text top="819" left="173" width="626" height="16" font="0">physical pages and the start address must be aligned to the region’s size. Each</text>
<text top="852" left="173" width="626" height="16" font="0">physical region also has a static type that describes the nature of the memory</text>
<text top="884" left="173" width="600" height="16" font="0">contained in the physical region (normal RAM or memory-mapped IO pages).</text>
<text top="928" left="190" width="309" height="14" font="7">data PhysicalType = RAM | IOM IOType</text>
<text top="973" left="173" width="626" height="16" font="0">We support two kinds of memory-mapped I/O regions: video RAM and the frame</text>
<text top="1006" left="173" width="184" height="16" font="0">buﬀer for VBE graphics</text>
<text top="1003" left="357" width="6" height="11" font="2">3</text>
<text top="1006" left="364" width="435" height="16" font="0">. We consider this to be a proof of concept for exporting</text>
<text top="1051" left="193" width="6" height="9" font="3">3</text>
<text top="1054" left="200" width="599" height="13" font="4">VBE (VESA BIOS Extension) is a graphics standard intended to simplify access to graphics</text>
</page>
<page number="86" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">64</text>
<text top="233" left="224" width="86" height="17" font="8">Environment</text>
<text top="377" left="224" width="62" height="17" font="8">Available</text>
<text top="407" left="349" width="159" height="17" font="8">Internal Kernel Memory</text>
<text top="347" left="349" width="92" height="17" font="8">User Memory</text>
<text top="200" left="373" width="85" height="17" font="8">Kernel Code</text>
<text top="263" left="374" width="37" height="17" font="8">Heap</text>
<text top="439" left="564" width="113" height="17" font="8">Page Directories</text>
<text top="376" left="564" width="154" height="17" font="8">Communication Pages</text>
<text top="317" left="564" width="103" height="17" font="8">User Mappings</text>
<text top="169" left="517" width="131" height="17" font="8">OS Implementation</text>
<text top="202" left="518" width="120" height="17" font="8">H Implementation</text>
<text top="231" left="517" width="31" height="17" font="8">RTS</text>
<text top="264" left="459" width="150" height="17" font="8">Kernel data structures</text>
<text top="407" left="564" width="86" height="17" font="8">Page Tables</text>
<text top="338" left="735" width="36" height="13" font="2">normal</text>
<text top="352" left="737" width="32" height="13" font="2">pages</text>
<text top="212" left="671" width="65" height="13" font="2">environment</text>
<text top="226" left="687" width="32" height="13" font="2">pages</text>
<text top="405" left="695" width="86" height="13" font="2">page-table page</text>
<text top="433" left="696" width="76" height="13" font="2">page-directory</text>
<text top="447" left="721" width="26" height="13" font="2">page</text>
<text top="500" left="188" width="595" height="16" font="0">Figure 4.4: During the bootstrapping process, H reserves a portion of phys-</text>
<text top="535" left="188" width="595" height="16" font="0">ical memory for the kernel’s execution environment. The remaining memory</text>
<text top="569" left="188" width="595" height="16" font="0">becomes available to the client for use as page-tables, page-directories, user</text>
<text top="604" left="188" width="595" height="16" font="0">memory, and communication pages for sharing information between the kernel</text>
<text top="639" left="188" width="146" height="16" font="0">and user processes.</text>
<text top="695" left="173" width="626" height="16" font="0">I/O device information using physical regions, rather than an complete implemen-</text>
<text top="728" left="173" width="626" height="16" font="0">tation. Other kinds of memory-mapped I/O could easily be supported by extending</text>
<text top="762" left="173" width="463" height="15" font="0">IOType and adding the appropriate conﬁguration code in H.</text>
<text top="804" left="190" width="189" height="14" font="7">data IOType = VideoRAM</text>
<text top="830" left="293" width="301" height="14" font="7">| FrameBuffer (Addr Physical) HWord</text>
<text top="875" left="173" width="626" height="16" font="0">The arguments to the frame buﬀer constructor describe the location and size of</text>
<text top="908" left="173" width="626" height="16" font="0">the buﬀer. We store this information so that a client can obtain precise informa-</text>
<text top="940" left="173" width="626" height="16" font="0">tion about the frame buﬀer location, which may not have a valid region size or</text>
<text top="988" left="173" width="626" height="13" font="4">devices without speciﬁc knowledge about the target hardware [3]. We expose the frame buﬀer to</text>
<text top="1017" left="173" width="613" height="13" font="4">support client-level graphics drivers, but this functionality is not used in existing clients of H.</text>
</page>
<page number="87" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">65</text>
<text top="163" left="173" width="626" height="16" font="0">alignment. There may be additional VBE graphics information that a client imple-</text>
<text top="195" left="173" width="626" height="16" font="0">menting VBE graphics will need from from the bootloader; any such information</text>
<text top="228" left="173" width="248" height="16" font="0">can easily be added if necessary.</text>
<text top="260" left="199" width="600" height="16" font="0">Now that we have introduced the types for describing address ranges and phys-</text>
<text top="293" left="173" width="626" height="16" font="0">ical memory types, we can examine the implementation of the memory handle type</text>
<text top="325" left="173" width="626" height="16" font="0">presented in Section 4.2. A PhysicalRegion is a record with two ﬁelds: a physical</text>
<text top="358" left="173" width="579" height="16" font="0">ﬂexpage representing the area described by the handle and a memory type.</text>
<text top="402" left="181" width="326" height="14" font="7">data PhysicalRegion = PhysicalRegion {</text>
<text top="428" left="388" width="52" height="14" font="7">region</text>
<text top="428" left="456" width="155" height="14" font="7">:: Fpage Physical,</text>
<text top="455" left="388" width="198" height="14" font="7">memType :: PhysicalType</text>
<text top="481" left="370" width="9" height="14" font="7">}</text>
<text top="526" left="173" width="626" height="16" font="0">Clients of the interface can examine the contents of physical regions—such as</text>
<text top="558" left="173" width="516" height="16" font="0">their size and type—but cannot create new values of the type.</text>
<text top="558" left="707" width="92" height="16" font="0">Recall from</text>
<text top="591" left="173" width="626" height="16" font="0">Section 4.2 that clients access regions through a combination of two primitives:</text>
<text top="625" left="173" width="630" height="15" font="0">initialRegions discovers the available memory on the machine and deriveRegion</text>
<text top="656" left="173" width="326" height="16" font="0">creates sub-regions of those initial regions.</text>
<text top="700" left="181" width="120" height="14" font="7">initialRegions</text>
<text top="700" left="319" width="180" height="14" font="7">:: H [PhysicalRegion]</text>
<text top="726" left="181" width="619" height="14" font="7">deriveRegion :: PhysicalRegion -&gt; Fpage Physical -&gt; Maybe PhysicalRegion</text>
<text top="771" left="173" width="626" height="16" font="0">We will cover the process of dividing physical memory into environment pages and</text>
<text top="804" left="173" width="626" height="16" font="0">the other categories in detail in Section 6.3. For now, it is suﬃcient to understand</text>
<text top="836" left="173" width="626" height="16" font="0">that H reserves a portion of physical memory that should not be accessed by the</text>
<text top="869" left="173" width="626" height="16" font="0">client and that it creates PhysicalRegion handles to all of the areas of memory</text>
<text top="901" left="173" width="247" height="16" font="0">that the client is allowed to use.</text>
<text top="934" left="199" width="600" height="16" font="0">The following rules describe the relationship between an existing region and a</text>
<text top="966" left="173" width="626" height="16" font="0">new region produced by deriveRegion. Assuming that the existing region starts</text>
<text top="999" left="173" width="626" height="16" font="0">at physical address, start , and has a size, logsize, a deriveRegion request will</text>
<text top="1031" left="173" width="626" height="16" font="0">produce a valid sub-region of the original when the following properties are true</text>
</page>
<page number="88" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">66</text>
<text top="163" left="173" width="446" height="16" font="0">of the new start address, new start , and size, new logsize:</text>
<text top="207" left="343" width="175" height="16" font="0">new logsize ≥ pageSize</text>
<text top="244" left="343" width="160" height="16" font="0">new logsize ≤ logsize</text>
<text top="280" left="356" width="134" height="16" font="0">new start ≥ start</text>
<text top="317" left="261" width="105" height="16" font="0">new start + 2</text>
<text top="314" left="366" width="63" height="11" font="2">new logsize</text>
<text top="316" left="436" width="86" height="17" font="0">≤ start + 2</text>
<text top="314" left="522" width="35" height="11" font="2">logsize</text>
<text top="354" left="220" width="140" height="16" font="0">new start mod (2</text>
<text top="351" left="360" width="63" height="11" font="2">new logsize</text>
<text top="354" left="424" width="39" height="16" font="0">) = 0</text>
<text top="394" left="173" width="626" height="16" font="0">If these restrictions are met, then deriveRegion returns a new region based at</text>
<text top="427" left="173" width="626" height="16" font="0">new start (start + oﬀ ) with size new logsize. Otherwise, the function returns</text>
<text top="461" left="173" width="520" height="15" font="0">Nothing to indicate that the requested region could not be created.</text>
<text top="519" left="173" width="41" height="16" font="0">4.3.2</text>
<text top="519" left="234" width="175" height="16" font="0">User-Code Modules</text>
<text top="563" left="173" width="626" height="16" font="0">The H interface provides limited support for managing the code and data placed</text>
<text top="595" left="173" width="626" height="16" font="0">in memory by the bootloader. Currently, we only expose information about exe-</text>
<text top="628" left="173" width="626" height="16" font="0">cutable multiboot modules to clients, but the design could be expanded to incorpo-</text>
<text top="660" left="173" width="626" height="16" font="0">rate the rest of the multiboot standard. Executable modules have been suﬃcient</text>
<text top="693" left="173" width="580" height="16" font="0">for running user-space programs in our L4 implementation (see Chapter 7).</text>
<text top="725" left="199" width="600" height="16" font="0">There are two key pieces of information in an executable multiboot module: the</text>
<text top="758" left="173" width="626" height="16" font="0">entry point to the module and a description of the memory that it occupies. The</text>
<text top="790" left="173" width="626" height="16" font="0">entry point is simply a word that contains the starting address of the program. The</text>
<text top="823" left="173" width="623" height="16" font="0">memory that is used by a module is described by a collection of physical regions.</text>
<text top="865" left="173" width="189" height="14" font="7">data Module = Module {</text>
<text top="891" left="310" width="60" height="14" font="7">modArea</text>
<text top="891" left="388" width="172" height="14" font="7">:: [PhysicalRegion],</text>
<text top="918" left="310" width="146" height="14" font="7">modEntry :: HWord</text>
<text top="944" left="293" width="9" height="14" font="7">}</text>
<text top="987" left="173" width="626" height="16" font="0">As with physical regions, the client can examine the contents of an executable</text>
<text top="1020" left="173" width="443" height="16" font="0">module, but cannot construct new modules themselves.</text>
<text top="1020" left="632" width="168" height="16" font="0">We represent module</text>
<text top="1052" left="173" width="626" height="16" font="0">memory as a list of physical regions because the number of pages occupied by a</text>
</page>
<page number="89" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">67</text>
<text top="163" left="173" width="626" height="16" font="0">module may not ﬁt the region size requirements. Clients are allowed to map module</text>
<text top="195" left="173" width="626" height="16" font="0">memory to users, as with any memory described by a handle, but the physical</text>
<text top="228" left="173" width="626" height="16" font="0">regions that are associated with bootloader modules are not exported through the</text>
<text top="260" left="173" width="626" height="16" font="0">normal physical region interface (i.e., they are not contained in initialRegions).</text>
<text top="293" left="173" width="626" height="16" font="0">We choose to separate the memory in this way to ensure that the distinction</text>
<text top="325" left="173" width="626" height="16" font="0">between free memory and bootloader memory is clear to the client, even though</text>
<text top="358" left="173" width="543" height="16" font="0">the client could ultimately use both types of memory in the same way.</text>
<text top="390" left="199" width="600" height="16" font="0">The client discovers the modules loaded in the current run of the system using</text>
<text top="423" left="173" width="626" height="16" font="0">the modules command, which returns a module descriptor for every executable</text>
<text top="455" left="173" width="626" height="16" font="0">bootloader module except for the kernel. There would be a memory-safety violation</text>
<text top="488" left="173" width="626" height="16" font="0">if the client could access the kernel module, because then the client could overwrite</text>
<text top="520" left="173" width="251" height="16" font="0">its own code and the code for H.</text>
<text top="564" left="173" width="180" height="14" font="7">modules :: H [Module]</text>
<text top="609" left="173" width="499" height="16" font="0">There are no other operations for working with the Module type.</text>
<text top="671" left="173" width="26" height="16" font="0">4.4</text>
<text top="671" left="219" width="358" height="16" font="0">VIRTUAL-MEMORY MANAGEMENT</text>
<text top="721" left="173" width="626" height="16" font="0">Virtual-to-physical memory mappings are a key component of memory-safety be-</text>
<text top="754" left="173" width="626" height="16" font="0">cause they establish the views of memory accessible to user programs and the ker-</text>
<text top="786" left="173" width="626" height="16" font="0">nel. The presence of a memory mapping can be seen as permission to read, modify,</text>
<text top="819" left="173" width="626" height="16" font="0">or execute a particular page of memory. We enforce the desired separation between</text>
<text top="851" left="173" width="626" height="16" font="0">entities in the system—the execution environment, the kernel, and the users—by</text>
<text top="884" left="173" width="626" height="16" font="0">appropriately controlling these views. We rely on a combination of static, type-</text>
<text top="916" left="173" width="626" height="16" font="0">based arguments and dynamic checking to enforce the safe construction of memory</text>
<text top="949" left="173" width="626" height="16" font="0">mappings. We particularly focus on the safety of the virtual memory management</text>
<text top="981" left="173" width="626" height="16" font="0">operations: page-directory creation and deletion (Section 4.4.1); adding, modi-</text>
<text top="1014" left="173" width="626" height="16" font="0">fying, and removing user-visible mappings (Section 4.4.2); adding kernel-visible</text>
<text top="1046" left="173" width="626" height="16" font="0">mappings (Section 4.4.3); and reading/writing memory mapped in kernel space</text>
</page>
<page number="90" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">68</text>
<text top="163" left="173" width="116" height="16" font="0">(Section 4.4.3).</text>
<text top="195" left="199" width="600" height="16" font="0">In addition to safety, generality is an important goal of the virtual memory</text>
<text top="228" left="173" width="626" height="16" font="0">interface design. We hope to support user-level separation policies in client ker-</text>
<text top="260" left="173" width="626" height="16" font="0">nels [82, 66] by providing expressive memory management functions that do not</text>
<text top="293" left="173" width="626" height="16" font="0">include unnecessary policy of their own. A correct implementation of H will guar-</text>
<text top="325" left="173" width="626" height="16" font="0">antee that there is no accidental ﬂow between user programs—that is, no data</text>
<text top="358" left="173" width="626" height="16" font="0">movement through memory that the client has not explicitly enabled through a</text>
<text top="390" left="173" width="626" height="16" font="0">mapping operation—but not restrict intentional communication. For example,</text>
<text top="423" left="173" width="626" height="16" font="0">memory-safety requires that page-directories and page-tables are not mapped to</text>
<text top="455" left="173" width="626" height="16" font="0">users, but we do not impose any sharing policy on normal page sharing between</text>
<text top="488" left="173" width="626" height="16" font="0">user-level programs or a user and the kernel. Throughout the design, our goal is to</text>
<text top="520" left="173" width="626" height="16" font="0">supply mechanisms that do not preclude separation between user programs, rather</text>
<text top="553" left="173" width="262" height="16" font="0">than a policy that enforces it [68].</text>
<text top="613" left="173" width="41" height="16" font="0">4.4.1</text>
<text top="613" left="234" width="136" height="16" font="0">Address Spaces</text>
<text top="657" left="173" width="626" height="16" font="0">The virtual-address space of the machine is split into two components: user-space,</text>
<text top="689" left="173" width="626" height="16" font="0">which contains the mappings for user-level programs and data; and kernel-space,</text>
<text top="722" left="173" width="626" height="16" font="0">which contains the mappings for kernel code and data. We use the user/supervisor</text>
<text top="754" left="173" width="626" height="16" font="0">bit in page table and page directory entries, as described in Section 2.2, to ensure</text>
<text top="787" left="173" width="626" height="16" font="0">that memory in kernel-space is not accessible to user programs. Our implemen-</text>
<text top="819" left="173" width="626" height="16" font="0">tation places the boundary between kernel-space and user-space at 3 GB so that</text>
<text top="852" left="173" width="626" height="16" font="0">the kernel lives in high memory. The choice of boundary and kernel location is</text>
<text top="884" left="173" width="314" height="16" font="0">arbitrary, but consistent with Linux [61].</text>
<text top="917" left="199" width="600" height="16" font="0">Client kernels have total control over the user portion of the virtual address-</text>
<text top="949" left="173" width="626" height="16" font="0">space. H will never place mappings in that area except for those explicitly re-</text>
<text top="982" left="173" width="626" height="16" font="0">quested by the client. There are no restrictions on the virtual addresses that</text>
<text top="1014" left="173" width="626" height="16" font="0">can be mapped. Kernel-space is divided into two areas: one that H controls and</text>
<text top="1047" left="173" width="626" height="16" font="0">one that the client controls. H must own part of this address-space to protect</text>
</page>
<page number="91" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">69</text>
<text top="163" left="173" width="626" height="16" font="0">the kernel code, H code and data, and Haskell run-time system. The remain-</text>
<text top="195" left="173" width="520" height="16" font="0">der of the virtual address-space is managed by the client kernel.</text>
<text top="195" left="709" width="90" height="16" font="0">H identiﬁes</text>
<text top="228" left="173" width="626" height="16" font="0">the parts of kernel space that are available to the client through the constant</text>
<text top="262" left="173" width="282" height="15" font="0">kernelMappableVirtualAddresses.</text>
<text top="298" left="190" width="438" height="14" font="7">kernelMappableVirtualAddresses :: H [Fpage Virtual]</text>
<text top="337" left="173" width="626" height="16" font="0">We describe the kernel controlled addresses as a list of ﬂexpages describing the free</text>
<text top="370" left="173" width="346" height="16" font="0">virtual-address ranges within kernel memory.</text>
<text top="402" left="199" width="600" height="16" font="0">Clients manipulate the mappings of a user address-space by inserting and mod-</text>
<text top="435" left="173" width="626" height="16" font="0">ifying entries in the page-map data structure. H provides access to page-maps</text>
<text top="467" left="173" width="626" height="16" font="0">through a restricted set of operations, because page-map correctness is important</text>
<text top="500" left="173" width="626" height="16" font="0">for the safety of the system. If a client could construct arbitrary page-maps, then</text>
<text top="532" left="173" width="626" height="16" font="0">they could circumvent the protection mechanisms of H by corrupting H’s private</text>
<text top="565" left="173" width="626" height="16" font="0">data or the execution environment itself (essentially, the client could obtain full</text>
<text top="597" left="173" width="626" height="16" font="0">access to physical memory). We maintain the integrity of each page-map data</text>
<text top="630" left="173" width="626" height="16" font="0">structure by deﬁning a type called PageMap with a hidden representation. Clients</text>
<text top="662" left="173" width="626" height="16" font="0">must use the interface to allocate page-maps in a controlled and safe way. When</text>
<text top="695" left="173" width="626" height="16" font="0">allocating a page-map, H converts a free page of memory into a page-directory by</text>
<text top="727" left="173" width="626" height="16" font="0">setting its status to the page-directory value and installing mappings for the envi-</text>
<text top="760" left="173" width="626" height="16" font="0">ronment pages. If the argument to the conversion is not free, then the operation</text>
<text top="792" left="173" width="626" height="16" font="0">will not be safe. Once the page has been converted, the client may not use that</text>
<text top="825" left="173" width="626" height="16" font="0">page for any other purpose until the page-map is explicitly freed. We enforce this</text>
<text top="857" left="173" width="626" height="16" font="0">restriction by dynamically checking the status of pages the client tries to map: any</text>
<text top="890" left="173" width="405" height="16" font="0">with the page-directory status will not be mappable.</text>
<text top="922" left="199" width="341" height="16" font="0">Page-map creation happens in two stages.</text>
<text top="922" left="559" width="240" height="16" font="0">First the client turns a page-</text>
<text top="955" left="173" width="508" height="16" font="0">sized physical region into a new value called a page-map page.</text>
<text top="955" left="697" width="102" height="16" font="0">The function</text>
<text top="989" left="173" width="626" height="15" font="0">createPageMapPage validates the size of a region and, if the size is correct, cre-</text>
<text top="1020" left="173" width="519" height="16" font="0">ates an unforgeable PageMapPage handle containing that region.</text>
<text top="1020" left="711" width="88" height="16" font="0">Both page-</text>
<text top="1052" left="173" width="626" height="16" font="0">directories and page-tables are created from pages that have been pre-validated</text>
</page>
<page number="92" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">70</text>
<text top="163" left="173" width="626" height="16" font="0">with createPageMapPage. A PageMapPage also stores information about where</text>
<text top="195" left="173" width="626" height="16" font="0">the region should be mapped in the kernel virtual address space so that H may</text>
<text top="228" left="173" width="626" height="16" font="0">read and write to the page. The second parameter to createPageMapPage is the</text>
<text top="260" left="173" width="626" height="16" font="0">address where the client would like the page-map page to be mapped for H (which</text>
<text top="293" left="173" width="626" height="16" font="0">must lie in the kernel controlled portion of the address space); the full details of</text>
<text top="325" left="173" width="481" height="16" font="0">H’s access to page-map memory will be covered in Section 6.4.</text>
<text top="369" left="190" width="438" height="14" font="7">createPageMapPage :: PhysicalRegion -&gt; Addr Virtual</text>
<text top="396" left="207" width="206" height="14" font="7">-&gt; H (Maybe PageMapPage)</text>
<text top="441" left="173" width="626" height="16" font="0">If the parameters pass the validity checks, then createPageMapPage returns a</text>
<text top="473" left="173" width="626" height="16" font="0">page-map page that can be passed as an argument to the page-map creation func-</text>
<text top="506" left="173" width="626" height="16" font="0">tion or supplied for H to use as a page-table (the H implementation allocates</text>
<text top="538" left="173" width="626" height="16" font="0">page-tables on demand in the mapping functions using client-supplied memory</text>
<text top="571" left="173" width="417" height="16" font="0">pages, we will cover these operations in Section 4.4.2).</text>
<text top="614" left="190" width="412" height="14" font="7">allocPageMap :: PageMapPage -&gt; H (Maybe PageMap)</text>
<text top="659" left="173" width="626" height="16" font="0">Page-map allocation creates an empty page-directory (with the page-directory sta-</text>
<text top="692" left="173" width="626" height="16" font="0">tus) that only contains the mappings for the environment pages. Before creating</text>
<text top="724" left="173" width="626" height="16" font="0">the page-directory, allocPageMap will check if the page is free; this is a necessary</text>
<text top="757" left="173" width="626" height="16" font="0">condition for safely creating a new page-directory. As a side eﬀect, allocPageMap</text>
<text top="789" left="173" width="626" height="16" font="0">will install an H-accessible mapping for the page-directory at the kernel virtual</text>
<text top="822" left="173" width="294" height="16" font="0">address speciﬁed by the PageMapPage.</text>
<text top="854" left="199" width="600" height="16" font="0">The client frees a page-map with the analogous function, freePageMap. The</text>
<text top="887" left="173" width="626" height="16" font="0">result of freePageMap is a handle describing the memory previously occupied by</text>
<text top="920" left="173" width="626" height="16" font="0">the page-directory and the memory for any page-tables that become free as a result</text>
<text top="952" left="173" width="626" height="16" font="0">of the operation. These newly freed pages are returned as a PhysicalRegion list</text>
<text top="985" left="173" width="224" height="16" font="0">for reuse by the client kernel.</text>
<text top="1028" left="190" width="378" height="14" font="7">freePageMap :: PageMap -&gt; H [PhysicalRegion]</text>
</page>
<page number="93" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">71</text>
<text top="163" left="173" width="626" height="16" font="0">Our implementation of H allows the current page-map to be freed by switching</text>
<text top="195" left="173" width="626" height="16" font="0">to a default system page-map that only contains mappings for the environment</text>
<text top="228" left="173" width="626" height="16" font="0">pages. A version of freePageMap that does not allow the current page-map to be</text>
<text top="260" left="173" width="626" height="16" font="0">freed would also be a reasonable implementation choice, but would require a slight</text>
<text top="293" left="173" width="436" height="16" font="0">adjustment to the type of the operation to signal failure.</text>
<text top="325" left="199" width="600" height="16" font="0">Page-map management illustrates an important aspect of the H design: the</text>
<text top="358" left="173" width="626" height="16" font="0">combination of static, type-based safety guarantees with run-time checks. There</text>
<text top="390" left="173" width="626" height="16" font="0">are some properties that we can enforce entirely statically using Haskell datatypes.</text>
<text top="423" left="173" width="626" height="16" font="0">For example, our implementation can rely on the fact that a PageMapPage cor-</text>
<text top="455" left="173" width="626" height="16" font="0">responds to a single page of memory because the only function for creating a</text>
<text top="489" left="173" width="626" height="15" font="0">PageMapPage checks that. Other properties are best enforced through a combina-</text>
<text top="520" left="173" width="626" height="16" font="0">tion of static and dynamic checks. Through the implementation of allocPageMap,</text>
<text top="553" left="173" width="626" height="16" font="0">we can be sure that every page with the page-directory status is mapped to an</text>
<text top="585" left="173" width="626" height="16" font="0">address that H can read and write. We also know that H makes every such page</text>
<text top="618" left="173" width="626" height="16" font="0">accessible through a PageMap handle. But even though the client cannot con-</text>
<text top="650" left="173" width="626" height="16" font="0">struct PageMap values—except through allocPageMap—we cannot be sure that</text>
<text top="683" left="173" width="626" height="16" font="0">every PageMap has the page-directory status. This asymmetry stems from the</text>
<text top="715" left="173" width="626" height="16" font="0">fact that H clients can free PageMap values but H cannot reclaim the handles be-</text>
<text top="748" left="173" width="626" height="16" font="0">cause they are just values that clients may hold onto even after the corresponding</text>
<text top="780" left="173" width="626" height="16" font="0">page-directory has been freed. Thus, the H implementation must combine the</text>
<text top="813" left="173" width="626" height="16" font="0">static information from types with dynamic status validity checks to be sure that</text>
<text top="847" left="173" width="626" height="15" font="0">PageMap operations are safe. More details about the implementation techniques</text>
<text top="878" left="173" width="491" height="16" font="0">used to guarantee safety will be covered in Sections 6.4 and 6.5.</text>
<text top="938" left="173" width="41" height="16" font="0">4.4.2</text>
<text top="938" left="234" width="122" height="16" font="0">User Memory</text>
<text top="982" left="173" width="626" height="16" font="0">Each page-map structure has an independent set of mappings in the user portion of</text>
<text top="1014" left="173" width="626" height="16" font="0">the virtual address-space that control which memory is accessible to user processes.</text>
<text top="1047" left="173" width="626" height="16" font="0">The same physical memory may be mapped in the user area of many page-maps if</text>
</page>
<page number="94" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">72</text>
<text top="163" left="173" width="626" height="16" font="0">so desired. The client modiﬁes these mappings indirectly using the operations of H.</text>
<text top="195" left="173" width="626" height="16" font="0">There are three essential operations available to the client: adding a new mapping</text>
<text top="228" left="173" width="626" height="16" font="0">to a contiguous block of physical memory, modifying the read/write permissions</text>
<text top="260" left="173" width="626" height="16" font="0">on an existing mapping, and removing a mapping. Each of the mapping functions</text>
<text top="293" left="173" width="388" height="16" font="0">operate on a single previously allocated page-map.</text>
<text top="325" left="199" width="600" height="16" font="0">As with the creation of PageMap objects, the client explicitly manages any</text>
<text top="358" left="173" width="626" height="16" font="0">additional memory that H requires for page-map storage. For example, with a</text>
<text top="390" left="173" width="626" height="16" font="0">two-level page-map, the function for adding a mapping might allocate a page-table</text>
<text top="423" left="173" width="626" height="16" font="0">page in which to store the mapping. When the client removes mappings from a</text>
<text top="455" left="173" width="626" height="16" font="0">page-map, the memory that stored those mappings will be freed and returned to</text>
<text top="488" left="173" width="626" height="16" font="0">the client if the pages are no longer needed for other mappings. H never retains</text>
<text top="520" left="173" width="290" height="16" font="0">control of any page that is not in use.</text>
<text top="553" left="199" width="600" height="16" font="0">The addMapping operation adds mappings from a range of virtual addresses</text>
<text top="585" left="173" width="626" height="16" font="0">(expressed as a ﬂexpage) to a block of physical memory of the same size. By using</text>
<text top="618" left="173" width="626" height="16" font="0">a PhysicalRegion value, we guarantee that the physical memory is safe for the</text>
<text top="650" left="173" width="243" height="16" font="0">client to map to user programs.</text>
<text top="691" left="190" width="473" height="14" font="7">addMapping :: [PageMapPage] -&gt; PageMap -&gt; Fpage Virtual</text>
<text top="718" left="327" width="378" height="14" font="7">-&gt; PhysicalRegion -&gt; Perms -&gt; H (Maybe Bool)</text>
<text top="760" left="173" width="626" height="16" font="0">The additional arguments expose some of the complexity of addMapping that we</text>
<text top="792" left="173" width="626" height="16" font="0">skirted over in its initial introduction in Section 4.2. The Perms argument spec-</text>
<text top="825" left="173" width="626" height="16" font="0">iﬁes the access rights to attach to the mapping. These permissions control the</text>
<text top="857" left="173" width="626" height="16" font="0">read/write/execute permission on the mapping, but not the user/supervisor set-</text>
<text top="890" left="173" width="626" height="16" font="0">ting because all mappings added through addMapping must be in user-space. The</text>
<text top="924" left="173" width="626" height="15" font="0">PageMap argument indicates the address-space where the mapping should be added.</text>
<text top="955" left="173" width="626" height="16" font="0">The list of PageMapPages is a supply of pre-validated memory pages that the client</text>
<text top="987" left="173" width="626" height="16" font="0">provides to H for page-table storage. In the current implementation of H, we al-</text>
<text top="1020" left="173" width="626" height="16" font="0">ways use zero or one of these pages. A Just result indicates success of the mapping</text>
<text top="1052" left="173" width="626" height="16" font="0">operation; the Boolean component indicates whether or not a PageMapPage was</text>
</page>
<page number="95" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">73</text>
<text top="163" left="173" width="626" height="16" font="0">needed. For implementations that potentially use more than one PageMapPage,</text>
<text top="195" left="173" width="626" height="16" font="0">the Boolean result may not be a good ﬁt; a natural number indicating the number</text>
<text top="228" left="173" width="399" height="16" font="0">of page-tables allocated would be more appropriate.</text>
<text top="260" left="199" width="600" height="16" font="0">The modifyMapping function changes the permissions attached to an existing</text>
<text top="293" left="173" width="71" height="16" font="0">mapping.</text>
<text top="293" left="260" width="539" height="16" font="0">As such, modifyMapping will never need to allocate new page-map</text>
<text top="325" left="173" width="626" height="16" font="0">storage; it works with the structures that are already there. The arguments to</text>
<text top="359" left="173" width="626" height="15" font="0">modifyMapping, in order, are the page-map to modify, the virtual ﬂexpage of the</text>
<text top="390" left="173" width="626" height="16" font="0">mapping to be modiﬁed, and the new permissions to attach to the mapping. The</text>
<text top="423" left="173" width="599" height="16" font="0">result of modifyMapping indicates whether or not the modiﬁcation succeeded.</text>
<text top="467" left="190" width="515" height="14" font="7">modifyMapping :: PageMap -&gt; Fpage Virtual -&gt; Perms -&gt; H Bool</text>
<text top="512" left="173" width="626" height="16" font="0">If the virtual ﬂexpage does not correspond to an existing mapping (either the</text>
<text top="544" left="173" width="626" height="16" font="0">ﬂexpage overlaps with the kernel portion of the virtual address-space or the ﬂex-</text>
<text top="577" left="173" width="626" height="16" font="0">page corresponds to memory that is not mapped in the speciﬁed page-map), then</text>
<text top="609" left="173" width="626" height="16" font="0">the function does not change the page-map. We do not allow the client to set</text>
<text top="642" left="173" width="626" height="16" font="0">the permissions of a mapping to nothing using this function—for that they must</text>
<text top="674" left="173" width="626" height="16" font="0">use removeMapping. Attempting to do so causes modifyMapping to return False</text>
<text top="707" left="173" width="356" height="16" font="0">without making any changes to the page-map.</text>
<text top="739" left="199" width="600" height="16" font="0">The ﬁnal operation on mappings is deletion. The function removeMapping</text>
<text top="772" left="173" width="626" height="16" font="0">deletes the mapping that corresponds to a particular virtual ﬂexpage. The argu-</text>
<text top="804" left="173" width="626" height="16" font="0">ments to the function are the page-map to modify and the ﬂexpage of the mapping</text>
<text top="837" left="173" width="606" height="16" font="0">to be removed. The result is the list of pages that were freed by the operation.</text>
<text top="881" left="190" width="610" height="14" font="7">removeMapping :: PageMap -&gt; Fpage Virtual -&gt; H (Maybe [PhysicalRegion])</text>
<text top="926" left="173" width="626" height="16" font="0">The operation behaves optimistically and modiﬁes any portion of the provided</text>
<text top="958" left="173" width="626" height="16" font="0">ﬂexpage that it can (even if some portion of the ﬂexpage is not mapped in the</text>
<text top="991" left="173" width="626" height="16" font="0">speciﬁed address space). The areas of memory that get modiﬁed by the operation</text>
<text top="1023" left="173" width="283" height="16" font="0">will always be ﬂexpage-sized regions.</text>
</page>
<page number="96" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">74</text>
<text top="163" left="199" width="600" height="16" font="0">The client may also read information about a user mapping that is already</text>
<text top="195" left="173" width="626" height="16" font="0">present in a page-map, for example, whether or not a particular page is mapped,</text>
<text top="228" left="173" width="626" height="16" font="0">and what the usage information is for a mapped page (whether the page has been</text>
<text top="260" left="173" width="626" height="16" font="0">read or written). We represent page-map entry information with values of the type</text>
<text top="294" left="173" width="626" height="15" font="0">MappingInfo. The client reads the mapping information for a particular page of</text>
<text top="325" left="173" width="376" height="16" font="0">virtual memory using the function readMapping.</text>
<text top="369" left="190" width="541" height="14" font="7">readMapping :: PageMap -&gt; Addr Virtual -&gt; H (Maybe MappingInfo)</text>
<text top="414" left="173" width="626" height="16" font="0">The ﬁrst argument is the page-map to examine and the second argument is a virtual</text>
<text top="447" left="173" width="626" height="16" font="0">address in the page of interest. H aligns the virtual address argument to a page-</text>
<text top="479" left="173" width="626" height="16" font="0">boundary, rounding down if necessary, and ﬁnds the information for that virtual</text>
<text top="512" left="173" width="626" height="16" font="0">address by consulting the page-directory and page-table bits. If the page is not</text>
<text top="544" left="173" width="626" height="16" font="0">mapped, then readMapping returns Nothing. Otherwise, the function returns a</text>
<text top="578" left="173" width="626" height="15" font="0">MappingInfo object that the client can examine using accessor functions provided</text>
<text top="609" left="173" width="42" height="16" font="0">by H.</text>
<text top="653" left="190" width="369" height="14" font="7">mappingAddr :: MappingInfo -&gt; Addr Physical</text>
<text top="679" left="190" width="69" height="14" font="7">accessed</text>
<text top="679" left="293" width="189" height="14" font="7">:: MappingInfo -&gt; Bool</text>
<text top="706" left="190" width="43" height="14" font="7">dirty</text>
<text top="706" left="293" width="189" height="14" font="7">:: MappingInfo -&gt; Bool</text>
<text top="751" left="173" width="626" height="16" font="0">The mappingAddr function returns the physical address that the virtual page of</text>
<text top="783" left="173" width="626" height="16" font="0">interest is mapped to. The client can also check whether or not the page has been</text>
<text top="816" left="173" width="626" height="16" font="0">read with the accessed function, and whether or not the page has been written</text>
<text top="848" left="173" width="190" height="16" font="0">with the dirty function.</text>
<text top="908" left="173" width="41" height="16" font="0">4.4.3</text>
<text top="908" left="234" width="140" height="16" font="0">Kernel Memory</text>
<text top="952" left="173" width="626" height="16" font="0">H supports the ability to add kernel mappings that are visible in every virtual</text>
<text top="985" left="173" width="626" height="16" font="0">address-space. The only constraint is that the mappings lie in the portion of</text>
<text top="1017" left="173" width="626" height="16" font="0">kernel-space not in use by H. Any memory that may be mapped to users may</text>
<text top="1050" left="173" width="626" height="16" font="0">be mapped into kernel space. We call these mappings client kernel mappings to</text>
</page>
<page number="97" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">75</text>
<text top="163" left="173" width="626" height="16" font="0">distinguish them from the H mappings that we use internally for page-map pages.</text>
<text top="195" left="173" width="626" height="16" font="0">The client manages the addresses where page-map pages are mapped, but, for</text>
<text top="228" left="173" width="585" height="16" font="0">safety reasons, cannot control the actual mapping operations on such pages.</text>
<text top="260" left="199" width="600" height="16" font="0">When the client adds a client kernel mapping, H returns a handle through</text>
<text top="293" left="173" width="626" height="16" font="0">which the client can read and write the mapped memory. We represent handles</text>
<text top="325" left="173" width="626" height="16" font="0">with the type KernelMapping, which is partially abstract. A KernelMapping con-</text>
<text top="358" left="173" width="626" height="16" font="0">tains a virtual ﬂexpage describing the mapped region, a physical region describing</text>
<text top="390" left="173" width="626" height="16" font="0">the underlying memory, and a set of read/write permissions. Clients may access</text>
<text top="423" left="173" width="626" height="16" font="0">these components of a KernelMapping but cannot construct a mapping handle</text>
<text top="455" left="173" width="87" height="16" font="0">themselves.</text>
<text top="488" left="199" width="600" height="16" font="0">We use kernel region handles to ensure that the client only accesses memory</text>
<text top="520" left="173" width="626" height="16" font="0">that has been mapped. Without this requirement, the client might try to access</text>
<text top="553" left="173" width="626" height="16" font="0">protected memory (the type of the mapping function guards against such behavior)</text>
<text top="585" left="173" width="626" height="16" font="0">or the client might request a memory access that causes H to page fault. We choose</text>
<text top="618" left="173" width="626" height="16" font="0">to prevent kernel faults through checking whenever possible. The lack of page faults</text>
<text top="650" left="173" width="400" height="16" font="0">in H makes memory errors easier to ﬁnd and debug.</text>
<text top="683" left="199" width="600" height="16" font="0">Handles alone, however, are not enough to prevent page faults; it is also impor-</text>
<text top="715" left="173" width="626" height="16" font="0">tant to guarantee that kernel mappings are accessed with valid permissions. We</text>
<text top="748" left="173" width="626" height="16" font="0">take the approach that the client can control the permissions attached to kernel</text>
<text top="780" left="173" width="626" height="16" font="0">mappings, even though this requires extra checking in the implementation of the</text>
<text top="813" left="173" width="626" height="16" font="0">write operations. A simpler (and potentially more eﬃcient) approach would be to</text>
<text top="845" left="173" width="626" height="16" font="0">force all kernel mappings to have read/write permissions so that faults can never</text>
<text top="878" left="173" width="46" height="16" font="0">occur.</text>
<text top="910" left="199" width="600" height="16" font="0">Initially, there are no client-accessible mappings in the kernel memory area.</text>
<text top="943" left="173" width="626" height="16" font="0">A client inserts mappings into this region by calling addKernelMapping with the</text>
<text top="975" left="173" width="626" height="16" font="0">physical region to map to the kernel, the location in virtual memory at which to</text>
<text top="1008" left="173" width="626" height="16" font="0">add the mapping (as a virtual ﬂexpage), the permissions to attach to the mapping,</text>
<text top="1040" left="173" width="626" height="16" font="0">and a Boolean value that indicates whether or not the new mapping should be user</text>
</page>
<page number="98" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">76</text>
<text top="163" left="173" width="78" height="16" font="0">accessible.</text>
<text top="205" left="190" width="515" height="14" font="7">addKernelMapping :: PhysicalRegion -&gt; Fpage Virtual -&gt; Perms</text>
<text top="231" left="379" width="292" height="14" font="7">-&gt; Bool -&gt; H (Maybe KernelMapping)</text>
<text top="275" left="173" width="626" height="16" font="0">A mapping cannot be added if the requested location for the mapping is not</text>
<text top="307" left="173" width="626" height="16" font="0">fully contained in the available portion of the kernel address-space or if the target</text>
<text top="340" left="173" width="231" height="16" font="0">memory is not a normal page.</text>
<text top="372" left="199" width="600" height="16" font="0">The client accesses kernel mappings through interface read and write functions</text>
<text top="405" left="173" width="626" height="16" font="0">called readKernelMapping and writeKernelMapping. These operations are sim-</text>
<text top="437" left="173" width="626" height="16" font="0">ilar to the standard peek and poke functions in the IO monad except that they</text>
<text top="470" left="173" width="626" height="16" font="0">are guaranteed to preserve memory-safety. The ﬁrst argument to both functions is</text>
<text top="502" left="173" width="626" height="16" font="0">the kernel mapping to access. The second argument is a word oﬀset that speciﬁes</text>
<text top="535" left="173" width="626" height="16" font="0">where in the mapping to read or write. The read function returns the word that</text>
<text top="567" left="173" width="626" height="16" font="0">lies at the requested oﬀset, and the write function requires an extra parameter</text>
<text top="600" left="173" width="312" height="16" font="0">containing the word to write to memory.</text>
<text top="642" left="190" width="146" height="14" font="7">readKernelMapping</text>
<text top="642" left="353" width="309" height="14" font="7">:: KernelMapping -&gt; HWord -&gt; H HWord</text>
<text top="668" left="190" width="541" height="14" font="7">writeKernelMapping :: KernelMapping -&gt; HWord -&gt; HWord -&gt; H Bool</text>
<text top="712" left="173" width="626" height="16" font="0">The oﬀset parameter is implicitly forced to lie within the region described by the</text>
<text top="744" left="173" width="626" height="16" font="0">speciﬁed kernel mapping. That is, old oﬀset mod mapping size. The write oper-</text>
<text top="777" left="173" width="625" height="16" font="0">ation may still fail because the permissions of the mapping may not be suﬃcient.</text>
<text top="809" left="199" width="600" height="16" font="0">We also provide specialized read and write operations for accessing page-sized</text>
<text top="842" left="173" width="626" height="16" font="0">kernel mappings (or the ﬁrst page of a larger region). The maximum oﬀset is</text>
<text top="874" left="173" width="626" height="16" font="0">a static constant that corresponds to the page size on the machine. We use a</text>
<text top="907" left="173" width="528" height="16" font="0">bounded type, Offset, to describe the restrictions on these accesses.</text>
<text top="949" left="190" width="249" height="14" font="7">newtype Offset = Offset HWord</text>
<text top="1002" left="190" width="249" height="14" font="7">instance Bounded Offset where</text>
<text top="1028" left="207" width="163" height="14" font="7">minBound = Offset 0</text>
<text top="1055" left="207" width="284" height="14" font="7">maxBound = Offset (pageWords - 1)</text>
</page>
<page number="99" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">77</text>
<text top="163" left="173" width="626" height="16" font="0">The specialized read and write functions behave similarly to the normal read and</text>
<text top="195" left="173" width="626" height="16" font="0">write functions, except that the oﬀset is constrained to lie in a single page. The</text>
<text top="228" left="173" width="626" height="16" font="0">expectation, borne out in the performance results of Chapter 8, is that the spe-</text>
<text top="260" left="173" width="626" height="16" font="0">cialized versions will be faster because the address validation is done relative to a</text>
<text top="293" left="173" width="626" height="16" font="0">compile-time constant, rather than a parameter that must be read from the kernel</text>
<text top="325" left="173" width="240" height="16" font="0">mapping structure at run-time.</text>
<text top="362" left="190" width="137" height="14" font="7">readWordAtOffset</text>
<text top="362" left="345" width="318" height="14" font="7">:: KernelMapping -&gt; Offset -&gt; H HWord</text>
<text top="388" left="190" width="541" height="14" font="7">writeWordAtOffset :: KernelMapping -&gt; Offset -&gt; HWord -&gt; H Bool</text>
<text top="425" left="173" width="626" height="16" font="0">These operations can be used on any kernel mapping regardless of its size, because</text>
<text top="458" left="173" width="626" height="16" font="0">we never create a kernel mapping that is smaller than a page, but only to access</text>
<text top="490" left="173" width="626" height="16" font="0">the ﬁrst page of data. Typically we only use the specialized functions on page-</text>
<text top="523" left="173" width="626" height="16" font="0">sized mappings, but avoiding a distinction between diﬀerent kernel mapping sizes</text>
<text top="555" left="173" width="384" height="16" font="0">prevents additional complications in the interface.</text>
<text top="616" left="173" width="26" height="16" font="0">4.5</text>
<text top="616" left="219" width="286" height="16" font="0">USER PROCESS EXECUTION</text>
<text top="666" left="173" width="626" height="16" font="0">H deﬁnes a minimal set of constructs in support of user-level execution. We avoid</text>
<text top="698" left="173" width="626" height="16" font="0">ﬁxing a speciﬁc notion of thread or process, and instead provide the basic building</text>
<text top="731" left="173" width="626" height="16" font="0">blocks necessary for managing such structures. In particular, we provide fault</text>
<text top="763" left="173" width="626" height="16" font="0">contexts (a mechanism for saving and accessing the register state of user programs)</text>
<text top="796" left="173" width="626" height="16" font="0">and interrupt/IRQ handling. With these low-level constructs, the client can deﬁne</text>
<text top="828" left="173" width="405" height="16" font="0">a variety of higher-level representations of user code.</text>
<text top="861" left="199" width="600" height="16" font="0">Our representation of register values is an abstraction of the register set on the</text>
<text top="893" left="173" width="605" height="16" font="0">underlying machine which we deﬁne as an algebraic datatype called Register.</text>
<text top="930" left="190" width="112" height="14" font="7">data Register</text>
<text top="956" left="207" width="576" height="14" font="7">= EDI | ESI | EBP | BogusESP | EBX | EDX | ECX | EAX | DS | ES | FS</text>
<text top="982" left="207" width="447" height="14" font="7">| GS | Handler | Code | EIP | CS | Eflags | ESP | SS</text>
<text top="1020" left="173" width="626" height="16" font="0">A fault context is a collection of the values contained in the registers when execu-</text>
<text top="1052" left="173" width="626" height="16" font="0">tion switches from user-mode to kernel-mode, along with some information that</text>
</page>
<page number="100" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">78</text>
<text top="163" left="173" width="626" height="16" font="0">describes the reason for the mode switch (the nature of the interrupt or IRQ).</text>
<text top="195" left="173" width="626" height="16" font="0">Typically the client only accesses the register values of the fault context because H</text>
<text top="228" left="173" width="626" height="16" font="0">packages up the interrupt or IRQ information in the Interrupt and IRQ datatypes.</text>
<text top="260" left="173" width="626" height="16" font="0">We omit the deﬁnition of these types here, but will discuss the details of their im-</text>
<text top="293" left="173" width="215" height="16" font="0">plementation in Section 6.8.</text>
<text top="325" left="199" width="600" height="16" font="0">We represent fault contexts using a handle type called FaultContext. The</text>
<text top="358" left="173" width="626" height="16" font="0">client explicitly allocates fault contexts for running user programs. The client</text>
<text top="390" left="173" width="626" height="16" font="0">kernel might use a single fault context to run many user programs (with the kernel</text>
<text top="423" left="173" width="626" height="16" font="0">managing the register values between runs) or the client might allocate a separate</text>
<text top="455" left="173" width="302" height="16" font="0">fault context for every user-level entity.</text>
<text top="499" left="190" width="301" height="14" font="7">allocFaultContext :: H FaultContext</text>
<text top="544" left="173" width="626" height="16" font="0">The client is not responsible for freeing the fault contexts that it creates: the</text>
<text top="577" left="173" width="555" height="16" font="0">Haskell garbage collector automatically reclaims the associated memory.</text>
<text top="609" left="199" width="600" height="16" font="0">The client accesses the information contained in any fault context register using</text>
<text top="643" left="173" width="626" height="15" font="0">readRegister and writeRegister. These functions access a particular register</text>
<text top="674" left="173" width="240" height="16" font="0">from a particular fault context.</text>
<text top="718" left="190" width="438" height="14" font="7">readRegister :: FaultContext -&gt; Register -&gt; H HWord</text>
<text top="744" left="190" width="498" height="14" font="7">writeRegister :: FaultContext -&gt; Register -&gt; HWord -&gt; H ()</text>
<text top="789" left="173" width="411" height="16" font="0">The register read and write functions always succeed.</text>
<text top="822" left="199" width="579" height="16" font="0">H provides a single function for jumping to user-level code, called execute.</text>
<text top="866" left="190" width="421" height="14" font="7">execute :: PageMap -&gt; FaultContext -&gt; H Interrupt</text>
<text top="911" left="173" width="626" height="16" font="0">The inspiration for this function comes from the execContext primitive in the</text>
<text top="943" left="173" width="626" height="16" font="0">original H interface [39]. We reuse many of the implementation techniques from</text>
<text top="976" left="173" width="626" height="16" font="0">that implementation, with some minor adjustments, particularly to the way fault</text>
<text top="1008" left="173" width="626" height="16" font="0">contexts are handled . The client speciﬁes the page-map to install prior to execu-</text>
<text top="1041" left="173" width="626" height="16" font="0">tion (which controls the memory that will be accessible) and the fault context to</text>
</page>
<page number="101" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">79</text>
<text top="163" left="173" width="626" height="16" font="0">restore (which determines the starting state of the code). H sets up the machine</text>
<text top="195" left="173" width="626" height="16" font="0">state according to these parameters and then switches the machine into user mode.</text>
<text top="228" left="173" width="626" height="16" font="0">The user code begins executing at the instruction pointer stored in the fault con-</text>
<text top="260" left="173" width="626" height="16" font="0">text parameter and continues running until control returns to the kernel through</text>
<text top="293" left="173" width="626" height="16" font="0">an interrupt, fault, or IRQ (recall the process through which mode switches occur</text>
<text top="325" left="173" width="626" height="16" font="0">that we described in Chapter 2). User-process execution is guaranteed to termi-</text>
<text top="358" left="173" width="626" height="16" font="0">nate because H sets up a timer that will eventually interrupt the user program and</text>
<text top="390" left="173" width="211" height="16" font="0">return control to the client.</text>
<text top="423" left="199" width="600" height="16" font="0">When control returns to kernel-mode, H packages up the interrupt information</text>
<text top="455" left="173" width="626" height="16" font="0">and returns that information to the client kernel. The interrupt format is speciﬁc</text>
<text top="488" left="173" width="626" height="16" font="0">to the interrupts that may occur on the underlying hardware platform and is</text>
<text top="520" left="173" width="626" height="16" font="0">deﬁned as a datatype with one constructor per type of interrupt. Some interrupts</text>
<text top="553" left="173" width="626" height="16" font="0">carry extra information, for example, an IRQ contains the number of the IRQ that</text>
<text top="585" left="173" width="626" height="16" font="0">occurred (described by the IRQ type) and a page fault carries information about</text>
<text top="618" left="173" width="392" height="16" font="0">the nature of the fault (the PageFaultErrorCode).</text>
<text top="650" left="199" width="600" height="16" font="0">Interrupts and faults fall under the domain of H, but I/O interrupts are man-</text>
<text top="683" left="173" width="626" height="16" font="0">aged by the client kernel. We supply functions for individually enabling, disabling,</text>
<text top="715" left="173" width="284" height="16" font="0">and acknowledging a particular IRQ:</text>
<text top="759" left="190" width="206" height="14" font="7">enableIRQ :: IRQ -&gt; H ()</text>
<text top="786" left="190" width="215" height="14" font="7">disableIRQ :: IRQ -&gt; H ()</text>
<text top="812" left="190" width="215" height="14" font="7">maskAckIRQ :: IRQ -&gt; H ()</text>
<text top="857" left="173" width="372" height="16" font="0">The IRQ management functions always succeed.</text>
<text top="890" left="199" width="600" height="16" font="0">Originally, the H interface design allowed the client kernel some control over</text>
<text top="922" left="173" width="626" height="16" font="0">interrupts and faults, namely, the ability to set whether or not interrupts occur in</text>
<text top="955" left="173" width="626" height="16" font="0">kernel-mode, using the functions enableInterrupts and disableInterrupts [39].</text>
<text top="998" left="190" width="137" height="14" font="7">enableInterrupts</text>
<text top="998" left="345" width="60" height="14" font="7">:: H ()</text>
<text top="1025" left="190" width="215" height="14" font="7">disableInterrupts :: H ()</text>
</page>
<page number="102" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">80</text>
<text top="163" left="173" width="626" height="16" font="0">Though we think that control over kernel interrupts is an important part of the</text>
<text top="195" left="173" width="626" height="16" font="0">API, our current implementation does not provide enough support for multi-</text>
<text top="228" left="173" width="626" height="16" font="0">threaded kernels to allow kernel interrupts. We believe that better multi-threaded</text>
<text top="260" left="173" width="634" height="16" font="0">support is possible by modifying our implementation to use multiple Haskell threads.</text>
<text top="293" left="173" width="626" height="16" font="0">The H API would require some extension to enable the client to install Haskell</text>
<text top="325" left="173" width="626" height="16" font="0">handlers for kernel interrupts. Then, the C-level interrupt handler could invoke</text>
<text top="358" left="173" width="626" height="16" font="0">the appropriate Haskell handler (in a new thread) when a kernel-mode interrupt</text>
<text top="390" left="173" width="626" height="16" font="0">occurs. These issues are an interesting topic for future work. Under the current</text>
<text top="423" left="173" width="626" height="16" font="0">scheme, clients with a short path through the kernel should not encounter issues.</text>
<text top="455" left="173" width="626" height="16" font="0">Other kernels will have to implement their own method for reducing the delay in</text>
<text top="488" left="173" width="153" height="16" font="0">handling interrupts.</text>
<text top="550" left="173" width="26" height="16" font="0">4.6</text>
<text top="550" left="219" width="165" height="16" font="0">INPUT/OUTPUT</text>
<text top="600" left="173" width="626" height="16" font="0">In this dissertation, we do not diverge signiﬁcantly from the input/output facilities</text>
<text top="632" left="173" width="626" height="16" font="0">of the original H design [39]. We support I/O port access by lifting the port opera-</text>
<text top="665" left="173" width="626" height="16" font="0">tions of the underlying architecture into Haskell. We also provide basic debugging</text>
<text top="697" left="173" width="334" height="16" font="0">facilities for use during kernel development.</text>
<text top="757" left="173" width="41" height="16" font="0">4.6.1</text>
<text top="757" left="234" width="47" height="16" font="0">Ports</text>
<text top="801" left="173" width="626" height="16" font="0">The client kernel accesses I/O ports through a direct lifting of the underlying</text>
<text top="834" left="173" width="626" height="16" font="0">assembly instructions for port access on the IA32. We do not consider safety</text>
<text top="866" left="173" width="626" height="16" font="0">issues concerning I/O ports in this work. If client kernels avoid using DMA, the</text>
<text top="899" left="173" width="626" height="16" font="0">port operations will not aﬀect the integrity of the memory structures of the kernel.</text>
<text top="931" left="173" width="626" height="16" font="0">In future designs it would be interesting to explore greater control over I/O ports</text>
<text top="964" left="173" width="533" height="16" font="0">through the interface, for example, the ability to control an IOMMU.</text>
<text top="996" left="199" width="600" height="16" font="0">Each port has a 16-bit port identiﬁcation number with a ﬁxed semantics on</text>
<text top="1029" left="173" width="626" height="16" font="0">the machine. We do not attach a semantics to port numbers, and simply represent</text>
</page>
<page number="103" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">81</text>
<text top="163" left="173" width="626" height="16" font="0">them using a type synonym for 16-bit words called Port. The client may read or</text>
<text top="195" left="173" width="340" height="16" font="0">write a byte, a short, or a word to any port.</text>
<text top="238" left="190" width="26" height="14" font="7">inB</text>
<text top="238" left="233" width="155" height="14" font="7">:: Port -&gt; H HByte</text>
<text top="265" left="190" width="26" height="14" font="7">inS</text>
<text top="265" left="233" width="163" height="14" font="7">:: Port -&gt; H HShort</text>
<text top="291" left="190" width="26" height="14" font="7">inW</text>
<text top="291" left="233" width="155" height="14" font="7">:: Port -&gt; H HWord</text>
<text top="318" left="190" width="180" height="14" font="7">outB :: Port -&gt; HByte</text>
<text top="318" left="388" width="60" height="14" font="7">-&gt; H ()</text>
<text top="344" left="190" width="258" height="14" font="7">outS :: Port -&gt; HShort -&gt; H ()</text>
<text top="371" left="190" width="180" height="14" font="7">outW :: Port -&gt; HWord</text>
<text top="371" left="388" width="60" height="14" font="7">-&gt; H ()</text>
<text top="415" left="173" width="244" height="16" font="0">The port operations do not fail.</text>
<text top="474" left="173" width="41" height="16" font="0">4.6.2</text>
<text top="474" left="234" width="94" height="16" font="0">Debugging</text>
<text top="519" left="173" width="626" height="16" font="0">H provides screen printing functionality for debugging purposes. Normally, clients</text>
<text top="551" left="173" width="626" height="16" font="0">will implement their own printing functions for user programs, but during client</text>
<text top="584" left="173" width="626" height="16" font="0">development it is very convenient to be able to print messages for testing and</text>
<text top="616" left="173" width="626" height="16" font="0">debugging. Any impure function, such as output, must be in the H monad, but</text>
<text top="649" left="173" width="528" height="16" font="0">we do not consider these functions to be a core part of the H design.</text>
<text top="681" left="199" width="600" height="16" font="0">Using a stripped down video driver written in C, the client can print a single</text>
<text top="714" left="173" width="626" height="16" font="0">character to the screen. We implement utility wrappers on this simple function for</text>
<text top="746" left="173" width="197" height="16" font="0">printing strings and lines.</text>
<text top="789" left="190" width="43" height="14" font="7">putch</text>
<text top="789" left="267" width="129" height="14" font="7">:: Char -&gt; H ()</text>
<text top="816" left="190" width="52" height="14" font="7">putstr</text>
<text top="816" left="267" width="146" height="14" font="7">:: String -&gt; H ()</text>
<text top="842" left="190" width="223" height="14" font="7">putstrln :: String -&gt; H ()</text>
<text top="886" left="173" width="626" height="16" font="0">The printing functions are memory-safe, but they might fault if the video RAM is</text>
<text top="919" left="173" width="626" height="16" font="0">not mapped in the current page-map. This is an exception to our usual philoso-</text>
<text top="951" left="173" width="626" height="16" font="0">phy that H operations should prevent faults whenever possible and it did lead to</text>
<text top="984" left="173" width="626" height="16" font="0">unexpected crashes during the early stages of developing H. An alternate imple-</text>
<text top="1016" left="173" width="626" height="16" font="0">mentation might use the serial port instead of the screen and avoid the issue of</text>
<text top="1049" left="173" width="150" height="16" font="0">page faults entirely.</text>
</page>
<page number="104" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">82</text>
<text top="236" left="447" width="77" height="16" font="0">Chapter 5</text>
<text top="287" left="218" width="535" height="16" font="0">FORMALIZING OPERATING SYSTEM MEMORY-SAFETY AS A</text>
<text top="319" left="342" width="288" height="16" font="0">NONINTERFERENCE PROPERTY</text>
<text top="412" left="173" width="626" height="16" font="0">A primary motivation for implementing operating systems using Haskell is that the</text>
<text top="444" left="173" width="626" height="16" font="0">language provides strong type- and memory-safety guarantees. From our choice of</text>
<text top="477" left="173" width="626" height="16" font="0">implementation language alone, we know that our client kernels do not contain null</text>
<text top="509" left="173" width="490" height="16" font="0">pointer dereferences, unsafe type casts, or any other safety errors</text>
<text top="507" left="663" width="6" height="11" font="2">1</text>
<text top="509" left="670" width="130" height="16" font="0">. The same type-</text>
<text top="542" left="173" width="626" height="16" font="0">and memory-safety guarantees do not hold for the operations of the H interface,</text>
<text top="574" left="173" width="626" height="16" font="0">because the H implementation uses potentially unsafe features of Haskell (such as</text>
<text top="607" left="173" width="626" height="16" font="0">pointers), and foreign calls to C. For this code, we must demonstrate safety, rather</text>
<text top="639" left="173" width="332" height="16" font="0">than relying on language-based guarantees.</text>
<text top="672" left="199" width="600" height="16" font="0">Unfortunately, deﬁning a memory-safety property for the H operations is not</text>
<text top="704" left="173" width="626" height="16" font="0">straightforward. In programming languages, safety typically refers to the absence</text>
<text top="737" left="173" width="626" height="16" font="0">of unchecked run-time errors with respect to the formal semantics of the language</text>
<text top="769" left="173" width="626" height="16" font="0">and memory-safety refers to the absence of a collection of memory-related run-time</text>
<text top="802" left="173" width="626" height="16" font="0">errors, such as a null-pointer dereference or a memory access outside the bounds of</text>
<text top="834" left="173" width="626" height="16" font="0">an array. If the operations of the H interface have been implemented correctly, then</text>
<text top="880" left="193" width="6" height="9" font="3">1</text>
<text top="882" left="200" width="600" height="13" font="4">The correctness of the Haskell compiler and the generated code is required for Haskell pro-</text>
<text top="911" left="173" width="626" height="13" font="4">grams to be type- and memory-safe. For the purposes of this dissertation, we assume the cor-</text>
<text top="939" left="173" width="626" height="13" font="4">rectness of the entire GHC implementation, including the compiler and run-time system. Like</text>
<text top="968" left="173" width="626" height="13" font="4">many large systems, the correctness of GHC has been established through testing and through</text>
<text top="997" left="173" width="626" height="13" font="4">a feedback loop between its large community of users and the developers. Ultimately, we would</text>
<text top="1026" left="173" width="626" height="13" font="4">like to implement H using a high-assurance run-time system, like the one that is currently under</text>
<text top="1054" left="173" width="458" height="13" font="4">development at Portland State University for the Habit language [73].</text>
</page>
<page number="105" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">83</text>
<text top="163" left="173" width="626" height="16" font="0">they should be memory-safe according to this colloquial deﬁnition, but this notion</text>
<text top="195" left="173" width="626" height="16" font="0">of memory-safety is not suﬃcient for our purposes. We want to guarantee that the</text>
<text top="228" left="173" width="626" height="16" font="0">H operations preserve language-based memory-safety in our client kernels, but even</text>
<text top="260" left="173" width="626" height="16" font="0">an H operation that is itself memory-safe with respect to the Haskell semantics can</text>
<text top="293" left="173" width="626" height="16" font="0">corrupt the run-time system and introduce memory-safety errors into the client.</text>
<text top="325" left="173" width="626" height="16" font="0">This is because the H operations have access to all of physical memory, including</text>
<text top="358" left="173" width="626" height="16" font="0">the Haskell heap and run-time system data. Thus, for an H operation to preserve</text>
<text top="390" left="173" width="626" height="16" font="0">language-based memory-safety at the client kernel level, we need a memory-safety</text>
<text top="423" left="173" width="626" height="16" font="0">property for our H operations that is stronger than traditional deﬁnitions. In</text>
<text top="455" left="173" width="626" height="16" font="0">addition to demonstrating that the H operations are memory-safe with respect to</text>
<text top="488" left="173" width="626" height="16" font="0">the colloquial deﬁnition, we must also demonstrate that they do not corrupt the</text>
<text top="520" left="173" width="626" height="16" font="0">Haskell run-time system or conﬁgure the virtual-memory translation tables in a</text>
<text top="553" left="173" width="519" height="16" font="0">way that would enable such corruption by a client or user program.</text>
<text top="585" left="199" width="600" height="16" font="0">The essential characteristics of the H interface with respect to run-time system</text>
<text top="618" left="173" width="342" height="16" font="0">integrity can be expressed as two properties:</text>
<text top="664" left="199" width="600" height="17" font="0">• Execution Environment Integrity: Memory occupied by the execution</text>
<text top="698" left="217" width="582" height="16" font="0">environment should be distinct from memory that is used for other purposes.</text>
<text top="730" left="217" width="583" height="16" font="0">No user-process or client kernel should be able to write to environment pages</text>
<text top="763" left="217" width="583" height="16" font="0">or alter the mappings to those pages. As discussed in Section 4.1, the execu-</text>
<text top="795" left="217" width="582" height="16" font="0">tion environment refers to all of the software components that are essential</text>
<text top="828" left="217" width="583" height="16" font="0">for the client kernel to execute, including the run-time system, Haskell heap</text>
<text top="860" left="217" width="194" height="16" font="0">pages, and C heap pages.</text>
<text top="907" left="199" width="600" height="17" font="0">• Address-Space Integrity: Memory that implements the view in a partic-</text>
<text top="940" left="217" width="583" height="16" font="0">ular address-space (such as a page-table or page-directory page) should be</text>
<text top="973" left="217" width="582" height="16" font="0">distinct from the memory that is used for other purposes. No user-process</text>
<text top="1005" left="217" width="583" height="16" font="0">should be able to write to these pages. Client kernels should only write to</text>
<text top="1038" left="217" width="494" height="16" font="0">these pages using operations that are appropriate for their type.</text>
</page>
<page number="106" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">84</text>
<text top="163" left="173" width="626" height="16" font="0">We deﬁne the memory-safety property for the H interface as the combination of</text>
<text top="195" left="173" width="626" height="16" font="0">execution environment integrity, address-space integrity, and traditional memory-</text>
<text top="228" left="173" width="626" height="16" font="0">safety. If our implementation of H satisﬁes this deﬁnition of memory-safety, then we</text>
<text top="260" left="173" width="626" height="16" font="0">can be sure that our kernel will not crash because the run-time system has been</text>
<text top="293" left="173" width="626" height="16" font="0">corrupted and that a buggy or malicious program running on top of H cannot</text>
<text top="325" left="173" width="626" height="16" font="0">insert values into the Haskell heap. In the remainder of this chapter, we focus</text>
<text top="358" left="173" width="626" height="16" font="0">on execution environment integrity and address-space integrity because these are</text>
<text top="390" left="173" width="626" height="16" font="0">novel properties that have not been explored in other work. We leave the proof</text>
<text top="423" left="173" width="594" height="16" font="0">that H is memory-safe in a traditional sense as future work (see Chapter 10).</text>
<text top="455" left="199" width="600" height="16" font="0">To enforce execution environment integrity and address-space integrity within</text>
<text top="488" left="173" width="626" height="16" font="0">the H implementation we utilize a combination of run-time checks and abstract</text>
<text top="520" left="173" width="626" height="16" font="0">datatypes to make sure that no direct writes to the run-time system memory via</text>
<text top="553" left="173" width="626" height="16" font="0">H operations are possible. Indirect writes to the Haskell heap during the course of</text>
<text top="585" left="173" width="626" height="16" font="0">the H’s execution do occur, but the semantics of the language, assuming a correct</text>
<text top="618" left="173" width="626" height="16" font="0">implementation, guarantee that such writes will not cause a type- or memory-safety</text>
<text top="650" left="173" width="626" height="16" font="0">violation. If execution environment integrity and address-space integrity hold for</text>
<text top="683" left="173" width="626" height="16" font="0">the H implementation, then we can ensure that the other system components do</text>
<text top="715" left="173" width="501" height="16" font="0">not corrupt the run-time system using the following mechanisms:</text>
<text top="762" left="199" width="600" height="17" font="0">• Client Kernels: Our client kernels are written entirely in the safe portion of</text>
<text top="795" left="217" width="582" height="16" font="0">Haskell and do not make foreign calls. We can therefore rely on the safety of</text>
<text top="828" left="217" width="582" height="16" font="0">Haskell for preventing unsafe accesses to the run-time system data because</text>
<text top="860" left="217" width="583" height="16" font="0">the run-time system does not permit Haskell programs to access its data</text>
<text top="893" left="217" width="582" height="16" font="0">structures or violate the safety guarantees of the language. Execution of the</text>
<text top="925" left="217" width="582" height="16" font="0">client kernel will impact the values stored in the run-time system memory,</text>
<text top="958" left="217" width="418" height="16" font="0">but not in a way that can cause memory-safety errors.</text>
<text top="1004" left="199" width="600" height="17" font="0">• User Programs: For user programs, we rely on hardware protection using</text>
<text top="1038" left="217" width="582" height="16" font="0">the MMU. When we conﬁgure the run-time system code and heap, we map</text>
</page>
<page number="107" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">85</text>
<text top="163" left="217" width="583" height="16" font="0">all of the memory with kernel-only permissions. User programs always run</text>
<text top="195" left="217" width="583" height="16" font="0">in user-mode and will fault if they attempt to access the run-time system</text>
<text top="228" left="217" width="39" height="16" font="0">data.</text>
<text top="272" left="173" width="626" height="16" font="0">We assume that client kernels behave in a safe way (when running on an uncor-</text>
<text top="305" left="173" width="626" height="16" font="0">rupted run-time system) as part of our assumption that the GHC implementation</text>
<text top="337" left="173" width="626" height="16" font="0">is correct, type-safe, and memory-safe. To verify that user-programs do not cor-</text>
<text top="370" left="173" width="626" height="16" font="0">rupt the run-time system, we need to formalize the property that the execution</text>
<text top="402" left="173" width="626" height="16" font="0">environment pages are always mapped with kernel-only permission, but do not</text>
<text top="435" left="173" width="451" height="16" font="0">need to model any other aspects of user-process execution.</text>
<text top="467" left="199" width="600" height="16" font="0">In the remainder of this chapter we will show how the execution environment</text>
<text top="500" left="173" width="626" height="16" font="0">integrity and address-space integrity components of the memory-safety property</text>
<text top="532" left="173" width="626" height="16" font="0">can be formalized as a separation property by instantiating the Rushby noninter-</text>
<text top="565" left="173" width="626" height="16" font="0">ference framework [82]. We will connect the instantiation of the framework to our</text>
<text top="597" left="173" width="626" height="16" font="0">implementation via an abstract model of the H operations. Establishing a formal</text>
<text top="630" left="173" width="626" height="16" font="0">connection between the model and the implementation is an interesting topic, but</text>
<text top="662" left="173" width="626" height="16" font="0">we do not tackle this work in this dissertation. Nevertheless we have attempted to</text>
<text top="695" left="173" width="626" height="16" font="0">maintain an informal level of consistency between these two descriptions of H and</text>
<text top="727" left="173" width="333" height="16" font="0">to point out any places where they diverge.</text>
<text top="760" left="199" width="600" height="16" font="0">We begin by reviewing the Rushby framework for reasoning about noninter-</text>
<text top="792" left="173" width="626" height="16" font="0">ference properties in Section 5.1. Section 5.2 discusses the notational style that</text>
<text top="825" left="173" width="626" height="16" font="0">we will use throughout the chapter. Section 5.3 presents our instantiation of the</text>
<text top="857" left="173" width="626" height="16" font="0">system state. Section 5.4 describes our division of the system into protection do-</text>
<text top="890" left="173" width="626" height="16" font="0">mains and our instantiation of the various components of the Rushby framework</text>
<text top="922" left="173" width="626" height="16" font="0">to support our memory-safety interpretation. Section 5.5 explains the safety prop-</text>
<text top="955" left="173" width="626" height="16" font="0">erty in terms of our security policy between domains. Section 5.6 deﬁnes the static</text>
<text top="987" left="173" width="626" height="16" font="0">invariants on the state that we expect all operations in our system to uphold. Sec-</text>
<text top="1020" left="173" width="626" height="16" font="0">tion 5.7 speciﬁes the dynamic behavior of the key H operations. Section 5.8 deﬁnes</text>
<text top="1052" left="173" width="626" height="16" font="0">the execution function for our Rushby instantiation and sketches a proof that our</text>
</page>
<page number="108" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="11" size="6" family="Times" color="#000000"/>
<text top="111" left="738" width="18" height="16" font="0">86</text>
<text top="163" left="173" width="620" height="16" font="0">instantiation satisﬁes the necessary properties set out by the Rushby framework.</text>
<text top="225" left="173" width="26" height="16" font="0">5.1</text>
<text top="225" left="219" width="580" height="16" font="0">BACKGROUND: RUSHBY’S NONINTERFERENCE FRAME-</text>
<text top="259" left="219" width="66" height="16" font="0">WORK</text>
<text top="310" left="173" width="626" height="16" font="0">This section summarizes Rushby’s framework for reasoning about system security</text>
<text top="342" left="173" width="626" height="16" font="0">[82]. The basis of this framework is an abstract model of computer systems and a</text>
<text top="375" left="173" width="626" height="16" font="0">representation of noninterference policies. Rushby uses these foundational elements</text>
<text top="407" left="173" width="626" height="16" font="0">to deﬁne security, to formalize assumptions, and to prove that a system satisfying</text>
<text top="440" left="173" width="215" height="16" font="0">those assumptions is secure.</text>
<text top="499" left="173" width="41" height="16" font="0">5.1.1</text>
<text top="499" left="234" width="126" height="16" font="0">System Model</text>
<text top="543" left="173" width="626" height="16" font="0">Rushby [82] models computer systems as state machines. An action is a state trans-</text>
<text top="576" left="173" width="626" height="16" font="0">former that also produces some output. The behavior of the system is speciﬁed</text>
<text top="608" left="173" width="626" height="16" font="0">by the functions step and output ; step performs a single state transition whereas</text>
<text top="641" left="173" width="304" height="16" font="0">output extracts the result of the action.</text>
<text top="691" left="173" width="393" height="16" font="0">Deﬁnition 1. A system (machine), M, consists of</text>
<text top="740" left="217" width="308" height="16" font="0">a set of states, S, with an initial state s</text>
<text top="747" left="525" width="6" height="11" font="2">0</text>
<text top="739" left="538" width="33" height="17" font="0">∈ S,</text>
<text top="790" left="217" width="185" height="16" font="0">a set of actions, A, and</text>
<text top="839" left="217" width="156" height="16" font="0">a set of outputs, O,</text>
<text top="889" left="173" width="257" height="16" font="0">together with execution functions,</text>
<text top="939" left="217" width="30" height="16" font="0">step</text>
<text top="939" left="291" width="148" height="16" font="0">:: S × A → S, and</text>
<text top="988" left="217" width="48" height="16" font="0">output</text>
<text top="988" left="292" width="118" height="16" font="0">:: S × A → O.</text>
</page>
<page number="109" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">87</text>
<text top="163" left="199" width="600" height="16" font="0">To express security constraints on the system, Rushby supplements the basic</text>
<text top="195" left="173" width="626" height="16" font="0">execution model with a notion of protection domains and a security policy. Actions</text>
<text top="228" left="173" width="626" height="16" font="0">in the system are partitioned into a set of domains, D , as speciﬁed by the function</text>
<text top="260" left="173" width="414" height="16" font="0">dom :: A → D . A reﬂexive binary relation on domains,</text>
<text top="260" left="614" width="185" height="16" font="0">(pronounced interferes),</text>
<text top="293" left="173" width="331" height="16" font="0">expresses the security policy of the system.</text>
<text top="343" left="240" width="128" height="16" font="0">:: D × D → Bool</text>
<text top="394" left="173" width="626" height="16" font="0">A domain u interferes with a domain v if information is allowed to ﬂow from u to v ,</text>
<text top="426" left="173" width="502" height="16" font="0">meaning that v can observe the eﬀects of u’s actions. The symbol</text>
<text top="426" left="704" width="96" height="16" font="0">(pronounced</text>
<text top="459" left="173" width="422" height="16" font="0">does not interfere) represents the complement relation.</text>
<text top="491" left="199" width="600" height="16" font="0">While the speciﬁc nature of states is abstract, the proof of the security def-</text>
<text top="524" left="173" width="626" height="16" font="0">inition requires some mechanism for determining what information is observable</text>
<text top="556" left="173" width="626" height="16" font="0">to a particular domain in each state. To this end, Rushby introduces an equiva-</text>
<text top="589" left="173" width="626" height="16" font="0">lence relation, ∼ :: S × S × D → Bool , called the view-partitioning relation. Two</text>
<text top="621" left="173" width="588" height="16" font="0">states, s and t , are equivalent from the perspective of a domain u, written s</text>
<text top="615" left="771" width="7" height="11" font="2">u</text>
<text top="620" left="768" width="32" height="17" font="0">∼ t ,</text>
<text top="654" left="173" width="626" height="16" font="0">if u cannot distinguish s and t . The precise meaning of ∼ is a parameter to the</text>
<text top="686" left="173" width="626" height="16" font="0">formulation. This relation extends naturally to an equivalence, ≈, over a set of</text>
<text top="719" left="173" width="94" height="16" font="0">domains, C .</text>
<text top="769" left="217" width="7" height="16" font="0">s</text>
<text top="761" left="232" width="9" height="11" font="2">C</text>
<text top="768" left="230" width="126" height="17" font="0">≈ t ≡ ∀u ∈ C . s</text>
<text top="763" left="366" width="7" height="11" font="2">u</text>
<text top="768" left="363" width="25" height="17" font="0">∼ t</text>
<text top="820" left="199" width="600" height="16" font="0">A key characteristic of the model is the abstract nature of states, actions, and</text>
<text top="852" left="173" width="626" height="16" font="0">outputs. System developers have signiﬁcant ﬂexibility in the instantiation of these</text>
<text top="885" left="173" width="626" height="16" font="0">parameters, so the formulation can be applied to a wide variety of systems. The</text>
<text top="917" left="173" width="626" height="16" font="0">output function is a good example of this ﬂexibility. Bevier and Young [7] criticize</text>
<text top="950" left="173" width="626" height="16" font="0">the use of output , because many systems do not produce output in the traditional</text>
<text top="982" left="173" width="626" height="16" font="0">sense. Their model replaces output with a view function, that extracts a portion</text>
<text top="1015" left="173" width="626" height="16" font="0">of the state. However, the distinction between output and view is gratuitous, as</text>
<text top="1047" left="173" width="494" height="16" font="0">view is a valid instantiation of output in the Rushby framework.</text>
</page>
<page number="110" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">88</text>
<text top="158" left="383" width="91" height="16" font="0">policy = {A</text>
<text top="158" left="501" width="34" height="16" font="0">B , B</text>
<text top="158" left="565" width="24" height="16" font="0">C }</text>
<text top="198" left="346" width="9" height="16" font="0">0</text>
<text top="198" left="407" width="9" height="16" font="0">1</text>
<text top="198" left="467" width="9" height="16" font="0">2</text>
<text top="227" left="284" width="13" height="16" font="0">A</text>
<text top="227" left="343" width="9" height="16" font="0">a</text>
<text top="234" left="351" width="6" height="11" font="2">1</text>
<text top="243" left="399" width="0" height="23" font="0">''</text>
<text top="259" left="283" width="12" height="16" font="0">B</text>
<text top="259" left="403" width="8" height="16" font="0">b</text>
<text top="266" left="411" width="6" height="11" font="2">1</text>
<text top="275" left="459" width="0" height="23" font="0">''</text>
<text top="290" left="283" width="13" height="16" font="0">C</text>
<text top="290" left="463" width="8" height="16" font="0">c</text>
<text top="297" left="471" width="6" height="11" font="2">1</text>
<text top="331" left="272" width="33" height="13" font="4">(a) a</text>
<text top="337" left="305" width="6" height="9" font="3">1</text>
<text top="331" left="318" width="108" height="13" font="4">interferes with c</text>
<text top="337" left="427" width="6" height="9" font="3">1</text>
<text top="331" left="440" width="43" height="13" font="4">via in-</text>
<text top="360" left="272" width="117" height="13" font="4">tervening action b</text>
<text top="365" left="390" width="6" height="9" font="3">1</text>
<text top="198" left="563" width="9" height="16" font="0">0</text>
<text top="198" left="623" width="9" height="16" font="0">1</text>
<text top="198" left="683" width="9" height="16" font="0">2</text>
<text top="227" left="500" width="13" height="16" font="0">A</text>
<text top="227" left="559" width="9" height="16" font="0">a</text>
<text top="234" left="568" width="6" height="11" font="2">1</text>
<text top="247" left="676" width="0" height="23" font="0">++</text>
<text top="259" left="500" width="12" height="16" font="0">B</text>
<text top="259" left="680" width="8" height="16" font="0">b</text>
<text top="266" left="688" width="6" height="11" font="2">1</text>
<text top="290" left="499" width="13" height="16" font="0">C</text>
<text top="290" left="620" width="8" height="16" font="0">c</text>
<text top="297" left="628" width="6" height="11" font="2">1</text>
<text top="331" left="494" width="33" height="13" font="4">(b) a</text>
<text top="337" left="527" width="6" height="9" font="3">1</text>
<text top="331" left="539" width="149" height="13" font="4">cannot interfere with c</text>
<text top="337" left="688" width="6" height="9" font="3">1</text>
<text top="397" left="173" width="626" height="16" font="0">Figure 5.1: Intervening actions allow indirect interference between domains. A, B ,</text>
<text top="432" left="173" width="426" height="16" font="0">and C are domains in a system. The policy contains A</text>
<text top="432" left="627" width="67" height="16" font="0">B and B</text>
<text top="432" left="724" width="75" height="16" font="0">C . In the</text>
<text top="466" left="173" width="626" height="16" font="0">diagram, columns represent execution steps, where the numeric label corresponds</text>
<text top="501" left="173" width="315" height="16" font="0">to the state an action executes in (e.g., a</text>
<text top="508" left="488" width="6" height="11" font="2">1</text>
<text top="501" left="500" width="97" height="16" font="0">executes in s</text>
<text top="508" left="598" width="6" height="11" font="2">0</text>
<text top="501" left="611" width="90" height="16" font="0">producing s</text>
<text top="508" left="700" width="6" height="11" font="2">1</text>
<text top="501" left="708" width="92" height="16" font="0">). An arrow</text>
<text top="536" left="173" width="402" height="16" font="0">between two actions indicates potential interference.</text>
<text top="606" left="173" width="41" height="16" font="0">5.1.2</text>
<text top="606" left="234" width="317" height="16" font="0">Characterizing Domain Interactions</text>
<text top="651" left="173" width="626" height="16" font="0">A security policy speciﬁes which domains are allowed to interfere, but does not</text>
<text top="683" left="173" width="626" height="16" font="0">capture all information ﬂow between domains. For example, consider a system</text>
<text top="716" left="173" width="401" height="16" font="0">with three domains, A, B , and C , and a policy {A</text>
<text top="716" left="605" width="39" height="16" font="0">B , B</text>
<text top="716" left="677" width="122" height="16" font="0">C }, as pictured</text>
<text top="748" left="173" width="626" height="16" font="0">in Figure 5.1. Though the policy does not explicitly state that A interferes with</text>
<text top="781" left="173" width="582" height="16" font="0">C , information can ﬂow from A to C indirectly through actions in B . If</text>
<text top="781" left="787" width="12" height="16" font="0">is</text>
<text top="813" left="173" width="626" height="16" font="0">transitive, then A interferes with C in all situations. However, we are concerned</text>
<text top="846" left="173" width="151" height="16" font="0">with systems where</text>
<text top="846" left="354" width="445" height="16" font="0">is not assumed to be transitive, so we need a strategy for</text>
<text top="878" left="173" width="626" height="16" font="0">determining if information ﬂow from A to C occurs in a particular sequence of</text>
<text top="911" left="173" width="626" height="16" font="0">actions. A only interferes with C through B , so an action in A only interferes with</text>
<text top="943" left="173" width="451" height="16" font="0">an action in C when an intervening action in B is present.</text>
<text top="976" left="199" width="600" height="16" font="0">Rushby captures information ﬂow between domains formally with a function</text>
<text top="1008" left="173" width="181" height="16" font="0">called sources of type A</text>
<text top="1005" left="353" width="6" height="11" font="2">∗</text>
<text top="1007" left="363" width="229" height="17" font="0">× D → ℘(D ). The notation A</text>
<text top="1005" left="591" width="6" height="11" font="2">∗</text>
<text top="1008" left="603" width="196" height="16" font="0">represents the set of ﬁnite</text>
<text top="1041" left="173" width="626" height="16" font="0">sequences whose elements belong to the set A. The empty sequence is denoted</text>
</page>
<page number="111" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">89</text>
<text top="163" left="173" width="626" height="16" font="0">by [] and the sequence obtained by prepending a to as is denoted by (a:as). The</text>
<text top="195" left="173" width="626" height="16" font="0">notation ℘(D ) represents the set of subsets of the set D . Given a domain, u,</text>
<text top="228" left="173" width="626" height="16" font="0">and a sequence of actions, α, sources(α, u) is the set of domains that might leak</text>
<text top="260" left="173" width="265" height="16" font="0">information to u when α executes.</text>
<text top="310" left="173" width="626" height="16" font="0">Deﬁnition 2. The function, sources, which determines via what domains infor-</text>
<text top="345" left="173" width="489" height="16" font="0">mation can ﬂow to a particular domain u, is deﬁned as follows:</text>
<text top="381" left="208" width="54" height="16" font="0">sources</text>
<text top="381" left="353" width="11" height="16" font="0">::</text>
<text top="381" left="383" width="13" height="16" font="0">A</text>
<text top="378" left="396" width="6" height="11" font="2">∗</text>
<text top="380" left="410" width="104" height="17" font="0">× D → ℘(D )</text>
<text top="416" left="208" width="102" height="16" font="0">sources([], u)</text>
<text top="416" left="352" width="13" height="16" font="0">=</text>
<text top="415" left="383" width="27" height="17" font="0">{u}</text>
<text top="501" left="208" width="126" height="16" font="0">sources(a:as, u)</text>
<text top="501" left="352" width="13" height="16" font="0">=</text>
<text top="438" left="383" width="16" height="8" font="0"></text>
<text top="454" left="383" width="16" height="8" font="0"></text>
<text top="460" left="383" width="16" height="8" font="0"></text>
<text top="465" left="383" width="16" height="8" font="0"></text>
<text top="470" left="383" width="16" height="8" font="0"></text>
<text top="476" left="383" width="16" height="8" font="0"></text>
<text top="481" left="383" width="16" height="8" font="0"></text>
<text top="487" left="383" width="16" height="8" font="0"></text>
<text top="492" left="383" width="16" height="8" font="0"></text>
<text top="524" left="383" width="16" height="8" font="0"></text>
<text top="530" left="383" width="16" height="8" font="0"></text>
<text top="535" left="383" width="16" height="8" font="0"></text>
<text top="540" left="383" width="16" height="8" font="0"></text>
<text top="546" left="383" width="16" height="8" font="0"></text>
<text top="551" left="383" width="16" height="8" font="0"></text>
<text top="557" left="383" width="16" height="8" font="0"></text>
<text top="562" left="383" width="16" height="8" font="0"></text>
<text top="451" left="402" width="201" height="16" font="0">sources(as, u) ∪ {dom(a)}</text>
<text top="486" left="420" width="268" height="16" font="0">if ∃v . v ∈ sources(as, u) ∧ dom(a)</text>
<text top="486" left="716" width="8" height="16" font="0">v</text>
<text top="521" left="402" width="106" height="16" font="0">sources(as, u)</text>
<text top="555" left="420" width="72" height="16" font="0">otherwise</text>
<text top="589" left="173" width="626" height="16" font="0">Given a non-empty sequence of actions, (a:as), sources checks whether an action,</text>
<text top="623" left="173" width="626" height="16" font="0">a, interferes with an action in sources(as, u). This condition is true if an inter-</text>
<text top="658" left="173" width="626" height="16" font="0">vening action in as allows information to ﬂow from dom(a) to u, or if the security</text>
<text top="693" left="173" width="425" height="16" font="0">policy allows direct interference between dom(a) and u.</text>
<text top="740" left="199" width="600" height="16" font="0">Security under a noninterference policy means that actions not allowed to in-</text>
<text top="773" left="173" width="626" height="16" font="0">terfere with a domain, u, are truly unobservable to u. Rushby captures this in-</text>
<text top="805" left="173" width="626" height="16" font="0">terpretation of security by simulating system execution. Executing a sequence of</text>
<text top="838" left="173" width="626" height="16" font="0">actions should produce the same results, from the perspective of u, as executing</text>
<text top="870" left="173" width="434" height="16" font="0">the same sequence with non-interfering actions removed.</text>
<text top="903" left="199" width="600" height="16" font="0">The function ipurge removes all actions that do not interfere with a particular</text>
<text top="935" left="173" width="626" height="16" font="0">domain from a sequence of actions. The purge process relies on sources to ana-</text>
<text top="968" left="173" width="626" height="16" font="0">lyze whether each action in the sequence may leak information to the domain in</text>
<text top="1000" left="173" width="69" height="16" font="0">question.</text>
</page>
<page number="112" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">90</text>
<text top="163" left="173" width="626" height="16" font="0">Deﬁnition 3. We deﬁne a function, ipurge, which, given a list of actions, α, and</text>
<text top="198" left="173" width="586" height="16" font="0">a domain, u, returns a list containing the actions in α that interfere with u.</text>
<text top="234" left="208" width="46" height="16" font="0">ipurge</text>
<text top="234" left="355" width="11" height="16" font="0">::</text>
<text top="234" left="385" width="13" height="16" font="0">A</text>
<text top="231" left="398" width="6" height="11" font="2">∗</text>
<text top="233" left="411" width="77" height="17" font="0">× D → A</text>
<text top="231" left="488" width="6" height="11" font="2">∗</text>
<text top="269" left="208" width="94" height="16" font="0">ipurge([], u)</text>
<text top="269" left="353" width="13" height="16" font="0">=</text>
<text top="269" left="385" width="11" height="16" font="0">[]</text>
<text top="319" left="208" width="127" height="16" font="0">ipurge(a : as, u)</text>
<text top="319" left="353" width="13" height="16" font="0">=</text>
<text top="293" left="385" width="16" height="8" font="0"></text>
<text top="310" left="385" width="16" height="8" font="0"></text>
<text top="342" left="385" width="16" height="8" font="0"></text>
<text top="304" left="404" width="337" height="16" font="0">a:ipurge(as, u) if dom(a) ∈ sources(a:as, u)</text>
<text top="338" left="404" width="98" height="16" font="0">ipurge(as, u)</text>
<text top="338" left="523" width="72" height="16" font="0">otherwise</text>
<text top="370" left="173" width="625" height="16" font="0">When α = a:as, ipurge uses sources to determine if a interferes with u. If not, a</text>
<text top="405" left="173" width="73" height="16" font="0">is purged.</text>
<text top="452" left="199" width="600" height="16" font="0">Rushby models the execution of a sequence of actions with run, which is a</text>
<text top="484" left="173" width="340" height="16" font="0">natural extension of step from Section 5.1.1.</text>
<text top="519" left="208" width="27" height="16" font="0">run</text>
<text top="519" left="336" width="10" height="16" font="0">::</text>
<text top="519" left="365" width="48" height="16" font="0">S × A</text>
<text top="516" left="414" width="6" height="11" font="2">∗</text>
<text top="518" left="427" width="34" height="17" font="0">→ S</text>
<text top="552" left="208" width="71" height="16" font="0">run(s, [])</text>
<text top="552" left="334" width="14" height="16" font="0">=</text>
<text top="552" left="365" width="7" height="16" font="0">s</text>
<text top="584" left="208" width="108" height="16" font="0">run(s, (a:as))</text>
<text top="584" left="334" width="14" height="16" font="0">=</text>
<text top="584" left="365" width="139" height="16" font="0">run(step(s,a), as)</text>
<text top="615" left="173" width="512" height="16" font="0">We often wish to run a sequence of actions from the initial state, s</text>
<text top="622" left="685" width="6" height="11" font="2">0</text>
<text top="615" left="692" width="108" height="16" font="0">, or to extract</text>
<text top="648" left="173" width="625" height="16" font="0">the output produced by an action following such an execution. The functions do</text>
<text top="680" left="173" width="377" height="16" font="0">and test are shorthands for these two operations.</text>
<text top="716" left="208" width="18" height="16" font="0">do</text>
<text top="716" left="303" width="10" height="16" font="0">::</text>
<text top="716" left="332" width="13" height="16" font="0">A</text>
<text top="713" left="345" width="6" height="11" font="2">∗</text>
<text top="715" left="358" width="34" height="17" font="0">→ S</text>
<text top="748" left="208" width="44" height="16" font="0">do(α)</text>
<text top="748" left="301" width="14" height="16" font="0">=</text>
<text top="748" left="332" width="42" height="16" font="0">run(s</text>
<text top="755" left="374" width="6" height="11" font="2">0</text>
<text top="748" left="381" width="29" height="16" font="0">, α)</text>
<text top="788" left="208" width="27" height="16" font="0">test</text>
<text top="788" left="303" width="10" height="16" font="0">::</text>
<text top="788" left="332" width="13" height="16" font="0">A</text>
<text top="785" left="345" width="6" height="11" font="2">∗</text>
<text top="787" left="358" width="76" height="17" font="0">× A → O</text>
<text top="821" left="208" width="75" height="16" font="0">test (α, a)</text>
<text top="821" left="301" width="14" height="16" font="0">=</text>
<text top="821" left="332" width="129" height="16" font="0">output (do(α), a)</text>
<text top="852" left="173" width="595" height="16" font="0">We now use these functions to state Rushby’s formulation of system security:</text>
<text top="901" left="173" width="626" height="16" font="0">Deﬁnition 4 (Security Property). Let s be the state that results from running an</text>
<text top="935" left="173" width="626" height="16" font="0">arbitrary sequence of actions, α, from the initial state, and let t be the state that</text>
<text top="970" left="173" width="626" height="16" font="0">results from running the corresponding purged list. A system is secure if the output</text>
<text top="1005" left="173" width="434" height="16" font="0">produced by executing any action is the same in s and t .</text>
<text top="1052" left="217" width="294" height="16" font="0">test (α, a) = test (ipurge(α, dom(a)), a)</text>
</page>
<page number="113" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">91</text>
<text top="186" left="173" width="41" height="16" font="0">5.1.3</text>
<text top="186" left="234" width="186" height="16" font="0">Establishing Security</text>
<text top="230" left="173" width="626" height="16" font="0">Rushby employs a technique called unwinding to prove that a system satisﬁes the</text>
<text top="263" left="173" width="626" height="16" font="0">security property. Many noninterference formulations use this approach [7, 33, 93].</text>
<text top="295" left="173" width="626" height="16" font="0">Unwinding establishes that a system with well-behaved state transitions is secure.</text>
<text top="328" left="173" width="626" height="16" font="0">A set of unwinding conditions specify the expected properties of state transitions,</text>
<text top="360" left="173" width="573" height="16" font="0">and the unwinding theorem links these conditions to the security property.</text>
<text top="393" left="199" width="600" height="16" font="0">Rushby speciﬁes three unwinding conditions—output consistency, local respect,</text>
<text top="425" left="173" width="626" height="16" font="0">and weak step consistency—and proves that the security property holds for systems</text>
<text top="458" left="173" width="221" height="16" font="0">that satisfy these conditions.</text>
<text top="504" left="173" width="626" height="16" font="0">Deﬁnition 5 (Output Consistency). A system is output consistent if the output</text>
<text top="539" left="173" width="601" height="16" font="0">produced by executing an action in equivalent states is the same in both states.</text>
<text top="584" left="217" width="7" height="16" font="0">s</text>
<text top="576" left="230" width="42" height="11" font="2">dom(a)</text>
<text top="583" left="244" width="14" height="17" font="0">∼</text>
<text top="584" left="277" width="253" height="16" font="0">t ⇒ output (s, a) = output (t , a)</text>
<text top="678" left="173" width="626" height="16" font="0">Deﬁnition 6 (Local Respect). A system locally respects the security policy if the</text>
<text top="713" left="173" width="626" height="16" font="0">eﬀect of an action, a, which may not interfere with a domain, u, is unobservable</text>
<text top="747" left="173" width="626" height="16" font="0">to u. That is, the state produced by executing a is equivalent, from u’s perspective,</text>
<text top="782" left="173" width="228" height="16" font="0">to the state before a executed.</text>
<text top="826" left="217" width="58" height="16" font="0">dom(a)</text>
<text top="826" left="302" width="60" height="16" font="0">u ⇒ s</text>
<text top="820" left="371" width="7" height="11" font="2">u</text>
<text top="825" left="368" width="91" height="17" font="0">∼ step(s, a)</text>
<text top="921" left="173" width="626" height="16" font="0">Deﬁnition 7 (Weak Step Consistency). A system is weakly step consistent if the</text>
<text top="955" left="173" width="592" height="16" font="0">states that result from executing an action in equivalent states are equivalent.</text>
<text top="1004" left="217" width="7" height="16" font="0">s</text>
<text top="998" left="233" width="7" height="11" font="2">u</text>
<text top="1003" left="230" width="66" height="17" font="0">∼ t ∧ s</text>
<text top="997" left="303" width="42" height="11" font="2">dom(a)</text>
<text top="1003" left="317" width="14" height="17" font="0">∼</text>
<text top="1004" left="350" width="121" height="16" font="0">t ⇒ step(s, a)</text>
<text top="998" left="479" width="7" height="11" font="2">u</text>
<text top="1003" left="476" width="89" height="17" font="0">∼ step(t , a)</text>
</page>
<page number="114" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">92</text>
<text top="163" left="173" width="233" height="16" font="0">Theorem 1 (Unwinding). Let</text>
<text top="163" left="434" width="365" height="16" font="0">be a policy and M a view-partitioned system that</text>
<text top="198" left="173" width="13" height="16" font="0">is</text>
<text top="247" left="194" width="159" height="16" font="0">1. output consistent,</text>
<text top="297" left="194" width="229" height="16" font="0">2. weakly step consistent, and</text>
<text top="346" left="194" width="135" height="16" font="0">3. locally respects</text>
<text top="346" left="352" width="5" height="16" font="0">.</text>
<text top="396" left="173" width="161" height="16" font="0">Then M is secure for</text>
<text top="396" left="358" width="5" height="16" font="0">.</text>
<text top="451" left="199" width="600" height="16" font="0">Rushby proves the unwinding theorem using properties of sources and ≈, the</text>
<text top="483" left="173" width="285" height="16" font="0">details of which are in his paper [82].</text>
<text top="545" left="173" width="26" height="16" font="0">5.2</text>
<text top="545" left="219" width="109" height="16" font="0">NOTATION</text>
<text top="595" left="173" width="626" height="16" font="0">We use Haskell syntax for the deﬁnitions and speciﬁcations presented in the re-</text>
<text top="628" left="173" width="626" height="16" font="0">mainder of this chapter. We choose Haskell as the speciﬁcation language in place of</text>
<text top="660" left="173" width="626" height="16" font="0">a traditional mathematical notation to enable us to type check the model through-</text>
<text top="693" left="173" width="626" height="16" font="0">out the development process. This approach is less formal than developing our</text>
<text top="725" left="173" width="626" height="16" font="0">model of H directly in the language of a theorem prover. When instantiating the</text>
<text top="758" left="173" width="626" height="16" font="0">Rushby framework using Haskell, we model the system state as a datatype. We</text>
<text top="790" left="173" width="626" height="16" font="0">also model the set of domains, D , the set of actions, A, and the set of outputs, O ,</text>
<text top="823" left="173" width="626" height="16" font="0">as types. The security policy is a relation between domains that we implement as</text>
<text top="855" left="173" width="626" height="16" font="0">a function. All functions in the formalism are encoded as Haskell functions in our</text>
<text top="888" left="173" width="102" height="16" font="0">instantiation.</text>
<text top="920" left="199" width="600" height="16" font="0">Our model is not executable, but in our experience type checking alone was</text>
<text top="953" left="173" width="626" height="16" font="0">still useful for catching bugs. Because we use types to represent the essential fea-</text>
<text top="985" left="173" width="626" height="16" font="0">tures of the Rushby framework, the compiler acts as a consistency checker on the</text>
<text top="1018" left="173" width="626" height="16" font="0">deﬁnitions. Using a programming notation also helps us to avoid overlooking the</text>
</page>
<page number="115" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">93</text>
<text top="163" left="173" width="626" height="16" font="0">behavior of cases that might be abstracted over in a purely mathematical deﬁni-</text>
<text top="195" left="173" width="626" height="16" font="0">tion. For example, the Haskell compiler provides warnings for incomplete pattern</text>
<text top="228" left="173" width="626" height="16" font="0">matches, which indicates that we might have forgotten to insert the behavior of an</text>
<text top="260" left="173" width="626" height="16" font="0">operation in one or more cases. Every property and speciﬁcation that we present</text>
<text top="293" left="173" width="626" height="16" font="0">in this chapter has been type checked to establish a minimum level of consistency.</text>
<text top="325" left="173" width="626" height="16" font="0">Since developing the Haskell model, we have also translated the code into HOL</text>
<text top="358" left="173" width="626" height="16" font="0">Light [43]. The translation was very direct and did not require any nontrivial</text>
<text top="390" left="173" width="626" height="16" font="0">modiﬁcations to the speciﬁcations, giving us a greater degree of conﬁdence in the</text>
<text top="423" left="173" width="626" height="16" font="0">model. We present the Haskell model here because the reader will already be</text>
<text top="455" left="173" width="436" height="16" font="0">familiar with the notation from our review in Chapter 3.</text>
<text top="488" left="199" width="600" height="16" font="0">In some cases, aspects of the speciﬁcation might be uncomputable or might</text>
<text top="520" left="173" width="626" height="16" font="0">be semantically unclear when viewed through a Haskell lens. In particular, we</text>
<text top="553" left="173" width="626" height="16" font="0">use mathematical constructs that are not deﬁned in Haskell so that we can easily</text>
<text top="585" left="173" width="626" height="16" font="0">express the appropriate properties in our speciﬁcations. For example, we introduce</text>
<text top="618" left="173" width="626" height="16" font="0">the function forall of type (a -&gt; Bool) -&gt; Bool to express the property that a</text>
<text top="650" left="173" width="626" height="16" font="0">particular predicate holds of every member of a type a. Throughout this chapter,</text>
<text top="683" left="173" width="240" height="16" font="0">we will use the convention that</text>
<text top="727" left="190" width="223" height="14" font="7">forall (\arg -&gt; -- :: Type</text>
<text top="753" left="207" width="52" height="14" font="7">p arg)</text>
<text top="798" left="173" width="117" height="16" font="0">is equivalent to</text>
<text top="848" left="217" width="144" height="17" font="0">∀arg ∈ Type. p arg</text>
<text top="899" left="173" width="626" height="16" font="0">even though we do not provide a deﬁnition for the Haskell function forall in our</text>
<text top="932" left="173" width="626" height="16" font="0">model. The speciﬁcations throughout this chapter also use an exists function of</text>
<text top="964" left="173" width="626" height="16" font="0">type (a -&gt; Bool) -&gt; Bool that is an analog to the mathematical construct ∃.</text>
<text top="997" left="173" width="626" height="16" font="0">Our uses of exists follows a similar notational convention to our uses of forall.</text>
</page>
<page number="116" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">94</text>
<text top="163" left="173" width="26" height="16" font="0">5.3</text>
<text top="163" left="219" width="183" height="16" font="0">MACHINE MODEL</text>
<text top="213" left="173" width="626" height="16" font="0">As a starting point for our Rushby instantiation, we develop an abstract model</text>
<text top="246" left="173" width="626" height="16" font="0">of IA32 hardware that is suﬃciently expressive to describe the aspects of memory</text>
<text top="278" left="173" width="626" height="16" font="0">management that are relevant for describing execution environment and address-</text>
<text top="311" left="173" width="626" height="16" font="0">space integrity. The machine model serves as the state component of the Rushby</text>
<text top="343" left="173" width="626" height="16" font="0">framework, and will ultimately help us to provide meaning for the memory-safety</text>
<text top="376" left="173" width="626" height="16" font="0">property of our system. The representational choices that we make in the model</text>
<text top="408" left="173" width="626" height="16" font="0">are important because they impact the aspects of system behavior that our safety</text>
<text top="441" left="173" width="626" height="16" font="0">property will be able to capture. Any concept that we hope to describe with a</text>
<text top="473" left="173" width="626" height="16" font="0">property in the remainder of the dissertation must have appropriate hooks in the</text>
<text top="506" left="173" width="626" height="16" font="0">state. As such, our state will include high-level components that reﬂect the internal</text>
<text top="538" left="173" width="626" height="16" font="0">state of H as well as low-level components that reﬂect the state of the machine. If</text>
<text top="571" left="173" width="626" height="16" font="0">we do not capture enough details about the machine and H’s internal state, then</text>
<text top="603" left="173" width="626" height="16" font="0">we will not be able to express the appropriate properties of our implementation</text>
<text top="636" left="173" width="626" height="16" font="0">in our speciﬁcations. However, we also wish to avoid clouding the model with</text>
<text top="668" left="173" width="626" height="16" font="0">extraneous information; if we include too many details about the machine that</text>
<text top="701" left="173" width="626" height="16" font="0">are not directly related to our notion of memory-safety, then our speciﬁcation will</text>
<text top="733" left="173" width="400" height="16" font="0">become diﬃcult to understand and to reason about.</text>
<text top="766" left="199" width="600" height="16" font="0">Our ultimate goal is to capture the execution environment and address-space</text>
<text top="798" left="173" width="626" height="16" font="0">integrity properties presented at the beginning of this chapter, so we use these</text>
<text top="831" left="173" width="626" height="16" font="0">properties as the driving force guiding which concepts to include in our machine</text>
<text top="863" left="173" width="626" height="16" font="0">model. Capturing these properties requires a fairly detailed model of the structure</text>
<text top="896" left="173" width="626" height="16" font="0">of page-tables and page-directories so that we can reﬂect what happens to these</text>
<text top="928" left="173" width="626" height="16" font="0">pages during updates. We must also distinguish between memory pages used for</text>
<text top="961" left="173" width="626" height="16" font="0">diﬀerent purposes, because we cannot protect environment and page-map pages if</text>
<text top="993" left="173" width="626" height="16" font="0">we cannot identify them. We ignore many other details of the machine that do</text>
<text top="1026" left="173" width="626" height="16" font="0">not directly aﬀect the interactions between the domains of the system (the client</text>
</page>
<page number="117" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">95</text>
<text top="163" left="173" width="626" height="16" font="0">operating system, user programs, H, and the run-time system) and the protected</text>
<text top="195" left="173" width="626" height="16" font="0">classes of memory. For example, the dirty bit of a page describes whether or not</text>
<text top="228" left="173" width="626" height="16" font="0">that page has been written to and therefore provides information about the state</text>
<text top="260" left="173" width="626" height="16" font="0">and history of that page. This information is essential for a high ﬁdelity machine</text>
<text top="293" left="173" width="626" height="16" font="0">model, and is potentially important for a model that aims to capture conﬁdentiality</text>
<text top="325" left="173" width="626" height="16" font="0">properties about information ﬂow between domains. However, the value of this bit,</text>
<text top="358" left="173" width="626" height="16" font="0">and even its existence, does not aﬀect the integrity of the Haskell run-time system.</text>
<text top="390" left="173" width="626" height="16" font="0">For this reason we leave dirty bits out of our memory model, along with many</text>
<text top="423" left="173" width="576" height="16" font="0">other details of the machine that are not related to the properties at hand.</text>
<text top="455" left="199" width="600" height="16" font="0">The rest of this section introduces the components that are necessary for our</text>
<text top="488" left="173" width="626" height="16" font="0">model. Section 5.3.1 describes our representation of virtual and physical memory,</text>
<text top="520" left="173" width="626" height="16" font="0">including the virtual-address translation hardware. Section 5.3.2 presents a higher</text>
<text top="553" left="173" width="626" height="16" font="0">level view of memory in the form of physical and virtual memory regions. Sec-</text>
<text top="585" left="173" width="626" height="16" font="0">tion 5.3.3 combines the fundamental concepts of the model into a state type that</text>
<text top="618" left="173" width="305" height="16" font="0">will form the basis of our formalization.</text>
<text top="678" left="173" width="41" height="16" font="0">5.3.1</text>
<text top="678" left="234" width="263" height="16" font="0">Virtual and Physical Memory</text>
<text top="722" left="173" width="626" height="16" font="0">As in the design of the interface, we associate a dynamic status with each page</text>
<text top="754" left="173" width="626" height="16" font="0">of physical memory that reﬂects its current usage as an environment page, as a</text>
<text top="787" left="173" width="626" height="16" font="0">page-directory page, as a page-table page, or as a normal page of client-controlled</text>
<text top="819" left="173" width="626" height="16" font="0">memory. In the design chapter (Chapter 4) we explored the idea that the set of</text>
<text top="852" left="173" width="626" height="16" font="0">operations available on diﬀerent types of page are diﬀerent. In the model, we go</text>
<text top="884" left="173" width="626" height="16" font="0">one step further and distinguish the type of data stored in each page to capture</text>
<text top="917" left="173" width="479" height="16" font="0">the semantics that H associates with each of these page types.</text>
<text top="949" left="199" width="600" height="16" font="0">Table 5.1 catalogs the primitive types that we use to model physical and virtual</text>
<text top="982" left="173" width="626" height="16" font="0">addresses. We build on these primitive types and introduce a datatype to represent</text>
<text top="1014" left="173" width="626" height="16" font="0">memory pages called Page. We model the Status type described in Section 4.1 by</text>
<text top="1047" left="173" width="626" height="16" font="0">encoding each possible status value as a constructor for the Page type. Here, we</text>
</page>
<page number="118" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">96</text>
<text top="165" left="188" width="48" height="15" font="7">Name</text>
<text top="165" left="374" width="104" height="15" font="7">Width (bits)</text>
<text top="165" left="496" width="95" height="15" font="7">Description</text>
<text top="194" left="188" width="137" height="14" font="7">SuperpageAddress</text>
<text top="192" left="374" width="16" height="15" font="7">10</text>
<text top="192" left="496" width="282" height="15" font="7">Address aligned to a 4 MB page bound-</text>
<text top="219" left="496" width="282" height="15" font="7">ary. Corresponds to the top 10 bits of</text>
<text top="245" left="496" width="80" height="15" font="7">an address.</text>
<text top="273" left="188" width="129" height="14" font="7">SuperpageOffset</text>
<text top="272" left="374" width="16" height="15" font="7">10</text>
<text top="272" left="496" width="282" height="15" font="7">Oﬀset into a 4 MB page (identiﬁes a</text>
<text top="298" left="496" width="87" height="15" font="7">4 KB page).</text>
<text top="327" left="188" width="163" height="14" font="7">PhysicalPageAddress</text>
<text top="325" left="374" width="16" height="15" font="7">20</text>
<text top="325" left="496" width="282" height="15" font="7">Address aligned to a 4 KB phys-</text>
<text top="352" left="496" width="76" height="15" font="7">ical page.</text>
<text top="352" left="607" width="171" height="15" font="7">Produced by combin-</text>
<text top="378" left="496" width="22" height="15" font="7">ing</text>
<text top="378" left="537" width="8" height="15" font="7">a</text>
<text top="380" left="564" width="137" height="14" font="7">SuperpageAddress</text>
<text top="378" left="720" width="32" height="15" font="7">with</text>
<text top="378" left="770" width="8" height="15" font="7">a</text>
<text top="406" left="496" width="133" height="14" font="7">SuperpageOffset.</text>
<text top="433" left="188" width="155" height="14" font="7">PageDirectoryIndex</text>
<text top="432" left="374" width="16" height="15" font="7">10</text>
<text top="432" left="496" width="213" height="15" font="7">Index into a page-directory.</text>
<text top="432" left="733" width="46" height="15" font="7">Corre-</text>
<text top="458" left="496" width="282" height="15" font="7">sponds to the top 10 bits of a virtual</text>
<text top="485" left="496" width="58" height="15" font="7">address.</text>
<text top="513" left="188" width="120" height="14" font="7">PageTableIndex</text>
<text top="512" left="374" width="16" height="15" font="7">10</text>
<text top="512" left="496" width="178" height="15" font="7">Index into a page-table.</text>
<text top="512" left="689" width="89" height="15" font="7">Corresponds</text>
<text top="538" left="496" width="282" height="15" font="7">to the ten bits below the page-directory</text>
<text top="564" left="496" width="43" height="15" font="7">index.</text>
<text top="593" left="188" width="155" height="14" font="7">VirtualPageAddress</text>
<text top="591" left="374" width="16" height="15" font="7">20</text>
<text top="591" left="496" width="57" height="15" font="7">Address</text>
<text top="591" left="569" width="51" height="15" font="7">aligned</text>
<text top="591" left="636" width="15" height="15" font="7">to</text>
<text top="591" left="666" width="8" height="15" font="7">a</text>
<text top="591" left="690" width="8" height="15" font="7">4</text>
<text top="591" left="713" width="24" height="15" font="7">KB</text>
<text top="591" left="753" width="25" height="15" font="7">vir-</text>
<text top="618" left="496" width="28" height="15" font="7">tual</text>
<text top="618" left="541" width="37" height="15" font="7">page.</text>
<text top="618" left="617" width="68" height="15" font="7">Produced</text>
<text top="618" left="702" width="17" height="15" font="7">by</text>
<text top="618" left="735" width="43" height="15" font="7">comb-</text>
<text top="644" left="496" width="282" height="15" font="7">ing a PageDirectoryIndex with a</text>
<text top="672" left="496" width="125" height="14" font="7">PageTableIndex.</text>
<text top="699" left="188" width="52" height="14" font="7">Offset</text>
<text top="698" left="374" width="16" height="15" font="7">12</text>
<text top="698" left="496" width="282" height="15" font="7">Oﬀset into a 4 KB page. Corresponds</text>
<text top="724" left="496" width="282" height="15" font="7">to the low 12 bits of a virtual or physical</text>
<text top="751" left="496" width="58" height="15" font="7">address.</text>
<text top="779" left="188" width="129" height="14" font="7">PhysicalAddress</text>
<text top="778" left="374" width="16" height="15" font="7">32</text>
<text top="778" left="496" width="282" height="15" font="7">Address in physical memory. Produced</text>
<text top="804" left="496" width="282" height="15" font="7">by combining a PhysicalPageAddress</text>
<text top="830" left="496" width="116" height="15" font="7">with an Offset.</text>
<text top="859" left="188" width="120" height="14" font="7">VirtualAddress</text>
<text top="857" left="374" width="16" height="15" font="7">32</text>
<text top="857" left="496" width="282" height="15" font="7">Address in virtual memory. Produced</text>
<text top="884" left="496" width="282" height="15" font="7">by combing a VirtualPageAddress</text>
<text top="910" left="496" width="116" height="15" font="7">with an Offset.</text>
<text top="939" left="188" width="103" height="14" font="7">RegionLength</text>
<text top="937" left="374" width="16" height="15" font="7">32</text>
<text top="937" left="496" width="217" height="15" font="7">Length of a region of memory.</text>
<text top="993" left="173" width="626" height="16" font="0">Table 5.1: The primitive types of the model. We break virtual and physical ad-</text>
<text top="1028" left="173" width="626" height="16" font="0">dresses into these ﬁne-grained components to capture the meaning of each element</text>
<text top="1062" left="173" width="626" height="16" font="0">of an address in the types. This approach provides better documentation and</text>
<text top="1097" left="173" width="528" height="16" font="0">reﬂects the alignment constraints of various operations in the model.</text>
</page>
<page number="119" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">97</text>
<text top="163" left="173" width="626" height="16" font="0">identify ﬁve possible status values for pages: environment, normal, page-directory,</text>
<text top="195" left="173" width="626" height="16" font="0">page-table, and uninstalled. The addition of an uninstalled status value reﬂects</text>
<text top="228" left="173" width="626" height="16" font="0">the fact that it is possible to address physical pages that are not available on</text>
<text top="260" left="173" width="626" height="16" font="0">the machine; this possibility must be handled explicitly in the formal model for</text>
<text top="293" left="173" width="626" height="16" font="0">completeness. Each constructor has a single argument that describes the data</text>
<text top="325" left="173" width="626" height="16" font="0">currently contained in the page, except for uninstalled pages which contain no</text>
<text top="358" left="173" width="39" height="16" font="0">data.</text>
<text top="400" left="190" width="275" height="14" font="7">data Page = Environment PageData</text>
<text top="427" left="276" width="146" height="14" font="7">| Normal PageData</text>
<text top="453" left="276" width="284" height="14" font="7">| PageDirectory DirectoryPageData</text>
<text top="480" left="276" width="215" height="14" font="7">| PageTable TablePageData</text>
<text top="506" left="276" width="120" height="14" font="7">| NotInstalled</text>
<text top="550" left="173" width="626" height="16" font="0">The use of diﬀerent types for the contents of page directories, page tables, and</text>
<text top="582" left="173" width="626" height="16" font="0">environment/normal pages reﬂects the semantic distinction between these pages</text>
<text top="615" left="173" width="626" height="16" font="0">from the perspective of H. In this chapter, we will use the following predicates,</text>
<text top="647" left="173" width="480" height="16" font="0">deﬁned in the obvious way, to test the status of speciﬁc pages.</text>
<text top="690" left="190" width="464" height="14" font="7">isEnvironment, isNormal, isPageDirectory, isPageTable,</text>
<text top="716" left="207" width="95" height="14" font="7">isInstalled</text>
<text top="716" left="319" width="129" height="14" font="7">:: Page -&gt; Bool</text>
<text top="760" left="173" width="626" height="16" font="0">We use tests like these in the speciﬁcation to describe conditions that must hold</text>
<text top="792" left="173" width="626" height="16" font="0">for the set of pages with a particular status, especially in the well-formedness</text>
<text top="825" left="173" width="194" height="16" font="0">deﬁnitions of Section 5.6.</text>
<text top="857" left="199" width="600" height="16" font="0">Both environment pages and normal pages store generic data as far as H is</text>
<text top="890" left="173" width="626" height="16" font="0">concerned. H will never write to or read from locations in these pages. We model</text>
<text top="922" left="173" width="626" height="16" font="0">the contents of these pages so that we can model the execution of the full system:</text>
<text top="955" left="173" width="626" height="16" font="0">the Haskell run-time system reads from and writes to the environment pages; a</text>
<text top="987" left="173" width="626" height="16" font="0">kernel reads from and writes to normal pages that are mapped into kernel-space;</text>
<text top="1020" left="173" width="626" height="16" font="0">and user-level programs read from and write to normal pages that are mapped</text>
<text top="1052" left="173" width="626" height="16" font="0">into user-space. Because there are no special semantics associated with the data</text>
</page>
<page number="120" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">98</text>
<text top="163" left="173" width="626" height="16" font="0">of these pages, we model their contents as bytes and a complete page as a function</text>
<text top="195" left="173" width="176" height="16" font="0">from Offsets to bytes.</text>
<text top="235" left="190" width="266" height="14" font="7">type PageData = Offset -&gt; Word8</text>
<text top="276" left="199" width="600" height="16" font="0">The semantics of the data contained in page-directories and page-tables is spec-</text>
<text top="309" left="173" width="626" height="16" font="0">iﬁed by the IA32 architecture. We model page-directory data as a function from a</text>
<text top="341" left="173" width="626" height="16" font="0">page-directory index (the top ten bits of a virtual address) to a page-directory entry</text>
<text top="374" left="173" width="626" height="16" font="0">(called DirectoryContents). Not all page-directory indexes contain an entry—we</text>
<text top="406" left="173" width="408" height="16" font="0">explicitly represent this partiality with a Maybe type.</text>
<text top="446" left="190" width="601" height="14" font="7">type DirectoryPageData = PageDirectoryIndex -&gt; Maybe DirectoryContents</text>
<text top="487" left="173" width="626" height="16" font="0">A page-directory entry is either a superpage (for entries that use a 4 MB page)</text>
<text top="519" left="173" width="626" height="16" font="0">or a page-table (for entries that use 4 KB pages). A superpage entry contains</text>
<text top="552" left="173" width="626" height="16" font="0">the physical address of the 4 MB page mapped by the entry. A page-table entry</text>
<text top="584" left="173" width="626" height="16" font="0">contains one of these physical page addresses that points to the appropriate page-</text>
<text top="617" left="173" width="626" height="16" font="0">table. We represent 4 KB-aligned PhysicalPageAddresses as a pair containing a</text>
<text top="651" left="173" width="346" height="15" font="0">SuperpageAddress and a SuperpageOffset.</text>
<text top="689" left="190" width="438" height="14" font="7">data DirectoryContents = Superpage SuperpageAddress</text>
<text top="715" left="388" width="232" height="14" font="7">| Table PhysicalPageAddress</text>
<text top="768" left="190" width="524" height="14" font="7">type PhysicalPageAddress = (SuperpageAddress,SuperpageOffset)</text>
<text top="809" left="173" width="626" height="16" font="0">We model page-table data as a function from page-table indexes to page-table</text>
<text top="842" left="173" width="626" height="16" font="0">entries. A page-table entry is simply the physical address of the 4 KB page mapped</text>
<text top="874" left="173" width="98" height="16" font="0">by the entry.</text>
<text top="914" left="190" width="550" height="14" font="7">type TablePageData = PageTableIndex -&gt; Maybe PhysicalPageAddress</text>
<text top="955" left="173" width="626" height="16" font="0">As with page-directories, the possibility for unmapped pages is captured with a</text>
<text top="989" left="173" width="91" height="15" font="0">Maybe type.</text>
<text top="1020" left="199" width="600" height="16" font="0">We ignore permissions on page-directory and page-table entries. In our ex-</text>
<text top="1052" left="173" width="626" height="16" font="0">perience, read/write permissions complicate the formalization of properties that</text>
</page>
<page number="121" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="738" width="18" height="16" font="0">99</text>
<text top="163" left="173" width="626" height="16" font="0">relate to virtual-to-physical address translation and are not necessary for capturing</text>
<text top="195" left="173" width="626" height="16" font="0">our notion of memory-safety. Correct conﬁguration of kernel mappings using the</text>
<text top="228" left="173" width="626" height="16" font="0">user/supervisor bit is essential for deﬁning the memory-safety property—because</text>
<text top="260" left="173" width="626" height="16" font="0">the H implementation enforces separation between the run-time system and the</text>
<text top="293" left="173" width="626" height="16" font="0">user-programs by conﬁguring the run-time system pages to be accessible only in</text>
<text top="325" left="173" width="626" height="16" font="0">kernel-mode—but we model this separation without directly encoding permissions</text>
<text top="358" left="173" width="626" height="16" font="0">in the state by using well-formedness conditions (see Section 5.6). Any errors in</text>
<text top="390" left="173" width="626" height="16" font="0">the conﬁguration or speciﬁcation will be caught through a violation of the top-level</text>
<text top="423" left="173" width="626" height="16" font="0">security property, which assumes that every action produces a well-formed state,</text>
<text top="455" left="173" width="626" height="16" font="0">rather than through a permissions check. We will examine the security property</text>
<text top="488" left="173" width="109" height="16" font="0">in Section 5.5.</text>
<text top="520" left="199" width="600" height="16" font="0">The page-directory and page-table indexes that serve as oﬀsets into pages of</text>
<text top="553" left="173" width="626" height="16" font="0">those types come from our representation of page-aligned virtual addresses as a</text>
<text top="585" left="173" width="626" height="16" font="0">page-directory index paired with a page-table index, matching the semantics given</text>
<text top="618" left="173" width="418" height="16" font="0">to virtual addresses by the hardware (see Section 2.2).</text>
<text top="662" left="190" width="533" height="14" font="7">type VirtualPageAddress = (PageDirectoryIndex, PageTableIndex)</text>
<text top="707" left="173" width="626" height="16" font="0">This is similar to the representation of PhysicalPageAddress described previously</text>
<text top="739" left="173" width="418" height="16" font="0">as a superpage address paired with a superpage oﬀset.</text>
<text top="772" left="199" width="600" height="16" font="0">We model supervisor-only mappings by partitioning the virtual address-space</text>
<text top="804" left="173" width="626" height="16" font="0">into a user-space component and a kernel-space component. Mappings that reside</text>
<text top="837" left="173" width="626" height="16" font="0">in kernel-space are treated as though they are not accessible to user programs,</text>
<text top="869" left="173" width="626" height="16" font="0">even though we do not explicitly model the distinction between user and supervisor</text>
<text top="902" left="173" width="626" height="16" font="0">permission. User-space mappings are accessible to anyone. We keep the nature of</text>
<text top="934" left="173" width="626" height="16" font="0">the user-kernel boundary abstract, but provide functions for testing which space</text>
<text top="967" left="173" width="137" height="16" font="0">an address lies in.</text>
<text top="1011" left="190" width="481" height="14" font="7">isUserAddress, isKernelAddress :: VirtualAddress -&gt; Bool</text>
<text top="1037" left="190" width="584" height="14" font="7">isUserPageAddress, isKernelPageAddress :: VirtualPageAddress -&gt; Bool</text>
</page>
<page number="122" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">100</text>
<text top="163" left="173" width="626" height="16" font="0">There are space testing functions for both page-aligned and non-aligned virtual</text>
<text top="195" left="173" width="626" height="16" font="0">addresses. Certain operations of the model, such as adding a new user mapping,</text>
<text top="228" left="173" width="488" height="16" font="0">are only valid for addresses in one portion of the address-space.</text>
<text top="288" left="173" width="41" height="16" font="0">5.3.2</text>
<text top="288" left="234" width="150" height="16" font="0">Memory Regions</text>
<text top="332" left="173" width="626" height="16" font="0">As in the H design, regions of memory play an important role in our model. A</text>
<text top="364" left="173" width="626" height="16" font="0">physical region is any contiguous range of physical pages. This simple notion of</text>
<text top="397" left="173" width="626" height="16" font="0">regions leads to a simple representation as the address of the ﬁrst page in the</text>
<text top="429" left="173" width="414" height="16" font="0">region paired with the length of the region (in pages).</text>
<text top="473" left="190" width="326" height="14" font="7">data PhysicalRegion = PhysicalRegion {</text>
<text top="500" left="207" width="129" height="14" font="7">physRegionStart</text>
<text top="500" left="353" width="198" height="14" font="7">:: PhysicalPageAddress,</text>
<text top="526" left="207" width="275" height="14" font="7">physRegionLength :: RegionLength</text>
<text top="552" left="190" width="9" height="14" font="7">}</text>
<text top="597" left="173" width="626" height="16" font="0">Our representation of physical regions in the model is more general than the repre-</text>
<text top="630" left="173" width="626" height="16" font="0">sentation presented in the design chapter (see Section 4.3.1) because we allow any</text>
<text top="662" left="173" width="626" height="16" font="0">grouping of contiguous physical pages. The ﬂexpage constraints are convenient</text>
<text top="695" left="173" width="626" height="16" font="0">when implementing operations on physical regions, but they are not essential to</text>
<text top="727" left="173" width="626" height="16" font="0">the safety of the interface. The only restriction we place on physical regions in the</text>
<text top="760" left="173" width="626" height="16" font="0">model is that the entire region must lie in available memory. A more reﬁned model</text>
<text top="792" left="173" width="626" height="16" font="0">could add the ﬂexpage constraints to the PhysicalRegion type to more closely</text>
<text top="825" left="173" width="346" height="16" font="0">approximate the level of the implementation.</text>
<text top="857" left="199" width="600" height="16" font="0">Though our representation of regions is simple, it is not the best ﬁt for some</text>
<text top="890" left="173" width="626" height="16" font="0">of the properties that we would like to write about regions. For example, quantiﬁ-</text>
<text top="922" left="173" width="626" height="16" font="0">cation over the pages of a region occurs frequently, which might make a list or set</text>
<text top="955" left="173" width="626" height="16" font="0">operation more ideal. We avoid these representations because they make it harder</text>
<text top="987" left="173" width="626" height="16" font="0">to ensure that the pages of a given region are contiguous in physical memory. In-</text>
<text top="1020" left="173" width="626" height="16" font="0">stead, we deﬁne functions that map our representation onto structures that make</text>
</page>
<page number="123" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">101</text>
<text top="163" left="173" width="626" height="16" font="0">property formulation easier. For example, toListPhysicalRegion enumerates the</text>
<text top="195" left="173" width="295" height="16" font="0">pages contained in a particular region.</text>
<text top="239" left="190" width="541" height="14" font="7">toListPhysicalRegion :: PhysicalRegion -&gt; [PhysicalPageAddress]</text>
<text top="286" left="173" width="626" height="15" font="0">memberPhysicalRegion determines whether a particular page is contained by a</text>
<text top="317" left="173" width="165" height="16" font="0">given physical region.</text>
<text top="360" left="190" width="593" height="14" font="7">memberPhysicalRegion :: PhysicalPageAddress -&gt; PhysicalRegion -&gt; Bool</text>
<text top="405" left="173" width="626" height="16" font="0">Another useful function on regions calculates whether one region is a subregion of</text>
<text top="438" left="173" width="63" height="16" font="0">another.</text>
<text top="482" left="190" width="541" height="14" font="7">isPhysicalSubregion :: PhysicalRegion -&gt; PhysicalRegion -&gt; Bool</text>
<text top="527" left="199" width="600" height="16" font="0">We track the initial set of physical regions (the regions that are returned by a</text>
<text top="559" left="173" width="626" height="16" font="0">call to the interface primitive initialRegions) and the set of all active region han-</text>
<text top="592" left="173" width="626" height="16" font="0">dles (the initial regions plus those that have been produced by a call to the interface</text>
<text top="624" left="173" width="626" height="16" font="0">function deriveRegion) in a type called RegionState. This approach diﬀers from</text>
<text top="657" left="173" width="626" height="16" font="0">our implementation, where we use an abstract datatype to represent physical re-</text>
<text top="689" left="173" width="626" height="16" font="0">gions and therefore do not need to track the set of active handles. We choose to</text>
<text top="722" left="173" width="626" height="16" font="0">track set of active handles in the state of our model because we can quantify over</text>
<text top="754" left="173" width="626" height="16" font="0">this set as a convenient mechanism for expressing properties about the memory</text>
<text top="787" left="173" width="626" height="16" font="0">that is pointed to by region handles, for example, that a PhysicalRegion never</text>
<text top="819" left="173" width="617" height="16" font="0">includes any environment pages. We will explore these properties in Section 5.6.</text>
<text top="863" left="190" width="275" height="14" font="7">data RegionState = RegionState {</text>
<text top="889" left="207" width="318" height="14" font="7">initialRegions :: Set PhysicalRegion,</text>
<text top="916" left="207" width="275" height="14" font="7">allRegions :: Set PhysicalRegion</text>
<text top="942" left="190" width="9" height="14" font="7">}</text>
<text top="987" left="173" width="626" height="16" font="0">The initial regions and the set of all regions are tracked separately because H</text>
<text top="1020" left="173" width="626" height="16" font="0">provides a function for querying the set of initial regions at any time during system</text>
<text top="1052" left="173" width="78" height="16" font="0">execution.</text>
</page>
<page number="124" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">102</text>
<text top="163" left="199" width="600" height="16" font="0">Virtual regions are handled in the same fashion as physical regions and describe</text>
<text top="195" left="173" width="266" height="16" font="0">contiguous ranges of virtual pages.</text>
<text top="238" left="190" width="309" height="14" font="7">data VirtualRegion = VirtualRegion {</text>
<text top="264" left="207" width="129" height="14" font="7">virtRegionStart</text>
<text top="264" left="353" width="189" height="14" font="7">:: VirtualPageAddress,</text>
<text top="291" left="207" width="378" height="14" font="7">virtRegionLength :: RegionLength -- in pages</text>
<text top="317" left="190" width="9" height="14" font="7">}</text>
<text top="360" left="173" width="626" height="16" font="0">As with physical regions, we deﬁne utility functions on virtual regions to make</text>
<text top="393" left="173" width="626" height="16" font="0">working with them easier: toListVirtualRegion converts a virtual region into</text>
<text top="425" left="173" width="626" height="16" font="0">the list of pages that the region contains and memberVirtualRegion tests if a</text>
<text top="458" left="173" width="330" height="16" font="0">page belongs to a particular virtual region.</text>
<text top="500" left="190" width="515" height="14" font="7">toListVirtualRegion :: VirtualRegion -&gt; [VirtualPageAddress]</text>
<text top="527" left="190" width="567" height="14" font="7">memberVirtualRegion :: VirtualPageAddress -&gt; VirtualRegion -&gt; Bool</text>
<text top="570" left="199" width="600" height="16" font="0">Virtual regions must belong to either the user portion of the address space or</text>
<text top="603" left="173" width="626" height="16" font="0">the kernel portion of the address space. We disallow regions that span both spaces</text>
<text top="635" left="173" width="626" height="16" font="0">or that overﬂow. The predicates isUserRegion and isKernelRegion indicate</text>
<text top="668" left="173" width="413" height="16" font="0">which portion of the address space a region describes.</text>
<text top="710" left="190" width="455" height="14" font="7">isUserRegion, isKernelRegion :: VirtualRegion -&gt; Bool</text>
<text top="754" left="173" width="626" height="16" font="0">The virtual region must be entirely contained in the appropriate portion of the</text>
<text top="786" left="173" width="626" height="16" font="0">address space for the corresponding predicate to return True. Thus, there is no</text>
<text top="819" left="173" width="626" height="16" font="0">region for which both isUserRegion and isKernelRegion are both true but there</text>
<text top="851" left="173" width="379" height="16" font="0">may be regions for which neither predicate holds.</text>
<text top="911" left="173" width="41" height="16" font="0">5.3.3</text>
<text top="911" left="234" width="127" height="16" font="0">Machine State</text>
<text top="955" left="173" width="626" height="16" font="0">In our model, the state tracks the current page-directory (the CR3 register), the</text>
<text top="987" left="173" width="626" height="16" font="0">reference page-directory, the status and contents of each page available on the ma-</text>
<text top="1020" left="173" width="626" height="16" font="0">chine, and the current set of region handles. The reference page-directory is a spe-</text>
<text top="1052" left="173" width="626" height="16" font="0">cial page-directory that contains all of the kernel-mappings, including the mappings</text>
</page>
<page number="125" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">103</text>
<text top="163" left="173" width="626" height="16" font="0">for the Haskell run-time system. We use the reference page-directory to represent</text>
<text top="195" left="173" width="626" height="16" font="0">kernel-only mappings in lieu of an explicit representation of the user/supervisor</text>
<text top="228" left="173" width="626" height="16" font="0">bit. Any page that is mapped in the reference page-directory is treated as though</text>
<text top="260" left="173" width="626" height="16" font="0">it were mapped with kernel-only permission in the hardware. We also use the refer-</text>
<text top="293" left="173" width="626" height="16" font="0">ence page-directory as an implementation technique for ensuring that the run-time</text>
<text top="325" left="173" width="626" height="16" font="0">system, H, and the kernel have the same view of memory in every address-space</text>
<text top="358" left="173" width="626" height="16" font="0">(see Section 6.7). Modeling the reference page-directory in the state allows us to</text>
<text top="390" left="173" width="626" height="16" font="0">formalize the property that every address space has a consistent view of kernel-</text>
<text top="423" left="173" width="46" height="16" font="0">space.</text>
<text top="467" left="190" width="172" height="14" font="7">data State = State {</text>
<text top="493" left="207" width="26" height="14" font="7">cr3</text>
<text top="493" left="293" width="146" height="14" font="7">:: PageDirectory,</text>
<text top="520" left="207" width="232" height="14" font="7">reference :: PageDirectory,</text>
<text top="546" left="207" width="52" height="14" font="7">status</text>
<text top="546" left="293" width="266" height="14" font="7">:: PhysicalPageAddress -&gt; Page,</text>
<text top="572" left="207" width="60" height="14" font="7">regions</text>
<text top="572" left="293" width="120" height="14" font="7">:: RegionState</text>
<text top="599" left="190" width="9" height="14" font="7">}</text>
<text top="652" left="190" width="344" height="14" font="7">type PageDirectory = PhysicalPageAddress</text>
<text top="697" left="173" width="626" height="16" font="0">We represent CR3 and the reference page-directory as physical address pointers</text>
<text top="729" left="173" width="626" height="16" font="0">to page-directories. We introduce a type synonym called PageDirectory for doc-</text>
<text top="762" left="173" width="626" height="16" font="0">umentation. The page data is stored in a status component that maps physical</text>
<text top="794" left="173" width="626" height="16" font="0">page addresses to the information about the corresponding physical pages. The</text>
<text top="827" left="173" width="442" height="16" font="0">region handles are contained in a RegionState structure.</text>
<text top="859" left="199" width="600" height="16" font="0">Not all values of the state type are acceptable. Some possible values of this type</text>
<text top="892" left="173" width="626" height="16" font="0">might describe states that are unsafe or that H should never allow the system to</text>
<text top="924" left="173" width="626" height="16" font="0">enter. In Section 5.6 we will formulate a series of well-formedness constraints that</text>
<text top="957" left="173" width="626" height="16" font="0">describe the essential properties we expect of a memory-safe state. For example,</text>
<text top="989" left="173" width="626" height="16" font="0">the set of region handles should never provide access to environment pages. In</text>
<text top="1022" left="173" width="493" height="16" font="0">a safe system, these constraints will hold on the initial state (s</text>
<text top="1029" left="666" width="6" height="11" font="2">0</text>
<text top="1022" left="680" width="119" height="16" font="0">is well-formed),</text>
</page>
<page number="126" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">104</text>
<text top="163" left="173" width="626" height="16" font="0">and every action in the system will produce a well-formed state given a well-</text>
<text top="195" left="173" width="626" height="16" font="0">formed input state. This inductive argument will help us to demonstrate safety</text>
<text top="228" left="173" width="626" height="16" font="0">for arbitrary executions of the system using only properties of the local transitions</text>
<text top="260" left="173" width="625" height="16" font="0">from state to state. We will deﬁne a single predicate on states called wellFormed</text>
<text top="293" left="173" width="626" height="16" font="0">that encompasses all of the well-formedness constraints of our model. In terms of</text>
<text top="325" left="173" width="604" height="16" font="0">this predicate, the inductive argument corresponds to the following properties.</text>
<text top="368" left="580" width="101" height="16" font="0">wellFormed s</text>
<text top="374" left="681" width="6" height="11" font="2">0</text>
<text top="404" left="220" width="468" height="17" font="0">∀s ∈ State, ∀op ∈ A.wellFormed s ⇒ wellFormed step(s, op)</text>
<text top="443" left="173" width="626" height="16" font="0">Recall that A is the set of actions in the Rushby framework. We will examine the</text>
<text top="475" left="173" width="533" height="16" font="0">speciﬁc nature of these actions for our system model in Section 5.4.1.</text>
<text top="532" left="173" width="265" height="16" font="0">Example: Address Translation</text>
<text top="532" left="456" width="351" height="16" font="0">The state associated with page-directory pages</text>
<text top="565" left="173" width="626" height="16" font="0">and page-table pages represents a mapping in memory that the hardware uses to</text>
<text top="597" left="173" width="626" height="16" font="0">perform virtual-to-physical address translations. The constructs in our model pro-</text>
<text top="630" left="173" width="626" height="16" font="0">vide a basis for deﬁning this translation function. We model address translation in</text>
<text top="662" left="173" width="626" height="16" font="0">hardware with two functions: translatePage computes the physical page address</text>
<text top="695" left="173" width="626" height="16" font="0">that a virtual page address maps to in any page-directory and translation trans-</text>
<text top="727" left="173" width="626" height="16" font="0">lates a virtual-address to a physical one in the current page-directory (CR3). In</text>
<text top="760" left="173" width="626" height="16" font="0">both cases, the result is a Maybe value because of the potential that the requested</text>
<text top="792" left="173" width="234" height="16" font="0">virtual address is not mapped.</text>
<text top="826" left="199" width="600" height="15" font="0">translatePage is a general function that may be used to examine and com-</text>
<text top="857" left="173" width="626" height="16" font="0">pare the mappings in any page directory. This function walks the hardware tables,</text>
<text top="890" left="173" width="626" height="16" font="0">ﬁrst examining the page-directory entry for the virtual-address and then (if nec-</text>
<text top="922" left="173" width="626" height="16" font="0">essary), examining the appropriate page-table. We write translatePage using</text>
<text top="955" left="173" width="626" height="16" font="0">do-notation in the Maybe monad (see Section 3.4) to handle failures within the</text>
<text top="987" left="173" width="417" height="16" font="0">deﬁnition concisely (including pattern-match failures).</text>
<text top="1028" left="190" width="524" height="14" font="7">translatePage :: State -&gt; PageDirectory -&gt; VirtualPageAddress</text>
<text top="1055" left="207" width="241" height="14" font="7">-&gt; Maybe PhysicalPageAddress</text>
</page>
<page number="127" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">105</text>
<text top="165" left="190" width="241" height="14" font="7">translatePage s pd (pdi,pti)</text>
<text top="192" left="207" width="430" height="14" font="7">= do PageDirectory dirpage &lt;- return (status s pd)</text>
<text top="218" left="250" width="155" height="14" font="7">pde &lt;- dirpage pdi</text>
<text top="245" left="250" width="95" height="14" font="7">case pde of</text>
<text top="271" left="267" width="515" height="14" font="7">Table ppa -&gt; do PageTable tablepage &lt;- return (status s ppa)</text>
<text top="297" left="405" width="112" height="14" font="7">tablepage pti</text>
<text top="324" left="267" width="447" height="14" font="7">Superpage spa -&gt; return (spa, toSuperpageOffset pti)</text>
<text top="363" left="173" width="626" height="16" font="0">There are several places where the computation might fail because the page be-</text>
<text top="396" left="173" width="626" height="16" font="0">ing translated is not mapped or because the data structures do not contain well-</text>
<text top="428" left="173" width="626" height="16" font="0">formed data. For example, the status of the page-directory being traversed must</text>
<text top="461" left="173" width="626" height="16" font="0">be PageDirectory. Some potential errors—like a page-directory entry that con-</text>
<text top="493" left="173" width="626" height="16" font="0">tains a Table but does not point to a page with the PageTable status—represent</text>
<text top="526" left="173" width="626" height="16" font="0">a misconﬁguration of the system state and we would like to ensure that this never</text>
<text top="558" left="173" width="626" height="16" font="0">happens in our implementation. Ensuring that every page pointed to by a Table</text>
<text top="591" left="173" width="626" height="16" font="0">entry in a page-directory is a page-table in the current state is exactly the kind of</text>
<text top="623" left="173" width="597" height="16" font="0">property that we will capture with well-formedness constraints in Section 5.6.</text>
<text top="656" left="199" width="600" height="16" font="0">Translating a virtual address to a physical one in the current page-directory</text>
<text top="688" left="173" width="626" height="16" font="0">may be accomplished with a straightforward invocation of translatePage on the</text>
<text top="721" left="173" width="314" height="16" font="0">page-directory currently installed in cr3.</text>
<text top="759" left="190" width="524" height="14" font="7">translate :: State -&gt; VirtualAddress -&gt; Maybe PhysicalAddress</text>
<text top="785" left="190" width="533" height="14" font="7">translate s (vpa, off) = do ppa &lt;- translatePage s (cr3 s) vpa</text>
<text top="812" left="431" width="146" height="14" font="7">return (ppa, off)</text>
<text top="851" left="173" width="626" height="16" font="0">Testing whether or not a particular page is mapped in a particular page-directory is</text>
<text top="883" left="173" width="626" height="16" font="0">accomplished by testing if translatePage returns a value constructed with Just.</text>
<text top="921" left="190" width="567" height="14" font="7">mappedPage :: State -&gt; PageDirectory -&gt; VirtualPageAddress -&gt; Bool</text>
<text top="948" left="190" width="455" height="14" font="7">mappedPage s pd vpa = isJust (translatePage s pd vpa)</text>
<text top="987" left="173" width="626" height="16" font="0">Typically we only care if a page is unmapped in all page-directories, rather than</text>
<text top="1020" left="173" width="626" height="16" font="0">in some particular page-directory. The function unmappedPage is true when no</text>
<text top="1052" left="173" width="329" height="16" font="0">page-directory maps a given physical page.</text>
</page>
<page number="128" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">106</text>
<text top="165" left="190" width="447" height="14" font="7">unmappedPage :: State -&gt; PhysicalPageAddress -&gt; Bool</text>
<text top="192" left="190" width="155" height="14" font="7">unmappedPage s ppa</text>
<text top="218" left="207" width="361" height="14" font="7">= forall (\pd -&gt; -- :: PhysicalPageAddress</text>
<text top="245" left="242" width="344" height="14" font="7">forall (\vpa -&gt; -- :: VirtualPageAddress</text>
<text top="271" left="259" width="258" height="14" font="7">case translatePage s pd vpa of</text>
<text top="297" left="276" width="129" height="14" font="7">Nothing -&gt; True</text>
<text top="324" left="276" width="223" height="14" font="7">Just ppa’ -&gt; ppa /= ppa’))</text>
<text top="369" left="173" width="626" height="16" font="0">The wrapper unmappedNormalPage tests if a page has a normal status and is</text>
<text top="401" left="173" width="256" height="16" font="0">unmapped in all page-directories.</text>
<text top="445" left="190" width="498" height="14" font="7">unmappedNormalPage :: State -&gt; PhysicalPageAddress -&gt; Bool</text>
<text top="472" left="190" width="576" height="14" font="7">unmappedNormalPage s ppa = isNormalPage s ppa &amp;&amp; unmappedPage s ppa</text>
<text top="517" left="173" width="626" height="16" font="0">These functions help us to express properties of translatePage more concisely in</text>
<text top="549" left="173" width="130" height="16" font="0">our speciﬁcation.</text>
<text top="611" left="173" width="26" height="16" font="0">5.4</text>
<text top="611" left="219" width="244" height="16" font="0">PROTECTION DOMAINS</text>
<text top="661" left="173" width="626" height="16" font="0">In this section we continue the process of instantiating the Rushby formalism to</text>
<text top="694" left="173" width="626" height="16" font="0">ﬁt our system. We focus on the essential components of protection domains: the</text>
<text top="726" left="173" width="626" height="16" font="0">set of domains in our system, the actions of those domains, and the portion of the</text>
<text top="759" left="173" width="626" height="16" font="0">system state that is accessible to each domain. We deﬁne the policy that governs</text>
<text top="791" left="173" width="342" height="16" font="0">interactions between domains in Section 5.5.</text>
<text top="824" left="199" width="600" height="16" font="0">Protection domains are the unit of resource protection and they represent the</text>
<text top="856" left="173" width="626" height="16" font="0">actors in a Rushby-style system. Each domain has a portion of the global state</text>
<text top="889" left="173" width="626" height="16" font="0">that it may view—its resources—and a set of actions that it may perform—its</text>
<text top="921" left="173" width="626" height="16" font="0">executable instructions. The security policy describes the eﬀect that these actions</text>
<text top="954" left="173" width="626" height="16" font="0">may have on the system state by specifying the domains that will be able to view</text>
<text top="986" left="173" width="626" height="16" font="0">the results of a particular domain’s actions. For example, a separation kernel might</text>
<text top="1019" left="173" width="626" height="16" font="0">be formalized by instantiating the set of domains to be the set of user processes</text>
<text top="1051" left="173" width="609" height="16" font="0">with a security policy that states that no process may interfere with any other.</text>
</page>
<page number="129" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">107</text>
<text top="163" left="199" width="600" height="16" font="0">In our system, the domains correspond to the basic components of our system:</text>
<text top="195" left="173" width="626" height="16" font="0">the H interface; the client kernel; and the user programs. Each of these components</text>
<text top="228" left="173" width="626" height="16" font="0">has a diﬀerent privilege level and therefore has the ability to perform diﬀerent</text>
<text top="260" left="173" width="626" height="16" font="0">actions and to access diﬀerent portions of the system state. In addition to these</text>
<text top="293" left="173" width="626" height="16" font="0">three domains, we model the execution environment as a domain so that we can</text>
<text top="325" left="173" width="626" height="16" font="0">capture the eﬀect that the Haskell run-time system has on the system state during</text>
<text top="358" left="173" width="78" height="16" font="0">execution.</text>
<text top="358" left="267" width="533" height="16" font="0">This gives the following list of domains, with the described set of</text>
<text top="390" left="173" width="154" height="16" font="0">allowable behaviors:</text>
<text top="438" left="196" width="603" height="16" font="0">E The environment domain. This domain is an abstract representation of the</text>
<text top="470" left="217" width="582" height="16" font="0">Haskell run-time system. The environment domain may arbitrarily write to</text>
<text top="503" left="217" width="582" height="16" font="0">any environment page and its view includes all of those pages. In this way,</text>
<text top="535" left="217" width="582" height="16" font="0">we do not assume any particular behavior of the run-time system, but allow</text>
<text top="568" left="217" width="583" height="16" font="0">the domain to observe any changes made to the environment memory during</text>
<text top="600" left="217" width="261" height="16" font="0">another domain’s turn to execute.</text>
<text top="648" left="195" width="604" height="16" font="0">H The H domain. This domain represents computations performed by the H</text>
<text top="680" left="217" width="582" height="16" font="0">interface. The H domain can view all of the protected system state, but</text>
<text top="713" left="217" width="583" height="16" font="0">should not write to environment pages. Otherwise, H has full control over</text>
<text top="745" left="217" width="583" height="16" font="0">the system state, such as the status of each memory page, the contents of</text>
<text top="778" left="217" width="583" height="16" font="0">page-map pages, and the set of memory handles. The actions available to</text>
<text top="810" left="217" width="525" height="16" font="0">the H domain include all of the operations of the H interface design.</text>
<text top="858" left="194" width="605" height="16" font="0">K The client kernel domain. This domain represents computations performed</text>
<text top="890" left="217" width="583" height="16" font="0">by the client kernel. The client kernel domain can view the normal pages</text>
<text top="923" left="217" width="551" height="16" font="0">that have been mapped into kernel-space and may write to these pages.</text>
<text top="970" left="195" width="604" height="16" font="0">U The user program domain. We group all user programs together because we</text>
<text top="1003" left="217" width="583" height="16" font="0">are not concerned about interactions between individual user-level entities,</text>
<text top="1035" left="217" width="583" height="16" font="0">just the impact that these entities have on the system state as a group. The</text>
</page>
<page number="130" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">108</text>
<text top="163" left="217" width="583" height="16" font="0">user domain can view all of the normal pages that have been mapped into</text>
<text top="195" left="217" width="514" height="16" font="0">the user portion of the address space and can write to these pages.</text>
<text top="243" left="199" width="600" height="16" font="0">We instantiate the set of domains, D, by deﬁning a datatype with values that</text>
<text top="275" left="173" width="368" height="16" font="0">correspond to each of these protection domains.</text>
<text top="319" left="190" width="189" height="14" font="7">data D = E | H | K | U</text>
<text top="376" left="173" width="41" height="16" font="0">5.4.1</text>
<text top="376" left="234" width="143" height="16" font="0">Domain Actions</text>
<text top="421" left="173" width="626" height="16" font="0">Each domain may perform certain actions that transform the system state. Ta-</text>
<text top="453" left="173" width="474" height="16" font="0">ble 5.2 describes the set of actions available to each domain.</text>
<text top="453" left="668" width="131" height="16" font="0">The eﬀects of an</text>
<text top="486" left="173" width="626" height="16" font="0">action are restricted to the portion of the system state that the associated domain</text>
<text top="518" left="173" width="626" height="16" font="0">is allowed to modify according to the security policy, which we will cover in Sec-</text>
<text top="551" left="173" width="626" height="16" font="0">tion 5.5. Note that this may be a subset of the portion of the state that the domain</text>
<text top="583" left="173" width="68" height="16" font="0">observes.</text>
<text top="616" left="199" width="600" height="16" font="0">The actions of the H domain correspond to the operations available in the H</text>
<text top="648" left="173" width="626" height="16" font="0">API. Though we do not formalize every H operation, the actions and speciﬁcations</text>
<text top="681" left="173" width="626" height="16" font="0">correspond to a representative set of the H operations. We focus on the subset of</text>
<text top="713" left="173" width="626" height="16" font="0">functions in H that are critical for memory-safety and ignore the facilities for I/O,</text>
<text top="746" left="173" width="626" height="16" font="0">debugging, and module loading. The only operation that we do not include from</text>
<text top="778" left="173" width="626" height="16" font="0">the memory management interface is modifyMapping for modifying the permissions</text>
<text top="811" left="173" width="626" height="16" font="0">attached to a mapping, which is conceptually equivalent to removing the existing</text>
<text top="843" left="173" width="626" height="16" font="0">mapping and then adding it back with the new permissions. In our current work we</text>
<text top="876" left="173" width="626" height="16" font="0">do not model permissions, so there is no interesting behavior of modifyMapping</text>
<text top="908" left="173" width="626" height="16" font="0">to specify. A write operation is available to the environment, kernel, and user</text>
<text top="941" left="173" width="68" height="16" font="0">domains.</text>
<text top="973" left="199" width="600" height="16" font="0">The set of actions, A, corresponds to a type with one constructor for each action</text>
<text top="1006" left="173" width="626" height="16" font="0">listed in Table 5.2. The arguments to the constructor are the parameters to the</text>
<text top="1038" left="173" width="52" height="16" font="0">action.</text>
</page>
<page number="131" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">109</text>
<text top="169" left="182" width="11" height="15" font="7">E</text>
<text top="170" left="235" width="112" height="14" font="7">WriteE va val</text>
<text top="169" left="476" width="313" height="15" font="7">Write value val to location va, if va is within</text>
<text top="201" left="476" width="210" height="15" font="7">the set of environment pages.</text>
<text top="234" left="182" width="12" height="15" font="7">H</text>
<text top="235" left="235" width="206" height="14" font="7">DeriveRegionH pr ppa len</text>
<text top="234" left="476" width="313" height="15" font="7">Derive a new region with start address ppa</text>
<text top="266" left="476" width="313" height="15" font="7">and length len from the existing region han-</text>
<text top="299" left="476" width="48" height="15" font="7">dle pr.</text>
<text top="333" left="235" width="223" height="14" font="7">AllocatePageDirectoryH ppa</text>
<text top="331" left="476" width="313" height="15" font="7">Convert the free normal page ppa into a</text>
<text top="364" left="476" width="145" height="15" font="7">page-directory page.</text>
<text top="398" left="235" width="180" height="14" font="7">FreePageDirectoryH pd</text>
<text top="396" left="476" width="232" height="15" font="7">Free the page-directory page pd.</text>
<text top="430" left="235" width="206" height="14" font="7">AddMappingH pd pts pr vr</text>
<text top="429" left="476" width="313" height="15" font="7">Add a user-space mapping from the vir-</text>
<text top="461" left="476" width="313" height="15" font="7">tual region vr to the physical region pr in</text>
<text top="494" left="476" width="313" height="15" font="7">the address space represented by the page-</text>
<text top="527" left="476" width="313" height="15" font="7">directory pd. Allocate page-tables from the</text>
<text top="559" left="476" width="282" height="15" font="7">list of free normal pages pts as needed.</text>
<text top="593" left="235" width="172" height="14" font="7">RemoveMappingH pd vr</text>
<text top="592" left="476" width="313" height="15" font="7">Remove the mapping to vr in address-space</text>
<text top="625" left="476" width="22" height="14" font="7">pd.</text>
<text top="658" left="235" width="198" height="14" font="7">AddKernelMappingH pr vr</text>
<text top="657" left="476" width="313" height="15" font="7">Add a kernel-space mapping from the virtual</text>
<text top="689" left="476" width="254" height="15" font="7">region vr to the physical region pr.</text>
<text top="723" left="235" width="95" height="14" font="7">ExecuteH pd</text>
<text top="722" left="476" width="313" height="15" font="7">Change the currently active page-directory</text>
<text top="754" left="476" width="42" height="15" font="7">to pd.</text>
<text top="787" left="182" width="13" height="15" font="7">K</text>
<text top="788" left="235" width="112" height="14" font="7">WriteK va val</text>
<text top="787" left="476" width="313" height="15" font="7">Write value val to location va, if va is within</text>
<text top="819" left="476" width="313" height="15" font="7">the set of normal pages mapped in kernel</text>
<text top="852" left="476" width="43" height="15" font="7">space.</text>
<text top="884" left="182" width="12" height="15" font="7">U</text>
<text top="886" left="235" width="112" height="14" font="7">WriteU va val</text>
<text top="884" left="476" width="313" height="15" font="7">Write value val to location va, if va is within</text>
<text top="917" left="476" width="313" height="15" font="7">the set of normal pages mapped in user</text>
<text top="949" left="476" width="43" height="15" font="7">space.</text>
<text top="1006" left="173" width="626" height="16" font="0">Table 5.2: The actions of each protection domain. None of the actions have outputs</text>
<text top="1041" left="173" width="626" height="16" font="0">because their eﬀect is observed through the state. We include write operations on</text>
<text top="1076" left="173" width="587" height="16" font="0">memory but not reads, because the ability to read is implicit in observation.</text>
</page>
<page number="132" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">110</text>
<text top="165" left="190" width="309" height="14" font="7">data A = WriteE VirtualAddress Word8</text>
<text top="192" left="250" width="541" height="14" font="7">| DeriveRegionH PhysicalRegion PhysicalPageAddress RegionLength</text>
<text top="218" left="250" width="378" height="14" font="7">| AllocatePageDirectoryH PhysicalPageAddress</text>
<text top="245" left="250" width="292" height="14" font="7">| FreePageDirectoryH PageDirectory</text>
<text top="271" left="250" width="421" height="14" font="7">| AddMappingH PageDirectory [PhysicalPageAddress]</text>
<text top="297" left="284" width="241" height="14" font="7">PhysicalRegion VirtualRegion</text>
<text top="324" left="250" width="378" height="14" font="7">| RemoveMappingH PageDirectory VirtualRegion</text>
<text top="350" left="250" width="412" height="14" font="7">| AddKernelMappingH PhysicalRegion VirtualRegion</text>
<text top="377" left="250" width="206" height="14" font="7">| ExecuteH PageDirectory</text>
<text top="403" left="250" width="249" height="14" font="7">| WriteK VirtualAddress Word8</text>
<text top="430" left="250" width="249" height="14" font="7">| WriteU VirtualAddress Word8</text>
<text top="474" left="173" width="626" height="16" font="0">None of the actions have outputs—their eﬀect is observed through the state. Thus,</text>
<text top="506" left="173" width="626" height="16" font="0">there is no need for an action like read, because the ability to read is implicit</text>
<text top="539" left="173" width="626" height="16" font="0">in observation. We instantiate the Rushby function that maps actions to their</text>
<text top="571" left="173" width="382" height="16" font="0">domain, called dom, in a straightforward manner.</text>
<text top="614" left="190" width="112" height="14" font="7">dom :: A -&gt; D</text>
<text top="640" left="190" width="137" height="14" font="7">dom (WriteE _ _)</text>
<text top="640" left="456" width="26" height="14" font="7">= E</text>
<text top="667" left="190" width="215" height="14" font="7">dom (DeriveRegionH _ _ _)</text>
<text top="667" left="456" width="26" height="14" font="7">= H</text>
<text top="693" left="190" width="215" height="14" font="7">dom (AddMappingH _ _ _ _)</text>
<text top="693" left="456" width="26" height="14" font="7">= H</text>
<text top="720" left="190" width="206" height="14" font="7">dom (RemoveMappingH _ _)</text>
<text top="720" left="456" width="26" height="14" font="7">= H</text>
<text top="746" left="190" width="232" height="14" font="7">dom (AddKernelMappingH _ _)</text>
<text top="746" left="456" width="26" height="14" font="7">= H</text>
<text top="772" left="190" width="292" height="14" font="7">dom (AllocatePageDirectoryH _) = H</text>
<text top="799" left="190" width="223" height="14" font="7">dom (FreePageDirectoryH _)</text>
<text top="799" left="456" width="26" height="14" font="7">= H</text>
<text top="825" left="190" width="137" height="14" font="7">dom (ExecuteH _)</text>
<text top="825" left="456" width="26" height="14" font="7">= H</text>
<text top="852" left="190" width="137" height="14" font="7">dom (WriteK _ _)</text>
<text top="852" left="456" width="26" height="14" font="7">= K</text>
<text top="878" left="190" width="137" height="14" font="7">dom (WriteU _ _)</text>
<text top="878" left="456" width="26" height="14" font="7">= U</text>
<text top="922" left="173" width="626" height="16" font="0">The naming scheme for actions makes the mapping obvious—each action belongs</text>
<text top="955" left="173" width="416" height="16" font="0">to the domain speciﬁed by the ﬁnal letter of its name.</text>
<text top="987" left="199" width="600" height="16" font="0">In Section 5.7 we will specify the appropriate behavior of each action in the</text>
<text top="1020" left="173" width="626" height="16" font="0">Rushby model as a relation between before and after states. These speciﬁcations</text>
<text top="1052" left="173" width="626" height="16" font="0">provide a connection between the abstract notion of memory-safety and the H</text>
</page>
<page number="133" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">111</text>
<text top="163" left="173" width="626" height="16" font="0">implementation code. A correct implementation of an H operation must satisfy</text>
<text top="195" left="173" width="626" height="16" font="0">the corresponding speciﬁcation. The link between a functional action of type A</text>
<text top="228" left="173" width="489" height="16" font="0">and the corresponding speciﬁcation is provided by actionSpec:</text>
<text top="268" left="190" width="369" height="14" font="7">actionSpec :: A -&gt; (State -&gt; State -&gt; Bool)</text>
<text top="294" left="190" width="206" height="14" font="7">actionSpec (WriteE va w)</text>
<text top="294" left="534" width="112" height="14" font="7">= writeE va w</text>
<text top="320" left="190" width="318" height="14" font="7">actionSpec (DeriveRegionH pr ppa len)</text>
<text top="320" left="534" width="223" height="14" font="7">= deriveRegionH pr ppa len</text>
<text top="347" left="190" width="584" height="14" font="7">actionSpec (AllocatePageDirectoryH ppa) = allocatePageDirectoryH ppa</text>
<text top="373" left="190" width="292" height="14" font="7">actionSpec (FreePageDirectoryH pd)</text>
<text top="373" left="534" width="198" height="14" font="7">= freePageDirectoryH pd</text>
<text top="400" left="190" width="318" height="14" font="7">actionSpec (AddMappingH pd pts pr vr)</text>
<text top="400" left="534" width="223" height="14" font="7">= addMappingH pd pts pr vr</text>
<text top="426" left="190" width="284" height="14" font="7">actionSpec (RemoveMappingH pd vr)</text>
<text top="426" left="534" width="189" height="14" font="7">= removeMappingH pd vr</text>
<text top="453" left="190" width="309" height="14" font="7">actionSpec (AddKernelMappingH pr vr)</text>
<text top="453" left="534" width="215" height="14" font="7">= addKernelMappingH pr vr</text>
<text top="479" left="190" width="206" height="14" font="7">actionSpec (ExecuteH pd)</text>
<text top="479" left="534" width="112" height="14" font="7">= executeH pd</text>
<text top="505" left="190" width="206" height="14" font="7">actionSpec (WriteK va w)</text>
<text top="505" left="534" width="112" height="14" font="7">= writeK va w</text>
<text top="532" left="190" width="206" height="14" font="7">actionSpec (WriteU va w)</text>
<text top="532" left="534" width="112" height="14" font="7">= writeU va w</text>
<text top="573" left="173" width="626" height="16" font="0">Though actionSpec relates all values of type State, we do not consider all possible</text>
<text top="605" left="173" width="626" height="16" font="0">states to be valid. There are certain basic properties of states that must hold in</text>
<text top="638" left="173" width="626" height="16" font="0">order for memory-safety to be meaningful in an H-based system. A state that</text>
<text top="670" left="173" width="626" height="16" font="0">satisﬁes these properties is well-formed ; we will deﬁne well-formedness precisely</text>
<text top="703" left="173" width="626" height="16" font="0">in Section 5.6. We integrate well-formedness into our model by projecting the</text>
<text top="737" left="173" width="626" height="15" font="0">actionSpec relation to well-formed states (as described in Section 5.8.1); within</text>
<text top="768" left="173" width="626" height="16" font="0">the relational speciﬁcations themselves we will therefore assume that the before</text>
<text top="800" left="173" width="248" height="16" font="0">and after states are well-formed.</text>
<text top="857" left="173" width="158" height="16" font="0">View-Partitioning</text>
<text top="857" left="348" width="451" height="16" font="0">We capture the notion of observable state through a set of</text>
<text top="890" left="173" width="626" height="16" font="0">view types that represent the portion of the state that is accessible to each domain.</text>
<text top="922" left="173" width="626" height="16" font="0">There is a distinct view type for each domain: EView describes the state of the</text>
<text top="955" left="173" width="626" height="16" font="0">environment domain, HView describes the H domain state, KView describes the</text>
<text top="987" left="173" width="626" height="16" font="0">kernel domain state, and UView describes the user domain state. We also deﬁne a</text>
<text top="1020" left="173" width="626" height="16" font="0">view function for each domain that extracts the portion of a particular state that</text>
<text top="1052" left="173" width="193" height="16" font="0">is visible to that domain.</text>
</page>
<page number="134" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">112</text>
<text top="163" left="199" width="600" height="16" font="0">The environment domain observes the data of the environment pages. It implic-</text>
<text top="195" left="173" width="626" height="16" font="0">itly relies on the virtual-to-physical mappings that allow environment page data</text>
<text top="228" left="173" width="626" height="16" font="0">to be read and written, even though the environment cannot observe the contents</text>
<text top="260" left="173" width="626" height="16" font="0">of page-directories and page-tables directly. A fundamental property of the envi-</text>
<text top="293" left="173" width="626" height="16" font="0">ronment domain is that the environment will always have the same pages available</text>
<text top="325" left="173" width="626" height="16" font="0">to it, no matter what address-space is currently active. Furthermore, no one may</text>
<text top="358" left="173" width="626" height="16" font="0">alter the mappings for the environment domain pages, for example, by remapping</text>
<text top="390" left="173" width="626" height="16" font="0">an environment page at a diﬀerent virtual-address. By observing the environment</text>
<text top="423" left="173" width="626" height="16" font="0">page data, and implicitly observing the mappings that link virtual addresses to</text>
<text top="455" left="173" width="626" height="16" font="0">physical ones, the environment domain can also witness the existence of multiply</text>
<text top="488" left="173" width="626" height="16" font="0">mapped physical pages. For example, if the environment domain has access to two</text>
<text top="520" left="173" width="514" height="16" font="0">virtual-addresses that map to the same physical address, called v</text>
<text top="527" left="687" width="6" height="11" font="2">1</text>
<text top="520" left="702" width="44" height="16" font="0">and v</text>
<text top="527" left="745" width="6" height="11" font="2">2</text>
<text top="520" left="752" width="47" height="16" font="0">, then</text>
<text top="553" left="173" width="431" height="16" font="0">the domain has the potential to notice that writes to v</text>
<text top="560" left="603" width="6" height="11" font="2">1</text>
<text top="553" left="617" width="182" height="16" font="0">change the data that is</text>
<text top="585" left="173" width="154" height="16" font="0">accessible through v</text>
<text top="592" left="326" width="6" height="11" font="2">2</text>
<text top="585" left="334" width="5" height="16" font="0">.</text>
<text top="618" left="199" width="600" height="16" font="0">We represent the view of the environment domain as a function from virtual</text>
<text top="650" left="173" width="626" height="16" font="0">page addresses to the observable information about pages. The use of virtual ad-</text>
<text top="683" left="173" width="626" height="16" font="0">dresses captures the implicit reliance on virtual-to-physical mappings. We deﬁne a</text>
<text top="715" left="173" width="626" height="16" font="0">reference count function based on virtual addresses that computes how many pages</text>
<text top="748" left="173" width="626" height="16" font="0">are also mapped to the same underlying physical page. We use the type Nat, for</text>
<text top="780" left="173" width="626" height="16" font="0">natural numbers, to indicate that the reference count should not be negative. Using</text>
<text top="813" left="173" width="626" height="16" font="0">this function, we deﬁne the observable information about a particular environment</text>
<text top="845" left="173" width="626" height="16" font="0">page to be the contents of that page paired with the reference count for that page.</text>
<text top="878" left="173" width="603" height="16" font="0">There is no observable data for pages that do not have an environment status.</text>
<text top="922" left="190" width="172" height="14" font="7">data EView = EView {</text>
<text top="948" left="207" width="541" height="14" font="7">eObservablePages :: VirtualPageAddress -&gt; Maybe (PageData, Nat)</text>
<text top="975" left="190" width="9" height="14" font="7">}</text>
<text top="1020" left="173" width="626" height="16" font="0">The view function of the environment domain ﬁnds the pages in the speciﬁed state</text>
<text top="1052" left="173" width="626" height="16" font="0">with the Environment type and constructs an EView value where precisely these</text>
</page>
<page number="135" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">113</text>
<text top="163" left="173" width="626" height="16" font="0">pages are observable. We assume the existence of a list containing the addresses</text>
<text top="195" left="173" width="626" height="16" font="0">of all available virtual page addresses, called allVirtualPages, for computing the</text>
<text top="228" left="173" width="121" height="16" font="0">reference count.</text>
<text top="272" left="181" width="198" height="14" font="7">viewE :: State -&gt; EView</text>
<text top="298" left="181" width="223" height="14" font="7">viewE s = EView observable</text>
<text top="325" left="199" width="172" height="14" font="7">where observable vpa</text>
<text top="351" left="267" width="335" height="14" font="7">= do ppa &lt;- translatePage s (cr3 s) vpa</text>
<text top="377" left="310" width="387" height="14" font="7">Environment contents &lt;- return (status s ppa)</text>
<text top="404" left="310" width="404" height="14" font="7">return (contents, referenceCount s (cr3 s) ppa)</text>
<text top="457" left="181" width="146" height="14" font="7">referenceCount ::</text>
<text top="483" left="199" width="498" height="14" font="7">State -&gt; PhysicalPageAddress -&gt; PhysicalPageAddress -&gt; Nat</text>
<text top="510" left="181" width="198" height="14" font="7">referenceCount s pd ppa</text>
<text top="536" left="199" width="601" height="14" font="7">= length [translatePage s pd vpa == Just ppa | vpa &lt;- allVirtualPages]</text>
<text top="589" left="181" width="335" height="14" font="7">allVirtualPages :: [VirtualPageAddress]</text>
<text top="634" left="173" width="626" height="16" font="0">Pages that are not a member of the environment will never be projected in the</text>
<text top="666" left="173" width="114" height="16" font="0">observable list.</text>
<text top="699" left="199" width="600" height="16" font="0">The H domain observes the entire system except for the contents of user and</text>
<text top="731" left="173" width="626" height="16" font="0">kernel data pages. Thus, the view of H contains the current page-directory, the</text>
<text top="764" left="173" width="626" height="16" font="0">status mapping for physical pages, the region handles, and the reference page-</text>
<text top="796" left="173" width="626" height="16" font="0">directory. The pages function returns Nothing for pages whose status is Normal.</text>
<text top="829" left="173" width="626" height="16" font="0">In this way, H can deduce that a physical address mapped to Nothing is Normal</text>
<text top="861" left="173" width="234" height="16" font="0">but it cannot see the contents.</text>
<text top="905" left="181" width="172" height="14" font="7">data HView = HView {</text>
<text top="932" left="310" width="95" height="14" font="7">currentPdir</text>
<text top="932" left="448" width="146" height="14" font="7">:: PageDirectory,</text>
<text top="958" left="310" width="43" height="14" font="7">pages</text>
<text top="958" left="448" width="318" height="14" font="7">:: PhysicalPageAddress -&gt; Maybe Page,</text>
<text top="984" left="310" width="120" height="14" font="7">hRegionHandles</text>
<text top="984" left="448" width="129" height="14" font="7">:: RegionState,</text>
<text top="1011" left="310" width="112" height="14" font="7">referencePdir</text>
<text top="1011" left="448" width="137" height="14" font="7">:: PageDirectory</text>
<text top="1037" left="293" width="9" height="14" font="7">}</text>
</page>
<page number="136" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">114</text>
<text top="163" left="173" width="626" height="16" font="0">The view function of the H domain projects cr3, the region handles, and the</text>
<text top="195" left="173" width="626" height="16" font="0">reference page-directory from the speciﬁed state. The view also includes page</text>
<text top="228" left="173" width="476" height="16" font="0">descriptions for all physical pages whose status is not Normal.</text>
<text top="267" left="190" width="198" height="14" font="7">viewH :: State -&gt; HView</text>
<text top="294" left="190" width="473" height="14" font="7">viewH s = HView (cr3 s) pages (regions s) (reference s)</text>
<text top="320" left="207" width="326" height="14" font="7">where pages ppa = case status s ppa of</text>
<text top="346" left="379" width="69" height="14" font="7">Normal _</text>
<text top="346" left="465" width="86" height="14" font="7">-&gt; Nothing</text>
<text top="373" left="379" width="34" height="14" font="7">page</text>
<text top="373" left="465" width="103" height="14" font="7">-&gt; Just page</text>
<text top="413" left="173" width="626" height="16" font="0">Unlike other domains, H may observe the contents and status of pages in its ob-</text>
<text top="446" left="173" width="626" height="16" font="0">servable set. The association of each page with a status is a private part of the H</text>
<text top="478" left="173" width="433" height="16" font="0">state, so other domains may only observe page contents.</text>
<text top="511" left="199" width="600" height="16" font="0">The kernel observes the contents of kernel data pages and environment pages.</text>
<text top="543" left="173" width="626" height="16" font="0">Though the kernel should not modify the environment data, it might distinguish</text>
<text top="576" left="173" width="626" height="16" font="0">the state of the Haskell run-time system indirectly through its own execution. As</text>
<text top="608" left="173" width="626" height="16" font="0">with the environment domain, we represent the observation function as a virtual</text>
<text top="641" left="173" width="626" height="16" font="0">page mapping to capture the indirect eﬀect of virtual-to-physical memory map-</text>
<text top="673" left="173" width="626" height="16" font="0">pings. The observable data about a page includes its contents and its reference</text>
<text top="706" left="173" width="626" height="16" font="0">count. Region handles are also observable, because they are a tool for communi-</text>
<text top="738" left="173" width="350" height="16" font="0">cating information between H and the kernel.</text>
<text top="778" left="190" width="86" height="14" font="7">data KView</text>
<text top="804" left="207" width="77" height="14" font="7">= KView {</text>
<text top="831" left="242" width="550" height="14" font="7">kObservablePages :: VirtualPageAddress -&gt; Maybe (PageData, Nat),</text>
<text top="857" left="242" width="120" height="14" font="7">kRegionHandles</text>
<text top="857" left="388" width="120" height="14" font="7">:: RegionState</text>
<text top="883" left="224" width="9" height="14" font="7">}</text>
<text top="924" left="173" width="626" height="16" font="0">The view function of the client kernel projects the region handles from the speciﬁed</text>
<text top="956" left="173" width="626" height="16" font="0">state and locates all physical pages that either have the Environment status or have</text>
<text top="989" left="173" width="423" height="16" font="0">the Normal status and are mapped at a kernel address.</text>
<text top="1028" left="190" width="198" height="14" font="7">viewK :: State -&gt; KView</text>
<text top="1055" left="190" width="326" height="14" font="7">viewK s = KView observable (regions s)</text>
</page>
<page number="137" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">115</text>
<text top="165" left="207" width="43" height="14" font="7">where</text>
<text top="192" left="224" width="120" height="14" font="7">observable vpa</text>
<text top="218" left="242" width="335" height="14" font="7">= do ppa &lt;- translatePage s (cr3 s) vpa</text>
<text top="245" left="284" width="352" height="14" font="7">let rcount = referenceCount s (cr3 s) ppa</text>
<text top="271" left="284" width="172" height="14" font="7">case status s ppa of</text>
<text top="297" left="302" width="301" height="14" font="7">Environment p -&gt; return (p, rcount)</text>
<text top="324" left="302" width="481" height="14" font="7">Normal p | isKernelPageAddress vpa -&gt; return (p, rcount)</text>
<text top="350" left="302" width="103" height="14" font="7">_ -&gt; Nothing</text>
<text top="395" left="199" width="600" height="16" font="0">The user domain observes normal pages of memory that are mapped in user</text>
<text top="428" left="173" width="626" height="16" font="0">space. Users cannot observe the contents of environment pages because the user</text>
<text top="460" left="173" width="626" height="16" font="0">programs are not writen in Haskell and therefore do not rely directly on the run-</text>
<text top="493" left="173" width="174" height="16" font="0">time system to execute</text>
<text top="490" left="347" width="6" height="11" font="2">2</text>
<text top="493" left="354" width="446" height="16" font="0">. The data observable about user pages is the contents and</text>
<text top="525" left="173" width="626" height="16" font="0">the reference count. For any pages outside of the observable set, the result will be</text>
<text top="559" left="173" width="69" height="15" font="0">Nothing.</text>
<text top="602" left="190" width="172" height="14" font="7">data UView = UView {</text>
<text top="628" left="207" width="541" height="14" font="7">uObservablePages :: VirtualPageAddress -&gt; Maybe (PageData, Nat)</text>
<text top="654" left="190" width="9" height="14" font="7">}</text>
<text top="699" left="173" width="626" height="16" font="0">The view function of the user domain projects those pages that have a Normal</text>
<text top="732" left="173" width="528" height="16" font="0">status in the speciﬁed state and are mapped in a user-space address.</text>
<text top="776" left="190" width="198" height="14" font="7">viewU :: State -&gt; UView</text>
<text top="802" left="190" width="223" height="14" font="7">viewU s = UView observable</text>
<text top="829" left="207" width="43" height="14" font="7">where</text>
<text top="855" left="224" width="120" height="14" font="7">observable vpa</text>
<text top="881" left="242" width="335" height="14" font="7">= do ppa &lt;- translatePage s (cr3 s) vpa</text>
<text top="908" left="284" width="172" height="14" font="7">case status s ppa of</text>
<text top="951" left="193" width="6" height="9" font="3">2</text>
<text top="954" left="200" width="599" height="13" font="4">Even if the user processes were written in Haskell, they would need to execute in their own</text>
<text top="982" left="173" width="626" height="13" font="4">user-level run-time system to maintain adequate separation between the kernel and the user</text>
<text top="1011" left="173" width="626" height="13" font="4">processes. Thus, we would never expect user-level programs to be able to observe the execution</text>
<text top="1040" left="173" width="85" height="13" font="4">environment.</text>
</page>
<page number="138" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">116</text>
<text top="165" left="302" width="361" height="14" font="7">Normal contents | isUserPageAddress vpa -&gt;</text>
<text top="192" left="319" width="404" height="14" font="7">return (contents, referenceCount s (cr3 s) ppa)</text>
<text top="218" left="302" width="103" height="14" font="7">_ -&gt; Nothing</text>
<text top="257" left="199" width="600" height="16" font="0">To tie our notion of view types and projection functions into the Rushby frame-</text>
<text top="290" left="173" width="626" height="16" font="0">work, we bring the per-domain deﬁnitions together into a uniﬁed view type and</text>
<text top="322" left="173" width="192" height="16" font="0">view projection function.</text>
<text top="361" left="190" width="558" height="14" font="7">data View = ViewE EView | ViewH HView | ViewK KView | ViewU UView</text>
<text top="413" left="190" width="223" height="14" font="7">view :: D -&gt; State -&gt; View</text>
<text top="440" left="190" width="223" height="14" font="7">view E s = ViewE (viewE s)</text>
<text top="466" left="190" width="223" height="14" font="7">view H s = ViewH (viewH s)</text>
<text top="493" left="190" width="223" height="14" font="7">view K s = ViewK (viewK s)</text>
<text top="519" left="190" width="223" height="14" font="7">view U s = ViewU (viewU s)</text>
<text top="558" left="173" width="626" height="16" font="0">By parameterizing over the domain being viewed, we abstract away from the spe-</text>
<text top="591" left="173" width="626" height="16" font="0">ciﬁc domains of our system and create a generic operation that could be deﬁned</text>
<text top="623" left="173" width="432" height="16" font="0">in any Rushby instantiation to capture observable state.</text>
<text top="656" left="199" width="600" height="16" font="0">The view function is the mechanism that we use to deﬁne Rushby’s view-</text>
<text top="688" left="173" width="238" height="16" font="0">partitioning relation on states,</text>
<text top="682" left="421" width="7" height="11" font="2">u</text>
<text top="687" left="418" width="382" height="17" font="0">∼. Recall that two states s and t are equivalent</text>
<text top="721" left="173" width="626" height="16" font="0">from the perspective of domain u if u cannot distinguish s and t through its view</text>
<text top="753" left="173" width="92" height="16" font="0">of the state.</text>
<text top="791" left="190" width="344" height="14" font="7">viewEquiv :: D -&gt; State -&gt; State -&gt; Bool</text>
<text top="818" left="190" width="326" height="14" font="7">viewEquiv u s t = view u s == view u t</text>
<text top="857" left="173" width="626" height="16" font="0">Note that the views of domains are not actually comparable in Haskell as written</text>
<text top="890" left="173" width="626" height="16" font="0">because they contain functions. We deﬁne a symbol to represent the comparison</text>
<text top="922" left="173" width="626" height="16" font="0">on functions so that we can type check our deﬁnitions and properties, but will</text>
<text top="955" left="173" width="626" height="16" font="0">never compute this value. The intuitive meaning behind the comparison is that</text>
<text top="987" left="173" width="601" height="16" font="0">functions within a view would produce the same output given the same input.</text>
<text top="1021" left="199" width="600" height="15" font="0">view also helps us to give meaning to the output function in the Rushby</text>
<text top="1052" left="173" width="626" height="16" font="0">model. H-based systems do not perform output in a traditional sense—all of the</text>
</page>
<page number="139" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">117</text>
<text top="163" left="173" width="370" height="16" font="0">eﬀects of operations are conﬁned to the state.</text>
<text top="163" left="559" width="240" height="16" font="0">Thus, to obtain the execution</text>
<text top="195" left="173" width="626" height="16" font="0">environment integrity and address-space integrity properties that we set out to</text>
<text top="228" left="173" width="626" height="16" font="0">prove at the beginning of the chapter, we treat the output produced by an action</text>
<text top="260" left="173" width="626" height="16" font="0">as the projection of the state visible by the domain of that action. Because outputs</text>
<text top="293" left="173" width="457" height="16" font="0">are simply views, we instantiate the output type O to View.</text>
<text top="333" left="190" width="112" height="14" font="7">type O = View</text>
<text top="386" left="190" width="215" height="14" font="7">output :: (State, A) -&gt; O</text>
<text top="412" left="190" width="352" height="14" font="7">output (s, a) = view (dom a) (step (s,a))</text>
<text top="453" left="173" width="626" height="16" font="0">Recall from Section 5.1 that step is an abstract function in the Rushby framework</text>
<text top="486" left="173" width="626" height="16" font="0">that computes the state produced by executing an action a in a state s. We will</text>
<text top="518" left="173" width="626" height="16" font="0">deﬁne step in Section 5.8. The outputs produced by running the same action in</text>
<text top="551" left="173" width="626" height="16" font="0">two states will be equal when the states observable to that domain after executing</text>
<text top="583" left="173" width="626" height="16" font="0">the action are equal. We will see when we discuss the policy of our system how</text>
<text top="616" left="173" width="395" height="16" font="0">this captures our desired memory-safety properties.</text>
<text top="648" left="199" width="600" height="16" font="0">Treating an action’s output as equivalent to the view of the action’s domain has</text>
<text top="681" left="173" width="626" height="16" font="0">an interesting ramiﬁcation: the output consistency unwinding condition of Rushby</text>
<text top="713" left="173" width="626" height="16" font="0">now reduces to a special case of the weak step consistency. We sketch the proof of</text>
<text top="746" left="173" width="369" height="16" font="0">this property of our instantiation in Section 5.8.</text>
<text top="807" left="173" width="26" height="16" font="0">5.5</text>
<text top="807" left="219" width="78" height="16" font="0">POLICY</text>
<text top="857" left="173" width="626" height="16" font="0">At the beginning of this chapter we identiﬁed execution environment integrity and</text>
<text top="890" left="173" width="626" height="16" font="0">address-space integrity as two key isolation properties for an H-based system. Ulti-</text>
<text top="922" left="173" width="626" height="16" font="0">mately, these properties are simply a mechanism for realizing the intuitive notions</text>
<text top="955" left="173" width="626" height="16" font="0">of memory-safety that we expect from our system, for example, that H does not</text>
<text top="987" left="173" width="626" height="16" font="0">modify the Haskell heap directly even though H’s implementation uses the po-</text>
<text top="1020" left="173" width="626" height="16" font="0">tentially unsafe primitives that would allow it to do so. A security policy bridges</text>
<text top="1052" left="173" width="626" height="16" font="0">the gap between resource-level isolation properties and the intuitive understanding</text>
</page>
<page number="140" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">118</text>
<text top="163" left="173" width="626" height="16" font="0">of memory-safety by capturing the interactions that occur between domains via</text>
<text top="195" left="173" width="626" height="16" font="0">resources like memory. Essentially, the policy speciﬁes the portion of the state</text>
<text top="228" left="173" width="626" height="16" font="0">that a particular domain may aﬀect: a domain A may modify the state that is</text>
<text top="260" left="173" width="367" height="16" font="0">present in the view of any domain B where A</text>
<text top="260" left="574" width="225" height="16" font="0">B . The absence of an inter-</text>
<text top="293" left="173" width="410" height="16" font="0">ference relationship between two domains, written A</text>
<text top="293" left="613" width="186" height="16" font="0">B , guarantees that B is</text>
<text top="325" left="173" width="626" height="16" font="0">unaﬀected by the execution of A (in a system that correctly upholds the policy).</text>
<text top="358" left="173" width="626" height="16" font="0">The security provided by a policy heavily depends on the system model used in</text>
<text top="390" left="173" width="626" height="16" font="0">the instantiation because the set of domains, the representation of the state, and</text>
<text top="423" left="173" width="626" height="16" font="0">the set of actions will inﬂuence the properties that can be captured by the policy.</text>
<text top="455" left="173" width="626" height="16" font="0">In this section, we will examine the considerations that go into the construction of</text>
<text top="488" left="173" width="626" height="16" font="0">a meaningful Rushby instantiation and the speciﬁc rationale behind some of our</text>
<text top="520" left="173" width="626" height="16" font="0">modeling choices (Section 5.5.1). We will also present the security policy for our</text>
<text top="553" left="173" width="174" height="16" font="0">system (Section 5.5.2).</text>
<text top="613" left="173" width="41" height="16" font="0">5.5.1</text>
<text top="613" left="234" width="175" height="16" font="0">Modeling Approach</text>
<text top="657" left="173" width="626" height="16" font="0">To determine the appropriate security policy for our system, we must carefully</text>
<text top="689" left="173" width="626" height="16" font="0">consider the desired interactions between domains from a memory-safety perspec-</text>
<text top="722" left="173" width="626" height="16" font="0">tive. As mentioned previously, we want the policy to capture the fact that H does</text>
<text top="754" left="173" width="626" height="16" font="0">not modify the Haskell heap. However, a memory-safe H implementation that does</text>
<text top="787" left="173" width="626" height="16" font="0">not modify the Haskell heap is useless if the H API exports operations that allow</text>
<text top="819" left="173" width="626" height="16" font="0">the client kernel or a user process to modify the heap directly or through some</text>
<text top="852" left="173" width="626" height="16" font="0">chain of events. Thus, we would like the policy to reﬂect that neither the kernel</text>
<text top="884" left="173" width="626" height="16" font="0">domain nor the user domain interferes with the environment domain. Along the</text>
<text top="917" left="173" width="626" height="16" font="0">same lines, H will not be able to enforce safety if its data gets corrupted, so we</text>
<text top="949" left="173" width="530" height="16" font="0">want a policy that protects H from the client and the user programs.</text>
<text top="982" left="199" width="600" height="16" font="0">With these high-level memory-safety properties in mind, we can develop a se-</text>
<text top="1014" left="173" width="626" height="16" font="0">curity policy that will enforce the intended interactions between domains. We</text>
<text top="1047" left="173" width="626" height="16" font="0">present the steps involved in creating a meaningful noninterference policy here,</text>
</page>
<page number="141" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">119</text>
<text top="163" left="173" width="626" height="16" font="0">even though some of the steps describe aspects of the model that were already</text>
<text top="195" left="173" width="626" height="16" font="0">covered in earlier sections. The formulation of the security policy is tightly inter-</text>
<text top="228" left="173" width="626" height="16" font="0">twined with the other concepts of the system model, so we present these steps as a</text>
<text top="260" left="173" width="626" height="16" font="0">summary of the Rushby instantiation process, and as a way to provide some intu-</text>
<text top="293" left="173" width="625" height="16" font="0">ition about the security policy we will develop throughout the rest of the section.</text>
<text top="325" left="199" width="600" height="16" font="0">The ﬁrst step in creating a policy is to identify the resources that will be</text>
<text top="358" left="173" width="626" height="16" font="0">described by the security property. Essentially, this corresponds to the resources</text>
<text top="390" left="173" width="626" height="16" font="0">that are modeled in the system state. In our case, the focus on memory-safety</text>
<text top="423" left="173" width="626" height="16" font="0">narrows our attention to resources that relate to memory management. In other</text>
<text top="455" left="173" width="626" height="16" font="0">systems, the resource of interest might be something like I/O ports or time. The</text>
<text top="488" left="173" width="626" height="16" font="0">second step is to determine the granularity of the operations and observations</text>
<text top="520" left="173" width="626" height="16" font="0">on that resource. The actions and views presented in Section 5.4 reﬂect our ideas</text>
<text top="553" left="173" width="626" height="16" font="0">about the appropriate granularity in an H-based system. In particular, we focus on</text>
<text top="585" left="173" width="626" height="16" font="0">memory pages because this is a natural ﬁt with the operations of H (the H design</text>
<text top="618" left="173" width="626" height="16" font="0">was in turn motivated by the granularity of memory management operations on</text>
<text top="650" left="173" width="626" height="16" font="0">the hardware). A noninterference formulation of memory-safety for a programming</text>
<text top="683" left="173" width="626" height="16" font="0">language might look very diﬀerent, for example, using variables or words as the</text>
<text top="715" left="173" width="626" height="16" font="0">granularity for memory operations. The ﬁnal step in our Rushby instantiation</text>
<text top="748" left="173" width="626" height="16" font="0">is to determine a security policy that captures the intended interactions between</text>
<text top="780" left="173" width="626" height="16" font="0">domains. For example, we can express the fact that H cannot corrupt the run-time</text>
<text top="813" left="173" width="280" height="16" font="0">system by creating a policy where H</text>
<text top="813" left="484" width="19" height="16" font="0">E .</text>
<text top="845" left="199" width="600" height="16" font="0">In general, we must strike a very delicate balance when crafting our noninter-</text>
<text top="878" left="173" width="626" height="16" font="0">ference policy. The relationship between the set of domains, the observable state,</text>
<text top="910" left="173" width="619" height="16" font="0">and the set of actions can be diﬃcult to manage. Some common pitfalls include:</text>
<text top="954" left="199" width="600" height="17" font="0">• Identifying Too Few Domains: Identifying the right set of domains is</text>
<text top="987" left="217" width="583" height="16" font="0">crucial. Interference within a domain is impossible to capture except in very</text>
<text top="1020" left="217" width="583" height="16" font="0">special circumstances, so any system components that are grouped together</text>
<text top="1052" left="217" width="583" height="16" font="0">will be allowed to interact freely. For example, if we combined the H and</text>
</page>
<page number="142" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">120</text>
<text top="163" left="217" width="582" height="16" font="0">environment domains into a single high-privilege domain, then we could not</text>
<text top="195" left="217" width="567" height="16" font="0">prove that H does not corrupt the Haskell heap under our security policy.</text>
<text top="242" left="199" width="600" height="17" font="0">• Inserting Too Few Policy Arrows: The policy arrows must accurately</text>
<text top="275" left="217" width="582" height="16" font="0">reﬂect the observations that are possible given the system model (including</text>
<text top="308" left="217" width="583" height="16" font="0">the eﬀects of each action and the representation of the state). If the policy</text>
<text top="340" left="217" width="583" height="16" font="0">does not accurately reﬂect the observable actions then we will not be able to</text>
<text top="373" left="217" width="347" height="16" font="0">prove that the system implements the policy.</text>
<text top="419" left="199" width="600" height="17" font="0">• Inserting Too Many Policy Arrows: In a system where every domain</text>
<text top="453" left="217" width="583" height="16" font="0">interferes with every other domain, there is nothing interesting to be learned</text>
<text top="485" left="217" width="583" height="16" font="0">from a noninterference proof. The policy must express enough noninterfer-</text>
<text top="518" left="217" width="456" height="16" font="0">ence to capture the intended safety properties, like our H</text>
<text top="518" left="710" width="89" height="16" font="0">E example.</text>
<text top="550" left="217" width="583" height="16" font="0">There is a tension between this need and the requirement that the security</text>
<text top="583" left="217" width="583" height="16" font="0">policy accurately reﬂects the observable actions in the system. The set of ac-</text>
<text top="615" left="217" width="583" height="16" font="0">tions must be carefully chosen to model just those domain interactions that</text>
<text top="648" left="217" width="409" height="16" font="0">contribute to the properties that we hope to capture.</text>
<text top="695" left="173" width="626" height="16" font="0">We carefully chose the set of domains and the actions available to each domain</text>
<text top="728" left="173" width="626" height="16" font="0">to support our ability to deﬁne a policy that enforces our desired memory-safety</text>
<text top="760" left="173" width="626" height="16" font="0">policy. In this section, we will identify the interference relationships necessitated</text>
<text top="793" left="173" width="127" height="16" font="0">by these choices.</text>
<text top="825" left="199" width="600" height="16" font="0">Before moving on to the actual policy, let us consider one ﬁnal example that</text>
<text top="858" left="173" width="626" height="16" font="0">illustrates the tensions that arise when designing a system model for a noninter-</text>
<text top="890" left="173" width="626" height="16" font="0">ference instantiation. When modeling Haskell execution in our system, we chose</text>
<text top="923" left="173" width="626" height="16" font="0">to introduce an action in the environment domain, WriteE, that may change any</text>
<text top="955" left="173" width="626" height="16" font="0">location in the Haskell heap. This action is designed to represent the execution of</text>
<text top="988" left="173" width="626" height="16" font="0">a Haskell program on top of the run-time system, such as H or the client kernel.</text>
<text top="1020" left="173" width="626" height="16" font="0">In this treatment of execution, we do not need to introduce any operation where</text>
</page>
<page number="143" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">121</text>
<text top="163" left="173" width="626" height="16" font="0">a domain other than the environment makes changes to the state that are observ-</text>
<text top="195" left="173" width="626" height="16" font="0">able to the environment domain. Alternatively, we could model the relationship</text>
<text top="228" left="173" width="626" height="16" font="0">between the execution of Haskell programs and the changes that happen in the</text>
<text top="260" left="173" width="626" height="16" font="0">heap explicitly. Both H and the kernel would then include an action, haskellStep,</text>
<text top="293" left="173" width="626" height="16" font="0">that would nondeterministically change some portion of the heap to reﬂect alloca-</text>
<text top="325" left="173" width="626" height="16" font="0">tion, collection, and computation. Aside from the fact that the alternative model</text>
<text top="358" left="173" width="626" height="16" font="0">is more complex, this would be a perfectly valid way to represent Haskell execu-</text>
<text top="390" left="173" width="626" height="16" font="0">tion. The problem is that our policy would need to include the interference arrows</text>
<text top="423" left="173" width="13" height="16" font="0">H</text>
<text top="423" left="223" width="436" height="16" font="0">E (H interferes with the run-time environment) and K</text>
<text top="423" left="697" width="102" height="16" font="0">E (the client</text>
<text top="455" left="173" width="626" height="16" font="0">kernel interferes with the run-time environment) to accurately capture the observ-</text>
<text top="488" left="173" width="626" height="16" font="0">able actions of the system. With this model, we cannot prove that H does not</text>
<text top="520" left="173" width="626" height="16" font="0">corrupt the Haskell heap because we cannot distinguish legitimate modiﬁcations</text>
<text top="553" left="173" width="284" height="16" font="0">from illegitimate ones. The policy H</text>
<text top="553" left="489" width="310" height="16" font="0">E states that all interference from H to</text>
<text top="585" left="173" width="626" height="16" font="0">E is allowed, so an incorrect H implementation that corrupts the heap (and would</text>
<text top="618" left="173" width="626" height="16" font="0">cause a client kernel to crash) still satisﬁes the security policy. In noninterference</text>
<text top="650" left="173" width="626" height="16" font="0">models, it is essential that one only model the aspects of information ﬂow that</text>
<text top="683" left="173" width="626" height="16" font="0">aﬀect the desired security property, in our case memory-safety, so that the policy</text>
<text top="715" left="173" width="498" height="16" font="0">does not become so broad as to permit invalid system behaviors.</text>
<text top="748" left="199" width="600" height="16" font="0">The actions of Section 5.4 are carefully crafted to support a policy that will</text>
<text top="780" left="173" width="626" height="16" font="0">enforce the high-level memory-safety properties that we are interested in while</text>
<text top="813" left="173" width="626" height="16" font="0">providing a good match for the design described in Chapter 4. Throughout the</text>
<text top="845" left="173" width="626" height="16" font="0">rest of the section, we will examine each domain and each action to determine the</text>
<text top="878" left="173" width="626" height="16" font="0">appropriate policy connections to other domains. Though the policy is guided by</text>
<text top="910" left="173" width="626" height="16" font="0">the actions in this sense, the actions were also guided by the desired policy during</text>
<text top="943" left="173" width="270" height="16" font="0">the process of designing the model.</text>
</page>
<page number="144" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">122</text>
<text top="163" left="173" width="41" height="16" font="0">5.5.2</text>
<text top="163" left="234" width="270" height="16" font="0">Interference Between Domains</text>
<text top="207" left="173" width="626" height="16" font="0">We build our policy by examining the semantics of the actions in each domain.</text>
<text top="239" left="173" width="626" height="16" font="0">Starting with the environment domain, there is only one action available to the</text>
<text top="272" left="173" width="626" height="16" font="0">domain—writeE—which modiﬁes a value in an environment page. As such, any</text>
<text top="304" left="173" width="626" height="16" font="0">domain that can view environment page data can be aﬀected by the execution of</text>
<text top="337" left="173" width="626" height="16" font="0">E. In the views presented in Section 5.4, both H and K observe the environment</text>
<text top="370" left="173" width="626" height="16" font="0">pages because these domains are written in Haskell (the language supported by</text>
<text top="402" left="173" width="626" height="16" font="0">E) and therefore directly depend on the state of the Haskell heap to execute. If</text>
<text top="435" left="173" width="626" height="16" font="0">we had an additional environment E’ containing a Java run-time system, then</text>
<text top="467" left="173" width="626" height="16" font="0">any system component written in Java would depend on (and therefore observe)</text>
<text top="500" left="173" width="626" height="16" font="0">E’. The environment domain itself also observes the environment page data. In</text>
<text top="532" left="173" width="473" height="16" font="0">our system, all domains observe the state of their domain.</text>
<text top="532" left="662" width="137" height="16" font="0">Though this may</text>
<text top="565" left="173" width="626" height="16" font="0">seem obvious, there are meaningful secure systems where it is essential that the</text>
<text top="597" left="173" width="626" height="16" font="0">state a domain can observe is disjoint from the state the domain can write to.</text>
<text top="630" left="173" width="626" height="16" font="0">Collecting these policy constraints leads us to introduce three policy arrows for</text>
<text top="662" left="173" width="193" height="16" font="0">the environment domain:</text>
<text top="704" left="222" width="12" height="16" font="0">E</text>
<text top="704" left="264" width="12" height="16" font="0">E</text>
<text top="741" left="220" width="12" height="16" font="0">E</text>
<text top="741" left="262" width="13" height="16" font="0">H</text>
<text top="778" left="220" width="12" height="16" font="0">E</text>
<text top="778" left="262" width="13" height="16" font="0">K</text>
<text top="820" left="173" width="626" height="16" font="0">Already, we have introduced a policy arrow that impacts our security argument.</text>
<text top="852" left="173" width="626" height="16" font="0">We originally said that only H may modify the page-directories and page-tables,</text>
<text top="885" left="173" width="626" height="16" font="0">and that we would like to capture this by demonstrating that no domains interfere</text>
<text top="917" left="173" width="626" height="16" font="0">with H. But this claim is too strong—the environment domain must interfere</text>
<text top="950" left="173" width="626" height="16" font="0">with H. However, we expect that the environment domain will interfere with H</text>
<text top="982" left="173" width="626" height="16" font="0">through a very limited interface, namely the environment pages, and will not write</text>
<text top="1015" left="173" width="626" height="16" font="0">to any of the data pages owned by H. This is an assumption of our model and</text>
<text top="1047" left="173" width="626" height="16" font="0">implementation—we trust the run-time system to execute correctly within its own</text>
</page>
<page number="145" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">123</text>
<text top="163" left="173" width="626" height="16" font="0">memory area. By encoding the interactions between the run-time system and the</text>
<text top="195" left="173" width="626" height="16" font="0">other actors in the security policy, we have made the nature of this assumption</text>
<text top="228" left="173" width="61" height="16" font="0">explicit.</text>
<text top="260" left="199" width="600" height="16" font="0">The H domain has many actions that we need to consider, because these are the</text>
<text top="293" left="173" width="626" height="16" font="0">actions that critically impact the memory-safety of the system. The operational</text>
<text top="325" left="173" width="626" height="16" font="0">speciﬁcations for these actions are complex (we will examine them in Section 5.7),</text>
<text top="358" left="173" width="626" height="16" font="0">but fortunately the memory-safety policy is simple. H may interfere with every</text>
<text top="390" left="173" width="248" height="16" font="0">domain except the environment.</text>
<text top="436" left="220" width="13" height="16" font="0">H</text>
<text top="436" left="264" width="13" height="16" font="0">H</text>
<text top="473" left="220" width="13" height="16" font="0">H</text>
<text top="473" left="263" width="13" height="16" font="0">K</text>
<text top="510" left="220" width="13" height="16" font="0">H</text>
<text top="510" left="264" width="13" height="16" font="0">U</text>
<text top="552" left="173" width="626" height="16" font="0">H interferes with the kernel by modifying the virtual-to-physical memory mappings</text>
<text top="584" left="173" width="626" height="16" font="0">that the kernel may access and by extending the set of region handles available for</text>
<text top="617" left="173" width="626" height="16" font="0">memory mappings. H interferes with the user domain by changing the virtual-to-</text>
<text top="649" left="173" width="626" height="16" font="0">physical memory mappings in user-space. The bootstrapping code of H constructs</text>
<text top="682" left="173" width="626" height="16" font="0">the initial view of the environment, but after that point H may not change anything</text>
<text top="714" left="173" width="626" height="16" font="0">in the environment domain. We do not model the behavior of the bootstrapping</text>
<text top="747" left="173" width="626" height="16" font="0">code, but rather assume an initial state that occurs after the set up process com-</text>
<text top="779" left="173" width="49" height="16" font="0">pletes.</text>
<text top="812" left="199" width="600" height="16" font="0">The kernel domain does not have much power in our model. We purposefully</text>
<text top="844" left="173" width="626" height="16" font="0">leave its behavior and policies abstract. The only action available to the kernel</text>
<text top="877" left="173" width="626" height="16" font="0">is to write to kernel-mapped pages, writeK. If the underlying physical memory</text>
<text top="909" left="173" width="626" height="16" font="0">being written to is also mapped in a user accessible address, then the user domain</text>
<text top="942" left="173" width="448" height="16" font="0">will observe a kernel write. Thus, K may interfere with U.</text>
<text top="987" left="220" width="13" height="16" font="0">K</text>
<text top="987" left="264" width="13" height="16" font="0">K</text>
<text top="1024" left="220" width="13" height="16" font="0">K</text>
<text top="1024" left="264" width="13" height="16" font="0">U</text>
</page>
<page number="146" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">124</text>
<text top="163" left="173" width="626" height="16" font="0">We choose a model where K does not interfere with H. This comes from our rep-</text>
<text top="195" left="173" width="626" height="16" font="0">resentation of actions where each H API function is modeled as an action in the H</text>
<text top="228" left="173" width="626" height="16" font="0">domain that may occur at any time. This is similar to the treatment of Haskell ex-</text>
<text top="260" left="173" width="626" height="16" font="0">ecution. By modeling actions in this way, we do not need to introduce any actions</text>
<text top="293" left="173" width="626" height="16" font="0">in K that interfere with H. The only kernel action is a write function and certainly</text>
<text top="325" left="173" width="626" height="16" font="0">this should not modify the H data structures. We think that associating actions</text>
<text top="358" left="173" width="626" height="16" font="0">with the callee rather than the caller is a useful technique in general for model-</text>
<text top="390" left="173" width="626" height="16" font="0">ing abstraction barriers in a noninterference framework. Without this technique,</text>
<text top="423" left="173" width="626" height="16" font="0">interference appears across abstraction boundaries in the policy and nothing can</text>
<text top="455" left="173" width="626" height="16" font="0">be learned about the system from the security property (a classic complaint about</text>
<text top="488" left="173" width="222" height="16" font="0">noninterference frameworks).</text>
<text top="520" left="199" width="600" height="16" font="0">The user domain is just as abstract as the kernel domain. The user may write</text>
<text top="553" left="173" width="626" height="16" font="0">to user-mapped pages via the function writeU, which may be observable to the</text>
<text top="585" left="173" width="542" height="16" font="0">kernel domain if the same physical memory is mapped in kernel space.</text>
<text top="631" left="220" width="13" height="16" font="0">U</text>
<text top="631" left="263" width="13" height="16" font="0">K</text>
<text top="668" left="220" width="13" height="16" font="0">U</text>
<text top="668" left="264" width="13" height="16" font="0">U</text>
<text top="710" left="173" width="626" height="16" font="0">Note that U does not interfere with H , even though, in the real implementation,</text>
<text top="742" left="173" width="626" height="16" font="0">the user domain can perform actions that change the hardware state in ways that</text>
<text top="775" left="173" width="626" height="16" font="0">are observable to H . For example, U might change the value of the dirty bit for a</text>
<text top="807" left="173" width="626" height="16" font="0">page by writing to that page. Such changes do not aﬀect the integrity of the H data</text>
<text top="840" left="173" width="430" height="16" font="0">structures, so we do not need to include a policy arrow U</text>
<text top="840" left="634" width="165" height="16" font="0">H when modeling our</text>
<text top="872" left="173" width="626" height="16" font="0">memory-safety property. The model supports a proof of the unwinding conditions</text>
<text top="905" left="173" width="626" height="16" font="0">for this policy by abstracting away the portions of the state that are not relevant</text>
<text top="937" left="173" width="626" height="16" font="0">to memory-safety. Thus, if we were to model the dirty bits in the machine state,</text>
<text top="970" left="173" width="626" height="16" font="0">then the view of U would include these bits so that user actions could make</text>
<text top="1002" left="173" width="626" height="16" font="0">modiﬁcations, but the view of H would not, to reﬂect the fact that H should not</text>
<text top="1035" left="173" width="400" height="16" font="0">rely on the value of the dirty bits in any operations.</text>
</page>
<page number="147" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">125</text>
<text top="163" left="199" width="600" height="16" font="0">In the future it would be interesting to extend the techniques used for mod-</text>
<text top="195" left="173" width="626" height="16" font="0">eling memory-safety in H to examine process separation in a speciﬁc kernel, like</text>
<text top="228" left="173" width="626" height="16" font="0">seL4 [60]. Eﬀectively reasoning about process safety in a realistic kernel will most</text>
<text top="260" left="173" width="626" height="16" font="0">likely require a dynamic security policy, rather than the static policy illustrated</text>
<text top="293" left="173" width="626" height="16" font="0">here, to account for domain creation and deletion. Our earlier work extends the</text>
<text top="325" left="173" width="626" height="16" font="0">Rushby framework to support the ability to formalize dynamic noninterference</text>
<text top="358" left="173" width="184" height="16" font="0">policies of this sort [66].</text>
<text top="397" left="351" width="90" height="16" font="0">policy = {E</text>
<text top="397" left="471" width="34" height="16" font="0">E , E</text>
<text top="397" left="534" width="36" height="16" font="0">H , E</text>
<text top="397" left="600" width="21" height="16" font="0">K ,</text>
<text top="431" left="386" width="13" height="16" font="0">H</text>
<text top="431" left="430" width="37" height="16" font="0">H , H</text>
<text top="431" left="497" width="37" height="16" font="0">K , H</text>
<text top="431" left="565" width="21" height="16" font="0">U ,</text>
<text top="466" left="420" width="13" height="16" font="0">K</text>
<text top="466" left="464" width="37" height="16" font="0">K , K</text>
<text top="466" left="532" width="21" height="16" font="0">U ,</text>
<text top="501" left="418" width="13" height="16" font="0">U</text>
<text top="501" left="462" width="37" height="16" font="0">K , U</text>
<text top="501" left="529" width="25" height="16" font="0">U }</text>
<text top="557" left="559" width="13" height="16" font="0">U</text>
<text top="526" left="578" width="0" height="23" font="0"></text>
<text top="676" left="578" width="0" height="23" font="0"></text>
<text top="632" left="403" width="12" height="16" font="0">E</text>
<text top="601" left="421" width="0" height="23" font="0"></text>
<text top="621" left="467" width="0" height="23" font="0">//</text>
<text top="687" left="548" width="0" height="23" font="0">''</text>
<text top="632" left="480" width="13" height="16" font="0">H</text>
<text top="601" left="499" width="0" height="23" font="0"></text>
<text top="560" left="552" width="0" height="23" font="0">&gt;&gt;</text>
<text top="682" left="552" width="0" height="23" font="0">  </text>
<text top="707" left="559" width="13" height="16" font="0">K</text>
<text top="715" left="578" width="0" height="23" font="0">NN</text>
<text top="565" left="555" width="0" height="23" font="0">LL</text>
<text top="756" left="173" width="626" height="16" font="0">Figure 5.2: The security policy of our system. The environment interferes with H</text>
<text top="791" left="173" width="626" height="16" font="0">and the kernel because they depend on the environment to run. H interferes with</text>
<text top="826" left="173" width="626" height="16" font="0">the kernel and the users by the same reasoning. The kernel and the user domains</text>
<text top="860" left="173" width="626" height="16" font="0">interfere freely with each other in our model because we do not put any restrictions</text>
<text top="895" left="173" width="623" height="16" font="0">on their communication through memory. All domains interfere with themselves.</text>
<text top="967" left="199" width="600" height="16" font="0">We bring the policies of each domain together in Figure 5.2 to illustrate the</text>
</page>
<page number="148" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">126</text>
<text top="163" left="173" width="626" height="16" font="0">overall interactions between the domains. From the ﬁgure, we can see that no do-</text>
<text top="195" left="173" width="626" height="16" font="0">main interferes with the environment domain (except itself) and that only the envi-</text>
<text top="228" left="173" width="626" height="16" font="0">ronment domain interferes with H. This policy matches our deﬁnition of memory-</text>
<text top="260" left="173" width="626" height="16" font="0">safety: the environment domain represents the environment pages and the H do-</text>
<text top="293" left="173" width="626" height="16" font="0">main represents the page-table and page-directory pages; if these domains are not</text>
<text top="325" left="173" width="626" height="16" font="0">interfered with then the integrity of the corresponding pages will be maintained.</text>
<text top="358" left="173" width="626" height="16" font="0">Thus, if our system obeys the security policy, then we can conclude that our de-</text>
<text top="390" left="173" width="626" height="16" font="0">sired memory-safety property holds. By design, memory-safety is guaranteed by</text>
<text top="423" left="173" width="626" height="16" font="0">our system organization and the available set of actions. Unfortunately, the ac-</text>
<text top="455" left="173" width="626" height="16" font="0">tions may be implemented in a way that introduces violations of the policy and</text>
<text top="488" left="173" width="626" height="16" font="0">thereby the memory-safety property. In Sections 5.6 and 5.7 we will explore the</text>
<text top="520" left="173" width="626" height="16" font="0">properties that our action implementations must satisfy in order to enforce the</text>
<text top="553" left="173" width="115" height="16" font="0">security policy.</text>
<text top="615" left="173" width="26" height="16" font="0">5.6</text>
<text top="615" left="219" width="207" height="16" font="0">WELL-FORMEDNESS</text>
<text top="665" left="173" width="626" height="16" font="0">Well-formedness conditions codify the basic conﬁguration properties that are nec-</text>
<text top="697" left="173" width="626" height="16" font="0">essary to support memory-safety in an H-based system. These conditions express</text>
<text top="730" left="173" width="626" height="16" font="0">what it means for a value of the state type to be valid. Many of the well-formedness</text>
<text top="762" left="173" width="626" height="16" font="0">constraints relate directly to the invariants presented in the design chapter (Chap-</text>
<text top="795" left="173" width="626" height="16" font="0">ter 4), while others reﬂect more fundamental assumptions about the machine</text>
<text top="827" left="173" width="626" height="16" font="0">model. For example, we require that the CR3 register always points to a valid</text>
<text top="860" left="173" width="626" height="16" font="0">page-directory. We connect well-formedness to memory-safety by specifying that</text>
<text top="892" left="173" width="626" height="16" font="0">every action in our system will produce a well-formed state (given a well-formed</text>
<text top="925" left="173" width="341" height="16" font="0">input state) if the operation is memory-safe.</text>
<text top="957" left="199" width="600" height="16" font="0">We do not relate well-formedness to the unwinding conditions of the Rushby</text>
<text top="990" left="173" width="626" height="16" font="0">framework directly, but anticipate that well-formedness of states will be essential</text>
<text top="1022" left="173" width="626" height="16" font="0">to any proof of the security property. The well-formedness conditions are such that</text>
</page>
<page number="149" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">127</text>
<text top="163" left="173" width="626" height="16" font="0">we would not expect the domains to satisfy the security policy from Section 5.5</text>
<text top="195" left="173" width="626" height="16" font="0">if the actions did not maintain well-formedness. Section 5.8 illustrates the use of</text>
<text top="228" left="173" width="626" height="16" font="0">well-formedness conditions for demonstrating aspects of the unwinding conditions.</text>
<text top="288" left="173" width="41" height="16" font="0">5.6.1</text>
<text top="288" left="234" width="503" height="16" font="0">CR3 and Reference Page-Directory Are Page-Directories</text>
<text top="332" left="173" width="626" height="16" font="0">We deﬁne a well-formedness constraint on states to describe the property that</text>
<text top="364" left="173" width="626" height="16" font="0">the CR3 register, represented by the cr3 state component, must point to a page-</text>
<text top="397" left="173" width="626" height="16" font="0">directory. The same property must also hold of the reference page-directory. These</text>
<text top="429" left="173" width="626" height="16" font="0">predicates are true if the page pointed to by the appropriate state component has</text>
<text top="462" left="173" width="181" height="16" font="0">a page-directory status.</text>
<text top="505" left="190" width="301" height="14" font="7">cr3IsPageDirectory :: State -&gt; Bool</text>
<text top="532" left="190" width="490" height="14" font="7">cr3IsPageDirectory s = isPageDirectory (status s (cr3 s))</text>
<text top="585" left="190" width="352" height="14" font="7">referenceIsPageDirectory :: State -&gt; Bool</text>
<text top="611" left="190" width="593" height="14" font="7">referenceIsPageDirectory s = isPageDirectory (status s (reference s))</text>
<text top="656" left="173" width="626" height="16" font="0">The reference page-directory reﬂects a known good view of kernel-space that an</text>
<text top="688" left="173" width="626" height="16" font="0">implementation can use as a baseline when creating new page-directories. In the</text>
<text top="721" left="173" width="626" height="16" font="0">model, the reference directory helps us to express properties of the kernel-space</text>
<text top="753" left="173" width="626" height="16" font="0">mappings and the view of memory seen by privileged domains such as the Haskell</text>
<text top="786" left="173" width="626" height="16" font="0">run-time system and H. We deﬁne several well-formedness constraints that describe</text>
<text top="818" left="173" width="626" height="16" font="0">the characteristics of the reference page-directory and its relationship to the other</text>
<text top="851" left="173" width="234" height="16" font="0">page-directories in the system.</text>
<text top="911" left="173" width="41" height="16" font="0">5.6.2</text>
<text top="911" left="234" width="499" height="16" font="0">Reference Page-Directory Maps Kernel-Space Addresses</text>
<text top="955" left="173" width="626" height="16" font="0">The ﬁrst characteristic of the reference page-directory that we capture through</text>
<text top="987" left="173" width="626" height="16" font="0">well-formedness is the notion that this directory only maps kernel-space addresses.</text>
<text top="1020" left="173" width="626" height="16" font="0">No user-space mappings may be present. The formulation uses the translatePage</text>
<text top="1052" left="173" width="213" height="16" font="0">function from Section 5.3.3.</text>
</page>
<page number="150" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">128</text>
<text top="165" left="190" width="387" height="14" font="7">referenceMapsKernelAddresses :: State -&gt; Bool</text>
<text top="192" left="190" width="258" height="14" font="7">referenceMapsKernelAddresses s</text>
<text top="218" left="207" width="361" height="14" font="7">= forall (\vpa -&gt; -- :: VirtualPageAddress</text>
<text top="245" left="242" width="198" height="14" font="7">isKernelPageAddress vpa</text>
<text top="271" left="242" width="421" height="14" font="7">|| isNothing (translatePage s (reference s) vpa))</text>
<text top="316" left="173" width="627" height="16" font="0">If any user virtual page addresses are mapped in the state, then this well-formedness</text>
<text top="349" left="173" width="289" height="16" font="0">condition is false, otherwise it is true.</text>
<text top="408" left="173" width="41" height="16" font="0">5.6.3</text>
<text top="408" left="234" width="509" height="16" font="0">Reference Page-Directory Maps Every Environment Page</text>
<text top="452" left="173" width="626" height="16" font="0">The next important property of the reference directory is that it contains a map-</text>
<text top="485" left="173" width="626" height="16" font="0">ping to every environment page in the system. According to the design presented</text>
<text top="517" left="173" width="626" height="16" font="0">in Chapter 4 and the operation speciﬁcations in Section 5.7, no operation will ever</text>
<text top="550" left="173" width="626" height="16" font="0">create a new environment page. If all environment pages are mapped in every</text>
<text top="582" left="173" width="626" height="16" font="0">state, then the set of pages that are observable to the environment domain will</text>
<text top="615" left="173" width="626" height="16" font="0">not change from state to state. This is important for memory-safety because our</text>
<text top="647" left="173" width="626" height="16" font="0">security policy states that no domain is allowed to interfere with the environment</text>
<text top="680" left="173" width="626" height="16" font="0">domain. If H (or a client kernel) could change the pages observable to the environ-</text>
<text top="712" left="173" width="626" height="16" font="0">ment domain then this policy would not hold. Establishing that the environment</text>
<text top="745" left="173" width="626" height="16" font="0">pages are mapped in the reference directory is the ﬁrst step towards ensuring the</text>
<text top="777" left="173" width="49" height="16" font="0">policy.</text>
<text top="821" left="190" width="387" height="14" font="7">referenceContainsEnvironment :: State -&gt; Bool</text>
<text top="848" left="190" width="258" height="14" font="7">referenceContainsEnvironment s</text>
<text top="874" left="207" width="369" height="14" font="7">= forall (\ppa -&gt; -- :: PhysicalPageAddress</text>
<text top="900" left="242" width="292" height="14" font="7">not (isEnvironment (status s ppa))</text>
<text top="927" left="242" width="369" height="14" font="7">|| exists (\vpa -&gt; -- :: VirtualPageAddress</text>
<text top="953" left="345" width="352" height="14" font="7">case translatePage s (reference s) vpa of</text>
<text top="980" left="362" width="60" height="14" font="7">Nothing</text>
<text top="980" left="448" width="69" height="14" font="7">-&gt; False</text>
<text top="1006" left="362" width="223" height="14" font="7">Just ppa’ -&gt; ppa == ppa’))</text>
</page>
<page number="151" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">129</text>
<text top="163" left="173" width="626" height="16" font="0">The formulation of referenceContainsEnvironment quantiﬁes over each physical</text>
<text top="195" left="173" width="626" height="16" font="0">page address. For any environment page, there must exist a virtual page address</text>
<text top="228" left="173" width="626" height="16" font="0">whose translation in the reference page-directory equals the address of the envi-</text>
<text top="260" left="173" width="110" height="16" font="0">ronment page.</text>
<text top="320" left="173" width="41" height="16" font="0">5.6.4</text>
<text top="320" left="234" width="441" height="16" font="0">All Page-Directories Contain Reference Mappings</text>
<text top="364" left="173" width="626" height="16" font="0">The previous property establishes that every environment page is mapped in the</text>
<text top="397" left="173" width="626" height="16" font="0">reference page-directory. If we can establish that every other page-directory in the</text>
<text top="429" left="173" width="626" height="16" font="0">system contains the same kernel-space mappings as this directory, then we can</text>
<text top="462" left="173" width="626" height="16" font="0">guarantee that there is a consistent view of kernel-space no matter which page-</text>
<text top="494" left="173" width="626" height="16" font="0">directory CR3 points to. From this we can deduce that the set of pages accessible</text>
<text top="527" left="173" width="626" height="16" font="0">to the environment domain does not change from state to state. We express this</text>
<text top="559" left="173" width="626" height="16" font="0">property in Haskell by quantifying over each kernel-space virtual page address</text>
<text top="592" left="173" width="626" height="16" font="0">in pages with a page-directory status. The translation of the virtual address in</text>
<text top="624" left="173" width="626" height="16" font="0">a given page-directory must match the translation of the same address in the</text>
<text top="657" left="173" width="146" height="16" font="0">reference directory.</text>
<text top="701" left="190" width="412" height="14" font="7">pageDirectoriesContainReference :: State -&gt; Bool</text>
<text top="727" left="190" width="284" height="14" font="7">pageDirectoriesContainReference s</text>
<text top="753" left="207" width="369" height="14" font="7">= forall (\ppa -&gt; -- :: PhysicalPageAddress</text>
<text top="780" left="242" width="172" height="14" font="7">case status s ppa of</text>
<text top="806" left="259" width="155" height="14" font="7">PageDirectory _ -&gt;</text>
<text top="833" left="276" width="344" height="14" font="7">forall (\vpa -&gt; -- :: VirtualPageAddress</text>
<text top="859" left="293" width="206" height="14" font="7">isUserPageAddress vpa ||</text>
<text top="886" left="293" width="292" height="14" font="7">(translatePage s (reference s) vpa</text>
<text top="912" left="302" width="241" height="14" font="7">== translatePage s ppa vpa))</text>
<text top="938" left="259" width="86" height="14" font="7">_ -&gt; True)</text>
<text top="983" left="173" width="626" height="16" font="0">This property ignores the translation of user-space addresses. None are mapped in</text>
<text top="1016" left="173" width="626" height="16" font="0">the reference directory and we expect user-space mappings to be diﬀerent in the</text>
<text top="1048" left="173" width="171" height="16" font="0">other page-directories.</text>
</page>
<page number="152" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">130</text>
<text top="163" left="173" width="41" height="16" font="0">5.6.5</text>
<text top="163" left="234" width="565" height="16" font="0">Environment Pages Are Only Mapped to Addresses That Are</text>
<text top="198" left="234" width="364" height="16" font="0">Mapped in the Reference Page-Directory</text>
<text top="242" left="173" width="626" height="16" font="0">In addition to protecting the mappings of the environment domain, we need to</text>
<text top="274" left="173" width="626" height="16" font="0">ensure the integrity of the run-time system data. H has direct access to the envi-</text>
<text top="307" left="173" width="626" height="16" font="0">ronment memory through the unsafe operations of the FFI, but we trust H not to</text>
<text top="339" left="173" width="626" height="16" font="0">purposefully manipulate this memory. The operation speciﬁcations will help us to</text>
<text top="372" left="173" width="626" height="16" font="0">validate that H does not modify the environment data accidentally. Client kernels</text>
<text top="404" left="173" width="626" height="16" font="0">cannot modify the environment data because of the privilege restrictions imposed</text>
<text top="437" left="173" width="626" height="16" font="0">by H in software: H does not expose any operation that would allow a client to</text>
<text top="469" left="173" width="626" height="16" font="0">modify environment memory. For the user domain, we use hardware rings to en-</text>
<text top="502" left="173" width="626" height="16" font="0">force separation between user processes and the execution environment. The ﬁnal</text>
<text top="534" left="173" width="626" height="16" font="0">property of the reference directory captures the requirement that all mappings to</text>
<text top="567" left="173" width="626" height="16" font="0">environment pages are present in the reference directory. Because the reference</text>
<text top="599" left="173" width="626" height="16" font="0">directory contains no user-space mappings, this is equivalent to saying that no</text>
<text top="632" left="173" width="501" height="16" font="0">environment page is ever reachable through a user-space address.</text>
<text top="676" left="190" width="369" height="14" font="7">environmentOnlyInReference :: State -&gt; Bool</text>
<text top="702" left="190" width="241" height="14" font="7">environmentOnlyInReference s</text>
<text top="728" left="207" width="361" height="14" font="7">= forall (\pd -&gt; -- :: PhysicalPageAddress</text>
<text top="755" left="242" width="344" height="14" font="7">forall (\vpa -&gt; -- :: VirtualPageAddress</text>
<text top="781" left="259" width="258" height="14" font="7">case translatePage s pd vpa of</text>
<text top="808" left="276" width="395" height="14" font="7">Just ppa -&gt; not (isEnvironment (status s ppa))</text>
<text top="834" left="379" width="284" height="14" font="7">|| mappedPage s (reference s) vpa</text>
<text top="860" left="276" width="146" height="14" font="7">Nothing -&gt; True))</text>
<text top="905" left="173" width="626" height="16" font="0">The environmentOnlyInReference property is false if any page-directory con-</text>
<text top="938" left="173" width="626" height="16" font="0">tains a mapping to an environment page that is not also present in the reference</text>
<text top="970" left="173" width="72" height="16" font="0">directory.</text>
</page>
<page number="153" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">131</text>
<text top="163" left="173" width="41" height="16" font="0">5.6.6</text>
<text top="163" left="234" width="257" height="16" font="0">Mapped Pages Are Available</text>
<text top="207" left="173" width="635" height="16" font="0">Another dimension of our memory-safety property is the protection of page-directory</text>
<text top="239" left="173" width="626" height="16" font="0">and page-table contents. This aspect of memory-safety depends on the dynamic be-</text>
<text top="272" left="173" width="626" height="16" font="0">havior of the H operations because, unlike environment pages, the set of pages with</text>
<text top="304" left="173" width="626" height="16" font="0">the page-table and page-directory status is not ﬁxed. Still, there are fundamental</text>
<text top="337" left="173" width="626" height="16" font="0">properties that must hold of the translation table structures (which correspond</text>
<text top="370" left="173" width="626" height="16" font="0">to the status ﬁeld of the state) in order for them to be well-formed. The ﬁrst</text>
<text top="402" left="173" width="626" height="16" font="0">such property states that no virtual address maps to a physical address that is</text>
<text top="435" left="173" width="626" height="16" font="0">not installed on the machine. A table/directory entry must contain nothing or a</text>
<text top="467" left="173" width="231" height="16" font="0">mapping to available memory.</text>
<text top="507" left="190" width="344" height="14" font="7">mappedPagesAreAvailable :: State -&gt; Bool</text>
<text top="534" left="190" width="215" height="14" font="7">mappedPagesAreAvailable s</text>
<text top="560" left="207" width="361" height="14" font="7">= forall (\pd -&gt; -- :: PhysicalPageAddress</text>
<text top="586" left="242" width="163" height="14" font="7">case status s pd of</text>
<text top="613" left="259" width="155" height="14" font="7">PageDirectory _ -&gt;</text>
<text top="639" left="293" width="344" height="14" font="7">forall (\vpa -&gt; -- :: VirtualPageAddress</text>
<text top="666" left="310" width="258" height="14" font="7">case translatePage s pd vpa of</text>
<text top="692" left="327" width="60" height="14" font="7">Nothing</text>
<text top="692" left="405" width="60" height="14" font="7">-&gt; True</text>
<text top="719" left="327" width="292" height="14" font="7">Just ppa -&gt; isInstalledPage s ppa)</text>
<text top="745" left="259" width="86" height="14" font="7">_ -&gt; True)</text>
<text top="786" left="173" width="626" height="16" font="0">We quantify over page-directories and virtual page addresses. The value of the</text>
<text top="819" left="173" width="626" height="16" font="0">property mappedPagesAreAvailable will be false if the translation function indi-</text>
<text top="851" left="173" width="448" height="16" font="0">cates there is a mapping installed but no such page exists.</text>
<text top="911" left="173" width="41" height="16" font="0">5.6.7</text>
<text top="911" left="234" width="328" height="16" font="0">Page-Table Pointers Are Page-Tables</text>
<text top="955" left="173" width="626" height="16" font="0">We also deﬁne a well-formedness property that ensures that page-directory entries</text>
<text top="987" left="173" width="626" height="16" font="0">are consistent with the rest of the state. In particular, if a page-directory entry</text>
<text top="1020" left="173" width="626" height="16" font="0">contains a page-table pointer, but the page pointed to by that address is not a</text>
<text top="1052" left="173" width="626" height="16" font="0">page-table according to the status ﬁeld of the state, then something is wrong.</text>
</page>
<page number="154" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">132</text>
<text top="163" left="173" width="626" height="16" font="0">Maybe an incorrect pointer was installed in the directory or maybe the status</text>
<text top="195" left="173" width="626" height="16" font="0">was not appropriately updated, but we will not necessarily be able to protect the</text>
<text top="228" left="173" width="321" height="16" font="0">contents of the page-table in such a state.</text>
<text top="272" left="190" width="369" height="14" font="7">tablePointersArePageTables :: State -&gt; Bool</text>
<text top="298" left="190" width="241" height="14" font="7">tablePointersArePageTables s</text>
<text top="325" left="207" width="146" height="14" font="7">= forall (\ppa -&gt;</text>
<text top="325" left="370" width="215" height="14" font="7">-- :: PhysicalPageAddress</text>
<text top="351" left="242" width="344" height="14" font="7">forall (\pdi -&gt; -- :: PageDirectoryIndex</text>
<text top="377" left="259" width="172" height="14" font="7">case status s ppa of</text>
<text top="404" left="276" width="163" height="14" font="7">PageDirectory pd -&gt;</text>
<text top="430" left="293" width="120" height="14" font="7">case pd pdi of</text>
<text top="457" left="310" width="412" height="14" font="7">Just (Table ppa’) -&gt; isPageTable (status s ppa’)</text>
<text top="483" left="310" width="9" height="14" font="7">_</text>
<text top="483" left="336" width="60" height="14" font="7">-&gt; True</text>
<text top="510" left="276" width="95" height="14" font="7">_ -&gt; True))</text>
<text top="555" left="173" width="626" height="16" font="0">We specify tablePointersArePageTables by quantifying over all possible page-</text>
<text top="587" left="173" width="580" height="16" font="0">directory entries (any index into a page with the page-directory status).</text>
<text top="587" left="769" width="30" height="16" font="0">The</text>
<text top="620" left="173" width="626" height="16" font="0">property is true if every entry that maps to a table entry points to a page with the</text>
<text top="652" left="173" width="136" height="16" font="0">page-table status.</text>
<text top="712" left="173" width="41" height="16" font="0">5.6.8</text>
<text top="712" left="234" width="497" height="16" font="0">Regions Are Consistent and Disjoint From Environment</text>
<text top="756" left="173" width="496" height="16" font="0">The last component of the state is the set of region handles.</text>
<text top="756" left="685" width="114" height="16" font="0">The ﬁrst well-</text>
<text top="788" left="173" width="626" height="16" font="0">formedness constraint on region handles simply provides consistency between the</text>
<text top="821" left="173" width="626" height="16" font="0">two components of the RegionState. Recall from Section 5.3.3 that we track the</text>
<text top="853" left="173" width="626" height="16" font="0">set of initial regions and the set of all regions. The initial regions must be a subset</text>
<text top="886" left="173" width="198" height="16" font="0">of the total set of regions.</text>
<text top="930" left="190" width="352" height="14" font="7">initialRegionsAreRegions :: State -&gt; Bool</text>
<text top="956" left="190" width="223" height="14" font="7">initialRegionsAreRegions s</text>
<text top="983" left="207" width="430" height="14" font="7">= Set.isSubsetOf (initialRegions r) (allRegions r)</text>
<text top="1009" left="199" width="43" height="14" font="7">where</text>
<text top="1035" left="216" width="112" height="14" font="7">r = regions s</text>
</page>
<page number="155" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">133</text>
<text top="163" left="173" width="626" height="16" font="0">The region handles describe the memory that may be used by client kernels for their</text>
<text top="195" left="173" width="626" height="16" font="0">own purposes. This includes mapping memory to the user domain and mapping</text>
<text top="228" left="173" width="626" height="16" font="0">memory into the free portion of kernel-space with read-write access for the kernel</text>
<text top="260" left="173" width="626" height="16" font="0">domain. If the memory described by the regions included any environment pages,</text>
<text top="293" left="173" width="626" height="16" font="0">then it would be possible to violate the policy that no domains interfere with</text>
<text top="325" left="173" width="626" height="16" font="0">the environment. The property environmentOnlyInReference would be violated</text>
<text top="358" left="173" width="626" height="16" font="0">if the client mapped environment memory to the user domain, but we cannot</text>
<text top="390" left="173" width="626" height="16" font="0">avoid extra kernel-space mappings to the environment with the properties we have</text>
<text top="423" left="173" width="626" height="16" font="0">examined so far. Instead, we provide a strong guarantee that the kernel cannot</text>
<text top="455" left="173" width="626" height="16" font="0">access the environment memory by deﬁning a well-formedness constraint stating</text>
<text top="488" left="173" width="516" height="16" font="0">that no region handle contains a reference to an environment page.</text>
<text top="532" left="190" width="352" height="14" font="7">regionsAreNotEnvironment :: State -&gt; Bool</text>
<text top="558" left="190" width="223" height="14" font="7">regionsAreNotEnvironment s</text>
<text top="585" left="207" width="369" height="14" font="7">= not (any (existsRegion isEnvironmentPage)</text>
<text top="611" left="302" width="318" height="14" font="7">(Set.elems (allRegions (regions s))))</text>
<text top="657" left="173" width="626" height="15" font="0">isEnvironmentPage is a predicate that tests the status of a physical address in a</text>
<text top="689" left="173" width="607" height="16" font="0">particular state. We deﬁne similar predicates on the other status types as well.</text>
<text top="732" left="190" width="490" height="14" font="7">isEnvironmentPage :: State -&gt; PhysicalPageAddress -&gt; Bool</text>
<text top="759" left="190" width="464" height="14" font="7">isEnvironmentPage s ppa = isEnvironment (status s ppa)</text>
<text top="812" left="190" width="576" height="14" font="7">isNormalPage, isPageDirectoryPage, isPageTablePage, isInstalledPage</text>
<text top="838" left="207" width="335" height="14" font="7">:: State -&gt; PhysicalPageAddress -&gt; Bool</text>
<text top="884" left="173" width="626" height="15" font="0">regionsAreNotEnvironment is true for states where the region handles do not</text>
<text top="916" left="173" width="542" height="16" font="0">contain a reference to any physical page with the status Environment.</text>
<text top="975" left="173" width="41" height="16" font="0">5.6.9</text>
<text top="975" left="234" width="208" height="16" font="0">Putting It All Together</text>
<text top="1019" left="173" width="626" height="16" font="0">We use these well-formedness constraints to express the idea that there are certain</text>
<text top="1052" left="173" width="626" height="16" font="0">fundamental properties enforced by every operation in the system by constraining</text>
</page>
<page number="156" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">134</text>
<text top="163" left="173" width="626" height="16" font="0">the allowed values of State to the well-formed set. We formulate a predicate on</text>
<text top="195" left="173" width="626" height="16" font="0">states called wellFormed that encompasses all of the well-formedness constraints</text>
<text top="228" left="173" width="73" height="16" font="0">on states.</text>
<text top="272" left="190" width="232" height="14" font="7">wellFormed :: State -&gt; Bool</text>
<text top="298" left="190" width="326" height="14" font="7">wellFormed s = cr3IsPageDirectory s &amp;&amp;</text>
<text top="325" left="319" width="249" height="14" font="7">referenceIsPageDirectory s &amp;&amp;</text>
<text top="351" left="319" width="284" height="14" font="7">referenceMapsKernelAddresses s &amp;&amp;</text>
<text top="377" left="319" width="284" height="14" font="7">referenceContainsEnvironment s &amp;&amp;</text>
<text top="404" left="319" width="309" height="14" font="7">pageDirectoriesContainReference s &amp;&amp;</text>
<text top="430" left="319" width="266" height="14" font="7">environmentOnlyInReference s &amp;&amp;</text>
<text top="457" left="319" width="241" height="14" font="7">mappedPagesAreAvailable s &amp;&amp;</text>
<text top="483" left="319" width="266" height="14" font="7">tablePointersArePageTables s &amp;&amp;</text>
<text top="510" left="319" width="249" height="14" font="7">initialRegionsAreRegions s &amp;&amp;</text>
<text top="536" left="319" width="223" height="14" font="7">regionsAreNotEnvironment s</text>
<text top="581" left="173" width="626" height="16" font="0">The well-formedness conditions capture our intuition for what properties will be</text>
<text top="613" left="173" width="626" height="16" font="0">necessary to prove the unwinding conditions described in Section 5.1. Most corre-</text>
<text top="646" left="173" width="626" height="16" font="0">spond to the informal invariants that we created during the process of designing</text>
<text top="678" left="173" width="626" height="16" font="0">and implementing H to enforce our notion of memory-safety. It is possible that</text>
<text top="711" left="173" width="626" height="16" font="0">the set of well-formedness conditions is not suﬃcient to prove the unwinding con-</text>
<text top="743" left="173" width="429" height="16" font="0">ditions, but the predicate can be extended as necessary.</text>
<text top="805" left="173" width="26" height="16" font="0">5.7</text>
<text top="805" left="219" width="526" height="16" font="0">CONNECTING THE MODEL AND IMPLEMENTATION</text>
<text top="855" left="173" width="626" height="16" font="0">Well-formedness provides the baseline for a well-behaving system. The next step</text>
<text top="888" left="173" width="626" height="16" font="0">in assuring memory-safety is to specify the eﬀects of each action of the model.</text>
<text top="920" left="173" width="626" height="16" font="0">Specifying the permitted behavior of each action will make the interactions between</text>
<text top="953" left="173" width="626" height="16" font="0">domains more concrete and will help us to gain conﬁdence that the security policy</text>
<text top="985" left="173" width="626" height="16" font="0">holds between our domains. We present the action speciﬁcations as relations on</text>
<text top="1018" left="173" width="626" height="16" font="0">well-formed states. We opted against a functional style that directly describes the</text>
<text top="1050" left="173" width="626" height="16" font="0">transformation each action performs on states because we found that approach</text>
</page>
<page number="157" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">135</text>
<text top="163" left="173" width="626" height="16" font="0">forced us to specify details that are not relevant for safety. Our goal is to present</text>
<text top="195" left="173" width="626" height="16" font="0">a speciﬁcation that supports memory-safety and prevents memory leaks via the H</text>
<text top="228" left="173" width="626" height="16" font="0">operations with a minimal number of extraneous details. The speciﬁcations serve</text>
<text top="260" left="173" width="626" height="16" font="0">as a further instantiation of the actions presented in Section 5.4.1 and provide a</text>
<text top="293" left="173" width="300" height="16" font="0">foundation for future veriﬁcation work.</text>
<text top="325" left="199" width="600" height="16" font="0">A particular beneﬁt of the relational style is that nondeterminism is built in.</text>
<text top="358" left="173" width="626" height="16" font="0">Given a particular before state, the relational speciﬁcation of an action may hold</text>
<text top="390" left="173" width="626" height="16" font="0">for many diﬀerent after states. This property of the relational model allows us to</text>
<text top="423" left="173" width="626" height="16" font="0">leave aspects of the system that are not relevant for safety out of the model. For</text>
<text top="455" left="173" width="626" height="16" font="0">example, when we specify the behavior of user program execution, we can ignore</text>
<text top="488" left="173" width="626" height="16" font="0">any changes that occur in user memory pages. The manner in which a user program</text>
<text top="520" left="173" width="626" height="16" font="0">changes the contents of these pages is irrelevant to our safety argument and, with a</text>
<text top="553" left="173" width="626" height="16" font="0">relational model, we can leave these contents unspeciﬁed. This is in stark contrast</text>
<text top="585" left="173" width="626" height="16" font="0">to a functional model where we must specify a single result state that describes the</text>
<text top="618" left="173" width="626" height="16" font="0">particular changes a user program makes to memory, even though we do not care</text>
<text top="650" left="173" width="626" height="16" font="0">about these values. Nondeterminism must be added to such a model explicitly, for</text>
<text top="683" left="173" width="626" height="16" font="0">example, by using an oracle to generate values, but the overall speciﬁcation will be</text>
<text top="715" left="173" width="626" height="16" font="0">more complicated. Of course, the downside to the nondeterminism of the relational</text>
<text top="748" left="173" width="626" height="16" font="0">model is that the gap between the speciﬁcation and the actual implementation</text>
<text top="780" left="173" width="626" height="16" font="0">(where actions are functions) is larger than with a functional model. We choose</text>
<text top="813" left="173" width="626" height="16" font="0">to start with the relational model because it is easy to capture the properties of</text>
<text top="845" left="173" width="626" height="16" font="0">interest, knowing full well that a reﬁnement into a functional model will likely be</text>
<text top="878" left="173" width="533" height="16" font="0">an important stepping stone on the path to any full veriﬁcation of H.</text>
<text top="910" left="199" width="600" height="16" font="0">A further beneﬁt of the relational style is that it separates the demonstra-</text>
<text top="943" left="173" width="626" height="16" font="0">tion that the actions produce well-formed states from the demonstration that the</text>
<text top="975" left="173" width="626" height="16" font="0">actions reﬁne their speciﬁcation. Specifying the connection of the action speci-</text>
<text top="1008" left="173" width="626" height="16" font="0">ﬁcations to the functions of our H implementation is straightforward; there is a</text>
</page>
<page number="158" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">136</text>
<text top="163" left="173" width="626" height="16" font="0">single action speciﬁcation, op that corresponds to each memory management op-</text>
<text top="195" left="173" width="626" height="16" font="0">eration, opImp, in H. We must show that, for every action op in the model, the</text>
<text top="228" left="173" width="171" height="16" font="0">implementation opImp</text>
<text top="274" left="199" width="232" height="17" font="0">• preserves well-formed states</text>
<text top="307" left="217" width="422" height="17" font="0">∀s ∈ State. wellFormed s ⇒ wellFormed (opImp s)</text>
<text top="354" left="199" width="448" height="17" font="0">• implements the speciﬁcation when the action is possible</text>
<text top="387" left="217" width="86" height="17" font="0">∀s ∈ State.</text>
<text top="422" left="254" width="382" height="15" font="0">wellFormed s ∧ (∃s’. actionSpec op s s’) ⇒</text>
<text top="454" left="254" width="231" height="15" font="0">actionSpec op s (opImp s)</text>
<text top="499" left="199" width="456" height="17" font="0">• and preserves the system state when the action is invalid</text>
<text top="532" left="217" width="86" height="17" font="0">∀s ∈ State.</text>
<text top="567" left="254" width="407" height="15" font="0">wellFormed s ∧ (∀s’. ¬(actionSpec op s s’)) ⇒</text>
<text top="599" left="254" width="99" height="15" font="0">opImp s = s</text>
<text top="645" left="173" width="626" height="16" font="0">An implementation that satisﬁes these properties is a valid instantiation for the</text>
<text top="678" left="173" width="626" height="16" font="0">action that corresponds to op in our Rushby model. Proving that our implemen-</text>
<text top="710" left="173" width="626" height="16" font="0">tation satisﬁes these properties is future work. Note that well-formedness alone is</text>
<text top="743" left="173" width="626" height="16" font="0">not suﬃcient for memory-safety because some aspects of a correct implementation</text>
<text top="775" left="173" width="359" height="16" font="0">rely on the dynamic behavior of the operation.</text>
<text top="835" left="173" width="41" height="16" font="0">5.7.1</text>
<text top="835" left="234" width="204" height="16" font="0">Speciﬁcation of WriteE</text>
<text top="879" left="173" width="626" height="16" font="0">The ﬁrst action in our model is the WriteE operation of the environment domain.</text>
<text top="913" left="173" width="626" height="15" font="0">WriteE has additional arguments of type VirtualAddress (the location to write)</text>
<text top="944" left="173" width="626" height="16" font="0">and Word8 (the value to write). The intended behavior of WriteE is to modify</text>
<text top="977" left="173" width="626" height="16" font="0">a location in one of the pages owned by the environment domain. According to</text>
<text top="1009" left="173" width="626" height="16" font="0">the security policy (see Section 5.5), the environment domain can interfere with</text>
<text top="1042" left="173" width="626" height="16" font="0">itself and H, but should only write to pages with the environment status. Thus,</text>
</page>
<page number="159" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">137</text>
<text top="163" left="173" width="626" height="16" font="0">in our speciﬁcation, writeE is true when the contents of a single byte in a single</text>
<text top="195" left="173" width="626" height="16" font="0">environment page change. writeE is false if the status of any page changes or if</text>
<text top="228" left="173" width="386" height="16" font="0">the contents of any non-environment page change.</text>
<text top="266" left="190" width="507" height="14" font="7">writeE :: VirtualAddress -&gt; Word8 -&gt; State -&gt; State -&gt; Bool</text>
<text top="292" left="190" width="223" height="14" font="7">writeE va val state state’</text>
<text top="319" left="207" width="215" height="14" font="7">= cr3 state == cr3 state’</text>
<text top="345" left="224" width="326" height="14" font="7">&amp;&amp; reference state == reference state’</text>
<text top="372" left="224" width="292" height="14" font="7">&amp;&amp; regions state == regions state’</text>
<text top="398" left="224" width="249" height="14" font="7">&amp;&amp; case translate state va of</text>
<text top="424" left="267" width="137" height="14" font="7">Nothing -&gt; False</text>
<text top="451" left="267" width="146" height="14" font="7">Just (ppa,off) -&gt;</text>
<text top="477" left="284" width="387" height="14" font="7">forall (\someppa -&gt; -- :: PhysicalPageAddress</text>
<text top="504" left="302" width="146" height="14" font="7">if someppa /= ppa</text>
<text top="530" left="327" width="430" height="14" font="7">then status state someppa == status state’ someppa</text>
<text top="557" left="327" width="284" height="14" font="7">else case status state someppa of</text>
<text top="583" left="388" width="172" height="14" font="7">Environment pdata -&gt;</text>
<text top="609" left="405" width="249" height="14" font="7">case status state’ someppa of</text>
<text top="636" left="422" width="180" height="14" font="7">Environment pdata’ -&gt;</text>
<text top="662" left="439" width="326" height="14" font="7">pdata’ == updatePageData off val pdata</text>
<text top="689" left="422" width="86" height="14" font="7">_ -&gt; False</text>
<text top="715" left="388" width="95" height="14" font="7">_ -&gt; False)</text>
<text top="754" left="173" width="626" height="16" font="0">The ﬁrst few conjuncts are frame rules stating that this operation does not change</text>
<text top="787" left="173" width="626" height="16" font="0">the cr3 or reference page-directory settings and that it does not change the set of</text>
<text top="819" left="173" width="626" height="16" font="0">region handles. The only state component that is relevant for the writeE operation</text>
<text top="852" left="173" width="626" height="16" font="0">is the status ﬁeld. We will see similar frame rules in each of our speciﬁcations—</text>
<text top="884" left="173" width="427" height="16" font="0">each of our actions only modiﬁes a portion of the state.</text>
<text top="943" left="173" width="41" height="16" font="0">5.7.2</text>
<text top="943" left="234" width="276" height="16" font="0">Speciﬁcation of DeriveRegionH</text>
<text top="987" left="173" width="626" height="16" font="0">The DeriveRegionH action creates a new region handle from an existing one. The</text>
<text top="1020" left="173" width="626" height="16" font="0">additional arguments are the starting region (of type PhysicalRegion) and the</text>
<text top="1052" left="173" width="626" height="16" font="0">parameters for the new region: a start address of type PhysicalPageAddress and</text>
</page>
<page number="160" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">138</text>
<text top="163" left="173" width="626" height="16" font="0">a length of type RegionLength. The most important property of this action is</text>
<text top="195" left="173" width="626" height="16" font="0">that it maintains our inductive argument on regions: if the initial regions do not</text>
<text top="228" left="173" width="626" height="16" font="0">point to any environment memory then no region we create will either. We specify</text>
<text top="260" left="173" width="626" height="16" font="0">this by requiring that the starting region is a member of the existing handle set</text>
<text top="293" left="173" width="626" height="16" font="0">and that the new region being created is a subregion of the starting one. The set</text>
<text top="325" left="173" width="626" height="16" font="0">of all regions in the after state must contain exactly one more region handle than</text>
<text top="358" left="173" width="626" height="16" font="0">the set of all regions in the before state, and this handle must match the region</text>
<text top="390" left="173" width="405" height="16" font="0">description given by the start and length arguments.</text>
<text top="426" left="181" width="601" height="14" font="7">deriveRegionH :: PhysicalRegion -&gt; PhysicalPageAddress -&gt; RegionLength</text>
<text top="452" left="199" width="215" height="14" font="7">-&gt; State -&gt; State -&gt; Bool</text>
<text top="478" left="181" width="318" height="14" font="7">deriveRegionH pr ppa len state state’</text>
<text top="505" left="199" width="215" height="14" font="7">= cr3 state == cr3 state’</text>
<text top="531" left="216" width="326" height="14" font="7">&amp;&amp; reference state == reference state’</text>
<text top="558" left="216" width="275" height="14" font="7">&amp;&amp; status state == status state’</text>
<text top="584" left="216" width="584" height="14" font="7">&amp;&amp; initialRegions (regions state) == initialRegions (regions state’)</text>
<text top="611" left="216" width="198" height="14" font="7">&amp;&amp; Set.member pr allOld</text>
<text top="637" left="216" width="301" height="14" font="7">&amp;&amp; isPhysicalSubregion newRegion pr</text>
<text top="663" left="216" width="266" height="14" font="7">&amp;&amp; Set.isSubsetOf allOld allNew</text>
<text top="690" left="216" width="550" height="14" font="7">&amp;&amp; goodDerivedRegion (Set.toList (Set.difference allNew allOld))</text>
<text top="716" left="199" width="43" height="14" font="7">where</text>
<text top="743" left="216" width="301" height="14" font="7">allOld = allRegions (regions state)</text>
<text top="769" left="216" width="309" height="14" font="7">allNew = allRegions (regions state’)</text>
<text top="796" left="216" width="292" height="14" font="7">newRegion = PhysicalRegion ppa len</text>
<text top="822" left="216" width="326" height="14" font="7">goodDerivedRegion [r] = r == newRegion</text>
<text top="848" left="216" width="163" height="14" font="7">goodDerivedRegion _</text>
<text top="848" left="405" width="60" height="14" font="7">= False</text>
<text top="885" left="173" width="626" height="16" font="0">The derive region action only modiﬁes the set of all region handles; deriveRegionH</text>
<text top="917" left="173" width="389" height="16" font="0">will be false if any other state component changes.</text>
<text top="976" left="173" width="41" height="16" font="0">5.7.3</text>
<text top="976" left="234" width="356" height="16" font="0">Speciﬁcation of AllocatePageDirectoryH</text>
<text top="1021" left="173" width="626" height="15" font="0">AllocatePageDirectoryH turns a physical page into a page-directory page. There</text>
<text top="1052" left="173" width="626" height="16" font="0">are important safety issues at play in this operation, because the physical page</text>
</page>
<page number="161" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">139</text>
<text top="163" left="173" width="626" height="16" font="0">could introduce a channel for the user domain or kernel domain to access page-</text>
<text top="195" left="173" width="626" height="16" font="0">directory contents. Page-directory pages are owned by the H domain, so this would</text>
<text top="228" left="173" width="626" height="16" font="0">violate the security policy. We prevent such a channel by specifying that the page</text>
<text top="260" left="173" width="626" height="16" font="0">being converted must not be mapped in any portion of any address space. The</text>
<text top="293" left="173" width="626" height="16" font="0">page must also have the normal status, because a page with any other status is</text>
<text top="325" left="173" width="626" height="16" font="0">currently in use by H or the environment. For allocatePageDirectoryH to be</text>
<text top="358" left="173" width="626" height="16" font="0">satisﬁed, the status of the newly created page-directory must match the reference</text>
<text top="390" left="173" width="626" height="16" font="0">page-directory (containing all of the same kernel-space mappings and no user-space</text>
<text top="423" left="173" width="494" height="16" font="0">mappings) and the status of all other pages must be unchanged.</text>
<text top="467" left="190" width="610" height="14" font="7">allocatePageDirectoryH :: PhysicalPageAddress -&gt; State -&gt; State -&gt; Bool</text>
<text top="493" left="190" width="335" height="14" font="7">allocatePageDirectoryH ppa state state’</text>
<text top="520" left="207" width="215" height="14" font="7">= cr3 state == cr3 state’</text>
<text top="546" left="224" width="326" height="14" font="7">&amp;&amp; reference state == reference state’</text>
<text top="572" left="224" width="292" height="14" font="7">&amp;&amp; regions state == regions state’</text>
<text top="599" left="224" width="266" height="14" font="7">&amp;&amp; unmappedNormalPage state ppa</text>
<text top="625" left="224" width="481" height="14" font="7">&amp;&amp; forall (\someppa -&gt; -- someppa :: PhysicalPageAddress</text>
<text top="652" left="267" width="146" height="14" font="7">if someppa /= ppa</text>
<text top="678" left="293" width="430" height="14" font="7">then status state someppa == status state’ someppa</text>
<text top="705" left="293" width="223" height="14" font="7">else status state’ someppa</text>
<text top="731" left="336" width="309" height="14" font="7">== status state’ (reference state’))</text>
<text top="788" left="173" width="41" height="16" font="0">5.7.4</text>
<text top="788" left="234" width="321" height="16" font="0">Speciﬁcation of FreePageDirectoryH</text>
<text top="834" left="173" width="626" height="15" font="0">FreePageDirectoryH is the essentially the inverse of AllocatePageDirectoryH:</text>
<text top="865" left="173" width="626" height="16" font="0">the action frees a page-directory page and converts it to an unmapped normal</text>
<text top="897" left="173" width="626" height="16" font="0">page. We specify freePageDirectoryH using allocatePageDirectoryH with the</text>
<text top="930" left="173" width="626" height="16" font="0">additional condition that the physical page must be zeroed in the after state. The</text>
<text top="962" left="173" width="495" height="16" font="0">page zeroPageData is a constant that maps every oﬀset to zero.</text>
</page>
<page number="162" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">140</text>
<text top="165" left="190" width="524" height="14" font="7">freePageDirectoryH :: PageDirectory -&gt; State -&gt; State -&gt; Bool</text>
<text top="192" left="190" width="292" height="14" font="7">freePageDirectoryH pd state state’</text>
<text top="218" left="207" width="344" height="14" font="7">= allocatePageDirectoryH pd state’ state</text>
<text top="245" left="224" width="232" height="14" font="7">&amp;&amp; case status state’ pd of</text>
<text top="271" left="267" width="369" height="14" font="7">Normal pagedata -&gt; pagedata == zeroPageData</text>
<text top="297" left="267" width="9" height="14" font="7">_</text>
<text top="297" left="405" width="215" height="14" font="7">-&gt; False -- never happens</text>
<text top="350" left="190" width="206" height="14" font="7">zeroPageData :: PageData</text>
<text top="397" left="173" width="626" height="15" font="0">freePageDirectoryH requires that the page-directory does not contain any user</text>
<text top="428" left="173" width="626" height="16" font="0">mappings when it is freed. This is stronger than the requirements of the actual</text>
<text top="460" left="173" width="626" height="16" font="0">H implementation—we specify as part of the API that the page-directory should</text>
<text top="493" left="173" width="626" height="16" font="0">be empty of user mappings but allow the free to proceed in all cases. To make</text>
<text top="525" left="173" width="626" height="16" font="0">H match the speciﬁcation, we would need to revise the type of the freePageMap</text>
<text top="558" left="173" width="626" height="16" font="0">operation to permit failure if the operation is invoked on a non-empty directory.</text>
<text top="590" left="173" width="626" height="16" font="0">This semantic dimension of free is not critical for memory-safety, but can introduce</text>
<text top="623" left="173" width="594" height="16" font="0">space leaks if any page-tables that are in use for mappings are not reclaimed.</text>
<text top="683" left="173" width="41" height="16" font="0">5.7.5</text>
<text top="683" left="234" width="273" height="16" font="0">Speciﬁcation of AddMappingH</text>
<text top="727" left="173" width="626" height="16" font="0">Adding a mapping to the user portion of the address-space is the most complicated</text>
<text top="759" left="173" width="626" height="16" font="0">action in our model. We split the speciﬁcation into two parts: addMapping speci-</text>
<text top="792" left="173" width="626" height="16" font="0">ﬁes most of the behavior of adding a mapping (in such a way that removeMappingH</text>
<text top="824" left="173" width="626" height="16" font="0">will be the inverse operation) and addMappingH supplements the addMapping spec-</text>
<text top="857" left="173" width="626" height="16" font="0">iﬁcation with requirements that are speciﬁc to AddMappingH. The AddMappingH</text>
<text top="889" left="173" width="626" height="16" font="0">action adds a mapping from a virtual region to a physical region in a speciﬁed</text>
<text top="922" left="173" width="626" height="16" font="0">page-directory. When adding the mappings, H may need to allocate page-tables</text>
<text top="954" left="173" width="626" height="16" font="0">to support the translation of the addresses of the virtual region. As we saw in the</text>
<text top="987" left="173" width="626" height="16" font="0">design chapter (see Section 4.4.2), the client kernel provides the memory for these</text>
<text top="1019" left="173" width="626" height="16" font="0">page-tables. We model this by including a parameter to the add mapping action</text>
<text top="1052" left="173" width="626" height="16" font="0">that is a list of physical pages that may be converted into page-tables as needed.</text>
</page>
<page number="163" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">141</text>
<text top="163" left="173" width="466" height="16" font="0">This gives addMapping and addMappingH the following type:</text>
<text top="202" left="190" width="558" height="14" font="7">addMapping, addMappingH :: PageDirectory -&gt; [PhysicalPageAddress]</text>
<text top="228" left="207" width="515" height="14" font="7">-&gt; PhysicalRegion -&gt; VirtualRegion -&gt; State -&gt; State -&gt; Bool</text>
<text top="269" left="173" width="630" height="16" font="0">An important semantic diﬀerence between the two speciﬁcations is that addMapping</text>
<text top="301" left="173" width="626" height="16" font="0">expects a precise list of the set of page-tables that are needed for the operation</text>
<text top="334" left="173" width="518" height="16" font="0">while addMappingH expects a superset of the necessary page-tables.</text>
<text top="366" left="199" width="600" height="16" font="0">Due to the large number of parameters with very speciﬁc semantics, much of</text>
<text top="399" left="173" width="626" height="16" font="0">the complexity of the speciﬁcation stems from the parameter validation properties.</text>
<text top="431" left="173" width="424" height="16" font="0">The speciﬁcation must handle the following conditions:</text>
<text top="473" left="199" width="600" height="17" font="0">• The address speciﬁed as the page-directory to add the mappings to must</text>
<text top="507" left="217" width="366" height="16" font="0">actually be a page-directory in the before state.</text>
<text top="551" left="199" width="600" height="17" font="0">• Each of the potential page-table pages must be a free page. This corresponds</text>
<text top="585" left="217" width="550" height="16" font="0">to having a normal status and not being mapped in any page-directory.</text>
<text top="630" left="199" width="600" height="17" font="0">• None of the potential page-tables may lie within the physical region to be</text>
<text top="663" left="217" width="66" height="16" font="0">mapped.</text>
<text top="708" left="199" width="600" height="17" font="0">• All of the pages within the physical region must be mappable, which corre-</text>
<text top="742" left="217" width="277" height="16" font="0">sponds to having the normal status.</text>
<text top="787" left="199" width="600" height="17" font="0">• The virtual region and physical region parameters must be regions of the</text>
<text top="820" left="217" width="97" height="16" font="0">same length.</text>
<text top="865" left="199" width="600" height="17" font="0">• The virtual region must entirely consist of user-space addresses (this action</text>
<text top="899" left="217" width="275" height="16" font="0">cannot add kernel-space mappings).</text>
<text top="943" left="199" width="600" height="17" font="0">• None of the virtual addresses within the virtual region should be mapped—</text>
<text top="977" left="217" width="358" height="16" font="0">we do not allow over-mappings via this action.</text>
<text top="1020" left="173" width="626" height="16" font="0">These properties appear following the frame rules (AddMappingH does not change</text>
<text top="1054" left="173" width="344" height="15" font="0">cr3, reference or regions) in addMapping.</text>
</page>
<page number="164" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">142</text>
<text top="165" left="190" width="309" height="14" font="7">addMapping pd pts pr vr state state’</text>
<text top="192" left="207" width="215" height="14" font="7">= cr3 state == cr3 state’</text>
<text top="218" left="224" width="326" height="14" font="7">&amp;&amp; reference state == reference state’</text>
<text top="245" left="224" width="292" height="14" font="7">&amp;&amp; regions state == regions state’</text>
<text top="271" left="224" width="266" height="14" font="7">&amp;&amp; isPageDirectoryPage state pd</text>
<text top="297" left="224" width="223" height="14" font="7">&amp;&amp; case status state pd of</text>
<text top="324" left="267" width="258" height="14" font="7">PageDirectory pdirdata -&gt; True</text>
<text top="350" left="267" width="86" height="14" font="7">_ -&gt; False</text>
<text top="377" left="224" width="318" height="14" font="7">&amp;&amp; all (unmappedNormalPage state) pts</text>
<text top="403" left="224" width="464" height="14" font="7">&amp;&amp; all (\ppa -&gt; not (memberPhysicalRegion ppa pr)) pts</text>
<text top="430" left="224" width="455" height="14" font="7">&amp;&amp; all (isNormalPage state) (toListPhysicalRegion pr)</text>
<text top="456" left="224" width="387" height="14" font="7">&amp;&amp; physRegionLength pr == virtRegionLength vr</text>
<text top="482" left="224" width="155" height="14" font="7">&amp;&amp; isUserRegion vr</text>
<text top="509" left="224" width="404" height="14" font="7">&amp;&amp; forall (\somevpa -&gt; -- :: VirtualPageAddress</text>
<text top="535" left="267" width="284" height="14" font="7">if memberVirtualRegion somevpa vr</text>
<text top="562" left="293" width="395" height="14" font="7">then translatePage state pd somevpa == Nothing</text>
<text top="588" left="293" width="301" height="14" font="7">else translatePage state pd somevpa</text>
<text top="615" left="336" width="301" height="14" font="7">== translatePage state’ pd somevpa)</text>
<text top="654" left="173" width="626" height="16" font="0">The ﬁnal conjunct, which speciﬁes that the pages of the virtual region are not</text>
<text top="687" left="173" width="626" height="16" font="0">mapped, also speciﬁes the relationship between the virtual-to-physical translation</text>
<text top="719" left="173" width="626" height="16" font="0">of the before state and the after state. For any page that is not in the virtual</text>
<text top="752" left="173" width="554" height="16" font="0">region, the translation must not be aﬀected by the AddMappingH action.</text>
<text top="784" left="199" width="600" height="16" font="0">The remainder of the speciﬁcation is solely focused on the relationship between</text>
<text top="817" left="173" width="626" height="16" font="0">the before and after states. The fundamental property we expect as a result of</text>
<text top="849" left="173" width="626" height="16" font="0">adding a mapping is that, in the after state, each page address in the virtual region</text>
<text top="882" left="173" width="484" height="16" font="0">maps to the corresponding page address in the physical region.</text>
<text top="921" left="224" width="438" height="14" font="7">&amp;&amp; and (zipWith isMappedTo (toListVirtualRegion vr)</text>
<text top="947" left="456" width="223" height="14" font="7">(toListPhysicalRegion pr))</text>
<text top="989" left="173" width="626" height="15" font="0">isMappedTo is a locally-deﬁned utility that tests if the translation of a given virtual</text>
<text top="1020" left="173" width="334" height="16" font="0">address matches a given physical address.</text>
<text top="1020" left="523" width="276" height="16" font="0">Here, pd is the same as the page-</text>
<text top="1052" left="173" width="270" height="16" font="0">directory argument of addMapping.</text>
</page>
<page number="165" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">143</text>
<text top="165" left="190" width="515" height="14" font="7">isMappedTo vpa ppa = translatePage state’ pd vpa == Just ppa</text>
<text top="210" left="173" width="626" height="16" font="0">Note that the relational style allows us to specify the observable change to the</text>
<text top="243" left="173" width="626" height="16" font="0">translation tables (that the addresses within the virtual region are now mapped</text>
<text top="275" left="173" width="626" height="16" font="0">to the appropriate physical addresses) without specifying the mechanism. For</text>
<text top="308" left="173" width="626" height="16" font="0">example, an implementation of this speciﬁcation is free to use superpages or not.</text>
<text top="340" left="173" width="626" height="16" font="0">With a functional model we would have to make a commitment about what is</text>
<text top="373" left="173" width="317" height="16" font="0">ostensibly an implementation detail here.</text>
<text top="405" left="199" width="600" height="16" font="0">The eﬀect of AddMappingH on pages of memory that do not lie in the physical</text>
<text top="438" left="173" width="626" height="16" font="0">region being mapped should be limited in a memory-safe system. Pages in the set</text>
<text top="470" left="173" width="626" height="16" font="0">of new page-tables will have the page-table status in the new state and must be</text>
<text top="503" left="173" width="626" height="16" font="0">installed in a page-directory entry of the page-directory being modiﬁed. Environ-</text>
<text top="535" left="173" width="626" height="16" font="0">ment pages and all normal pages that are not in the set of new page-tables do not</text>
<text top="568" left="173" width="626" height="16" font="0">change. We allow the contents of the page-directory being modiﬁed and of any</text>
<text top="600" left="173" width="163" height="16" font="0">page-table to change.</text>
<text top="644" left="224" width="412" height="14" font="7">&amp;&amp; forall (\someppa -&gt; -- :: PhysicalPageAddress</text>
<text top="671" left="259" width="163" height="14" font="7">if elem someppa pts</text>
<text top="697" left="284" width="387" height="14" font="7">then tableMappedInDirectory state’ pd someppa</text>
<text top="723" left="284" width="498" height="14" font="7">else case (status state someppa, status state’ someppa) of</text>
<text top="750" left="345" width="326" height="14" font="7">(Normal pagedata, Normal pagedata’) -&gt;</text>
<text top="776" left="362" width="180" height="14" font="7">pagedata == pagedata’</text>
<text top="803" left="345" width="292" height="14" font="7">(PageTable _, PageTable _) -&gt; True</text>
<text top="829" left="345" width="447" height="14" font="7">(PageDirectory pdirdata, PageDirectory pdirdata’) -&gt;</text>
<text top="856" left="362" width="326" height="14" font="7">someppa == pd || pdirdata == pdirdata’</text>
<text top="882" left="345" width="412" height="14" font="7">(Environment pagedata, Environment pagedata’) -&gt;</text>
<text top="908" left="362" width="180" height="14" font="7">pagedata == pagedata’</text>
<text top="935" left="345" width="309" height="14" font="7">(NotInstalled, NotInstalled) -&gt; True</text>
<text top="961" left="345" width="95" height="14" font="7">_ -&gt; False)</text>
<text top="1006" left="173" width="626" height="16" font="0">Allowing any page-table to change is somewhat weak—there is a speciﬁc set of</text>
<text top="1039" left="173" width="626" height="16" font="0">page-tables that we expect to change because they are part of the translation of</text>
</page>
<page number="166" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">144</text>
<text top="163" left="173" width="626" height="16" font="0">the addresses in the virtual region. This set of page-tables is diﬃcult to identify</text>
<text top="195" left="173" width="626" height="16" font="0">in an abstract fashion. The weaker property will not allow any safety violations</text>
<text top="228" left="173" width="626" height="16" font="0">because the translations implemented by the page-tables must be predictable (only</text>
<text top="260" left="173" width="626" height="16" font="0">the translations for the pages being mapped change), but the speciﬁcation might</text>
<text top="293" left="173" width="294" height="16" font="0">allow some unexpected safe behaviors.</text>
<text top="325" left="199" width="600" height="16" font="0">In addition to the parameter validation properties we discussed previously,</text>
<text top="359" left="173" width="626" height="15" font="0">addMappingH requires that the list of potential page-tables does not contain any</text>
<text top="390" left="173" width="626" height="16" font="0">duplicates and that the physical region being mapped is a member of the set of all</text>
<text top="423" left="173" width="626" height="16" font="0">regions. Note that the implementation does not need to check that the physical</text>
<text top="455" left="173" width="626" height="16" font="0">region provided to AddMappingH is a member of the valid region set because the</text>
<text top="488" left="173" width="626" height="16" font="0">Haskell type system ensures that only valid members of the PhysicalRegion type</text>
<text top="520" left="173" width="346" height="16" font="0">are passed as parameters to the H operation.</text>
<text top="560" left="190" width="610" height="14" font="7">addMappingH :: PageDirectory -&gt; [PhysicalPageAddress] -&gt; PhysicalRegion</text>
<text top="587" left="207" width="361" height="14" font="7">-&gt; VirtualRegion -&gt; State -&gt; State -&gt; Bool</text>
<text top="613" left="190" width="318" height="14" font="7">addMappingH pd pts pr vr state state’</text>
<text top="640" left="207" width="275" height="14" font="7">= length (nub pts) == length pts</text>
<text top="666" left="224" width="387" height="14" font="7">&amp;&amp; Set.member pr (allRegions (regions state))</text>
<text top="692" left="224" width="318" height="14" font="7">&amp;&amp; any isAddMappingTables (inits pts)</text>
<text top="719" left="207" width="43" height="14" font="7">where</text>
<text top="745" left="224" width="541" height="14" font="7">isAddMappingTables used = addMapping pd used pr vr state state’</text>
<text top="786" left="173" width="626" height="16" font="0">We identify the precise set of page-tables needed for addMapping by specifying</text>
<text top="819" left="173" width="626" height="16" font="0">that addMappingH is true so long as some sublist of the potential page-table list</text>
<text top="851" left="173" width="626" height="16" font="0">(calculated using the function inits) satisﬁes the addMapping speciﬁcation when</text>
<text top="884" left="173" width="284" height="16" font="0">combined with the other parameters.</text>
<text top="943" left="173" width="41" height="16" font="0">5.7.6</text>
<text top="943" left="234" width="305" height="16" font="0">Speciﬁcation of RemoveMappingH</text>
<text top="987" left="173" width="626" height="16" font="0">The reverse of adding a mapping is removing a mapping with removeMappingH.</text>
<text top="1020" left="173" width="626" height="16" font="0">This operation is essentially the inverse of addMapping: it removes the mappings</text>
<text top="1052" left="173" width="626" height="16" font="0">from the speciﬁed virtual region to some underlying physical region and frees</text>
</page>
<page number="167" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">145</text>
<text top="163" left="173" width="626" height="16" font="0">some number of page-tables. We expect all of the preconditions of addMapping—</text>
<text top="195" left="173" width="626" height="16" font="0">for example, that the page-table pages are unmapped normal pages and that</text>
<text top="228" left="173" width="626" height="16" font="0">the virtual region does not map to any memory—to be the post-conditions of</text>
<text top="262" left="173" width="626" height="15" font="0">removeMappingH. The challenge in specifying the remove operation as the inverse</text>
<text top="293" left="173" width="626" height="16" font="0">of addMapping is that we must determine the underlying physical region and the</text>
<text top="325" left="173" width="626" height="16" font="0">list of page-tables that become free so that they may be supplied as arguments to</text>
<text top="358" left="173" width="626" height="16" font="0">the addMapping relation. These values can be calculated using the before and after</text>
<text top="390" left="173" width="626" height="16" font="0">states. We assume the existence of a list containing every value of the physical</text>
<text top="423" left="173" width="626" height="16" font="0">page address type, called allPhysicalPages, for use in computing the list of freed</text>
<text top="455" left="173" width="91" height="16" font="0">page-tables.</text>
<text top="499" left="190" width="146" height="14" font="7">removeMappingH ::</text>
<text top="526" left="207" width="481" height="14" font="7">PageDirectory -&gt; VirtualRegion -&gt; State -&gt; State -&gt; Bool</text>
<text top="552" left="190" width="284" height="14" font="7">removeMappingH pd vr state state’</text>
<text top="579" left="207" width="455" height="14" font="7">= case translatePage state pd (virtRegionStart vr) of</text>
<text top="605" left="242" width="137" height="14" font="7">Nothing -&gt; False</text>
<text top="631" left="242" width="550" height="14" font="7">Just ppa -&gt; let pr = PhysicalRegion ppa (virtRegionLength vr) in</text>
<text top="658" left="362" width="309" height="14" font="7">addMapping pd pts pr vr state’ state</text>
<text top="684" left="207" width="43" height="14" font="7">where</text>
<text top="711" left="216" width="378" height="14" font="7">pts = filter freedPageTable allPhysicalPages</text>
<text top="737" left="216" width="155" height="14" font="7">freedPageTable ppa</text>
<text top="763" left="233" width="404" height="14" font="7">= case (status state ppa, status state’ ppa) of</text>
<text top="790" left="267" width="498" height="14" font="7">(PageTable _, Normal pagedata) -&gt; pagedata == zeroPageData</text>
<text top="816" left="267" width="9" height="14" font="7">_</text>
<text top="816" left="293" width="69" height="14" font="7">-&gt; False</text>
<text top="869" left="190" width="352" height="14" font="7">allPhysicalPages :: [PhysicalPageAddress]</text>
<text top="914" left="173" width="626" height="16" font="0">The use of addMapping as opposed to addMappingH is important. We allow the</text>
<text top="947" left="173" width="626" height="16" font="0">remove operation to unmap regions of memory that do not correspond to physical</text>
<text top="979" left="173" width="626" height="16" font="0">regions in the set of regions handles. For example, if the region A is mapped using</text>
<text top="1013" left="173" width="626" height="15" font="0">addMappingH and the adjacent region B is also mapped using addMappingH, we</text>
<text top="1044" left="173" width="626" height="16" font="0">permit an invocation of removeMappingH that deletes the mapping to the region</text>
</page>
<page number="168" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">146</text>
<text top="164" left="173" width="626" height="15" font="0">A ∪ B in a single call, even if A ∪ B is not in the region handle set. This will</text>
<text top="195" left="173" width="626" height="16" font="0">not introduce safety issues because we will never unmap anything that was not</text>
<text top="228" left="173" width="626" height="16" font="0">mapped and the speciﬁcation for adding a mapping ensures that all user mappings</text>
<text top="260" left="173" width="279" height="16" font="0">correspond to valid physical regions.</text>
<text top="320" left="173" width="41" height="16" font="0">5.7.7</text>
<text top="320" left="234" width="332" height="16" font="0">Speciﬁcation of AddKernelMappingH</text>
<text top="364" left="173" width="626" height="16" font="0">Adding a kernel mapping is conceptually similar to adding a user mapping, but is</text>
<text top="397" left="173" width="626" height="16" font="0">much simpler because we assume that the page-tables for kernel-space are preallo-</text>
<text top="429" left="173" width="626" height="16" font="0">cated. Thus, there are no potential page-tables to manage in the speciﬁcation of</text>
<text top="463" left="173" width="626" height="15" font="0">AddKernelMappingH. We know that the view of kernel-space is consistent in every</text>
<text top="494" left="173" width="626" height="16" font="0">page-directory from our well-formedness conditions, so there is no need to specify</text>
<text top="527" left="173" width="626" height="16" font="0">a page-directory to update either. The remaining arguments are a physical region</text>
<text top="559" left="173" width="626" height="16" font="0">and a virtual region. We specify many of the same requirements for these param-</text>
<text top="592" left="173" width="626" height="16" font="0">eters as we did for the parameters to addMappingH: the region lengths must be</text>
<text top="624" left="173" width="626" height="16" font="0">the same, the pages of the physical region must mappable, and the physical region</text>
<text top="657" left="173" width="626" height="16" font="0">must be in the set of region handles. For kernel mappings, the virtual region must</text>
<text top="689" left="173" width="357" height="16" font="0">contain only addresses that lie in kernel-space.</text>
<text top="733" left="190" width="172" height="14" font="7">addKernelMappingH ::</text>
<text top="760" left="207" width="490" height="14" font="7">PhysicalRegion -&gt; VirtualRegion -&gt; State -&gt; State -&gt; Bool</text>
<text top="786" left="190" width="309" height="14" font="7">addKernelMappingH pr vr state state’</text>
<text top="812" left="207" width="215" height="14" font="7">= cr3 state == cr3 state’</text>
<text top="839" left="224" width="326" height="14" font="7">&amp;&amp; reference state == reference state’</text>
<text top="865" left="224" width="292" height="14" font="7">&amp;&amp; regions state == regions state’</text>
<text top="892" left="224" width="387" height="14" font="7">&amp;&amp; Set.member pr (allRegions (regions state))</text>
<text top="918" left="224" width="455" height="14" font="7">&amp;&amp; all (isNormalPage state) (toListPhysicalRegion pr)</text>
<text top="944" left="224" width="387" height="14" font="7">&amp;&amp; physRegionLength pr == virtRegionLength vr</text>
<text top="971" left="224" width="172" height="14" font="7">&amp;&amp; isKernelRegion vr</text>
<text top="1016" left="173" width="626" height="16" font="0">The relationship between the before and after states is very similar to the relation-</text>
<text top="1048" left="173" width="626" height="16" font="0">ship that we speciﬁed for user mappings. Only the virtual-to-physical translation</text>
</page>
<page number="169" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">147</text>
<text top="163" left="173" width="626" height="16" font="0">for pages in the virtual region being mapped may change. We express this require-</text>
<text top="195" left="173" width="626" height="16" font="0">ment as two properties. First we state that the virtual-to-physical translation for</text>
<text top="228" left="173" width="544" height="16" font="0">any address that does not belong to the virtual region will not change.</text>
<text top="266" left="224" width="404" height="14" font="7">&amp;&amp; forall (\somevpa -&gt; -- :: VirtualPageAddress</text>
<text top="292" left="267" width="258" height="14" font="7">memberVirtualRegion somevpa vr</text>
<text top="318" left="267" width="412" height="14" font="7">|| translatePage state (reference state) somevpa</text>
<text top="345" left="293" width="438" height="14" font="7">== translatePage state’ (reference state’) somevpa)</text>
<text top="384" left="173" width="626" height="16" font="0">Next, we state that the contents of physical memory stays the same, except for</text>
<text top="416" left="173" width="626" height="16" font="0">page-table pages, which might be modiﬁed to reﬂect the new virtual-to-physical</text>
<text top="449" left="173" width="197" height="16" font="0">mappings in kernel-space.</text>
<text top="486" left="216" width="412" height="14" font="7">&amp;&amp; forall (\someppa -&gt; -- :: PhysicalPageAddress</text>
<text top="513" left="259" width="490" height="14" font="7">if tableMappedInDirectory state (reference state) someppa</text>
<text top="539" left="284" width="344" height="14" font="7">then isPageTable (status state’ someppa)</text>
<text top="566" left="284" width="438" height="14" font="7">else status state someppa == status state’ someppa)</text>
<text top="605" left="173" width="626" height="16" font="0">In the after state, each page address of the virtual region will be mapped to the</text>
<text top="637" left="173" width="386" height="16" font="0">corresponding page address in the physical region.</text>
<text top="675" left="224" width="438" height="14" font="7">&amp;&amp; and (zipWith isMappedTo (toListVirtualRegion vr)</text>
<text top="701" left="456" width="223" height="14" font="7">(toListPhysicalRegion pr))</text>
<text top="728" left="207" width="43" height="14" font="7">where</text>
<text top="754" left="224" width="155" height="14" font="7">isMappedTo vpa ppa</text>
<text top="780" left="242" width="490" height="14" font="7">= translatePage state’ (reference state’) vpa == Just ppa</text>
<text top="819" left="173" width="626" height="16" font="0">We describe the update to the kernel-space mappings in terms of the reference</text>
<text top="852" left="173" width="626" height="16" font="0">page-directory. The kernel-space mappings of every other page-directory must</text>
<text top="884" left="173" width="626" height="16" font="0">also be updated to match the reference page-directory in order for the action to</text>
<text top="917" left="173" width="218" height="16" font="0">produce a well-formed state.</text>
<text top="976" left="173" width="41" height="16" font="0">5.7.8</text>
<text top="976" left="234" width="227" height="16" font="0">Speciﬁcation of ExecuteH</text>
<text top="1020" left="173" width="626" height="16" font="0">We deliberately model very little of the user domain’s state and, in turn, very</text>
<text top="1052" left="173" width="626" height="16" font="0">little of the behavior of H with respect to the user domain. Though the manner</text>
</page>
<page number="170" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">148</text>
<text top="163" left="173" width="626" height="16" font="0">in which H saves and restores user registers is important for correctness, it does</text>
<text top="195" left="173" width="626" height="16" font="0">not aﬀect our ability to protect the data structures of H or the run-time system.</text>
<text top="228" left="173" width="626" height="16" font="0">That is, incorrect management of user data does not impact memory-safety. We</text>
<text top="260" left="173" width="626" height="16" font="0">still model the H action for executing a user process, but the connection to the</text>
<text top="293" left="173" width="626" height="16" font="0">implementation is loose because we only specify the behavior that relates to the</text>
<text top="325" left="173" width="626" height="16" font="0">memory-safety critical portions of the state. In our model, the only observable</text>
<text top="358" left="173" width="626" height="16" font="0">eﬀect of ExecuteH is that the current page-directory changes. The argument to</text>
<text top="392" left="173" width="626" height="15" font="0">ExecuteH is the address of the page to install as a page-directory. The value of</text>
<text top="424" left="173" width="333" height="15" font="0">cr3 in the after state must equal this page.</text>
<text top="463" left="190" width="438" height="14" font="7">executeH :: PageDirectory -&gt; State -&gt; State -&gt; Bool</text>
<text top="489" left="190" width="206" height="14" font="7">executeH pd state state’</text>
<text top="516" left="207" width="318" height="14" font="7">= reference state == reference state’</text>
<text top="542" left="224" width="275" height="14" font="7">&amp;&amp; status state == status state’</text>
<text top="569" left="224" width="292" height="14" font="7">&amp;&amp; regions state == regions state’</text>
<text top="595" left="224" width="223" height="14" font="7">&amp;&amp; case status state pd of</text>
<text top="621" left="267" width="301" height="14" font="7">PageDirectory _ -&gt; cr3 state’ == pd</text>
<text top="648" left="267" width="86" height="14" font="7">_ -&gt; False</text>
<text top="689" left="173" width="626" height="16" font="0">We verify the status of the page-directory argument, but this is not strictly speak-</text>
<text top="721" left="173" width="626" height="16" font="0">ing necessary. Well-formedness already speciﬁes that the value of cr3 in the after</text>
<text top="754" left="173" width="626" height="16" font="0">state be a valid page-directory. We include the property for documentation and to</text>
<text top="786" left="173" width="626" height="16" font="0">help line up the speciﬁcation with the mechanism for enforcing well-formedness in</text>
<text top="819" left="173" width="155" height="16" font="0">the implementation.</text>
<text top="878" left="173" width="41" height="16" font="0">5.7.9</text>
<text top="878" left="234" width="207" height="16" font="0">Speciﬁcation of WriteK</text>
<text top="922" left="173" width="626" height="16" font="0">The ﬁnal actions of our model are the write operations for the kernel and user</text>
<text top="955" left="173" width="626" height="16" font="0">domains. The speciﬁcations for these operations are very similar. WriteK modiﬁes</text>
<text top="987" left="173" width="626" height="16" font="0">a single location in the set of pages that the kernel domain may access. This set</text>
<text top="1020" left="173" width="626" height="16" font="0">is equivalent to the set of pages with normal status that are mapped to a kernel-</text>
<text top="1052" left="173" width="626" height="16" font="0">space address. writeK is true when a single value in a single kernel-space mapped</text>
</page>
<page number="171" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">149</text>
<text top="163" left="173" width="626" height="16" font="0">normal page changes. writeK is false if the contents of any other page change or</text>
<text top="195" left="173" width="626" height="16" font="0">if the status of any page changes. We deﬁne writeK in terms of an abstract write</text>
<text top="228" left="173" width="541" height="16" font="0">predicate, writeA, that we will also use in the speciﬁcation of WriteU.</text>
<text top="272" left="190" width="507" height="14" font="7">writeA :: VirtualAddress -&gt; Word8 -&gt; State -&gt; State -&gt; Bool</text>
<text top="298" left="190" width="223" height="14" font="7">writeA va val state state’</text>
<text top="325" left="207" width="215" height="14" font="7">= cr3 state == cr3 state’</text>
<text top="351" left="224" width="326" height="14" font="7">&amp;&amp; reference state == reference state’</text>
<text top="377" left="224" width="292" height="14" font="7">&amp;&amp; regions state == regions state’</text>
<text top="404" left="224" width="249" height="14" font="7">&amp;&amp; case translate state va of</text>
<text top="430" left="267" width="137" height="14" font="7">Nothing -&gt; False</text>
<text top="457" left="267" width="146" height="14" font="7">Just (ppa,off) -&gt;</text>
<text top="483" left="284" width="387" height="14" font="7">forall (\someppa -&gt; -- :: PhysicalPageAddress</text>
<text top="510" left="302" width="146" height="14" font="7">if someppa /= ppa</text>
<text top="536" left="327" width="430" height="14" font="7">then status state someppa == status state’ someppa</text>
<text top="562" left="327" width="284" height="14" font="7">else case status state someppa of</text>
<text top="589" left="388" width="129" height="14" font="7">Normal pdata -&gt;</text>
<text top="615" left="405" width="249" height="14" font="7">case status state’ someppa of</text>
<text top="642" left="422" width="163" height="14" font="7">Normal pagedata’ -&gt;</text>
<text top="668" left="439" width="326" height="14" font="7">pdata’ == updatePageData off val pdata</text>
<text top="694" left="422" width="86" height="14" font="7">_ -&gt; False</text>
<text top="721" left="388" width="95" height="14" font="7">_ -&gt; False)</text>
<text top="774" left="190" width="507" height="14" font="7">writeK :: VirtualAddress -&gt; Word8 -&gt; State -&gt; State -&gt; Bool</text>
<text top="800" left="190" width="223" height="14" font="7">writeK va val state state’</text>
<text top="827" left="207" width="241" height="14" font="7">= writeA va val state state’</text>
<text top="853" left="224" width="180" height="14" font="7">&amp;&amp; isKernelAddress va</text>
<text top="910" left="173" width="52" height="16" font="0">5.7.10</text>
<text top="910" left="245" width="207" height="16" font="0">Speciﬁcation of WriteU</text>
<text top="954" left="173" width="626" height="16" font="0">The writeU speciﬁcation is identical to writeK except that the user domain may</text>
<text top="987" left="173" width="626" height="16" font="0">modify normal pages that are mapped to a user-space address, rather than a kernel-</text>
<text top="1019" left="173" width="626" height="16" font="0">space address. Otherwise the relationship between the before and after states is</text>
<text top="1052" left="173" width="545" height="16" font="0">exactly the same. We use writeA to express this common relationship.</text>
</page>
<page number="172" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">150</text>
<text top="165" left="190" width="507" height="14" font="7">writeU :: VirtualAddress -&gt; Word8 -&gt; State -&gt; State -&gt; Bool</text>
<text top="192" left="190" width="223" height="14" font="7">writeU va val state state’</text>
<text top="218" left="207" width="241" height="14" font="7">= writeA va val state state’</text>
<text top="245" left="224" width="163" height="14" font="7">&amp;&amp; isUserAddress va</text>
<text top="304" left="173" width="26" height="16" font="0">5.8</text>
<text top="304" left="219" width="308" height="16" font="0">VERIFYING MEMORY-SAFETY</text>
<text top="354" left="173" width="626" height="16" font="0">Verifying memory-safety for the model of H, and ultimately the implementation,</text>
<text top="387" left="173" width="626" height="16" font="0">are important steps for increasing the assurance of the abstraction layer. A proof</text>
<text top="419" left="173" width="626" height="16" font="0">of the unwinding conditions is particularly important, because such a proof is</text>
<text top="452" left="173" width="626" height="16" font="0">necessary to demonstrate that our instantiation of the Rushby framework is valid.</text>
<text top="484" left="173" width="626" height="16" font="0">In this section, we complete the instantiation of the Rushby framework by providing</text>
<text top="517" left="173" width="626" height="16" font="0">a deﬁnition of the step function that connects our action speciﬁcations to our</text>
<text top="549" left="173" width="626" height="16" font="0">noninterference model. We also state the theorem that the completed instantiation</text>
<text top="582" left="173" width="626" height="16" font="0">satisﬁes the unwinding conditions. The proof of this theorem remains as future</text>
<text top="614" left="173" width="626" height="16" font="0">work, but we outline the expected high-level proof structure and sketch some the</text>
<text top="647" left="173" width="626" height="16" font="0">basic steps that it requires. Chapter 10 will cover our ongoing and future work to</text>
<text top="679" left="173" width="626" height="16" font="0">complete the proof and to formally verify the unwinding conditions for our model</text>
<text top="712" left="173" width="38" height="16" font="0">of H.</text>
<text top="771" left="173" width="41" height="16" font="0">5.8.1</text>
<text top="771" left="234" width="330" height="16" font="0">Completing the Rushby Instantiation</text>
<text top="816" left="173" width="626" height="16" font="0">Recall from Section 5.1.1 that the Rushby framework models system execution</text>
<text top="848" left="173" width="267" height="16" font="0">using a state transformer function:</text>
<text top="898" left="217" width="142" height="16" font="0">step :: (S , A) → S .</text>
<text top="949" left="173" width="626" height="16" font="0">This function produces the state that results from applying a given action in a</text>
<text top="981" left="173" width="626" height="16" font="0">particular state. The step function is the ﬁnal piece that is missing from our system</text>
<text top="1014" left="173" width="624" height="16" font="0">instantiation, which, according to the deﬁnition in Section 5.1.1, is a machine M</text>
<text top="1046" left="173" width="122" height="16" font="0">that consists of:</text>
</page>
<page number="173" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">151</text>
<text top="162" left="199" width="341" height="17" font="0">• a set of states, S , (deﬁned in Section 5.3);</text>
<text top="196" left="199" width="365" height="17" font="0">• a set of actions, A, (deﬁned in Section 5.4.1);</text>
<text top="230" left="199" width="402" height="17" font="0">• a set of outputs, O (also deﬁned in Section 5.4.1);</text>
<text top="264" left="199" width="371" height="17" font="0">• an execution function, step :: S × A → S ; and</text>
<text top="298" left="199" width="536" height="17" font="0">• an output function, output :: S × A → O (deﬁned in Section 5.4.1).</text>
<text top="346" left="173" width="626" height="16" font="0">The action speciﬁcations presented in Section 5.7 describe the intended eﬀect of</text>
<text top="379" left="173" width="626" height="16" font="0">each action on the system state, so our deﬁnition of step should collect each of</text>
<text top="411" left="173" width="626" height="16" font="0">these action meanings into a single execution function. However, the relational</text>
<text top="444" left="173" width="626" height="16" font="0">style of our speciﬁcations is not a natural ﬁt with the step function because it</text>
<text top="476" left="173" width="580" height="16" font="0">allows a single action to produce an arbitrary number of valid result states.</text>
<text top="509" left="199" width="600" height="16" font="0">To bridge the gap between our speciﬁcation and the semantics of step within</text>
<text top="541" left="173" width="484" height="16" font="0">the Rushby framework, we introduce an intermediate property,</text>
<text top="591" left="217" width="317" height="16" font="0">canStepTo :: State → A → State → Bool ,</text>
<text top="642" left="173" width="328" height="16" font="0">which describes a relational notion of step.</text>
<text top="692" left="217" width="124" height="16" font="0">canStepTo s a s</text>
<text top="692" left="357" width="399" height="16" font="0">= wellFormed s ∧ wellFormed s ∧ actionSpec a s s</text>
<text top="742" left="173" width="621" height="16" font="0">canStepTo s a s is true for any well-formed states s and s where the after state s</text>
<text top="775" left="173" width="626" height="16" font="0">is reachable from the before state s via the action a. This property encapsulates</text>
<text top="807" left="173" width="626" height="16" font="0">the notion that the two states are related by the speciﬁcation for action a by</text>
<text top="840" left="173" width="441" height="16" font="0">projecting the actionSpec relation to well-formed states.</text>
<text top="872" left="199" width="600" height="16" font="0">We can use canStepTo to produce the set of all after states that are related to</text>
<text top="905" left="173" width="399" height="16" font="0">a particular before state by an action. For example,</text>
<text top="948" left="190" width="515" height="14" font="7">relatedStates s a = [s’ | s’ &lt;- allStates, canStepTo s a s’]</text>
<text top="975" left="207" width="404" height="14" font="7">-- allStates = list of all values of type State</text>
<text top="1020" left="173" width="626" height="16" font="0">describes the set of states that are related to s by a. We use relatedStates to</text>
<text top="1052" left="173" width="626" height="16" font="0">deﬁne step by returning an arbitrary state from the set of possible after states.</text>
</page>
<page number="174" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">152</text>
<text top="163" left="173" width="626" height="16" font="0">We know that it is possible to pick an arbitrary state in this way by the axiom of</text>
<text top="195" left="173" width="626" height="16" font="0">choice. If there are no after states related to a particular before state—for example,</text>
<text top="228" left="173" width="626" height="16" font="0">because the before state is not well-formed—then step acts as the identity function.</text>
<text top="269" left="190" width="275" height="14" font="7">step :: (State, Action) -&gt; State</text>
<text top="295" left="190" width="335" height="14" font="7">step (s, a) = case relatedStates s a of</text>
<text top="322" left="327" width="60" height="14" font="7">[] -&gt; s</text>
<text top="348" left="327" width="258" height="14" font="7">states -&gt; pickArbitrary states</text>
<text top="390" left="173" width="626" height="16" font="0">We design this deﬁnition of step with the invariants of Sections 5.3.3 and 5.7 in</text>
<text top="423" left="173" width="44" height="16" font="0">mind:</text>
<text top="467" left="199" width="600" height="17" font="0">• every action produces a well-formed after state when applied to a well-formed</text>
<text top="500" left="217" width="129" height="16" font="0">before state; and</text>
<text top="546" left="199" width="600" height="17" font="0">• given a valid action, a, in a before state, s, the after state, s will satisfy</text>
<text top="579" left="217" width="136" height="16" font="0">actionSpec a s s .</text>
<text top="624" left="173" width="626" height="16" font="0">In our deﬁnition of step, invalid actions cannot modify the state, because an imple-</text>
<text top="656" left="173" width="626" height="16" font="0">mentation should block such actions without allowing them to make any changes</text>
<text top="689" left="173" width="626" height="16" font="0">to the system. In practice, an implementation would likely return error informa-</text>
<text top="721" left="173" width="626" height="16" font="0">tion to the actor describing the cause of the failure (for example, an integer error</text>
<text top="754" left="173" width="626" height="16" font="0">code). We do not model return values of operations at all in our formalization, so</text>
<text top="786" left="173" width="461" height="16" font="0">invalid actions appear to be no-ops in our deﬁnition of step.</text>
<text top="846" left="173" width="41" height="16" font="0">5.8.2</text>
<text top="846" left="234" width="462" height="16" font="0">Properties of the H Speciﬁcation and System Model</text>
<text top="890" left="173" width="626" height="16" font="0">In order for our instantiation of Rushby to be valid, the system model must satisfy</text>
<text top="922" left="173" width="626" height="16" font="0">the three unwinding conditions, which ensure that actions in the system behave in</text>
<text top="955" left="173" width="626" height="16" font="0">a way that is consistent with the policy. One goal of the policy for our instantiation</text>
<text top="987" left="173" width="626" height="16" font="0">is to enforce the execution environment integrity property, ensuring that the run-</text>
<text top="1020" left="173" width="626" height="16" font="0">time system cannot be corrupted. Thus, an important part of the proof of the</text>
<text top="1052" left="173" width="626" height="16" font="0">unwinding conditions will involve demonstrating that no other domain can interfere</text>
</page>
<page number="175" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">153</text>
<text top="163" left="173" width="626" height="16" font="0">with the environment domain. In this section, we present two supporting lemmas</text>
<text top="195" left="173" width="626" height="16" font="0">that we have already identiﬁed as relevant to a complete proof that actions of other</text>
<text top="228" left="173" width="626" height="16" font="0">domains are not visible to the environment, and sketch their proofs to illustrate</text>
<text top="260" left="173" width="591" height="16" font="0">the kind of techniques that are useful for verifying the unwinding conditions.</text>
<text top="304" left="173" width="626" height="16" font="0">Lemma 1 (No H Changes to Environment Mappings). No action belonging to the</text>
<text top="339" left="173" width="626" height="16" font="0">H domain modiﬁes the virtual-to-physical memory mappings for any memory page</text>
<text top="373" left="173" width="226" height="16" font="0">with the Environment status:</text>
<text top="418" left="217" width="562" height="17" font="0">∀s ∈ State, pd ∈ PageDirectory, vpa ∈ VirtualPageAddress, a ∈ Action.</text>
<text top="458" left="235" width="520" height="16" font="0">dom(a) = H ∧ isEnvironmentPage s (translatePage s pd vpa) ⇒</text>
<text top="497" left="235" width="453" height="16" font="0">translatePage s pd vpa = translatePage (step(s, a)) pd vpa</text>
<text top="543" left="173" width="626" height="16" font="0">Proof Sketch. There are seven cases: one for each action belonging to the H do-</text>
<text top="577" left="173" width="626" height="16" font="0">main. DeriveRegionH, AllocatePageDirectoryH, and FreePageDirectoryH do</text>
<text top="612" left="173" width="626" height="16" font="0">not modify any memory mappings and this property is clearly stated in the spec-</text>
<text top="647" left="173" width="626" height="16" font="0">iﬁcation of each action. Thus, we prove the lemma in a straightforward manner</text>
<text top="681" left="173" width="626" height="16" font="0">for each of these cases. The lemma is more diﬃcult to prove for the AddMappingH,</text>
<text top="718" left="173" width="626" height="15" font="0">RemoveMappingH, and AddKernelMappingH cases, because these actions do change</text>
<text top="751" left="173" width="626" height="16" font="0">the virtual-to-physical mappings for a set of addresses. We must demonstrate that</text>
<text top="785" left="173" width="626" height="16" font="0">the mappings visible to the environment domain remain constant even in the pres-</text>
<text top="820" left="173" width="626" height="16" font="0">ence of these updates to the virtual-memory translation structures. Let us examine</text>
<text top="855" left="173" width="587" height="16" font="0">the particular case of AddMappingH as an example of how we might proceed.</text>
<text top="913" left="173" width="187" height="16" font="0">Case: AddMappingH</text>
<text top="913" left="377" width="422" height="16" font="0">The AddMappingH action takes four parameters: a page-</text>
<text top="948" left="173" width="626" height="16" font="0">directory in which to add new mappings, a list of physical addresses that correspond</text>
<text top="983" left="173" width="626" height="16" font="0">to pages that may be turned into page-tables, a physical region to map, and a</text>
<text top="1017" left="173" width="626" height="16" font="0">virtual region in which to add the new mappings. In order for the lemma to be</text>
<text top="1052" left="173" width="440" height="16" font="0">true, the following properties must hold of our deﬁnition:</text>
</page>
<page number="176" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">154</text>
<text top="163" left="187" width="612" height="16" font="0">(i) The virtual region must not contain any address that is already mapped to</text>
<text top="198" left="214" width="278" height="16" font="0">a page with the environment status;</text>
<text top="234" left="182" width="617" height="16" font="0">(ii) The physical region must not contain any pages that have the Environment</text>
<text top="268" left="214" width="85" height="16" font="0">status; and</text>
<text top="305" left="177" width="622" height="16" font="0">(iii) No page supplied as a possible page-tables may have the Environment status.</text>
<text top="349" left="173" width="626" height="16" font="0">The ﬁrst property stems from a line in the speciﬁcation that states that the vir-</text>
<text top="383" left="173" width="626" height="16" font="0">tual region can only be mapped if it contains entirely user-level addresses. When</text>
<text top="418" left="173" width="626" height="16" font="0">combined with the well-formedness conditions environmentOnlyInReference—</text>
<text top="453" left="173" width="626" height="16" font="0">which states that pages with the Environment status are not mapped to any</text>
<text top="487" left="173" width="626" height="16" font="0">addresses that are not mapped in the reference page-directory—and the condition</text>
<text top="523" left="173" width="626" height="15" font="0">referenceMapsKernelAddresses—which states that the reference page-directory</text>
<text top="557" left="173" width="626" height="16" font="0">does not map any user-level addresses—we can conclude that the action will not</text>
<text top="591" left="173" width="626" height="16" font="0">map any virtual region that is already mapped to an environment page. We can</text>
<text top="626" left="173" width="626" height="16" font="0">establish the second property from the fact that AddMappingH will only map physi-</text>
<text top="661" left="173" width="626" height="16" font="0">cal pages that belong to a physical region contained in the allRegions component</text>
<text top="695" left="173" width="626" height="16" font="0">of the system state. The well-formedness condition regionsAreNotEnvironment</text>
<text top="730" left="173" width="626" height="16" font="0">guarantees that no such region contains a page with the Environment status, so</text>
<text top="765" left="173" width="626" height="16" font="0">the speciﬁcation for AddMappingH upholds the second property. The third property</text>
<text top="799" left="173" width="392" height="16" font="0">is covered by the following line in the speciﬁcation,</text>
<text top="837" left="190" width="292" height="14" font="7">all (unmappedNormalPage state) pts</text>
<text top="879" left="173" width="626" height="16" font="0">which states that every element of pts, the list of page-table pages, must be a</text>
<text top="913" left="173" width="626" height="16" font="0">free page with the Normal status. Thus, none of the page-table pages can be envi-</text>
<text top="948" left="173" width="626" height="16" font="0">ronment pages. Having demonstrated these three key properties, we can conclude</text>
<text top="983" left="173" width="304" height="16" font="0">that the lemma holds for AddMappingH.</text>
<text top="1017" left="199" width="600" height="16" font="0">The requirements for proving the RemoveMappingH and AddKernelMappingH</text>
<text top="1052" left="173" width="626" height="16" font="0">cases are very similar to the AddMappingH case, as are the speciﬁcations of these</text>
</page>
<page number="177" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">155</text>
<text top="163" left="173" width="626" height="16" font="0">actions. RemoveMappingH is deﬁned with the same speciﬁcation as AddMappingH,</text>
<text top="198" left="173" width="626" height="16" font="0">so the proof should be very similar (though dealing with unmapping rather than</text>
<text top="232" left="173" width="626" height="16" font="0">mapping). The speciﬁcation for AddKernelMappingH is largely the same but with</text>
<text top="267" left="173" width="626" height="16" font="0">some simpliﬁcations because kernel mappings do not need to allocate page-tables.</text>
<text top="302" left="173" width="626" height="16" font="0">Next, let us examine the proof for ExecuteH, the ﬁnal case necessary for this</text>
<text top="336" left="173" width="56" height="16" font="0">lemma.</text>
<text top="396" left="173" width="140" height="16" font="0">Case: ExecuteH</text>
<text top="398" left="331" width="468" height="15" font="0">ExecuteH installs a given page-directory as the current page-</text>
<text top="431" left="173" width="626" height="16" font="0">directory by changing the value of CR3 in the state. The speciﬁcation states that</text>
<text top="465" left="173" width="626" height="16" font="0">any page with the PageDirectory status may be installed in this way. We can</text>
<text top="500" left="173" width="626" height="16" font="0">use the well-formedness conditions to demonstrate that even this weak restric-</text>
<text top="535" left="173" width="626" height="16" font="0">tion is suﬃcient to ensure that ExecuteH cannot modify the virtual-to-physical</text>
<text top="569" left="173" width="626" height="16" font="0">memory mappings of the environment domain. The well-formedness condition</text>
<text top="606" left="173" width="638" height="15" font="0">pageDirectoriesContainReference tells us that any page with the PageDirectory</text>
<text top="639" left="173" width="626" height="16" font="0">status will contain all of the mappings that are present in the reference page-</text>
<text top="673" left="173" width="626" height="16" font="0">directory. When combined with referenceContainsEnvironment—which states</text>
<text top="708" left="173" width="626" height="16" font="0">that the reference page-directory includes mappings to all of the pages with the</text>
<text top="744" left="173" width="626" height="15" font="0">Environment status—and the condition environmentOnlyInReference—which</text>
<text top="777" left="173" width="626" height="16" font="0">states that there are no mappings to environment pages that are not contained</text>
<text top="812" left="173" width="626" height="16" font="0">in the reference page-directory—we can conclude that every PageDirectory con-</text>
<text top="847" left="173" width="626" height="16" font="0">tains the same mappings to the environment pages. Thus, the environment domain</text>
<text top="881" left="173" width="626" height="16" font="0">will not be able to distinguish the mappings available in any page-directory in a</text>
<text top="916" left="173" width="137" height="16" font="0">well-formed state.</text>
</page>
<page number="178" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">156</text>
<text top="163" left="173" width="626" height="16" font="0">Lemma 2 (No H Changes to Environment View). No action belonging to the H</text>
<text top="198" left="173" width="412" height="16" font="0">domain modiﬁes the view of the environment domain:</text>
<text top="245" left="217" width="334" height="17" font="0">∀s ∈ State, a ∈ Action. dom(a) = H ⇒ s</text>
<text top="240" left="566" width="9" height="11" font="2">E</text>
<text top="245" left="564" width="91" height="17" font="0">∼ step(s, a)</text>
<text top="295" left="173" width="626" height="16" font="0">Proof Sketch. The view of the environment domain includes the location, contents,</text>
<text top="329" left="173" width="626" height="16" font="0">and reference count for each memory page that is mapped with the Environment</text>
<text top="364" left="173" width="626" height="16" font="0">status. We know that no H action changes the location at which an environment</text>
<text top="399" left="173" width="626" height="16" font="0">page is mapped from Lemma 1. The reference count of an environment page</text>
<text top="433" left="173" width="626" height="16" font="0">will not change unless a virtual-to-physical mapping for that page is added or</text>
<text top="468" left="173" width="626" height="16" font="0">removed, so we can also conclude that no H action changes the reference count as</text>
<text top="503" left="173" width="626" height="16" font="0">a consequence of Lemma 1. We can prove that no action changes the contents of</text>
<text top="537" left="173" width="517" height="16" font="0">an environment page by examining the speciﬁcation of each action.</text>
<text top="572" left="199" width="600" height="16" font="0">The speciﬁcations for DeriveRegionH and ExecuteH include frame conditions</text>
<text top="607" left="173" width="626" height="16" font="0">stating that they do not modify the status of any page. The status value of an en-</text>
<text top="641" left="173" width="626" height="16" font="0">vironment page includes its contents, so these actions cannot change the contents</text>
<text top="676" left="173" width="626" height="16" font="0">of an environment page. AllocatePageDirectoryH and FreePageDirectoryH will</text>
<text top="711" left="173" width="626" height="16" font="0">only change the status of the page provided as an input value, which the speciﬁca-</text>
<text top="745" left="173" width="626" height="16" font="0">tion states must not be an environment page. The speciﬁcations for AddMappingH</text>
<text top="780" left="173" width="626" height="16" font="0">and RemoveMappingH explicitly state that the data contained in any page with the</text>
<text top="816" left="173" width="626" height="15" font="0">Environment status does not change. The speciﬁcation for AddKernelMappingH</text>
<text top="849" left="173" width="626" height="16" font="0">states that all physical memory stays the same except for pages with the PageTable</text>
<text top="884" left="173" width="51" height="16" font="0">status.</text>
<text top="943" left="173" width="41" height="16" font="0">5.8.3</text>
<text top="943" left="234" width="309" height="16" font="0">Proving the Unwinding Conditions</text>
<text top="987" left="173" width="626" height="16" font="0">Now that we have completed the deﬁnition of our system and built a collection</text>
<text top="1020" left="173" width="626" height="16" font="0">of lemmas describing some of its properties, we can prove that our instantiation</text>
<text top="1052" left="173" width="626" height="16" font="0">of the Rushby framework is valid. If our system is indeed a valid instantiation,</text>
</page>
<page number="179" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">157</text>
<text top="163" left="173" width="626" height="16" font="0">then we can conclude that our system also satisﬁes the Unwinding Theorem from</text>
<text top="195" left="173" width="626" height="16" font="0">Section 5.1.3 and that our action speciﬁcations enforce the execution environment</text>
<text top="228" left="173" width="367" height="16" font="0">integrity and address space integrity properties.</text>
<text top="274" left="173" width="626" height="16" font="0">Theorem 2 (Valid Instantiation). The deﬁnitions provided throughout this chapter</text>
<text top="309" left="173" width="347" height="16" font="0">for the components of the Rushby framework,</text>
<text top="355" left="186" width="157" height="16" font="0">(i) the machine, M ,</text>
<text top="391" left="181" width="241" height="16" font="0">(ii) the set of domains, D , and</text>
<text top="427" left="175" width="376" height="16" font="0">(iii) the policy that governs domain interactions,</text>
<text top="474" left="173" width="502" height="16" font="0">form a valid instantiation that satisﬁes the unwinding conditions.</text>
<text top="520" left="173" width="626" height="16" font="0">Proof Sketch: We present an outline of the high-level steps necessary to prove the</text>
<text top="555" left="173" width="616" height="16" font="0">correctness of Theorem 2. A full proof remains as future work (see Chapter 10).</text>
<text top="601" left="173" width="626" height="16" font="0">Step 1: Unfold the deﬁnition of step to produce subgoals in terms of canStepTo.</text>
<text top="635" left="235" width="564" height="16" font="0">We begin with the unfolding for local respect, which is deﬁned directly in</text>
<text top="670" left="235" width="105" height="16" font="0">terms of step:</text>
<text top="719" left="279" width="58" height="16" font="0">dom(a)</text>
<text top="719" left="365" width="60" height="16" font="0">u ⇒ s</text>
<text top="713" left="434" width="7" height="11" font="2">u</text>
<text top="718" left="431" width="95" height="17" font="0">∼ step(s, a).</text>
<text top="767" left="235" width="564" height="16" font="0">For the case where there exists at least one state that is related to s by</text>
<text top="802" left="235" width="564" height="16" font="0">a, unfolding the deﬁnition of step gives the following statement of local</text>
<text top="837" left="235" width="59" height="16" font="0">respect:</text>
<text top="885" left="279" width="58" height="16" font="0">dom(a)</text>
<text top="885" left="365" width="60" height="16" font="0">u ⇒ s</text>
<text top="879" left="434" width="7" height="11" font="2">u</text>
<text top="884" left="431" width="269" height="17" font="0">∼ pickArbitrary (relatedStates s a)</text>
<text top="934" left="235" width="564" height="16" font="0">For the case where no related state exists, the right-hand side of the prop-</text>
<text top="969" left="235" width="124" height="16" font="0">erty reduces to s</text>
<text top="963" left="369" width="7" height="11" font="2">u</text>
<text top="968" left="366" width="433" height="17" font="0">∼ s, which is trivially true. If we let s equal an arbitrary</text>
<text top="1004" left="235" width="464" height="16" font="0">state that is related to s by a, then the property reduces to:</text>
<text top="1052" left="279" width="58" height="16" font="0">dom(a)</text>
<text top="1052" left="365" width="154" height="16" font="0">u ∧ canStepTo s a s</text>
<text top="1051" left="539" width="35" height="17" font="0">⇒ s</text>
<text top="1046" left="583" width="7" height="11" font="2">u</text>
<text top="1051" left="580" width="26" height="17" font="0">∼ s</text>
</page>
<page number="180" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">158</text>
<text top="163" left="235" width="121" height="16" font="0">by substitution.</text>
<text top="204" left="235" width="564" height="16" font="0">A similar unfolding technique applies to weak step consistency, which has</text>
<text top="239" left="235" width="308" height="16" font="0">the following deﬁnition in terms of step,</text>
<text top="283" left="279" width="7" height="16" font="0">s</text>
<text top="277" left="296" width="7" height="11" font="2">u</text>
<text top="282" left="293" width="65" height="17" font="0">∼ t ∧ s</text>
<text top="276" left="364" width="42" height="11" font="2">dom(a)</text>
<text top="282" left="379" width="14" height="17" font="0">∼</text>
<text top="283" left="411" width="121" height="16" font="0">t ⇒ step(s, a)</text>
<text top="277" left="541" width="7" height="11" font="2">u</text>
<text top="282" left="537" width="89" height="17" font="0">∼ step(t , a)</text>
<text top="327" left="235" width="564" height="16" font="0">The intermediate proof steps follow the same pattern as in local respect, so</text>
<text top="362" left="235" width="564" height="16" font="0">we skip straight to the ﬁnal representation where s has been substituted</text>
<text top="397" left="235" width="564" height="16" font="0">for an arbitrary state that is related to s by a and t is an arbitrary state</text>
<text top="431" left="235" width="189" height="16" font="0">that is related to t by a.</text>
<text top="476" left="279" width="7" height="16" font="0">s</text>
<text top="470" left="296" width="7" height="11" font="2">u</text>
<text top="475" left="293" width="54" height="17" font="0">∼ t ∧ s</text>
<text top="469" left="353" width="42" height="11" font="2">dom(a)</text>
<text top="475" left="367" width="14" height="17" font="0">∼</text>
<text top="476" left="400" width="304" height="16" font="0">t ∧ canStepTo s a s ∧ canStepTo t a t</text>
<text top="475" left="720" width="35" height="17" font="0">⇒ s</text>
<text top="470" left="769" width="7" height="11" font="2">u</text>
<text top="475" left="766" width="25" height="17" font="0">∼ t</text>
<text top="520" left="235" width="564" height="16" font="0">As before, the property is trivially true if there is no after state that is</text>
<text top="555" left="235" width="312" height="16" font="0">related to the before state by the action.</text>
<text top="602" left="173" width="626" height="16" font="0">Step 2: Demonstrate that output consistency reduces to weak step consistency</text>
<text top="637" left="235" width="564" height="16" font="0">under our instantiation of the output function output . Recall the deﬁnition</text>
<text top="672" left="235" width="314" height="16" font="0">of output consistency from Section 5.1.3:</text>
<text top="716" left="279" width="7" height="16" font="0">s</text>
<text top="709" left="293" width="42" height="11" font="2">dom(a)</text>
<text top="715" left="307" width="14" height="17" font="0">∼</text>
<text top="716" left="340" width="258" height="16" font="0">t ⇒ output (s, a) = output (t , a).</text>
<text top="761" left="235" width="337" height="16" font="0">Expanding the deﬁnition of output gives us:</text>
<text top="805" left="260" width="7" height="16" font="0">s</text>
<text top="798" left="274" width="42" height="11" font="2">dom(a)</text>
<text top="804" left="288" width="14" height="17" font="0">∼</text>
<text top="805" left="321" width="478" height="16" font="0">t ⇒ view (dom(a)) (step(s, a)) = view (dom(a)) (step(t , a)).</text>
<text top="849" left="235" width="564" height="16" font="0">Now the right-hand side of the arrow is equivalent to our deﬁnition of the</text>
<text top="884" left="235" width="200" height="16" font="0">view-partitioning relation.</text>
<text top="929" left="279" width="7" height="16" font="0">s</text>
<text top="921" left="293" width="42" height="11" font="2">dom(a)</text>
<text top="928" left="307" width="14" height="17" font="0">∼</text>
<text top="929" left="340" width="35" height="16" font="0">t ∧ s</text>
<text top="921" left="381" width="42" height="11" font="2">dom(a)</text>
<text top="928" left="395" width="14" height="17" font="0">∼</text>
<text top="929" left="428" width="121" height="16" font="0">t ⇒ step(s, a)</text>
<text top="921" left="554" width="42" height="11" font="2">dom(a)</text>
<text top="928" left="568" width="14" height="17" font="0">∼</text>
<text top="929" left="601" width="71" height="16" font="0">step(t , a)</text>
<text top="973" left="235" width="564" height="16" font="0">Applying the same unfolding techniques that we employed in Step 1 for</text>
<text top="1008" left="235" width="392" height="16" font="0">local respect and weak step consistency, we obtain,</text>
<text top="1052" left="279" width="7" height="16" font="0">s</text>
<text top="1045" left="293" width="42" height="11" font="2">dom(a)</text>
<text top="1051" left="307" width="14" height="17" font="0">∼</text>
<text top="1052" left="340" width="298" height="16" font="0">t ∧ canStepTo s a s ∧ canStepTo t a t</text>
<text top="1051" left="658" width="35" height="17" font="0">⇒ s</text>
<text top="1045" left="703" width="42" height="11" font="2">dom(a)</text>
<text top="1051" left="717" width="14" height="17" font="0">∼</text>
<text top="1052" left="750" width="17" height="16" font="0">t .</text>
</page>
<page number="181" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">159</text>
<text top="163" left="235" width="376" height="16" font="0">Recalling the deﬁnition of weak step consistency,</text>
<text top="213" left="279" width="7" height="16" font="0">s</text>
<text top="207" left="296" width="7" height="11" font="2">u</text>
<text top="212" left="293" width="54" height="17" font="0">∼ t ∧ s</text>
<text top="206" left="353" width="42" height="11" font="2">dom(a)</text>
<text top="212" left="367" width="14" height="17" font="0">∼</text>
<text top="213" left="400" width="304" height="16" font="0">t ∧ canStepTo s a s ∧ canStepTo t a t</text>
<text top="212" left="720" width="35" height="17" font="0">⇒ s</text>
<text top="207" left="769" width="7" height="11" font="2">u</text>
<text top="212" left="766" width="25" height="17" font="0">∼ t</text>
<text top="264" left="235" width="564" height="16" font="0">we can see that output consistency is now equivalent to weak step consis-</text>
<text top="299" left="235" width="564" height="16" font="0">tency in the special case where u equals dom(a). Thus, in future eﬀorts</text>
<text top="333" left="235" width="564" height="16" font="0">to verify the correctness of our system, it will be suﬃcient to prove just</text>
<text top="368" left="235" width="564" height="16" font="0">the local respect and weak step consistency unwinding conditions for our</text>
<text top="403" left="235" width="59" height="16" font="0">actions.</text>
<text top="452" left="173" width="626" height="16" font="0">Step 3: Prove local respect by cases. The proof of local respect splits into twelve</text>
<text top="486" left="235" width="564" height="16" font="0">top-level cases. These cases come directly from the deﬁnition of the prop-</text>
<text top="521" left="235" width="403" height="16" font="0">erty, which quantiﬁes over all noninterfering actions.</text>
<text top="571" left="279" width="58" height="16" font="0">dom(a)</text>
<text top="571" left="365" width="154" height="16" font="0">u ∧ canStepTo s a s</text>
<text top="570" left="539" width="35" height="17" font="0">⇒ s</text>
<text top="565" left="583" width="7" height="11" font="2">u</text>
<text top="570" left="580" width="26" height="17" font="0">∼ s</text>
<text top="622" left="235" width="564" height="16" font="0">A noninterfering action is one that belongs to a domain that does not</text>
<text top="656" left="235" width="564" height="16" font="0">interfere with some other domain. There are six cases in our security policy</text>
<text top="691" left="235" width="510" height="16" font="0">where one domain is guaranteed not to interfere with another: E</text>
<text top="691" left="778" width="21" height="16" font="0">U ,</text>
<text top="726" left="235" width="13" height="16" font="0">H</text>
<text top="726" left="288" width="42" height="16" font="0">E , K</text>
<text top="726" left="369" width="41" height="16" font="0">E , U</text>
<text top="726" left="449" width="42" height="16" font="0">E , K</text>
<text top="726" left="530" width="80" height="16" font="0">H , and U</text>
<text top="726" left="649" width="150" height="16" font="0">H . To prove local</text>
<text top="760" left="235" width="564" height="16" font="0">respect we must prove that all of the actions in each of the noninterfering</text>
<text top="795" left="235" width="564" height="16" font="0">domains do not produce observable eﬀects in the state of the uninterfered</text>
<text top="830" left="235" width="561" height="16" font="0">with domain. Each of E , K , and U only have one action, whereas the H</text>
<text top="864" left="235" width="564" height="16" font="0">domain contains seven. Instantiating the deﬁnition of local respect gives</text>
<text top="899" left="235" width="564" height="16" font="0">us the following proof obligations, accompanied by a brief discussion of</text>
<text top="934" left="235" width="366" height="16" font="0">the intuition behind the proof of each property:</text>
<text top="983" left="243" width="241" height="16" font="0">(a) canStepTo s WriteE s ⇒ s</text>
<text top="977" left="491" width="10" height="11" font="2">U</text>
<text top="982" left="490" width="26" height="17" font="0">∼ s</text>
<text top="1017" left="274" width="525" height="16" font="0">This case describes the fact that a write performed by the environ-</text>
<text top="1052" left="274" width="525" height="16" font="0">ment domain must not be observable to any user-level programs. We</text>
</page>
<page number="182" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">160</text>
<text top="163" left="274" width="525" height="16" font="0">use hardware-based protection to ensure that user-level programs can-</text>
<text top="198" left="274" width="525" height="16" font="0">not access the environment pages, which are mapped with kernel-only</text>
<text top="232" left="274" width="525" height="16" font="0">permission. Thus, our implementation must always map the envi-</text>
<text top="267" left="274" width="525" height="16" font="0">ronment pages with kernel-only permissions. The well-formedness</text>
<text top="302" left="274" width="525" height="16" font="0">condition environmentOnlyInReference describes the fact that the</text>
<text top="336" left="274" width="525" height="16" font="0">environment pages are only mapped in the reference page-directory,</text>
<text top="371" left="274" width="525" height="16" font="0">which, according to the referenceMapsKernelAddresses condition,</text>
<text top="406" left="274" width="525" height="16" font="0">contains only kernel-mapped addresses. Thus, these two aspects of</text>
<text top="440" left="274" width="525" height="16" font="0">well-formedness combine to ensure that all well-formed states satisfy</text>
<text top="475" left="274" width="525" height="16" font="0">the necessary correctness criteria to make this case of local respect</text>
<text top="510" left="274" width="36" height="16" font="0">true.</text>
<text top="546" left="242" width="306" height="16" font="0">(b) canStepTo s DeriveRegionH s ⇒ s</text>
<text top="540" left="556" width="9" height="11" font="2">E</text>
<text top="545" left="554" width="26" height="17" font="0">∼ s</text>
<text top="580" left="274" width="525" height="16" font="0">Lemma 2 demonstrates that no action belonging to the H domain</text>
<text top="615" left="274" width="525" height="16" font="0">modiﬁes the view of the environment domain. The DeriveRegionH</text>
<text top="650" left="274" width="525" height="16" font="0">action belongs to the H domain, so we can conclude that any suc-</text>
<text top="684" left="274" width="398" height="16" font="0">cessful step via this action does not aﬀect E ’s view.</text>
<text top="721" left="244" width="387" height="16" font="0">(c) canStepTo s AllocatePageDirectoryH s ⇒ s</text>
<text top="715" left="639" width="9" height="11" font="2">E</text>
<text top="720" left="637" width="26" height="17" font="0">∼ s</text>
<text top="755" left="274" width="415" height="16" font="0">Follows from Lemma 2, similarly to the previous case.</text>
<text top="791" left="242" width="343" height="16" font="0">(d) canStepTo s FreePageDirectory s ⇒ s</text>
<text top="785" left="593" width="9" height="11" font="2">E</text>
<text top="790" left="591" width="26" height="17" font="0">∼ s</text>
<text top="826" left="274" width="180" height="16" font="0">Follows from Lemma 2.</text>
<text top="862" left="244" width="286" height="16" font="0">(e) canStepTo s AddMappingH s ⇒ s</text>
<text top="856" left="538" width="9" height="11" font="2">E</text>
<text top="861" left="536" width="26" height="17" font="0">∼ s</text>
<text top="897" left="274" width="180" height="16" font="0">Follows from Lemma 2.</text>
<text top="933" left="245" width="312" height="16" font="0">(f) canStepTo s RemoveMappingH s ⇒ s</text>
<text top="927" left="566" width="9" height="11" font="2">E</text>
<text top="932" left="564" width="26" height="17" font="0">∼ s</text>
<text top="968" left="274" width="180" height="16" font="0">Follows from Lemma 2.</text>
<text top="1004" left="243" width="342" height="16" font="0">(g) canStepTo s AddKernelMappingH s ⇒ s</text>
<text top="998" left="593" width="9" height="11" font="2">E</text>
<text top="1003" left="591" width="26" height="17" font="0">∼ s</text>
<text top="1039" left="274" width="180" height="16" font="0">Follows from Lemma 2.</text>
</page>
<page number="183" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">161</text>
<text top="165" left="242" width="260" height="16" font="0">(h) canStepTo s ExecuteH s ⇒ s</text>
<text top="159" left="510" width="9" height="11" font="2">E</text>
<text top="164" left="508" width="26" height="17" font="0">∼ s</text>
<text top="200" left="274" width="180" height="16" font="0">Follows from Lemma 2.</text>
<text top="236" left="247" width="237" height="16" font="0">(i) canStepTo s WriteK s ⇒ s</text>
<text top="230" left="492" width="9" height="11" font="2">E</text>
<text top="235" left="490" width="26" height="17" font="0">∼ s</text>
<text top="271" left="274" width="525" height="16" font="0">The speciﬁcation of WriteK states that the action will only modify a</text>
<text top="305" left="274" width="525" height="16" font="0">virtual address that is mapped to a physical page with the Normal</text>
<text top="340" left="274" width="525" height="16" font="0">status type. Thus, WriteK cannot be used to modify environment</text>
<text top="375" left="274" width="525" height="16" font="0">pages or the translation pages that aﬀect the view of the environment</text>
<text top="409" left="274" width="61" height="16" font="0">domain.</text>
<text top="445" left="246" width="237" height="16" font="0">(j) canStepTo s WriteU s ⇒ s</text>
<text top="439" left="492" width="9" height="11" font="2">E</text>
<text top="444" left="490" width="26" height="17" font="0">∼ s</text>
<text top="482" left="274" width="525" height="15" font="0">WriteU and WriteK share a common speciﬁcation, except for the por-</text>
<text top="515" left="274" width="525" height="16" font="0">tion of the action description that states whether user or kernel ad-</text>
<text top="549" left="274" width="525" height="16" font="0">dresses are changed, so the same reasoning applies as in the previous</text>
<text top="584" left="274" width="36" height="16" font="0">case.</text>
<text top="620" left="242" width="241" height="16" font="0">(k) canStepTo s WriteK s ⇒ s</text>
<text top="614" left="491" width="10" height="11" font="2">H</text>
<text top="619" left="490" width="26" height="17" font="0">∼ s</text>
<text top="655" left="274" width="525" height="16" font="0">Some of the rationale applied in the E case applies here, namely,</text>
<text top="690" left="274" width="525" height="16" font="0">that WriteK will only change the data that is contained in normal</text>
<text top="724" left="274" width="47" height="16" font="0">pages.</text>
<text top="724" left="337" width="462" height="16" font="0">The view of the H domain does not permit it to observe</text>
<text top="759" left="274" width="525" height="16" font="0">the contents of normal pages, so writes to normal pages will not be</text>
<text top="794" left="274" width="525" height="16" font="0">observable. The frame conditions in the WriteK speciﬁcation ensure</text>
<text top="828" left="274" width="525" height="16" font="0">that the reference page-directory and regions state components, both</text>
<text top="863" left="274" width="525" height="16" font="0">of which are observable to H , do not change. The action does not</text>
<text top="898" left="274" width="525" height="16" font="0">change the status of any page. Thus, no state component that H can</text>
<text top="932" left="274" width="525" height="16" font="0">observe is modiﬁed by WriteK, so the view of the state seen by H in</text>
<text top="967" left="274" width="332" height="16" font="0">the before and after state will be the same.</text>
<text top="1003" left="247" width="237" height="16" font="0">(l) canStepTo s WriteU s ⇒ s</text>
<text top="997" left="491" width="10" height="11" font="2">H</text>
<text top="1002" left="490" width="26" height="17" font="0">∼ s</text>
<text top="1038" left="274" width="525" height="16" font="0">As described earlier, WriteU is speciﬁed in terms of the same relation</text>
</page>
<page number="184" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">162</text>
<text top="163" left="274" width="489" height="16" font="0">as WriteK so the same rationale applies as in the previous case.</text>
<text top="213" left="235" width="564" height="16" font="0">At the time of writing, we have mechanically veriﬁed cases (a), (b), (h), (i),</text>
<text top="247" left="235" width="564" height="16" font="0">(j), (k), and (l), following the basic intuition described here. We anticipate</text>
<text top="282" left="235" width="564" height="16" font="0">that proving the cases that relate to mappings management will be more</text>
<text top="317" left="235" width="564" height="16" font="0">complex than the proofs so far, but are hopeful that the sketches presented</text>
<text top="351" left="235" width="564" height="16" font="0">here will help direct us towards a proof architecture that minimizes the</text>
<text top="386" left="235" width="71" height="16" font="0">diﬃculty.</text>
<text top="435" left="173" width="626" height="16" font="0">Step 4: Prove weak step consistency by cases. Recalling the deﬁnition of weak</text>
<text top="470" left="235" width="329" height="16" font="0">step consistency that we derived in Step 1,</text>
<text top="523" left="279" width="7" height="16" font="0">s</text>
<text top="517" left="296" width="7" height="11" font="2">u</text>
<text top="522" left="293" width="54" height="17" font="0">∼ t ∧ s</text>
<text top="515" left="353" width="42" height="11" font="2">dom(a)</text>
<text top="522" left="367" width="14" height="17" font="0">∼</text>
<text top="523" left="400" width="304" height="16" font="0">t ∧ canStepTo s a s ∧ canStepTo t a t</text>
<text top="522" left="720" width="35" height="17" font="0">⇒ s</text>
<text top="517" left="769" width="7" height="11" font="2">u</text>
<text top="522" left="766" width="25" height="17" font="0">∼ t</text>
<text top="575" left="235" width="564" height="16" font="0">we can see that this proof will require 40 cases: one per action for each of</text>
<text top="610" left="235" width="219" height="16" font="0">the four protection domains.</text>
<text top="652" left="235" width="564" height="16" font="0">We can eliminate 12 of these 40 cases immediately because weak step</text>
<text top="687" left="235" width="564" height="16" font="0">consistency can be derived from local respect for any action, a, such that</text>
<text top="722" left="235" width="549" height="16" font="0">dom(a) does not interfere with u. Recall the deﬁnition of local respect:</text>
<text top="774" left="279" width="58" height="16" font="0">dom(a)</text>
<text top="774" left="365" width="154" height="16" font="0">u ∧ canStepTo s a s</text>
<text top="773" left="539" width="35" height="17" font="0">⇒ s</text>
<text top="768" left="583" width="7" height="11" font="2">u</text>
<text top="773" left="580" width="37" height="17" font="0">∼ s .</text>
<text top="827" left="235" width="564" height="16" font="0">canStepTo s a s is an assumption of weak step consistency, so when</text>
<text top="861" left="235" width="58" height="16" font="0">dom(a)</text>
<text top="861" left="326" width="205" height="16" font="0">u, we can conclude that s</text>
<text top="855" left="543" width="7" height="11" font="2">u</text>
<text top="860" left="540" width="259" height="17" font="0">∼ s . Similarly, we can conclude</text>
<text top="896" left="235" width="46" height="16" font="0">that t</text>
<text top="890" left="294" width="7" height="11" font="2">u</text>
<text top="895" left="291" width="346" height="17" font="0">∼ t using local respect. The assumption s</text>
<text top="890" left="650" width="7" height="11" font="2">u</text>
<text top="895" left="647" width="152" height="17" font="0">∼ t combined with</text>
<text top="931" left="235" width="384" height="16" font="0">transitivity of ∼ gives us the desired conclusion, s</text>
<text top="925" left="632" width="7" height="11" font="2">u</text>
<text top="930" left="629" width="36" height="17" font="0">∼ t .</text>
<text top="973" left="235" width="564" height="16" font="0">It remains to prove the remaining 28 cases where the domain of the action,</text>
<text top="1008" left="235" width="564" height="16" font="0">a, is permitted to interfere with the domain, u. Intuitively, weak step</text>
<text top="1042" left="235" width="564" height="16" font="0">consistency captures the property that information cannot ﬂow from a</text>
</page>
<page number="185" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">163</text>
<text top="164" left="449" width="10" height="16" font="0">S</text>
<text top="208" left="309" width="142" height="11" font="2">(view (dom(a)), view u)</text>
<text top="227" left="455" width="0" height="23" font="0"></text>
<text top="159" left="534" width="7" height="11" font="2">a</text>
<text top="154" left="595" width="44" height="25" font="0">// P(S)</text>
<text top="209" left="624" width="38" height="11" font="2">view u</text>
<text top="225" left="619" width="0" height="23" font="0"></text>
<text top="248" left="406" width="13" height="16" font="0">V</text>
<text top="255" left="419" width="42" height="11" font="2">dom(a)</text>
<text top="247" left="465" width="31" height="17" font="0">× V</text>
<text top="255" left="496" width="7" height="11" font="2">u</text>
<text top="239" left="590" width="38" height="25" font="0">// P(V</text>
<text top="255" left="628" width="7" height="11" font="2">u</text>
<text top="248" left="637" width="7" height="16" font="0">)</text>
<text top="287" left="173" width="626" height="16" font="0">Figure 5.3: An illustration of the intuition behind weak step consistency. S repre-</text>
<text top="322" left="173" width="192" height="16" font="0">sents the set of states, V</text>
<text top="329" left="365" width="42" height="11" font="2">dom(a)</text>
<text top="322" left="415" width="376" height="16" font="0">represents the view of the acting domain, and V</text>
<text top="329" left="791" width="7" height="11" font="2">u</text>
<text top="356" left="173" width="626" height="16" font="0">represents the view of the domain u. With our relational speciﬁcation, a single</text>
<text top="391" left="173" width="626" height="16" font="0">before state will be related to a set of after states by an action, a. For weak step</text>
<text top="426" left="173" width="626" height="16" font="0">consistency to hold, there must exist a function (represented by the dotted line)</text>
<text top="460" left="173" width="54" height="16" font="0">from V</text>
<text top="467" left="227" width="42" height="11" font="2">dom(a)</text>
<text top="459" left="274" width="31" height="17" font="0">× V</text>
<text top="467" left="305" width="7" height="11" font="2">u</text>
<text top="460" left="319" width="55" height="16" font="0">to P(V</text>
<text top="467" left="375" width="7" height="11" font="2">u</text>
<text top="460" left="383" width="12" height="16" font="0">).</text>
<text top="514" left="235" width="564" height="16" font="0">third-party domain (a domain that is neither the actor nor the domain,</text>
<text top="549" left="235" width="564" height="16" font="0">u) to u. We can express this property by saying that the view of u in</text>
<text top="583" left="235" width="564" height="16" font="0">the after state must be a function of the views of dom(a) and u in the</text>
<text top="618" left="235" width="564" height="16" font="0">before state. To handle nondeterministic actions, we express the property</text>
<text top="653" left="235" width="564" height="16" font="0">by saying that the set of u views in the possible after states is a function</text>
<text top="687" left="235" width="427" height="16" font="0">of the before views. Figure 5.3 illustrates this intuition.</text>
<text top="729" left="235" width="564" height="16" font="0">To complete the proof of weak step consistency, we can employ the same</text>
<text top="764" left="235" width="564" height="16" font="0">reasoning techniques that were used in the proof sketches of Lemma 1,</text>
<text top="799" left="235" width="564" height="16" font="0">Lemma 2, and local respect. Speciﬁcally, we must demonstrate the exis-</text>
<text top="834" left="235" width="564" height="16" font="0">tence of a function from the before views to the set of after views in each</text>
<text top="868" left="235" width="564" height="16" font="0">case. We sketch the proof of an example case in more detail to illustrate</text>
<text top="903" left="235" width="464" height="16" font="0">the application of these techniques to weak step consistency.</text>
<text top="970" left="235" width="130" height="16" font="0">Example Case:</text>
<text top="970" left="383" width="272" height="16" font="0">Let a = WriteE va val and u = H .</text>
<text top="1012" left="235" width="564" height="16" font="0">In this case, we must prove that a write action in the environment domain</text>
<text top="1047" left="235" width="564" height="16" font="0">does not update the state in such a way that information from the K or</text>
</page>
<page number="186" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">164</text>
<text top="163" left="235" width="564" height="16" font="0">U domains becomes visible through the view of H . By design, WriteE</text>
<text top="198" left="235" width="564" height="16" font="0">stores val in memory at virtual-address va and should not make any other</text>
<text top="232" left="235" width="563" height="16" font="0">changes to the state. We can see from the speciﬁcation of WriteE that va</text>
<text top="267" left="235" width="564" height="16" font="0">must map to a page with the Environment status in the before state in</text>
<text top="302" left="235" width="564" height="16" font="0">order for there to be any related after states. The status of all other physi-</text>
<text top="336" left="235" width="564" height="16" font="0">cal pages, which includes their contents, does not change. The contents of</text>
<text top="371" left="235" width="564" height="16" font="0">environment pages are within H ’s view, so H can observe the data value</text>
<text top="406" left="235" width="564" height="16" font="0">that is written. Thus, we must show that the views of E and H contain</text>
<text top="440" left="235" width="561" height="16" font="0">all of the information necessary to perform the write, because otherwise H</text>
<text top="475" left="235" width="564" height="16" font="0">might be able to distinguish the after states, s and t , based on invisible</text>
<text top="510" left="235" width="352" height="16" font="0">diﬀerences between the before states, s and t .</text>
<text top="552" left="235" width="564" height="16" font="0">The only information used to perform the write is the virtual-to-physical</text>
<text top="586" left="235" width="564" height="16" font="0">mapping for the page address va. H can observe the virtual-to-physical</text>
<text top="621" left="235" width="564" height="16" font="0">mappings for every page-directory, including the reference page-directory,</text>
<text top="656" left="235" width="564" height="16" font="0">which is used by the environment domain. To connect this explanation to</text>
<text top="690" left="235" width="564" height="16" font="0">the intuition presented in Figure 5.3, we can also construct the function</text>
<text top="725" left="235" width="97" height="16" font="0">that maps V</text>
<text top="732" left="332" width="9" height="11" font="2">E</text>
<text top="724" left="347" width="31" height="17" font="0">× V</text>
<text top="732" left="378" width="10" height="11" font="2">H</text>
<text top="725" left="396" width="55" height="16" font="0">to P(V</text>
<text top="732" left="451" width="10" height="11" font="2">H</text>
<text top="725" left="463" width="12" height="16" font="0">):</text>
<text top="775" left="252" width="241" height="14" font="7">\(e :: EView, h :: HView) -&gt;</text>
<text top="808" left="270" width="490" height="14" font="7">if isJust (eObservablePages e (fst va)) then {h’} else {}</text>
<text top="840" left="252" width="43" height="14" font="7">where</text>
<text top="873" left="270" width="206" height="14" font="7">h’ = h{ pages = pages’ }</text>
<text top="905" left="270" width="473" height="14" font="7">pages’ ppa = if ppa == ppa’ then page’ else pages h ppa</text>
<text top="938" left="270" width="430" height="14" font="7">ppa’ = translatePageH h (referencePdir h) (fst va)</text>
<text top="970" left="270" width="241" height="14" font="7">page’ = case pages h ppa’ of</text>
<text top="1003" left="356" width="258" height="14" font="7">Just (Environment pagedata) -&gt;</text>
<text top="1035" left="373" width="163" height="14" font="7">let pagedata’ off =</text>
</page>
<page number="187" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">165</text>
<text top="165" left="424" width="369" height="14" font="7">if off == snd va then val else pagedata off</text>
<text top="198" left="373" width="266" height="14" font="7">in Just (Environment pagedata’)</text>
<text top="230" left="356" width="52" height="14" font="7">x -&gt; x</text>
<text top="278" left="235" width="564" height="16" font="0">Here, translatePageH is simply a specialized version of translatePage</text>
<text top="312" left="235" width="564" height="16" font="0">that performs the address translation using the structures in the H state,</text>
<text top="347" left="235" width="564" height="16" font="0">rather than a global state. By deﬁning this function, and by our previous</text>
<text top="382" left="235" width="404" height="16" font="0">argument that WriteE only uses information from V</text>
<text top="388" left="640" width="9" height="11" font="2">E</text>
<text top="381" left="655" width="31" height="17" font="0">× V</text>
<text top="388" left="686" width="10" height="11" font="2">H</text>
<text top="382" left="698" width="102" height="16" font="0">, we can con-</text>
<text top="416" left="235" width="564" height="16" font="0">clude that weak step consistency holds in this case. We leave the proof of</text>
<text top="451" left="235" width="295" height="16" font="0">the remaining 27 cases as future work.</text>
<text top="560" left="173" width="41" height="16" font="0">5.8.4</text>
<text top="560" left="234" width="153" height="16" font="0">Model Validation</text>
<text top="604" left="173" width="626" height="16" font="0">Though our proof of the unwinding conditions is still incomplete, just the act of</text>
<text top="637" left="173" width="626" height="16" font="0">sketching out the proof has already led to minor changes in the formalization. The</text>
<text top="669" left="173" width="626" height="16" font="0">model presented in this chapter incorporates the appropriate adjustments, but in</text>
<text top="702" left="173" width="626" height="16" font="0">this section we describe the rationale for the changes in to illustrate the process of</text>
<text top="734" left="173" width="404" height="16" font="0">identifying and correcting an oversight in the model.</text>
<text top="767" left="199" width="600" height="16" font="0">The ﬁrst change concerned the view functions for observing memory in the</text>
<text top="799" left="173" width="626" height="16" font="0">environment, kernel, and user domains. The views in the original model did not</text>
<text top="832" left="173" width="626" height="16" font="0">contain any notion of a reference count on pages (see Section 5.4.1 for a discussion</text>
<text top="864" left="173" width="626" height="16" font="0">of domains and their views). The view of each domain was a partial mapping from</text>
<text top="897" left="173" width="626" height="16" font="0">virtual page address to contents without any additional information, which seemed</text>
<text top="929" left="173" width="626" height="16" font="0">like a reasonable abstraction for the functionality provided by virtual memory on</text>
<text top="962" left="173" width="626" height="16" font="0">the IA32. Unfortunately, weak step consistency cannot be proved with the original</text>
<text top="994" left="173" width="626" height="16" font="0">view deﬁnitions. The problem is best illustrated through an example, shown in</text>
<text top="1027" left="173" width="83" height="16" font="0">Figure 5.4.</text>
</page>
<page number="188" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="12" size="9" family="Times" color="#000000"/>
<text top="111" left="729" width="26" height="16" font="0">166</text>
<text top="241" left="256" width="57" height="12" font="2">virtual page</text>
<text top="254" left="259" width="51" height="12" font="2">addresses</text>
<text top="236" left="325" width="12" height="12" font="2">s1</text>
<text top="236" left="537" width="9" height="12" font="2">t1</text>
<text top="236" left="599" width="9" height="12" font="2">t2</text>
<text top="236" left="663" width="9" height="12" font="2">t3</text>
<text top="236" left="386" width="12" height="12" font="2">s2</text>
<text top="236" left="450" width="12" height="12" font="2">s3</text>
<text top="370" left="456" width="14" height="12" font="2">P1</text>
<text top="370" left="564" width="14" height="12" font="2">P2</text>
<text top="163" left="365" width="92" height="12" font="2">view of E in state <i>s</i></text>
<text top="164" left="576" width="90" height="12" font="2">view of E in state <i>t</i></text>
<text top="426" left="496" width="41" height="12" font="2">identical</text>
<text top="439" left="480" width="73" height="12" font="2">physical pages</text>
<text top="480" left="457" width="31" height="13" font="4">(a) s</text>
<text top="475" left="495" width="7" height="9" font="3">u</text>
<text top="480" left="493" width="21" height="14" font="4">∼ t</text>
<text top="593" left="253" width="58" height="12" font="2">virtual page</text>
<text top="607" left="256" width="51" height="12" font="2">addresses</text>
<text top="554" left="397" width="33" height="12" font="2">WriteE</text>
<text top="588" left="322" width="12" height="12" font="2">s1</text>
<text top="588" left="537" width="9" height="12" font="2">t1</text>
<text top="588" left="599" width="9" height="12" font="2">t2</text>
<text top="588" left="664" width="9" height="12" font="2">t3</text>
<text top="588" left="384" width="12" height="12" font="2">s2</text>
<text top="588" left="449" width="12" height="12" font="2">s3</text>
<text top="776" left="426" width="73" height="12" font="2">value changed</text>
<text top="789" left="438" width="49" height="12" font="2">by WriteE</text>
<text top="775" left="548" width="46" height="12" font="2">no longer</text>
<text top="788" left="543" width="56" height="12" font="2">equal to P1</text>
<text top="724" left="455" width="14" height="12" font="2">P1</text>
<text top="724" left="564" width="14" height="12" font="2">P2</text>
<text top="514" left="363" width="93" height="12" font="2">view of E in state <i>s</i></text>
<text top="515" left="576" width="91" height="12" font="2">view of E in state <i>t</i></text>
<text top="829" left="456" width="32" height="13" font="4">(b) s</text>
<text top="819" left="496" width="7" height="9" font="3">u</text>
<text top="829" left="494" width="21" height="14" font="4">∼ t</text>
<text top="867" left="173" width="626" height="16" font="0">Figure 5.4: Motivation for reference counts in the views of the environment, ker-</text>
<text top="902" left="173" width="626" height="16" font="0">nel, and user domains. A domain can observe the fact that a particular physical</text>
<text top="937" left="173" width="626" height="16" font="0">page is multiply mapped because a single write will change the value of more than</text>
<text top="971" left="173" width="626" height="16" font="0">one location. However, without reference counts, the domain will not be able to</text>
<text top="1006" left="173" width="626" height="16" font="0">distinguish two states with diﬀerent multiple mapping conﬁgurations. This is a vi-</text>
<text top="1041" left="173" width="626" height="16" font="0">olation of weak step consistency, because executing the same action in (seemingly)</text>
<text top="1075" left="173" width="491" height="16" font="0">equivalent before states will not produce equivalent after states.</text>
</page>
<page number="189" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">167</text>
<text top="163" left="199" width="600" height="16" font="0">In Figure 5.4(a), the states s and t are indistinguishable because the visible</text>
<text top="195" left="173" width="626" height="16" font="0">virtual addresses all map to the same values. However, a single WriteE action</text>
<text top="228" left="173" width="626" height="16" font="0">produces states that are no longer equivalent because of the hidden sharing, as</text>
<text top="260" left="173" width="626" height="16" font="0">shown in Figure 5.4(b). Weak step consistency guarantees that the after states</text>
<text top="293" left="173" width="626" height="16" font="0">produced by executing an action in equivalent before states will be equivalent,</text>
<text top="325" left="173" width="626" height="16" font="0">which is not true in this case. We can conclude from this example that physical</text>
<text top="358" left="173" width="626" height="16" font="0">page sharing between multiple virtual addresses is an important part of the envi-</text>
<text top="390" left="173" width="626" height="16" font="0">ronment domain’s view. After making this observation, we updated the view of</text>
<text top="423" left="173" width="626" height="16" font="0">the environment domain to include a reference count that reﬂected page sharing.</text>
<text top="455" left="173" width="626" height="16" font="0">The same rationale applies for the kernel and user domains, so we added reference</text>
<text top="488" left="173" width="222" height="16" font="0">counts to their views as well.</text>
<text top="520" left="199" width="600" height="16" font="0">Another change we made to the model was to introduce the page status value</text>
<text top="554" left="173" width="626" height="15" font="0">NotInstalled. During the course of developing the model, we experimented with</text>
<text top="585" left="173" width="626" height="16" font="0">a few diﬀerent approaches for handling the possibility that some addressable pages</text>
<text top="618" left="173" width="626" height="16" font="0">of physical memory may not be present in a given system conﬁguration. At one</text>
<text top="650" left="173" width="626" height="16" font="0">point, we explicitly included a parameter describing the list of installed pages and</text>
<text top="683" left="173" width="626" height="16" font="0">constructed all of our speciﬁcations using forall and exists operators over this list.</text>
<text top="715" left="173" width="626" height="16" font="0">This approach did seem like a good ﬁt once we began to think about mechanization,</text>
<text top="748" left="173" width="513" height="16" font="0">so we were motivated to introduce the status value NotInstalled.</text>
<text top="810" left="173" width="26" height="16" font="0">5.9</text>
<text top="810" left="219" width="109" height="16" font="0">SUMMARY</text>
<text top="860" left="173" width="626" height="16" font="0">In this chapter, we provided a deﬁnition of memory-safety for the H interface in</text>
<text top="892" left="173" width="626" height="16" font="0">terms of a noninterference security policy. We instantiated the Rushby frame-</text>
<text top="925" left="173" width="626" height="16" font="0">work [82] to formalize two novel properties called execution environment integrity</text>
<text top="957" left="173" width="626" height="16" font="0">and address-space integrity that supplement the traditional deﬁnition of memory-</text>
<text top="990" left="173" width="626" height="16" font="0">safety. These integrity properties ensure that the Haskell run-time environment</text>
</page>
<page number="190" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">168</text>
<text top="163" left="173" width="626" height="16" font="0">cannot be corrupted, even when we use potentially unsafe operations in the imple-</text>
<text top="195" left="173" width="121" height="16" font="0">mentation of H.</text>
<text top="228" left="199" width="600" height="16" font="0">Our work in this dissertation introduces the framework and methodology for</text>
<text top="260" left="173" width="626" height="16" font="0">reasoning about memory-safety as a noninterference property. Much future work</text>
<text top="293" left="173" width="626" height="16" font="0">remains before we can conclude that our implementation of H is memory-safe</text>
<text top="325" left="173" width="393" height="16" font="0">according to our deﬁnition. In particular, we must:</text>
<text top="372" left="199" width="600" height="17" font="0">• Demonstrate that H is memory-safe according to the colloquial deﬁnition</text>
<text top="405" left="217" width="530" height="16" font="0">(for example, that no H operation should dereference a null pointer).</text>
<text top="452" left="199" width="600" height="17" font="0">• Prove the unwinding conditions for the speciﬁcations described in Section 5.7.</text>
<text top="485" left="217" width="583" height="16" font="0">We have sketched some of the steps necessary for this proof in Section 5.8</text>
<text top="518" left="217" width="582" height="16" font="0">and formally veriﬁed a few cases, but a complete proof is necessary before</text>
<text top="550" left="217" width="436" height="16" font="0">we can conclude that the speciﬁcations are memory-safe.</text>
<text top="597" left="199" width="600" height="17" font="0">• Establish a formal connection between the model and the implementation.</text>
<text top="630" left="217" width="583" height="16" font="0">Without formally connecting the speciﬁcations to the real operations of H,</text>
<text top="663" left="217" width="582" height="16" font="0">we cannot use our formalism to conclude anything about the operations that</text>
<text top="695" left="217" width="582" height="16" font="0">are actually called by client kernels. Section 5.7 describes the properties</text>
<text top="728" left="217" width="583" height="16" font="0">that a valid instantiation must satisfy; we must prove these properties of our</text>
<text top="760" left="217" width="533" height="16" font="0">implementation to establish that our implementation is memory-safe.</text>
<text top="808" left="173" width="626" height="16" font="0">As we pursue these topics, it is possible that we will need to make changes to certain</text>
<text top="840" left="173" width="626" height="16" font="0">aspects of the formalization presented here. In particular, the speciﬁcations, the</text>
<text top="873" left="173" width="626" height="16" font="0">well-formedness constraints, and the implementation of the H primitives might</text>
<text top="905" left="173" width="626" height="16" font="0">not satisfy the properties above without some modiﬁcation. For example, the</text>
<text top="938" left="173" width="626" height="16" font="0">well-formedness conditions might be insuﬃcient, in which case we would add any</text>
<text top="970" left="173" width="264" height="16" font="0">necessary constraints on the state.</text>
</page>
<page number="191" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">169</text>
<text top="236" left="447" width="77" height="16" font="0">Chapter 6</text>
<text top="287" left="290" width="393" height="16" font="0">IMPLEMENTING THE ABSTRACTION LAYER</text>
<text top="379" left="173" width="626" height="16" font="0">In this chapter we describe the implementation of the abstraction layer. We focus</text>
<text top="412" left="173" width="626" height="16" font="0">on the essential implementation techniques, rather than providing an exhaustive</text>
<text top="444" left="173" width="626" height="16" font="0">catalog of every function and its implementation. Sections 6.1 and Section 6.2</text>
<text top="477" left="173" width="626" height="16" font="0">describe our implementation of H using a monad with ﬁne-grained type constraints</text>
<text top="509" left="173" width="626" height="16" font="0">captured by type classes. Section 6.3 explains the bootstrapping code in H and the</text>
<text top="542" left="173" width="626" height="16" font="0">techniques that are used for communicating hardware conﬁguration information to</text>
<text top="574" left="173" width="626" height="16" font="0">the client kernel. Section 6.4 discusses our approach to managing page-tables and</text>
<text top="607" left="173" width="626" height="16" font="0">page-directories. Section 6.5 describes the implementation of the techniques for</text>
<text top="639" left="173" width="626" height="16" font="0">enforcing memory-safety. Section 6.6 presents the implementation of the function</text>
<text top="672" left="173" width="626" height="16" font="0">that adds user-space mappings. Section 6.7 explains our implementation of kernel-</text>
<text top="704" left="173" width="626" height="16" font="0">space mappings. Finally, Section 6.8 explains our mechanism for executing user</text>
<text top="737" left="173" width="179" height="16" font="0">programs from Haskell.</text>
<text top="798" left="173" width="26" height="16" font="0">6.1</text>
<text top="798" left="219" width="580" height="16" font="0">SAFELY ENCAPSULATING THE ABSTRACTION LAYER OP-</text>
<text top="833" left="219" width="106" height="16" font="0">ERATIONS</text>
<text top="883" left="173" width="626" height="16" font="0">We implement the H interface as a monad that supports precisely those operations</text>
<text top="916" left="173" width="626" height="16" font="0">that we described in the abstraction layer design in Chapter 4. This monad, called</text>
<text top="948" left="173" width="626" height="16" font="0">H, replaces the IO monad as the base monad in an H-based system. Under the</text>
<text top="981" left="173" width="626" height="16" font="0">hood, we implement the H monad using the facilities of the IO monad, but the</text>
<text top="1013" left="173" width="626" height="16" font="0">underlying implementation is not observable to the client kernel. Clients of the H</text>
<text top="1046" left="173" width="626" height="16" font="0">interface cannot access any eﬀectful operations that are not explicitly exported by</text>
</page>
<page number="192" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">170</text>
<text top="163" left="173" width="626" height="16" font="0">the H monad. All of the unsafe functionality from the IO monad is inaccessible</text>
<text top="195" left="173" width="626" height="16" font="0">because of the static scoping mechanisms available through the Haskell module</text>
<text top="228" left="173" width="317" height="16" font="0">system. Figure 6.1 illustrates this design.</text>
<text top="455" left="460" width="53" height="13" font="2">IO monad</text>
<text top="402" left="463" width="49" height="13" font="2">H monad</text>
<text top="314" left="473" width="28" height="13" font="2">client</text>
<text top="329" left="471" width="33" height="13" font="2">kernel</text>
<text top="530" left="243" width="486" height="16" font="0">Figure 6.1: The H monad interface. Though we implement the</text>
<text top="565" left="243" width="486" height="16" font="0">H monad using the potentially unsafe features of the IO monad,</text>
<text top="600" left="243" width="486" height="16" font="0">the Haskell compiler ensures that client kernels only access the</text>
<text top="634" left="243" width="161" height="16" font="0">H monad operations.</text>
<text top="693" left="199" width="600" height="16" font="0">The H monad is essentially a wrapper for the IO monad representation. Be-</text>
<text top="725" left="173" width="626" height="16" font="0">cause the representation is hidden, we can also store private local state needed by</text>
<text top="758" left="173" width="626" height="16" font="0">the H implementation without being concerned that the state will be corrupted</text>
<text top="790" left="173" width="626" height="16" font="0">by a client kernel. The local state could be anything that we ﬁnd useful in the</text>
<text top="823" left="173" width="626" height="16" font="0">implementation of H; for example, we introduce a single state component for track-</text>
<text top="855" left="173" width="626" height="16" font="0">ing the virtual addresses where page-tables and page-directories are mapped (these</text>
<text top="888" left="173" width="626" height="16" font="0">mappings allow H to read and write page-tables/directories without page faulting).</text>
<text top="920" left="199" width="600" height="16" font="0">We track the virtual address mappings for page-tables and page-directories us-</text>
<text top="953" left="173" width="626" height="16" font="0">ing the Haskell library type for dictionaries called Map (deﬁned in the standard</text>
<text top="985" left="173" width="626" height="16" font="0">library Data.Map). The HMap dictionary maps physical addresses to virtual ad-</text>
<text top="1018" left="173" width="626" height="16" font="0">dresses. The physical addresses represent the physical locations of page-tables or</text>
</page>
<page number="193" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">171</text>
<text top="163" left="173" width="626" height="16" font="0">page-directories that we would like to access in the implementation of H. The vir-</text>
<text top="195" left="173" width="626" height="16" font="0">tual addresses correspond to locations in kernel-space through which H can access</text>
<text top="228" left="173" width="626" height="16" font="0">the speciﬁed physical page without faulting. We assume that the arbitrary physi-</text>
<text top="260" left="173" width="626" height="16" font="0">cal and virtual addresses permitted by the HMap type are aligned to the page-size</text>
<text top="293" left="173" width="626" height="16" font="0">on the machine. A physical page that is not in the dictionary cannot be accessed</text>
<text top="325" left="173" width="42" height="16" font="0">by H.</text>
<text top="369" left="190" width="395" height="14" font="7">type HMap = Map (Addr Physical) (Addr Virtual)</text>
<text top="414" left="173" width="626" height="16" font="0">Section 6.4 will cover more details about this mechanism for physical memory</text>
<text top="447" left="173" width="90" height="16" font="0">access in H.</text>
<text top="479" left="199" width="600" height="16" font="0">We incorporate our dictionary into the H monad using a state monad trans-</text>
<text top="512" left="173" width="626" height="16" font="0">former with the IO monad as the base. We deﬁne H as a newtype with a hidden</text>
<text top="544" left="173" width="602" height="16" font="0">constructor so that the client cannot observe the representation of the monad.</text>
<text top="588" left="190" width="335" height="14" font="7">newtype H a = H { unH :: ST HMap IO a }</text>
<text top="635" left="173" width="626" height="15" font="0">unH extracts the underlying computation from inside the H monad constructor. We</text>
<text top="666" left="173" width="626" height="16" font="0">use unH as a convenience within the implementation of the monad; this function</text>
<text top="698" left="173" width="228" height="16" font="0">is also hidden from the client.</text>
<text top="731" left="199" width="600" height="16" font="0">Within the deﬁnition of our H primitives, we use the liftIO operation to embed</text>
<text top="763" left="173" width="626" height="16" font="0">computations from the IO monad into the H monad. This is necessary because</text>
<text top="796" left="173" width="626" height="16" font="0">many of the low-level services that H uses to provide operating system support, for</text>
<text top="828" left="173" width="626" height="16" font="0">example, foreign function calls, must run in the IO monad. For monads constructed</text>
<text top="861" left="173" width="626" height="16" font="0">with a monad transformer, a value from the underlying monad can be turned into</text>
<text top="893" left="173" width="626" height="16" font="0">a value of the transformed type (in this case, H) using a function called lift, as</text>
<text top="926" left="173" width="262" height="16" font="0">shown in the deﬁnition of liftIO.</text>
<text top="969" left="190" width="180" height="14" font="7">liftIO :: IO a -&gt; H a</text>
<text top="996" left="190" width="180" height="14" font="7">liftIO m = H (lift m)</text>
<text top="1041" left="173" width="626" height="16" font="0">It is crucial that the client cannot access liftIO: this function converts any IO</text>
</page>
<page number="194" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">172</text>
<text top="163" left="173" width="626" height="16" font="0">operation into an H operation and would eliminate our ability to distinguish po-</text>
<text top="195" left="173" width="626" height="16" font="0">tentially unsafe computations from safe ones if used improperly. We rely on the</text>
<text top="228" left="173" width="555" height="16" font="0">module system, covered in Chapter 3.5, to restrict calls to this function.</text>
<text top="260" left="199" width="600" height="16" font="0">The only operation available to the client is the run operation that executes a</text>
<text top="293" left="173" width="626" height="16" font="0">computation of type H and produces a result of type IO. We must include such</text>
<text top="325" left="173" width="626" height="16" font="0">a function because we cannot change the type of the main function required by</text>
<text top="358" left="173" width="626" height="16" font="0">Haskell: the client kernel must contain a top-level function called main of type</text>
<text top="392" left="173" width="626" height="15" font="0">IO (). We intend for the client to invoke runH only once in the main function to</text>
<text top="423" left="173" width="626" height="16" font="0">produce a type-correct program. The client could produce unsafe code by running</text>
<text top="455" left="173" width="626" height="16" font="0">the safe H component of their program interspersed with unsafe IO operations, but</text>
<text top="488" left="173" width="626" height="16" font="0">the violation of the intended H model would be obvious from inspecting the code.</text>
<text top="525" left="190" width="163" height="14" font="7">runH :: H a -&gt; IO a</text>
<text top="552" left="190" width="369" height="14" font="7">runH (H m) = do (x,_) &lt;- (unST m) Map.empty</text>
<text top="578" left="327" width="69" height="14" font="7">return x</text>
<text top="616" left="173" width="626" height="16" font="0">We run an H computation by supplying the state-monad run function with an</text>
<text top="649" left="173" width="483" height="16" font="0">initial value (an empty memory map) for the state component.</text>
<text top="709" left="173" width="26" height="16" font="0">6.2</text>
<text top="709" left="219" width="569" height="16" font="0">TYPE CLASSES FOR FINE-GRAINED EFFECT TRACKING</text>
<text top="760" left="173" width="626" height="16" font="0">The H monad allows a client kernel to access the abstraction layer operations in a</text>
<text top="792" left="173" width="626" height="16" font="0">tightly controlled, safe way. The type alone tells us which side-eﬀects a function</text>
<text top="825" left="173" width="626" height="16" font="0">might perform: a monadic type H a signals that a function may perform any</text>
<text top="857" left="173" width="626" height="16" font="0">side eﬀect deﬁned by the H monad while a non-monadic type guarantees that the</text>
<text top="890" left="173" width="626" height="16" font="0">function is side eﬀect free. Expressing this kind of explicit eﬀect tracking using</text>
<text top="922" left="173" width="626" height="16" font="0">types is one of the beneﬁts to writing our kernel in Haskell, but the granularity of</text>
<text top="955" left="173" width="626" height="16" font="0">the eﬀect tracking is still fairly coarse because of the diversity of eﬀects available</text>
<text top="987" left="173" width="626" height="16" font="0">through H. Most functions that run on top of H will only require a subset of the H</text>
<text top="1020" left="173" width="626" height="16" font="0">monad’s functionality, but a type of the form H a does not allow us to distinguish</text>
<text top="1052" left="173" width="430" height="16" font="0">which of H’s operations a particular function might use.</text>
</page>
<page number="195" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">173</text>
<text top="163" left="199" width="600" height="16" font="0">In Chapter 3 we demonstrated how type classes allow us to express predicates</text>
<text top="195" left="173" width="626" height="16" font="0">on Haskell types. In particular, we can deﬁne predicates on monadic types that</text>
<text top="228" left="173" width="626" height="16" font="0">capture dependencies on speciﬁc monadic operators. For example, a timer inter-</text>
<text top="260" left="173" width="626" height="16" font="0">rupt handler that has no arguments and only accesses the port I/O functionality</text>
<text top="293" left="173" width="265" height="16" font="0">of H can be written with the type:</text>
<text top="336" left="190" width="292" height="14" font="7">timerInterrupt :: (Port m) =&gt; m ()</text>
<text top="380" left="173" width="626" height="16" font="0">The Port m constraint indicates that timerInterrupt depends on the functional-</text>
<text top="413" left="173" width="626" height="16" font="0">ity deﬁned in the Port class. The deﬁnition of Port includes all of the H functions</text>
<text top="445" left="173" width="626" height="16" font="0">for accessing I/O ports. We know from the type alone that timerInterrupt will</text>
<text top="478" left="173" width="626" height="16" font="0">not access any of the H operations that are not described in the Port class—the</text>
<text top="510" left="173" width="626" height="16" font="0">type is a static guarantee that timerInterrupt does not modify any user map-</text>
<text top="543" left="173" width="626" height="16" font="0">pings, delete any page-directories, or execute any user programs (which would be</text>
<text top="575" left="173" width="508" height="16" font="0">rather surprising behavior for a timer interrupt handler, after all).</text>
<text top="608" left="199" width="600" height="16" font="0">The client may use these classes in isolation to deﬁne functions with precise</text>
<text top="640" left="173" width="626" height="16" font="0">types or in combination to create functions that access a variety of the eﬀects</text>
<text top="673" left="173" width="626" height="16" font="0">available through H. The timerInterrupt function is an example of the former</text>
<text top="705" left="173" width="626" height="16" font="0">case. In contrast, consider the function for creating a new thread from our L4</text>
<text top="738" left="173" width="626" height="16" font="0">kernel: this function allocates a fault context for the new thread and might allocate</text>
<text top="770" left="173" width="626" height="16" font="0">a new page-directory (if we are creating the thread in a new address-space). If the</text>
<text top="803" left="173" width="626" height="16" font="0">thread is being created in a new address-space, the function must also set up some</text>
<text top="835" left="173" width="626" height="16" font="0">initial user-space mappings in the new page-directory. Using the predicates deﬁned</text>
<text top="868" left="173" width="423" height="16" font="0">in Table 6.1, we give createThread the following type:</text>
<text top="911" left="190" width="524" height="14" font="7">createThread :: (Execution m, UserMemory m, Paging m) =&gt; m ()</text>
<text top="955" left="173" width="626" height="16" font="0">Decomposing the H monad into ﬁne-grained classes allows us to give more reﬁned</text>
<text top="987" left="173" width="626" height="16" font="0">types to the functions of the client kernel, strengthens our compiler-checked docu-</text>
<text top="1020" left="173" width="626" height="16" font="0">mentation, and has the potential to make veriﬁcation easier. The set of behaviors</text>
<text top="1052" left="173" width="626" height="16" font="0">that are possible in the timerInterrupt function are much more limited than</text>
</page>
<page number="196" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">174</text>
<text top="172" left="206" width="97" height="15" font="7">Class Name</text>
<text top="172" left="328" width="140" height="15" font="7">Class Operations</text>
<text top="172" left="504" width="97" height="15" font="7">Class Name</text>
<text top="172" left="620" width="140" height="15" font="7">Class Operations</text>
<text top="197" left="206" width="52" height="14" font="7">Paging</text>
<text top="197" left="328" width="103" height="14" font="7">allocPageMap</text>
<text top="197" left="504" width="86" height="14" font="7">IRQControl</text>
<text top="197" left="620" width="77" height="14" font="7">enableIRQ</text>
<text top="219" left="328" width="95" height="14" font="7">freePageMap</text>
<text top="219" left="620" width="86" height="14" font="7">disableIRQ</text>
<text top="241" left="328" width="146" height="14" font="7">createPageMapPage</text>
<text top="241" left="620" width="86" height="14" font="7">maskAckIRQ</text>
<text top="264" left="206" width="86" height="14" font="7">UserMemory</text>
<text top="264" left="328" width="86" height="14" font="7">addMapping</text>
<text top="264" left="504" width="77" height="14" font="7">Execution</text>
<text top="264" left="620" width="146" height="14" font="7">allocFaultContext</text>
<text top="287" left="328" width="112" height="14" font="7">modifyMapping</text>
<text top="287" left="620" width="103" height="14" font="7">readRegister</text>
<text top="309" left="328" width="112" height="14" font="7">removeMapping</text>
<text top="309" left="620" width="112" height="14" font="7">writeRegister</text>
<text top="332" left="328" width="95" height="14" font="7">readMapping</text>
<text top="332" left="620" width="60" height="14" font="7">execute</text>
<text top="354" left="206" width="103" height="14" font="7">KernelMemory</text>
<text top="354" left="328" width="137" height="14" font="7">addKernelMapping</text>
<text top="354" left="504" width="60" height="14" font="7">Modules</text>
<text top="354" left="620" width="60" height="14" font="7">modules</text>
<text top="377" left="328" width="146" height="14" font="7">readKernelMapping</text>
<text top="399" left="328" width="155" height="14" font="7">writeKernelMapping</text>
<text top="422" left="328" width="137" height="14" font="7">readWordAtOffset</text>
<text top="444" left="328" width="146" height="14" font="7">writeWordAtOffset</text>
<text top="467" left="206" width="34" height="14" font="7">Port</text>
<text top="467" left="328" width="26" height="14" font="7">inB</text>
<text top="467" left="504" width="43" height="14" font="7">Debug</text>
<text top="467" left="620" width="43" height="14" font="7">putch</text>
<text top="489" left="328" width="26" height="14" font="7">inS</text>
<text top="489" left="620" width="52" height="14" font="7">putstr</text>
<text top="512" left="328" width="26" height="14" font="7">inW</text>
<text top="512" left="620" width="69" height="14" font="7">putstrln</text>
<text top="534" left="328" width="34" height="14" font="7">outB</text>
<text top="556" left="328" width="34" height="14" font="7">outS</text>
<text top="579" left="328" width="34" height="14" font="7">outW</text>
<text top="632" left="173" width="626" height="16" font="0">Table 6.1: The division of the H interface functions into type classes. See Chapter 4</text>
<text top="666" left="173" width="312" height="16" font="0">for the details of each of these functions.</text>
<text top="714" left="173" width="626" height="16" font="0">those in the createThread function, which is useful knowledge for both formal</text>
<text top="747" left="173" width="181" height="16" font="0">and informal reasoning.</text>
<text top="779" left="199" width="600" height="16" font="0">To demonstrate the mechanism for deﬁning type classes on monadic types</text>
<text top="812" left="173" width="626" height="16" font="0">in Haskell, we will examine the deﬁnition of the UserMemory type class and the</text>
<text top="844" left="173" width="626" height="16" font="0">accompanying deﬁnitions that are necessary to use the class in our client kernels</text>
<text top="877" left="173" width="626" height="16" font="0">with H. As shown in Table 6.1, the UserMemory class describes the operations on</text>
<text top="909" left="173" width="626" height="16" font="0">the user-portion of the address-space. It contains four operations: adding a user-</text>
<text top="942" left="173" width="626" height="16" font="0">space mapping; modifying the permissions on a user-space mapping; removing a</text>
<text top="974" left="173" width="418" height="16" font="0">user-space mapping; and reading an existing mapping.</text>
</page>
<page number="197" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">175</text>
<text top="163" left="199" width="600" height="16" font="0">The ﬁrst step in our deﬁnition of UserMemory is to declare the class and the</text>
<text top="195" left="173" width="202" height="16" font="0">functions that it supports.</text>
<text top="239" left="181" width="301" height="14" font="7">class Monad m =&gt; UserMemory m where</text>
<text top="266" left="190" width="86" height="14" font="7">addMapping</text>
<text top="266" left="310" width="378" height="14" font="7">:: [PageMapPage] -&gt; PageMap -&gt; Fpage Virtual</text>
<text top="292" left="353" width="378" height="14" font="7">-&gt; PhysicalRegion -&gt; Perms -&gt; m (Maybe Bool)</text>
<text top="318" left="190" width="515" height="14" font="7">modifyMapping :: PageMap -&gt; Fpage Virtual -&gt; Perms -&gt; m Bool</text>
<text top="345" left="190" width="610" height="14" font="7">removeMapping :: PageMap -&gt; Fpage Virtual -&gt; m (Maybe [PhysicalRegion])</text>
<text top="371" left="190" width="95" height="14" font="7">readMapping</text>
<text top="371" left="310" width="438" height="14" font="7">:: PageMap -&gt; Addr Virtual -&gt; m (Maybe MappingInfo)</text>
<text top="416" left="173" width="626" height="16" font="0">Note that the declaration of UserMemory includes a signature for each of the op-</text>
<text top="449" left="173" width="626" height="16" font="0">erations in the H interface that performs user-space mappings, but replaces each</text>
<text top="481" left="173" width="626" height="16" font="0">use of the H type constructor with a type variable m. Because UserMemory de-</text>
<text top="514" left="173" width="626" height="16" font="0">ﬁnes a predicate on monadic types, we include the constraint Monad m for the type</text>
<text top="546" left="173" width="80" height="16" font="0">variable m.</text>
<text top="579" left="199" width="600" height="16" font="0">We declare two instances of the UserMemory class. The ﬁrst describes how the</text>
<text top="611" left="173" width="626" height="16" font="0">functions of UserMemory are implemented for H, binding the overloaded names</text>
<text top="644" left="173" width="626" height="16" font="0">to the non-overloaded primitives deﬁned by the H interface implementation. The</text>
<text top="676" left="173" width="626" height="16" font="0">name Impl.addMapping refers to the H implementation of the addMapping function</text>
<text top="709" left="173" width="390" height="16" font="0">that is deﬁned in a module called Impl, and so on.</text>
<text top="753" left="181" width="232" height="14" font="7">instance UserMemory H where</text>
<text top="779" left="199" width="86" height="14" font="7">addMapping</text>
<text top="779" left="319" width="146" height="14" font="7">= Impl.addMapping</text>
<text top="806" left="199" width="292" height="14" font="7">modifyMapping = Impl.modifyMapping</text>
<text top="832" left="199" width="292" height="14" font="7">removeMapping = Impl.removeMapping</text>
<text top="858" left="199" width="95" height="14" font="7">readMapping</text>
<text top="858" left="319" width="155" height="14" font="7">= Impl.readMapping</text>
<text top="903" left="173" width="626" height="16" font="0">The second instance is for monads constructed with a monad transformer. This</text>
<text top="936" left="173" width="626" height="16" font="0">allows us to use the functions of UserMemory in transformed versions of the H</text>
<text top="968" left="173" width="626" height="16" font="0">monad, for example, a monad that adds a state component to H using a state-</text>
<text top="1001" left="173" width="152" height="16" font="0">monad transformer.</text>
</page>
<page number="198" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">176</text>
<text top="165" left="181" width="619" height="14" font="7">instance (MonadT t, Monad (t m), UserMemory m) =&gt; UserMemory (t m) where</text>
<text top="192" left="199" width="86" height="14" font="7">addMapping</text>
<text top="192" left="319" width="387" height="14" font="7">sr pm r fp p = lift (addMapping sr pm r fp p)</text>
<text top="218" left="199" width="180" height="14" font="7">modifyMapping pm fp p</text>
<text top="218" left="431" width="258" height="14" font="7">= lift (modifyMapping pm fp p)</text>
<text top="245" left="199" width="163" height="14" font="7">removeMapping pm fp</text>
<text top="245" left="431" width="241" height="14" font="7">= lift (removeMapping pm fp)</text>
<text top="271" left="199" width="95" height="14" font="7">readMapping</text>
<text top="271" left="319" width="43" height="14" font="7">pm va</text>
<text top="271" left="431" width="223" height="14" font="7">= lift (readMapping pm va)</text>
<text top="314" left="173" width="626" height="16" font="0">The deﬁnitions in the transformer instance lift the deﬁnitions of the UserMemory</text>
<text top="346" left="173" width="626" height="16" font="0">functions into the transformed monad. The ability to use the functions of H in</text>
<text top="379" left="173" width="626" height="16" font="0">transformed versions of the monad is important in our case study (Chapter 7),</text>
<text top="411" left="173" width="549" height="16" font="0">where we will incorporate kernel-speciﬁc state-components on top of H.</text>
<text top="444" left="199" width="600" height="16" font="0">The deﬁnitions for the other type classes follow the same pattern. These classes</text>
<text top="476" left="173" width="626" height="16" font="0">are easy to deﬁne and modify, so client kernel developers can create any organi-</text>
<text top="509" left="173" width="626" height="16" font="0">zation of the H operations that turns out to be useful. In our case study, the</text>
<text top="541" left="173" width="626" height="16" font="0">compiler-checked documentation was useful during development and many func-</text>
<text top="574" left="173" width="626" height="16" font="0">tions did end up with very precise types. However, the organization presented here</text>
<text top="606" left="173" width="626" height="16" font="0">did not capture the common patterns of side-eﬀect usage as well as it could, in par-</text>
<text top="639" left="173" width="626" height="16" font="0">ticular, with respect to the Debug class. Adding a simple print statement to track</text>
<text top="671" left="173" width="626" height="16" font="0">down a bug required us to modify the type signature for the problematic function,</text>
<text top="704" left="173" width="626" height="16" font="0">as well as the signatures for all of the calling functions, their calling functions, etc.</text>
<text top="736" left="173" width="626" height="16" font="0">In a future version of the implementation, we would construct the H type classes</text>
<text top="769" left="173" width="626" height="16" font="0">diﬀerently so that debugging facilities are available in all H operations, rather than</text>
<text top="801" left="173" width="626" height="16" font="0">creating a special type class for debug operations. This would reduce the number</text>
<text top="834" left="173" width="441" height="16" font="0">of type signature modiﬁcations needed during debugging.</text>
<text top="895" left="173" width="26" height="16" font="0">6.3</text>
<text top="895" left="219" width="98" height="16" font="0">BOOTING</text>
<text top="945" left="173" width="626" height="16" font="0">The H interface executes with support from a modiﬁed version of the GHC run-</text>
<text top="978" left="173" width="128" height="16" font="0">time system [31]</text>
<text top="976" left="301" width="6" height="11" font="2">1</text>
<text top="978" left="308" width="491" height="16" font="0">. The modiﬁcations allow us to run Haskell programs on bare</text>
<text top="1023" left="193" width="6" height="9" font="3">1</text>
<text top="1026" left="200" width="568" height="13" font="4">The original eﬀort to port the GHC run-time system to bare metal was done by J´</text>
<text top="1026" left="760" width="20" height="13" font="4">er´</text>
<text top="1026" left="773" width="27" height="13" font="4">emy</text>
<text top="1054" left="173" width="94" height="13" font="4">Bobbio and S´</text>
<text top="1054" left="260" width="539" height="13" font="4">ebastian Carlier as part of the hOp project (unfortunately, the project website is no</text>
</page>
<page number="199" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">177</text>
<text top="163" left="173" width="626" height="16" font="0">metal by removing GHC’s dependencies on an underlying operating system. The</text>
<text top="195" left="173" width="626" height="16" font="0">fundamental services provided by the run-time system, such as garbage collection</text>
<text top="228" left="173" width="626" height="16" font="0">and program execution, are not aﬀected, but some of GHC’s higher-level library</text>
<text top="260" left="173" width="221" height="16" font="0">features need to be removed.</text>
<text top="293" left="199" width="600" height="16" font="0">Even though the run-time system is designed to run on bare metal, certain</text>
<text top="325" left="173" width="626" height="16" font="0">facilities must be in place before Haskell code can start executing. For example,</text>
<text top="358" left="173" width="626" height="16" font="0">we must explicitly set aside memory for the Haskell heap because there is not</text>
<text top="390" left="173" width="626" height="16" font="0">an underlying operating system to provide memory to GHC on demand. In this</text>
<text top="423" left="173" width="626" height="16" font="0">section, we present the bootstrapping tools that help us to reserve memory for</text>
<text top="455" left="173" width="626" height="16" font="0">the run-time system, H, and the client kernel, as well as the mechanisms through</text>
<text top="488" left="173" width="626" height="16" font="0">which we communicate conﬁguration information safely from the start-up code to</text>
<text top="520" left="173" width="128" height="16" font="0">the client kernel.</text>
<text top="553" left="199" width="600" height="16" font="0">The primary function of the bootstrapping code is to divide the available phys-</text>
<text top="585" left="173" width="626" height="16" font="0">ical memory between the execution environment and the client kernel. Along the</text>
<text top="618" left="173" width="522" height="16" font="0">way, H performs the following initialization and conﬁguration tasks:</text>
<text top="664" left="199" width="600" height="17" font="0">• Allocate and Initialize Page Status Values: Every page of physical</text>
<text top="698" left="217" width="583" height="16" font="0">memory has an associated status value that H uses to enforce memory-safety</text>
<text top="730" left="217" width="583" height="16" font="0">(as discussed in Section 4.1 and Chapter 5). The bootstrapping code is</text>
<text top="763" left="217" width="583" height="16" font="0">responsible for allocating and initializing the data structure that tracks status</text>
<text top="795" left="217" width="582" height="16" font="0">information throughout the execution of H (see Section 6.5 for details about</text>
<text top="828" left="217" width="299" height="16" font="0">this data structure and its operations).</text>
<text top="874" left="199" width="600" height="17" font="0">• Initialize the Haskell Heap: Our Haskell code cannot run until we provide</text>
<text top="908" left="217" width="583" height="16" font="0">the run-time system with memory for a heap. H selects a portion of the</text>
<text top="956" left="173" width="626" height="13" font="4">longer online). Andrew Tolmach and Thomas Hallgren developed the ﬁrst version of the run-time</text>
<text top="985" left="173" width="626" height="13" font="4">system used in the H interface in conjunction with their work on the House operating system [39].</text>
<text top="1013" left="173" width="626" height="13" font="4">Our current work is based on a version of the run-time system created by Kenneth Graunke [34]</text>
<text top="1042" left="173" width="615" height="13" font="4">using patches to GHC created by Adam Wick for the HaLVM project [40] at Galois, Inc. [28].</text>
</page>
<page number="200" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="13" size="11" family="Times" color="#000000"/>
<text top="111" left="729" width="26" height="16" font="0">178</text>
<text top="347" left="293" width="132" height="17" font="8">custom RTS library</text>
<text top="301" left="284" width="149" height="17" font="8">GHC run-time system</text>
<text top="250" left="275" width="168" height="17" font="8">Haskell H interface code</text>
<text top="199" left="317" width="83" height="17" font="8">client kernel</text>
<text top="327" left="589" width="84" height="17" font="8">C and ASM </text>
<text top="346" left="575" width="113" height="17" font="8">H interface code</text>
<text top="227" left="464" width="145" height="15" font="13">H accesses configuration</text>
<text top="242" left="491" width="92" height="15" font="13">data stored in C</text>
<text top="171" left="486" width="147" height="15" font="13">H starts client by invoking</text>
<text top="187" left="498" width="123" height="15" font="13">Haskell main function</text>
<text top="285" left="474" width="62" height="15" font="13">H provides</text>
<text top="301" left="466" width="79" height="15" font="13">heap memory</text>
<text top="316" left="484" width="43" height="15" font="13">to GHC</text>
<text top="377" left="451" width="65" height="17" font="8">hardware</text>
<text top="434" left="243" width="486" height="16" font="0">Figure 6.2: The low-level architecture of H. A custom run-time</text>
<text top="469" left="243" width="486" height="16" font="0">system library provides GHC with bare metal implementations</text>
<text top="503" left="243" width="486" height="16" font="0">of important system services, such as timers. The C portion of</text>
<text top="538" left="243" width="486" height="16" font="0">H conﬁgures the system and provides the GHC run-time system</text>
<text top="573" left="243" width="281" height="16" font="0">with memory for the Haskell heap.</text>
<text top="573" left="541" width="188" height="16" font="0">Once the bootstrapping</text>
<text top="608" left="243" width="486" height="16" font="0">process is complete, H invokes the main function of the client</text>
<text top="642" left="243" width="338" height="16" font="0">kernel and we begin executing Haskell code.</text>
<text top="699" left="217" width="583" height="16" font="0">available physical memory, registers this memory with the run-time system,</text>
<text top="731" left="217" width="583" height="16" font="0">and updates the status of the pages to reﬂect their new use as protected</text>
<text top="764" left="217" width="148" height="16" font="0">environment pages.</text>
<text top="810" left="199" width="349" height="17" font="0">• Save Module Information From Grub</text>
<text top="809" left="548" width="6" height="11" font="2">2</text>
<text top="811" left="555" width="244" height="16" font="0">: H passes the set of executable</text>
<text top="844" left="217" width="582" height="16" font="0">modules from Grub to the client kernel by constructing safe Haskell wrappers</text>
<text top="876" left="217" width="583" height="16" font="0">of the raw module descriptors (see Section 4.3.2). To enable us to construct</text>
<text top="909" left="217" width="582" height="16" font="0">these wrappers later, the bootstrapping code saves the module descriptors in</text>
<text top="941" left="217" width="446" height="16" font="0">a persistent data structure that is accessible from Haskell.</text>
<text top="987" left="193" width="6" height="9" font="3">2</text>
<text top="989" left="200" width="599" height="13" font="4">Grub is a bootloader package maintained by the GNU Project [37]. It runs before the kernel</text>
<text top="1018" left="173" width="626" height="13" font="4">and passes on important conﬁguration information from the BIOS, and information about data</text>
<text top="1046" left="173" width="570" height="13" font="4">loaded on the machine, such as user programs and the kernel (in the form of modules).</text>
</page>
<page number="201" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">179</text>
<text top="162" left="199" width="600" height="17" font="0">• Conﬁgure Kernel Space Mappings: The bootstrapping code is respon-</text>
<text top="195" left="217" width="583" height="16" font="0">sible for setting up the reference page-directory that we use to guarantee</text>
<text top="228" left="217" width="582" height="16" font="0">a consistent view of kernel-space in all address spaces. We will cover the</text>
<text top="260" left="217" width="464" height="16" font="0">speciﬁc design of the reference page-directory in Section 6.7.</text>
<text top="307" left="199" width="600" height="17" font="0">• Compute the Initial Regions: Any free memory remaining after the rest</text>
<text top="340" left="217" width="583" height="16" font="0">of the initialization tasks is passed on to the client kernel via the primitive</text>
<text top="374" left="217" width="583" height="15" font="0">initialRegions. The bootstrapping code computes the free areas of mem-</text>
<text top="405" left="217" width="583" height="16" font="0">ory and saves a description of these initial regions in a data structure that</text>
<text top="438" left="217" width="256" height="16" font="0">the Haskell code can access later.</text>
<text top="485" left="173" width="626" height="16" font="0">Once all of the conﬁguration and initialization tasks are complete, we can begin</text>
<text top="518" left="173" width="626" height="16" font="0">executing Haskell code. H calls into Haskell by invoking the main function of</text>
<text top="550" left="173" width="626" height="16" font="0">the client kernel. The client kernel begins running and may request conﬁguration</text>
<text top="583" left="173" width="626" height="16" font="0">data from the Haskell H interface, such as the set of initial regions. H handles</text>
<text top="615" left="173" width="626" height="16" font="0">such a request by using the FFI to access the information that we saved in C</text>
<text top="648" left="173" width="626" height="16" font="0">during the bootstrapping process. Figure 6.2 illustrates these components of the</text>
<text top="680" left="173" width="328" height="16" font="0">H architecture and the start-up procedure.</text>
<text top="713" left="199" width="600" height="16" font="0">All of the conﬁguration information computed during start-up is stored in C</text>
<text top="745" left="173" width="52" height="16" font="0">arrays.</text>
<text top="745" left="241" width="559" height="16" font="0">The Haskell code processes this raw description of the data to create</text>
<text top="778" left="173" width="626" height="16" font="0">Haskell data structures that H safely exports to the client. As an example of</text>
<text top="810" left="173" width="626" height="16" font="0">this technique, let us consider the implementation of the modules function, which</text>
<text top="843" left="173" width="626" height="16" font="0">returns the set of executable modules loaded by Grub (see Section 4.3.2 for more</text>
<text top="875" left="173" width="321" height="16" font="0">information about the modules function).</text>
<text top="908" left="199" width="600" height="16" font="0">The boot-time information about modules comes from a bootloader by Mark P.</text>
<text top="940" left="173" width="626" height="16" font="0">Jones, called mimg, that runs after Grub and before the kernel initialization code.</text>
<text top="973" left="173" width="626" height="16" font="0">When mimg runs, it generates headers that describe the layout of physical memory,</text>
<text top="1005" left="173" width="626" height="16" font="0">which the kernel initialization code parses to create the module structures. Each</text>
<text top="1038" left="173" width="408" height="16" font="0">header is three words long with the following format:</text>
</page>
<page number="202" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">180</text>
<text top="168" left="235" width="152" height="16" font="0">address of ﬁrst byte</text>
<text top="168" left="411" width="149" height="16" font="0">address of last byte</text>
<text top="168" left="618" width="86" height="16" font="0">entry point</text>
<text top="214" left="173" width="626" height="16" font="0">The ﬁrst word contains the start address of the region being described, the second</text>
<text top="246" left="173" width="626" height="16" font="0">contains the end address of the region, and the third contains the entry point of the</text>
<text top="279" left="173" width="626" height="16" font="0">module (if it is executable). An entry point of 0xFFFFFFFF signals that module</text>
<text top="311" left="173" width="626" height="16" font="0">is not executable. We access the array of headers by creating a pointer to the array</text>
<text top="344" left="173" width="110" height="16" font="0">using the FFI.</text>
<text top="388" left="173" width="387" height="14" font="7">foreign import ccall unsafe &#34;memory.h &amp; hdrs&#34;</text>
<text top="414" left="190" width="215" height="14" font="7">c_hdrs :: Ptr (Ptr HWord)</text>
<text top="459" left="173" width="626" height="16" font="0">The foreign keyword signals that we are creating a foreign function that we will</text>
<text top="493" left="173" width="626" height="15" font="0">import from C (a ccall). The portion of the declaration that is in quotes describes</text>
<text top="524" left="173" width="626" height="16" font="0">the location and name of the C variable or function being accessed. In the example,</text>
<text top="557" left="173" width="626" height="16" font="0">the declaration imports the C variable hdrs with the Haskell name c_hdrs. The</text>
<text top="589" left="173" width="626" height="16" font="0">keyword unsafe signals to the compiler that an imported function does not call</text>
<text top="622" left="173" width="445" height="16" font="0">any Haskell functions (which requires extra bookkeeping).</text>
<text top="654" left="199" width="600" height="16" font="0">Within the header array, the ﬁrst element of the array contains the number</text>
<text top="687" left="173" width="626" height="16" font="0">of entries. The remaining entries follow the previously described header format.</text>
<text top="719" left="173" width="626" height="16" font="0">We assume that the ﬁrst header describing an executable module refers to the</text>
<text top="752" left="173" width="626" height="16" font="0">kernel. All other executable modules from the headers array will be exported to</text>
<text top="784" left="173" width="626" height="16" font="0">the client kernel by modules. The compile-time conﬁguration of the system must</text>
<text top="817" left="173" width="626" height="16" font="0">ensure that the ordering invariant holds, because exporting the kernel module</text>
<text top="849" left="173" width="445" height="16" font="0">would potentially allow the kernel code to be overwritten.</text>
<text top="882" left="199" width="600" height="16" font="0">The modules function, shown in Figure 6.3, parses the header array and returns</text>
<text top="914" left="173" width="626" height="16" font="0">a list of Module structures. Much of the work done by modules is to split the regions</text>
<text top="947" left="173" width="626" height="16" font="0">described by the array into smaller ﬂexpage-sized regions so that we can export</text>
<text top="979" left="173" width="626" height="16" font="0">the memory area occupied by each module using the PhysicalRegion type (see</text>
<text top="1012" left="173" width="626" height="16" font="0">Section 4.3.2 for a discussion of this design choice). We use a function from the</text>
<text top="1044" left="173" width="626" height="16" font="0">bootstrapping code (written in C) called c_regionToFlexpages to do the splitting.</text>
</page>
<page number="203" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">181</text>
<text top="203" left="182" width="133" height="10" font="2">modules :: H [Module]</text>
<text top="225" left="182" width="57" height="10" font="2">modules =</text>
<text top="248" left="194" width="51" height="10" font="2">liftIO $</text>
<text top="271" left="194" width="152" height="10" font="2">do hdrPtr &lt;- peek c_hdrs</text>
<text top="294" left="214" width="197" height="10" font="2">numHdrs &lt;- peekByteOff hdrPtr 0</text>
<text top="316" left="214" width="152" height="10" font="2">fpPtr &lt;- mallocBytes 160</text>
<text top="339" left="214" width="229" height="10" font="2">ms &lt;- mapM (readModule hdrPtr fpPtr)</text>
<text top="362" left="283" width="76" height="10" font="2">[1..numHdrs]</text>
<text top="384" left="214" width="64" height="10" font="2">free fpPtr</text>
<text top="407" left="214" width="178" height="10" font="2">return (tail (catMaybes ms))</text>
<text top="430" left="182" width="32" height="10" font="2">where</text>
<text top="453" left="194" width="216" height="10" font="2">nextPage e = align (e+(1&lt;&lt;&lt;12)) 12</text>
<text top="475" left="194" width="203" height="10" font="2">createRegion :: Ptr HWord -&gt; Int</text>
<text top="498" left="207" width="127" height="10" font="2">-&gt; IO PhysicalRegion</text>
<text top="521" left="194" width="140" height="10" font="2">createRegion fpPtr i =</text>
<text top="543" left="207" width="197" height="10" font="2">do fpval &lt;- peekByteOff fpPtr i</text>
<text top="566" left="226" width="127" height="10" font="2">let fp = Fpage fpval</text>
<text top="589" left="226" width="191" height="10" font="2">return (PhysicalRegion fp RAM)</text>
<text top="202" left="482" width="273" height="10" font="2">readModule :: Ptr HWord -&gt; Ptr HWord -&gt; Int</text>
<text top="224" left="583" width="127" height="10" font="2">-&gt; IO (Maybe Module)</text>
<text top="247" left="482" width="133" height="10" font="2">readModule hdr fp i =</text>
<text top="270" left="494" width="216" height="10" font="2">do entry &lt;- peekByteOff hdr (12*i)</text>
<text top="293" left="513" width="140" height="10" font="2">if entry /= 0xffffffff</text>
<text top="315" left="532" width="260" height="10" font="2">then do first &lt;- peekByteOff hdr (12*i-8)</text>
<text top="338" left="583" width="203" height="10" font="2">last &lt;- peekByteOff hdr (12*i-4)</text>
<text top="361" left="583" width="210" height="10" font="2">nfps &lt;- c_regionToFlexpages first</text>
<text top="383" left="647" width="152" height="10" font="2">((nextPage last) - 1) fp</text>
<text top="406" left="583" width="178" height="10" font="2">rs &lt;- mapM (createRegion fp)</text>
<text top="429" left="634" width="121" height="10" font="2">[0,4..(4*(nfps-1))]</text>
<text top="452" left="583" width="197" height="10" font="2">return (Just (Module rs entry))</text>
<text top="474" left="532" width="121" height="10" font="2">else return Nothing</text>
<text top="658" left="173" width="626" height="16" font="0">Figure 6.3: The modules function. This function processes the module conﬁgu-</text>
<text top="693" left="173" width="626" height="16" font="0">ration information supplied by the bootstrapping code in C to produce a list of</text>
<text top="728" left="173" width="203" height="16" font="0">Haskell Module structures.</text>
<text top="778" left="190" width="421" height="14" font="7">foreign import ccall &#34;memory.h regionToFlexpages&#34;</text>
<text top="810" left="207" width="515" height="14" font="7">c_regionToFlexpages :: HWord -&gt; HWord -&gt; Ptr HWord -&gt; IO Int</text>
<text top="857" left="173" width="626" height="15" font="0">c_regionToFlexpages takes the start and end address of the region to be broken</text>
<text top="888" left="173" width="626" height="16" font="0">up and returns a corresponding list of ﬂexpages in an array supplied by the caller.</text>
<text top="920" left="173" width="626" height="16" font="0">We allocate this array explicitly from the Haskell heap as temporary storage and</text>
<text top="953" left="173" width="626" height="16" font="0">then process the result to create a list of physical regions occupied by a module.</text>
<text top="985" left="173" width="626" height="16" font="0">For simplicity we allocate enough space to hold the maximum possible ﬂexpages</text>
<text top="1018" left="173" width="626" height="16" font="0">that c_regionToFlexpages could generate. This is a waste of space and could</text>
<text top="1050" left="173" width="626" height="16" font="0">be optimized in future versions, but we only expect modules to be called once</text>
</page>
<page number="204" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">182</text>
<text top="163" left="173" width="626" height="16" font="0">during start-up so the overhead should not be signiﬁcant. The actual parsing of</text>
<text top="195" left="173" width="626" height="16" font="0">the headers array is done using the pointer access functions peek and peekElemOff</text>
<text top="228" left="173" width="308" height="16" font="0">deﬁned in the foreign function interface.</text>
<text top="260" left="199" width="600" height="16" font="0">Initial region information is communicated from C to Haskell to the client using</text>
<text top="293" left="173" width="626" height="16" font="0">essentially the same approach that we use for communicating module data. When</text>
<text top="325" left="173" width="626" height="16" font="0">the bootstrapping code begins executing, an array of header information, passed on</text>
<text top="358" left="173" width="626" height="16" font="0">from mimg, accurately describes the available memory on the machine. Through-</text>
<text top="390" left="173" width="626" height="16" font="0">out the bootstrapping process, we allocate portions of that available memory for</text>
<text top="423" left="173" width="626" height="16" font="0">the Haskell heap and for various conﬁguration data arrays. When we ﬁnally enter</text>
<text top="455" left="173" width="626" height="16" font="0">Haskell, the headers array no longer provides an accurate description of memory</text>
<text top="488" left="173" width="626" height="16" font="0">usage, so the bootstrapping code must save a new description of available memory</text>
<text top="520" left="173" width="626" height="16" font="0">that accounts for all of our allocations. To make the generation of PhysicalRegion</text>
<text top="553" left="173" width="626" height="16" font="0">values easier, the C code stores ﬂexpage-sized regions of memory that the Haskell</text>
<text top="585" left="173" width="626" height="16" font="0">code can use without any additional processing. As before, we import the array</text>
<text top="618" left="173" width="319" height="16" font="0">containing the free regions using the FFI.</text>
<text top="659" left="190" width="481" height="14" font="7">foreign import ccall unsafe &#34;memory.h &amp; initial_regions&#34;</text>
<text top="685" left="207" width="309" height="14" font="7">c_initial_regions :: Ptr (Ptr HWord)</text>
<text top="727" left="173" width="626" height="16" font="0">The start-up code guarantees that this pointer is appropriately initialized before</text>
<text top="760" left="173" width="536" height="16" font="0">we begin executing Haskell code; it is never modiﬁed after that point.</text>
<text top="792" left="199" width="600" height="16" font="0">The implementation of initialRegions (shown in Figure 6.4) turns each ﬂex-</text>
<text top="825" left="173" width="626" height="16" font="0">page in the initial regions array into a PhysicalRegion to export to the client.</text>
<text top="857" left="173" width="626" height="16" font="0">We read the length of the array from the ﬁrst word and map the region construc-</text>
<text top="890" left="173" width="626" height="16" font="0">tion function across the remaining entries. All of these regions are initialized with</text>
<text top="922" left="173" width="626" height="16" font="0">normal RAM as the region type. The memory mapped I/O regions are initialized</text>
<text top="955" left="173" width="626" height="16" font="0">via a diﬀerent mechanism: we explicitly construct each I/O region in Haskell and</text>
<text top="987" left="173" width="626" height="16" font="0">combine the results into a list called ioRegions. We currently only include video</text>
<text top="1020" left="173" width="626" height="16" font="0">RAM in the initial regions, but the set of supported I/O regions is easily extensible</text>
<text top="1052" left="173" width="626" height="16" font="0">(we have already added the support necessary for the VBE frame buﬀer, but this</text>
</page>
<page number="205" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">183</text>
<text top="203" left="188" width="229" height="10" font="2">initialRegions :: H [PhysicalRegion]</text>
<text top="225" left="188" width="368" height="10" font="2">initialRegions = liftIO $ do fps &lt;- peek c_initial_regions</text>
<text top="248" left="373" width="171" height="10" font="2">numfps &lt;- peekByteOff fps 0</text>
<text top="271" left="373" width="267" height="10" font="2">ramrs &lt;- mapM (newR fps) [4,8..(4*numfps)]</text>
<text top="294" left="373" width="25" height="10" font="2">iors</text>
<text top="294" left="411" width="76" height="10" font="2">&lt;- ioRegions</text>
<text top="316" left="373" width="140" height="10" font="2">return (ramrs ++ iors)</text>
<text top="339" left="201" width="32" height="10" font="2">where</text>
<text top="362" left="214" width="286" height="10" font="2">newR :: Ptr HWord -&gt; Int -&gt; IO PhysicalRegion</text>
<text top="384" left="214" width="292" height="10" font="2">newR fpPtr i = do fpval &lt;- peekByteOff fpPtr i</text>
<text top="407" left="328" width="311" height="10" font="2">return (PhysicalRegion (fpageFromWord fpval) RAM)</text>
<text top="477" left="173" width="626" height="16" font="0">Figure 6.4: The initialRegions procedure. The bootstrapping code produces an</text>
<text top="511" left="173" width="626" height="16" font="0">array of ﬂexpages that describe the free memory on the machine that has not been</text>
<text top="546" left="173" width="626" height="16" font="0">claimed for kernel purposes. The initialRegions procedure processes this array</text>
<text top="581" left="173" width="530" height="16" font="0">to create physical region handles that cannot be forged by the client.</text>
<text top="632" left="173" width="626" height="16" font="0">functionality is not thoroughly tested). initialRegions combines the result of</text>
<text top="664" left="173" width="626" height="16" font="0">the region processing for conventional memory with the ioRegions list to produce</text>
<text top="697" left="173" width="276" height="16" font="0">the set of available physical regions.</text>
<text top="759" left="173" width="26" height="16" font="0">6.4</text>
<text top="759" left="219" width="573" height="16" font="0">PRECISE KERNEL CONTROL OVER PAGE-MAP MEMORY</text>
<text top="809" left="173" width="626" height="16" font="0">Client kernels have full control over the memory that H will use to store page-</text>
<text top="841" left="173" width="425" height="16" font="0">tables and page-directories in the H interface design.</text>
<text top="841" left="614" width="185" height="16" font="0">Clients also specify the</text>
<text top="874" left="173" width="626" height="16" font="0">virtual addresses where these pages of memory should be be mapped in kernel-</text>
<text top="906" left="173" width="626" height="16" font="0">space. The H implementation must track all of the physical pages and virtual</text>
<text top="939" left="173" width="626" height="16" font="0">addresses that the client has supplied for the interface to use. Section 6.1 presented</text>
<text top="971" left="173" width="626" height="16" font="0">the mechanism for tracking client-supplied memory in the monad, whereas this</text>
<text top="1004" left="173" width="626" height="16" font="0">section describes the implementation techniques that we employ to allow client</text>
<text top="1036" left="173" width="626" height="16" font="0">control over page-map memory in a way that is memory-safe and that prevents</text>
</page>
<page number="206" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">184</text>
<text top="163" left="173" width="626" height="16" font="0">kernel page faults. We present the routines that help H to enforce safe status</text>
<text top="195" left="173" width="626" height="16" font="0">transitions in the implementation of memory operations and the approach that we</text>
<text top="228" left="173" width="626" height="16" font="0">use to guarantee that H will not page fault during memory management operations,</text>
<text top="260" left="173" width="626" height="16" font="0">even when accessing client-supplied page-tables and page-directories that can only</text>
<text top="293" left="173" width="349" height="16" font="0">be mapped at client-chosen virtual addresses.</text>
<text top="325" left="199" width="600" height="16" font="0">The PageMapPage type introduced in Section 4.4.1 is an abstraction for repre-</text>
<text top="358" left="173" width="626" height="16" font="0">senting either a page-table or page-directory page that the client wishes to donate</text>
<text top="390" left="173" width="626" height="16" font="0">to H. A page-map page contains a page-sized physical region that will be used to</text>
<text top="423" left="173" width="626" height="16" font="0">store the table or directory and a kernel-space virtual-address where the page will</text>
<text top="455" left="173" width="626" height="16" font="0">be mapped. We deﬁne the type in a straightforward fashion using a record with a</text>
<text top="488" left="173" width="193" height="16" font="0">ﬁeld for each component.</text>
<text top="528" left="190" width="275" height="14" font="7">data PageMapPage = PageMapPage {</text>
<text top="555" left="370" width="266" height="14" font="7">physicalPage :: PhysicalRegion,</text>
<text top="581" left="370" width="86" height="14" font="7">mappedAddr</text>
<text top="581" left="482" width="129" height="14" font="7">:: Addr Virtual</text>
<text top="607" left="353" width="9" height="14" font="7">}</text>
<text top="649" left="173" width="626" height="16" font="0">Each PageMapPage must satisfy certain invariants in order for H to safely use the</text>
<text top="681" left="173" width="626" height="16" font="0">page: the physical region component must be a single page of normal RAM and</text>
<text top="714" left="173" width="626" height="16" font="0">the virtual address must be a kernel-space address that is available to the client for</text>
<text top="746" left="173" width="626" height="16" font="0">mapping. The client-accessible function constructing values of the PageMapPage</text>
<text top="779" left="173" width="626" height="16" font="0">type checks that the invariants hold on the physical region virtual address that</text>
<text top="811" left="173" width="449" height="16" font="0">the client is attempting to turn into a page-map page.</text>
<text top="811" left="640" width="159" height="16" font="0">The utility function</text>
<text top="845" left="173" width="626" height="15" font="0">isKernelMappableVirtualAddress tests if a particular address is in the set of</text>
<text top="878" left="173" width="626" height="15" font="0">kernelMappableVirtualAddresses (introduced in Section 4.4.1), and will be pre-</text>
<text top="909" left="173" width="164" height="16" font="0">sented in Section 6.7.</text>
<text top="949" left="190" width="438" height="14" font="7">createPageMapPage :: PhysicalRegion -&gt; Addr Virtual</text>
<text top="975" left="207" width="206" height="14" font="7">-&gt; H (Maybe PageMapPage)</text>
<text top="1002" left="190" width="395" height="14" font="7">createPageMapPage pr@(PhysicalRegion _ RAM) va</text>
<text top="1028" left="207" width="232" height="14" font="7">| regionSize pr == pageBits</text>
<text top="1055" left="224" width="464" height="14" font="7">= do isClientAddr &lt;- isKernelMappableVirtualAddress va</text>
</page>
<page number="207" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">185</text>
<text top="165" left="267" width="464" height="14" font="7">if isClientAddr then return (Just (PageMapPage pr va))</text>
<text top="192" left="405" width="163" height="14" font="7">else return Nothing</text>
<text top="218" left="190" width="326" height="14" font="7">createPageMapPage _ _ = return Nothing</text>
<text top="263" left="173" width="626" height="16" font="0">H will never create a PageMapPage that does not satisfy the invariants and there is</text>
<text top="296" left="173" width="626" height="16" font="0">no other mechanism available to the client for creating values of the PageMapPage</text>
<text top="328" left="173" width="39" height="16" font="0">type.</text>
<text top="361" left="199" width="600" height="16" font="0">Once the client creates a PageMapPage, they can supply that page to any H</text>
<text top="393" left="173" width="626" height="16" font="0">function that might need to allocate a page-directory or page-table. The physical</text>
<text top="426" left="173" width="626" height="16" font="0">page and the virtual address contained in the page-map page remain free until H</text>
<text top="458" left="173" width="626" height="16" font="0">actually needs the memory. At that point, H performs any state-dependent safety</text>
<text top="491" left="173" width="626" height="16" font="0">checks that could not be performed in advance, converts the status of the page to</text>
<text top="523" left="173" width="626" height="16" font="0">the appropriate type (page-table or page-directory, depending on the context in</text>
<text top="556" left="173" width="626" height="16" font="0">which the page is being used), and installs a mapping from the speciﬁed virtual</text>
<text top="588" left="173" width="222" height="16" font="0">address to the physical page.</text>
<text top="621" left="199" width="600" height="16" font="0">The addHMapping function (shown in Figure 6.5) is responsible for adding the</text>
<text top="653" left="173" width="626" height="16" font="0">association between the physical region and the virtual address to the HMap dic-</text>
<text top="686" left="173" width="626" height="16" font="0">tionary. Before updating the dictionary, addHMapping must make sure that the</text>
<text top="718" left="173" width="626" height="16" font="0">virtual address component is not already mapped to a page-table or page-directory</text>
<text top="751" left="173" width="626" height="16" font="0">in the dictionary. After a successful call to addHMapping, the HMap dictionary will</text>
<text top="783" left="173" width="626" height="16" font="0">contain an entry for the page-map page. We do not modify the status of the page</text>
<text top="816" left="173" width="626" height="16" font="0">here; the caller updates the status (and checks the safety of the transition) as</text>
<text top="848" left="173" width="344" height="16" font="0">appropriate for the intended use of the page.</text>
<text top="881" left="199" width="600" height="16" font="0">Installation of the virtual-to-physical mapping where H can read and write</text>
<text top="913" left="173" width="626" height="16" font="0">the page-map page is handled by the utility installPageMapPage, also shown in</text>
<text top="946" left="173" width="626" height="16" font="0">Figure 6.5. installPageMapPage adds a kernel-space mapping from the virtual</text>
<text top="978" left="173" width="626" height="16" font="0">address contained in the page-map page to the start address of the physical region</text>
<text top="1011" left="173" width="626" height="16" font="0">component. The implementation ensures that the mapping will be visible in every</text>
<text top="1043" left="173" width="626" height="16" font="0">address space. (We will cover the techniques for adding mappings in Sections 6.6</text>
</page>
<page number="208" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">186</text>
<text top="202" left="183" width="229" height="10" font="2">addHMapping :: PageMapPage -&gt; H Bool</text>
<text top="224" left="183" width="210" height="10" font="2">addHMapping (PageMapPage pr va) =</text>
<text top="247" left="195" width="165" height="10" font="2">do inuse &lt;- isMappedToH va</text>
<text top="270" left="214" width="165" height="10" font="2">if inuse then return False</text>
<text top="293" left="233" width="203" height="10" font="2">else do update (\hms -&gt; ins hms)</text>
<text top="315" left="284" width="70" height="10" font="2">return True</text>
<text top="338" left="195" width="32" height="10" font="2">where</text>
<text top="361" left="208" width="140" height="10" font="2">paddr = regionStart pr</text>
<text top="383" left="208" width="19" height="10" font="2">ins</text>
<text top="383" left="246" width="133" height="10" font="2">= Map.insert paddr va</text>
<text top="202" left="445" width="273" height="10" font="2">installPageMapPage :: PageMapPage -&gt; H Bool</text>
<text top="224" left="445" width="152" height="10" font="2">installPageMapPage pmp =</text>
<text top="247" left="458" width="241" height="10" font="2">do vpdir &lt;- systemPageMapMappedAddress</text>
<text top="270" left="477" width="121" height="10" font="2">pt_addr &lt;- liftIO $</text>
<text top="293" left="559" width="203" height="10" font="2">c_find_pt vpdir (mappedAddr pmp)</text>
<text top="315" left="477" width="260" height="10" font="2">if pt_addr == (-1) then return False else</text>
<text top="338" left="496" width="70" height="10" font="2">do liftIO $</text>
<text top="361" left="559" width="229" height="10" font="2">c_add_table_entries vpt vfp ps 0 0x7</text>
<text top="383" left="515" width="70" height="10" font="2">return True</text>
<text top="406" left="458" width="32" height="10" font="2">where</text>
<text top="429" left="470" width="254" height="10" font="2">vpt = fromIntegral pt_addr + kernelSpace</text>
<text top="452" left="470" width="108" height="10" font="2">vfp = fpageToWord</text>
<text top="474" left="521" width="210" height="10" font="2">(fpage (mappedAddr pmp) pageBits)</text>
<text top="497" left="470" width="13" height="10" font="2">ps</text>
<text top="497" left="496" width="203" height="10" font="2">= regionStart (physicalPage pmp)</text>
<text top="566" left="173" width="524" height="16" font="0">Figure 6.5: Utilities for validating and installing a PageMapPage.</text>
<text top="566" left="714" width="85" height="16" font="0">The addH-</text>
<text top="603" left="173" width="626" height="15" font="0">Mapping function adds an entry to the HMap dictionary for a particular page-</text>
<text top="636" left="173" width="580" height="16" font="0">map page after making sure that the virtual address component is free.</text>
<text top="636" left="769" width="30" height="16" font="0">The</text>
<text top="672" left="173" width="626" height="15" font="0">installPageMapPage function adds a mapping in kernel space from the virtual</text>
<text top="705" left="173" width="626" height="16" font="0">address component of a page-map page to the physical page component. The</text>
<text top="740" left="173" width="626" height="16" font="0">address-space manipulations are done with the help of the C functions c find pt</text>
<text top="774" left="173" width="626" height="16" font="0">and c add table entries—these functions will be covered in more depth in Sec-</text>
<text top="809" left="173" width="626" height="16" font="0">tion 6.6. systemPageMapMappedAddress is a pointer to our implementation of the</text>
<text top="844" left="173" width="370" height="16" font="0">reference page-directory presented in Chapter 5.</text>
<text top="895" left="173" width="68" height="16" font="0">and 6.7.)</text>
<text top="928" left="199" width="600" height="16" font="0">As we saw in Chapter 4, H automatically returns the memory for any page-</text>
<text top="960" left="173" width="626" height="16" font="0">tables that become free as the result of a removeMapping operation. Client kernels</text>
<text top="993" left="173" width="626" height="16" font="0">explicitly free page-directories using the freePageMap operation. Before returning</text>
<text top="1025" left="173" width="626" height="16" font="0">one of these pages to the client, H must remove the entry for the page from the</text>
</page>
<page number="209" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">187</text>
<text top="164" left="173" width="626" height="15" font="0">HMap dictionary. As with the utilities for creating a page-map page, the caller is</text>
<text top="195" left="173" width="480" height="16" font="0">responsible for updating the status of the page as appropriate.</text>
<text top="239" left="190" width="335" height="14" font="7">removeHMapping :: Addr Physical -&gt; H ()</text>
<text top="266" left="190" width="223" height="14" font="7">removeHMapping pa = update</text>
<text top="292" left="207" width="301" height="14" font="7">(\(hms::HMap) -&gt; Map.delete pa hms)</text>
<text top="337" left="173" width="626" height="16" font="0">The implementation of removeHMapping uses the state-monad function update</text>
<text top="370" left="173" width="626" height="16" font="0">(which applies a given function to the state) in conjunction with the library func-</text>
<text top="402" left="173" width="369" height="16" font="0">tion Map.delete to modify the HMap dictionary.</text>
<text top="435" left="199" width="600" height="16" font="0">Allowing the client to control the physical and virtual memory that H uses for</text>
<text top="467" left="173" width="626" height="16" font="0">page-tables and directories guarantees that we always reserve precisely the right</text>
<text top="500" left="173" width="626" height="16" font="0">amount of memory for page-map storage. If we did not allow the client to control</text>
<text top="532" left="173" width="626" height="16" font="0">page-map pages in this way, then H would need to designate areas of memory</text>
<text top="565" left="173" width="626" height="16" font="0">statically for page-map storage. Undoubtedly the static solution would lead to an</text>
<text top="597" left="173" width="626" height="16" font="0">underutilization of resources or a premature exhaustion of the memory pool (even</text>
<text top="630" left="173" width="626" height="16" font="0">if there were free pages/addresses available in the client kernel). Instead, with</text>
<text top="662" left="173" width="626" height="16" font="0">our dynamic approach, H must do some extra tracking and dynamic checking to</text>
<text top="695" left="173" width="626" height="16" font="0">ensure that the memory-safety invariants of the system are never violated and that</text>
<text top="727" left="173" width="626" height="16" font="0">H does not page fault. However, we improve memory utilization and allow clients</text>
<text top="760" left="173" width="520" height="16" font="0">greater ﬂexibility to deﬁne their own memory management policies.</text>
<text top="821" left="173" width="26" height="16" font="0">6.5</text>
<text top="821" left="219" width="480" height="16" font="0">ENFORCING SAFE PAGE STATUS TRANSITIONS</text>
<text top="872" left="173" width="626" height="16" font="0">As we saw in Section 4.1, each page of physical memory has a dynamic status</text>
<text top="904" left="173" width="626" height="16" font="0">that reﬂects its current usage in the system. We identiﬁed four types of physical</text>
<text top="937" left="173" width="626" height="16" font="0">memory—page-directory pages, page-table pages, normal pages, and environment</text>
<text top="969" left="173" width="626" height="16" font="0">pages—and deﬁned a limited set of transitions between these page types. Run-time</text>
<text top="1002" left="173" width="626" height="16" font="0">checking of every transition is a fundamental part of our memory-safety enforce-</text>
<text top="1034" left="173" width="626" height="16" font="0">ment mechanism. Every H operation must satisfy the speciﬁcation described in</text>
</page>
<page number="210" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">188</text>
<text top="163" left="173" width="626" height="16" font="0">Section 5.7, and, more generally, the high-level memory-safety property introduced</text>
<text top="195" left="173" width="626" height="16" font="0">in Chapter 5. In this section, we will examine the implementation of page status</text>
<text top="228" left="173" width="626" height="16" font="0">tracking in H and the utilities that H uses to validate status transitions during</text>
<text top="260" left="173" width="78" height="16" font="0">execution.</text>
<text top="293" left="199" width="600" height="16" font="0">We represent dynamic status values in the interface using a Haskell datatype.</text>
<text top="325" left="173" width="626" height="16" font="0">The datatype has four constructors—Protected, Reserved, PageMapHandle, and</text>
<text top="359" left="173" width="630" height="15" font="0">Mapped—that correspond directly to the four roles for memory—environment pages,</text>
<text top="390" left="173" width="553" height="16" font="0">page-table pages, page-directory pages, and normal pages—respectively.</text>
<text top="428" left="190" width="558" height="14" font="7">data Status = Protected | Reserved | PageMapHandle | Mapped HWord</text>
<text top="467" left="173" width="626" height="16" font="0">The Mapped constructor takes a single argument that serves as a reference count</text>
<text top="500" left="173" width="626" height="16" font="0">for the number of times that a particular page is currently mapped. Reference</text>
<text top="532" left="173" width="626" height="16" font="0">counting is an important part of our mechanism for ensuring that user processes</text>
<text top="565" left="173" width="626" height="16" font="0">are never able to access memory when it is in use by the kernel for paging structures</text>
<text top="597" left="173" width="106" height="16" font="0">or other data.</text>
<text top="630" left="199" width="600" height="16" font="0">We track page status values in an array that maps each page of physical memory</text>
<text top="662" left="173" width="626" height="16" font="0">to an integer status value. We deﬁne the array in C and create a Haskell interface</text>
<text top="695" left="173" width="626" height="16" font="0">to the standard operations on the array. We use a C array so that we can easily</text>
<text top="727" left="173" width="626" height="16" font="0">initialize the status array in the start-up code for H: the start-up code conﬁgures</text>
<text top="760" left="173" width="626" height="16" font="0">the environment and set of available pages, and initializing the status values during</text>
<text top="792" left="173" width="626" height="16" font="0">boot prevents us from having to package this information up to pass to Haskell.</text>
<text top="825" left="173" width="626" height="16" font="0">Each integer status value maps to a value of the Status type that we deﬁned in</text>
<text top="857" left="173" width="626" height="16" font="0">Section 4.1: −1 corresponds to a Protected environment page, −2 corresponds to</text>
<text top="890" left="173" width="626" height="16" font="0">a Reserved page-table page, −3 corresponds to a PageMapHandle page-directory</text>
<text top="922" left="173" width="626" height="16" font="0">page, and any number greater than or equal to 0 corresponds to a Mappable normal</text>
<text top="955" left="173" width="626" height="16" font="0">page. For normal pages, the status value also captures a reference counter, that</text>
<text top="987" left="173" width="469" height="16" font="0">is, the number of places where the page is currently mapped.</text>
<text top="1020" left="199" width="600" height="16" font="0">The interface to the status array contains three functions that we lift into</text>
<text top="1052" left="173" width="626" height="16" font="0">Haskell using the foreign function interface: an operation for reading the status</text>
</page>
<page number="211" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">189</text>
<text top="163" left="173" width="626" height="16" font="0">of a page, an operation for modifying the status of a page, and an operation for</text>
<text top="195" left="173" width="626" height="16" font="0">modifying the status of many pages. For the single-page functions, the argument</text>
<text top="228" left="173" width="626" height="16" font="0">of type HWord is the address of the page whose status is being accessed; for the</text>
<text top="260" left="173" width="626" height="16" font="0">region update function the arguments of type HWord are the addresses of the start</text>
<text top="293" left="173" width="169" height="16" font="0">and end of the region.</text>
<text top="337" left="190" width="395" height="14" font="7">foreign import ccall &#34;memory.h readPageStatus&#34;</text>
<text top="363" left="207" width="301" height="14" font="7">c_readPageStatus :: HWord -&gt; IO Int</text>
<text top="416" left="190" width="412" height="14" font="7">foreign import ccall &#34;memory.h updatePageStatus&#34;</text>
<text top="442" left="207" width="369" height="14" font="7">c_updatePageStatus :: HWord -&gt; Int -&gt; IO ()</text>
<text top="495" left="190" width="430" height="14" font="7">foreign import ccall &#34;memory.h updateRegionStatus&#34;</text>
<text top="522" left="207" width="464" height="14" font="7">c_updateRegionStatus :: HWord -&gt; HWord -&gt; Int -&gt; IO ()</text>
<text top="567" left="173" width="626" height="16" font="0">These functions do not perform any checking or validation; they rely on the calling</text>
<text top="599" left="173" width="626" height="16" font="0">function to validate any transition being requested before modifying the array.</text>
<text top="632" left="173" width="626" height="16" font="0">Throughout the implementation of H, we will update status values using wrapper</text>
<text top="664" left="173" width="626" height="16" font="0">functions that lift the behavior of these basic primitives into the H monad and</text>
<text top="697" left="173" width="535" height="16" font="0">check to make sure that the status transition being performed is safe.</text>
<text top="729" left="199" width="600" height="16" font="0">Reading the status array does not introduce any safety issues, so the wrapper</text>
<text top="762" left="173" width="626" height="16" font="0">function is very simple. We read the integer status value from the array and</text>
<text top="794" left="173" width="626" height="16" font="0">convert this number into a Status value with the toEnum function. We deﬁne</text>
<text top="827" left="173" width="626" height="16" font="0">a custom instance of the Enum class—which describes operations for converting</text>
<text top="859" left="173" width="626" height="16" font="0">between integers and datatypes, including the conversion functions toEnum and</text>
<text top="893" left="173" width="626" height="15" font="0">fromEnum—for the Status type using the previously described mappings between</text>
<text top="924" left="173" width="322" height="16" font="0">integers and the constructors of this type.</text>
<text top="968" left="190" width="369" height="14" font="7">readPageStatus :: Addr Physical -&gt; H Status</text>
<text top="994" left="190" width="163" height="14" font="7">readPageStatus page</text>
<text top="1021" left="207" width="387" height="14" font="7">= do status &lt;- liftIO $ c_readPageStatus page</text>
<text top="1047" left="250" width="189" height="14" font="7">return (toEnum status)</text>
</page>
<page number="212" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">190</text>
<text top="163" left="173" width="626" height="16" font="0">We assume that the status array never contains an invalid number—we rely on</text>
<text top="195" left="173" width="626" height="16" font="0">the correctness of the initialization code and the status array update functions to</text>
<text top="228" left="173" width="163" height="16" font="0">enforce this property.</text>
<text top="260" left="199" width="600" height="16" font="0">Correctly managing the status array is crucial from a memory-safety perspec-</text>
<text top="293" left="173" width="626" height="16" font="0">tive. If we allow an invalid transition to occur by writing an invalid value into</text>
<text top="325" left="173" width="626" height="16" font="0">the array, the system loses the ability to protect the integrity of environment and</text>
<text top="358" left="173" width="626" height="16" font="0">page-map pages. We deﬁne the predicate checkTransition to validate a possible</text>
<text top="390" left="173" width="626" height="16" font="0">page status transition before we actually update the status array. This predicate</text>
<text top="423" left="173" width="626" height="16" font="0">reads the current status of a speciﬁed page and checks whether or not the pro-</text>
<text top="455" left="173" width="626" height="16" font="0">posed new status represents a valid transition. checkTransition is false when we</text>
<text top="488" left="173" width="626" height="16" font="0">attempt to modify the status of an environment page or convert a normal page</text>
<text top="520" left="173" width="466" height="16" font="0">that is mapped to a user into a page-table or page-directory.</text>
<text top="564" left="190" width="447" height="14" font="7">checkTransition :: Status -&gt; Addr Physical -&gt; H Bool</text>
<text top="591" left="190" width="189" height="14" font="7">checkTransition new pa</text>
<text top="617" left="207" width="344" height="14" font="7">= do old &lt;- liftIO $ c_readPageStatus pa</text>
<text top="644" left="250" width="215" height="14" font="7">case (toEnum old, new) of</text>
<text top="670" left="267" width="120" height="14" font="7">(Protected, _)</text>
<text top="670" left="568" width="129" height="14" font="7">-&gt; return False</text>
<text top="696" left="267" width="120" height="14" font="7">(_, Protected)</text>
<text top="696" left="568" width="129" height="14" font="7">-&gt; return False</text>
<text top="723" left="267" width="172" height="14" font="7">(Mapped 0, Reserved)</text>
<text top="723" left="568" width="120" height="14" font="7">-&gt; return True</text>
<text top="749" left="267" width="26" height="14" font="7">(_,</text>
<text top="749" left="362" width="77" height="14" font="7">Reserved)</text>
<text top="749" left="568" width="129" height="14" font="7">-&gt; return False</text>
<text top="776" left="267" width="215" height="14" font="7">(Mapped 0, PageMapHandle)</text>
<text top="776" left="568" width="120" height="14" font="7">-&gt; return True</text>
<text top="802" left="267" width="26" height="14" font="7">(_,</text>
<text top="802" left="362" width="120" height="14" font="7">PageMapHandle)</text>
<text top="802" left="568" width="129" height="14" font="7">-&gt; return False</text>
<text top="828" left="267" width="52" height="14" font="7">(_, _)</text>
<text top="828" left="568" width="120" height="14" font="7">-&gt; return True</text>
<text top="873" left="173" width="626" height="16" font="0">If checkTransition returns True, then we know that updating the status array</text>
<text top="906" left="173" width="281" height="16" font="0">with the proposed value will be safe.</text>
<text top="938" left="199" width="600" height="16" font="0">To modify the status of a single page, we validate the safety of the requested</text>
<text top="971" left="173" width="626" height="16" font="0">transition using checkTransition, updating the underlying status only if the tran-</text>
<text top="1003" left="173" width="204" height="16" font="0">sition turns out to be safe.</text>
</page>
<page number="213" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">191</text>
<text top="165" left="190" width="455" height="14" font="7">updatePageStatus :: Addr Physical -&gt; Status -&gt; H Bool</text>
<text top="192" left="190" width="223" height="14" font="7">updatePageStatus pa status</text>
<text top="218" left="207" width="352" height="14" font="7">= do proceed &lt;- checkTransition pa status</text>
<text top="245" left="250" width="86" height="14" font="7">if proceed</text>
<text top="271" left="276" width="455" height="14" font="7">then liftIO $ c_updatePageStatus pa (fromEnum status)</text>
<text top="297" left="276" width="120" height="14" font="7">else return ()</text>
<text top="324" left="250" width="120" height="14" font="7">return proceed</text>
<text top="369" left="173" width="626" height="16" font="0">The result of updatePageStatus indicates whether or not we successfully updated</text>
<text top="401" left="173" width="122" height="16" font="0">the page status.</text>
<text top="434" left="199" width="600" height="16" font="0">To modify the status of an entire region, we must validate the status transitions</text>
<text top="466" left="173" width="626" height="16" font="0">for the pages of the region individually. We again use checkTransition for this</text>
<text top="499" left="173" width="626" height="16" font="0">purpose. A region update may only proceed if all of the status transitions are safe.</text>
<text top="543" left="181" width="601" height="14" font="7">updateRegionStatus :: Addr Physical -&gt; Addr Physical -&gt; Status -&gt; H ()</text>
<text top="569" left="181" width="301" height="14" font="7">updateRegionStatus start end status</text>
<text top="596" left="199" width="395" height="14" font="7">= do proceeds &lt;- mapM (checkTransition status)</text>
<text top="622" left="388" width="241" height="14" font="7">[start, start+pageSize..end]</text>
<text top="648" left="242" width="129" height="14" font="7">if and proceeds</text>
<text top="675" left="267" width="533" height="14" font="7">then liftIO $ c_updateRegionStatus start end (fromEnum status)</text>
<text top="701" left="267" width="120" height="14" font="7">else return ()</text>
<text top="746" left="173" width="626" height="16" font="0">The status update functions are private to the implementation of H, even though</text>
<text top="779" left="173" width="626" height="16" font="0">the update functions only allow safe transitions. H relies on the correctness of</text>
<text top="811" left="173" width="626" height="16" font="0">the status array and the client kernel cannot be permitted to aﬀect H’s internal</text>
<text top="844" left="173" width="81" height="16" font="0">structures.</text>
<text top="876" left="199" width="600" height="16" font="0">In addition to the basic primitives for manipulating status settings, we deﬁne</text>
<text top="909" left="173" width="626" height="16" font="0">a number of utility functions that make updating the status values of an entire</text>
<text top="941" left="173" width="626" height="16" font="0">region easier. For example, we frequently need to increment the reference count</text>
<text top="974" left="173" width="626" height="16" font="0">for a mappable region, even if the reference count of the individual pages is not</text>
<text top="1006" left="173" width="73" height="16" font="0">the same.</text>
</page>
<page number="214" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">192</text>
<text top="165" left="190" width="395" height="14" font="7">incrementMappedCount :: PhysicalRegion -&gt; H ()</text>
<text top="192" left="190" width="198" height="14" font="7">incrementMappedCount pr</text>
<text top="218" left="207" width="352" height="14" font="7">= do refCounts &lt;- mapM readCount pagelist</text>
<text top="245" left="250" width="215" height="14" font="7">if (all (&gt;= 0) refCounts)</text>
<text top="271" left="276" width="378" height="14" font="7">then zipWithM_ updatePage refCounts pagelist</text>
<text top="297" left="276" width="120" height="14" font="7">else return ()</text>
<text top="324" left="207" width="43" height="14" font="7">where</text>
<text top="350" left="224" width="189" height="14" font="7">start = regionStart pr</text>
<text top="377" left="224" width="412" height="14" font="7">pagelist = [start, start+pageSize..regionEnd pr]</text>
<text top="403" left="224" width="576" height="14" font="7">readCount x = do count &lt;- readPageStatus x; return (fromEnum count)</text>
<text top="430" left="224" width="215" height="14" font="7">updatePage refCount paddr</text>
<text top="456" left="242" width="507" height="14" font="7">= updatePageStatus paddr (Mapped (fromIntegral refCount+1))</text>
<text top="501" left="173" width="626" height="16" font="0">If any page in the region is not mappable, then incrementMappedCount will fail,</text>
<text top="533" left="173" width="626" height="16" font="0">possibly after updating the status for a portion of the region. The caller is responsi-</text>
<text top="566" left="173" width="626" height="16" font="0">ble for checking that the pages of the region are actually mappable before invoking</text>
<text top="598" left="173" width="626" height="16" font="0">this function. The analogous function, decrementMappedCount, decrements the</text>
<text top="631" left="173" width="396" height="16" font="0">reference count of every page in a mappable region.</text>
<text top="663" left="199" width="600" height="16" font="0">The status manipulation functions deﬁned in this section provide a basis for</text>
<text top="696" left="173" width="626" height="16" font="0">enforcing memory-safety in the memory-management functions of the interface. As</text>
<text top="729" left="173" width="626" height="16" font="0">an example, let us consider the deﬁnition of allocPageMap. We ﬁrst introduced</text>
<text top="761" left="173" width="626" height="16" font="0">this function in Section 4.4.1 as the operation that converts a PageMapPage into a</text>
<text top="794" left="173" width="113" height="16" font="0">page-directory.</text>
<text top="837" left="190" width="412" height="14" font="7">allocPageMap :: PageMapPage -&gt; H (Maybe PageMap)</text>
<text top="864" left="190" width="163" height="14" font="7">allocPageMap pmpage</text>
<text top="890" left="207" width="430" height="14" font="7">= do usable &lt;- updatePageStatus page PageMapHandle</text>
<text top="917" left="250" width="77" height="14" font="7">if usable</text>
<text top="943" left="276" width="301" height="14" font="7">then do added &lt;- addHMapping pmpage</text>
<text top="969" left="345" width="326" height="14" font="7">installed &lt;- installPageMapPage pmpage</text>
<text top="996" left="345" width="180" height="14" font="7">if added &amp;&amp; installed</text>
<text top="1022" left="370" width="421" height="14" font="7">then do liftIO $ c_alloc_pdir (mappedAddr pmpage)</text>
<text top="1049" left="439" width="241" height="14" font="7">return (Just (PageMap page))</text>
</page>
<page number="215" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">193</text>
<text top="165" left="370" width="163" height="14" font="7">else return Nothing</text>
<text top="192" left="276" width="163" height="14" font="7">else return Nothing</text>
<text top="218" left="207" width="43" height="14" font="7">where</text>
<text top="245" left="224" width="344" height="14" font="7">page = regionStart (physicalPage pmpage)</text>
<text top="290" left="173" width="626" height="16" font="0">The ﬁrst step in allocating a page-directory is to make sure that converting the</text>
<text top="322" left="173" width="626" height="16" font="0">supplied page-map page into a page-directory will be safe. We invoke the func-</text>
<text top="355" left="173" width="626" height="16" font="0">tion updatePageStatus for this purpose: if the page-map page is not free, then</text>
<text top="389" left="173" width="628" height="15" font="0">updatePageStatus will return false and we will not proceed with the page-directory</text>
<text top="420" left="173" width="626" height="16" font="0">allocation. Otherwise, the transition is safe and we update the page status. Once</text>
<text top="452" left="173" width="626" height="16" font="0">we know that the page-directory can be allocated, we add a mapping for the page-</text>
<text top="485" left="173" width="626" height="16" font="0">directory to the HMap dictionary using addHMapping, install a virtual-to-physical</text>
<text top="517" left="173" width="626" height="16" font="0">mapping for H using installPageMapPage, and initialize the page-directory using</text>
<text top="551" left="173" width="626" height="15" font="0">c_alloc_pdir. We return a PageMap to the client that contains the physical ad-</text>
<text top="582" left="173" width="626" height="16" font="0">dress of the page-directory, but we hide this representation using a private newtype</text>
<text top="615" left="173" width="92" height="16" font="0">constructor.</text>
<text top="658" left="190" width="438" height="14" font="7">newtype PageMap = PageMap { pdir :: Addr Physical }</text>
<text top="703" left="173" width="626" height="16" font="0">We use the address, rather than a pointer, because we never access the page-map</text>
<text top="736" left="173" width="241" height="16" font="0">structure directly from Haskell.</text>
<text top="798" left="173" width="26" height="16" font="0">6.6</text>
<text top="798" left="219" width="483" height="16" font="0">DIVISION OF CODE BETWEEN C AND HASKELL</text>
<text top="848" left="173" width="626" height="16" font="0">We implement the H interface using a combination of Haskell and C code, with</text>
<text top="880" left="173" width="626" height="16" font="0">a small amount of assembly for accessing the hardware registers. Throughout the</text>
<text top="913" left="173" width="626" height="16" font="0">implementation, we employ a strategy for dividing the code between C and Haskell</text>
<text top="945" left="173" width="626" height="16" font="0">that places any potentially unsafe operations in C and any dynamic checking or</text>
<text top="978" left="173" width="626" height="16" font="0">parameter validation needed for safety in Haskell. As a result, many operations</text>
<text top="1010" left="173" width="626" height="16" font="0">that could be coded in Haskell directly are instead implemented in C. We choose</text>
<text top="1043" left="173" width="626" height="16" font="0">this strategy for simplicity: each portion of the implementation is responsible for</text>
</page>
<page number="216" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">194</text>
<text top="163" left="173" width="626" height="16" font="0">maintaining certain structures and invariants and the interface between the two</text>
<text top="195" left="173" width="626" height="16" font="0">languages is clear. Note that the total amount of the unsafe code is the same</text>
<text top="228" left="173" width="626" height="16" font="0">regardless of the approach; the techniques that would be necessary to implement</text>
<text top="260" left="173" width="626" height="16" font="0">the potentially unsafe operations in Haskell have the potential to break type- and</text>
<text top="293" left="173" width="262" height="16" font="0">memory-safety if used improperly.</text>
<text top="325" left="199" width="600" height="16" font="0">In this section, we will demonstrate our approach to partitioning the interface</text>
<text top="358" left="173" width="626" height="16" font="0">by examining the implementation of the addMapping function that we introduced</text>
<text top="390" left="173" width="626" height="16" font="0">in Section 4.4.2. addMapping installs a new virtual-to-physical mapping in user-</text>
<text top="423" left="173" width="626" height="16" font="0">space, using the C API to modify the underlying translation table structures as</text>
<text top="455" left="173" width="626" height="16" font="0">necessary. The speciﬁcs vary with the nature of the mapping: the C API provides</text>
<text top="488" left="173" width="626" height="16" font="0">functions for adding page-directory entries and adding page-table entries so that</text>
<text top="520" left="173" width="626" height="16" font="0">superpages can be used wherever possible. The C API also deﬁnes functions related</text>
<text top="553" left="173" width="626" height="16" font="0">to page-table management; there are primitives for locating an existing page-table,</text>
<text top="585" left="173" width="626" height="16" font="0">installing a new page-table in a page-directory, uninstalling a page-table from a</text>
<text top="618" left="173" width="626" height="16" font="0">page-directory, and zeroing a page. Table 6.2 summarizes the name, type, and</text>
<text top="650" left="173" width="549" height="16" font="0">function of each primitive we will need in the deﬁnition of addMapping.</text>
<text top="683" left="199" width="600" height="16" font="0">The implementation of addMapping is relatively complex because of the various</text>
<text top="715" left="173" width="626" height="16" font="0">safety and correctness conditions the function must handle. The algorithm for</text>
<text top="748" left="173" width="508" height="16" font="0">adding a mapping includes steps that perform the following tasks:</text>
<text top="794" left="199" width="600" height="17" font="0">• Parameter Validation: The client speciﬁes the virtual address range to</text>
<text top="828" left="217" width="583" height="16" font="0">map and the physical region that the address will map to as parameters.</text>
<text top="860" left="217" width="582" height="16" font="0">The virtual address region must be fully contained in user-space (to avoid</text>
<text top="893" left="217" width="583" height="16" font="0">mapping over the kernel environment) and the physical region must be map-</text>
<text top="925" left="217" width="583" height="16" font="0">pable in the current state (to avoid giving the user control over a page-table</text>
<text top="958" left="217" width="169" height="16" font="0">or environment page).</text>
<text top="1004" left="199" width="600" height="17" font="0">• Determining the Mapping Type: The size of the memory region being</text>
<text top="1038" left="217" width="583" height="16" font="0">mapped determines the underlying mechanism that we will use to add the</text>
</page>
<page number="217" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">195</text>
<text top="167" left="182" width="72" height="15" font="7">Function</text>
<text top="167" left="361" width="95" height="15" font="7">Description</text>
<text top="195" left="191" width="77" height="14" font="7">zero_page</text>
<text top="220" left="201" width="109" height="15" font="7">unsigned vaddr</text>
<text top="193" left="361" width="185" height="15" font="7">Zero a page of memory.</text>
<text top="193" left="566" width="234" height="15" font="7">The parameter vaddr must be</text>
<text top="220" left="361" width="438" height="15" font="7">mapped in the current address-space. We use this function</text>
<text top="246" left="361" width="438" height="15" font="7">before installing a client-supplied page as a page-table or page-</text>
<text top="272" left="361" width="323" height="15" font="7">directory and before freeing a page to a user.</text>
<text top="301" left="191" width="60" height="14" font="7">find_pt</text>
<text top="326" left="201" width="107" height="15" font="7">unsigned vpdir</text>
<text top="352" left="201" width="109" height="15" font="7">unsigned vaddr</text>
<text top="299" left="361" width="438" height="15" font="7">Find the page-table that corresponds to a particular virtual-</text>
<text top="325" left="361" width="58" height="15" font="7">address.</text>
<text top="325" left="434" width="365" height="15" font="7">The argument vpdir is the address of the page-</text>
<text top="352" left="361" width="438" height="15" font="7">directory where the page-table should be searched for—this</text>
<text top="378" left="361" width="438" height="15" font="7">must be a kernel-space virtual address that is mapped in the</text>
<text top="405" left="361" width="438" height="15" font="7">current page-directory. The function returns the physical ad-</text>
<text top="431" left="361" width="438" height="15" font="7">dress of the underlying page-table, if one exists, and −1 oth-</text>
<text top="457" left="361" width="48" height="15" font="7">erwise.</text>
<text top="486" left="191" width="146" height="14" font="7">install_pagetable</text>
<text top="511" left="201" width="107" height="15" font="7">unsigned vpdir</text>
<text top="537" left="201" width="109" height="15" font="7">unsigned vaddr</text>
<text top="564" left="201" width="101" height="15" font="7">unsigned ptab</text>
<text top="486" left="361" width="438" height="15" font="7">Install a newly allocated page-table into the page-directory</text>
<text top="512" left="361" width="142" height="15" font="7">speciﬁed by vpdir.</text>
<text top="512" left="518" width="282" height="15" font="7">We use the virtual address argument,</text>
<text top="540" left="361" width="438" height="14" font="7">vaddr, to calculate the appropriate index within vpdir to</text>
<text top="565" left="361" width="438" height="15" font="7">modify. The function assumes that vpdir is mapped and that</text>
<text top="591" left="361" width="332" height="15" font="7">the entry being modiﬁed is not already in use.</text>
<text top="620" left="191" width="146" height="14" font="7">add_table_entries</text>
<text top="645" left="201" width="110" height="15" font="7">unsigned vptab</text>
<text top="671" left="201" width="82" height="15" font="7">unsigned fp</text>
<text top="698" left="201" width="101" height="15" font="7">unsigned phys</text>
<text top="724" left="201" width="140" height="15" font="7">unsigned useraccess</text>
<text top="751" left="201" width="112" height="15" font="7">unsigned perms</text>
<text top="620" left="361" width="438" height="15" font="7">Add entries to a page-table. We use this function when map-</text>
<text top="646" left="361" width="438" height="15" font="7">ping less than 4 MB of memory into an address-space. vptab</text>
<text top="673" left="361" width="438" height="15" font="7">is the virtual-address of the page-table being modiﬁed; this</text>
<text top="699" left="361" width="438" height="15" font="7">address must be mapped in the current page-directory. fp</text>
<text top="726" left="361" width="438" height="15" font="7">is a ﬂexpage that describes the virtual region being mapped;</text>
<text top="753" left="361" width="438" height="14" font="7">phys is the ﬁrst physical address in the mapping, useraccess</text>
<text top="779" left="361" width="438" height="15" font="7">speciﬁes whether or not the mapping will be user-accessible;</text>
<text top="805" left="361" width="438" height="15" font="7">and perms deﬁnes the read/write permissions for the mapping.</text>
<text top="831" left="361" width="349" height="15" font="7">We require that the size of fp is less than 4 MB.</text>
<text top="860" left="191" width="129" height="14" font="7">add_dir_entries</text>
<text top="885" left="201" width="107" height="15" font="7">unsigned vpdir</text>
<text top="911" left="201" width="82" height="15" font="7">unsigned fp</text>
<text top="938" left="201" width="101" height="15" font="7">unsigned phys</text>
<text top="964" left="201" width="140" height="15" font="7">unsigned useraccess</text>
<text top="990" left="201" width="112" height="15" font="7">unsigned perms</text>
<text top="860" left="361" width="438" height="15" font="7">The analog of add_table_entries for adding page-directory</text>
<text top="886" left="361" width="51" height="15" font="7">entries.</text>
<text top="886" left="429" width="371" height="15" font="7">We use this function to add superpage mappings</text>
<text top="913" left="361" width="438" height="15" font="7">when a region of memory larger than 4 MB is being mapped.</text>
<text top="941" left="361" width="438" height="14" font="7">vpdir is the mapped virtual address of the page-directory</text>
<text top="966" left="361" width="115" height="15" font="7">being modiﬁed.</text>
<text top="966" left="498" width="302" height="15" font="7">The other parameters are the same as</text>
<text top="993" left="361" width="438" height="14" font="7">add_table_entries. We require that the size of fp is greater</text>
<text top="1018" left="361" width="166" height="15" font="7">than or equal to 4 MB.</text>
<text top="1096" left="197" width="579" height="16" font="0">Table 6.2: The C API for managing page-tables and page-directory entries.</text>
</page>
<page number="218" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">196</text>
<text top="163" left="217" width="583" height="16" font="0">mapping: for mappings smaller than 4 MB we use page-tables while for larger</text>
<text top="195" left="217" width="583" height="16" font="0">mappings we use superpages (this is always possible because of the size and</text>
<text top="228" left="217" width="277" height="16" font="0">alignment restrictions on ﬂexpages).</text>
<text top="273" left="199" width="600" height="17" font="0">• Page-Table Allocation: If the mapping will use a page-table, addMapping</text>
<text top="306" left="217" width="582" height="16" font="0">must determine whether or not a page-table is already in place at the appro-</text>
<text top="339" left="217" width="583" height="16" font="0">priate page-directory entry. If a page-table is not in place, then addMapping</text>
<text top="371" left="217" width="582" height="16" font="0">will allocate a new page-table using a page-map page supplied by the client.</text>
<text top="404" left="217" width="583" height="16" font="0">Our implementation will never allocate more than one page-table because the</text>
<text top="436" left="217" width="583" height="16" font="0">alignment and size restrictions on ﬂexpages guarantee that superpage entries</text>
<text top="469" left="217" width="583" height="16" font="0">may be used for any region that cannot be mapped with a single page-table.</text>
<text top="514" left="199" width="600" height="17" font="0">• Updating the Page-Table or Page-Directory: The addMapping func-</text>
<text top="547" left="217" width="582" height="16" font="0">tion uses the C API to modify a page-table or page-directory as appropriate</text>
<text top="580" left="217" width="168" height="16" font="0">for the mapping type.</text>
<text top="623" left="173" width="628" height="16" font="0">To make the implementation more digestible, we break the deﬁnition of addMapping</text>
<text top="656" left="173" width="626" height="16" font="0">into a number of small functions that roughly correspond to these tasks. The rest</text>
<text top="688" left="173" width="432" height="16" font="0">of the section presents the deﬁnitions of these functions.</text>
<text top="721" left="199" width="600" height="16" font="0">The ﬁrst step in the algorithm for adding a mapping is to validate the virtual</text>
<text top="753" left="173" width="626" height="16" font="0">and physical region parameters supplied by the client. The physical region must</text>
<text top="786" left="173" width="626" height="16" font="0">be mappable in the current state, meaning that none of the pages contained in the</text>
<text top="818" left="173" width="626" height="16" font="0">region are a page-table, page-directory, or environment page. The virtual region</text>
<text top="851" left="173" width="626" height="16" font="0">must be entirely contained in user-space and the two regions must be the same</text>
<text top="883" left="173" width="32" height="16" font="0">size.</text>
<text top="923" left="190" width="515" height="14" font="7">validParameters :: PhysicalRegion -&gt; Fpage Virtual -&gt; H Bool</text>
<text top="949" left="190" width="206" height="14" font="7">validParameters phys vfp</text>
<text top="975" left="207" width="352" height="14" font="7">= do validTarget &lt;- regionIsMappable phys</text>
<text top="1002" left="250" width="163" height="14" font="7">return (validTarget</text>
<text top="1028" left="319" width="103" height="14" font="7">&amp;&amp; (fpageEnd</text>
<text top="1028" left="439" width="155" height="14" font="7">vfp &lt; kernelSpace)</text>
<text top="1055" left="319" width="326" height="14" font="7">&amp;&amp; (fpageSize vfp == regionSize phys))</text>
</page>
<page number="219" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">197</text>
<text top="163" left="173" width="626" height="16" font="0">The result of validParameters is true when the parameters satisfy all of the</text>
<text top="195" left="173" width="152" height="16" font="0">required conditions.</text>
<text top="228" left="199" width="600" height="16" font="0">We determine the mapping type by looking at the size of the virtual ﬂexpage be-</text>
<text top="260" left="173" width="626" height="16" font="0">ing mapped. A size value greater than or equal to 22 bits indicates that the ﬂexpage</text>
<text top="293" left="173" width="626" height="16" font="0">is large enough to use superpages for the mapping. The rest of the implementation</text>
<text top="325" left="173" width="626" height="16" font="0">for this case is simple: we simply invoke the C API function for adding directory</text>
<text top="358" left="173" width="626" height="16" font="0">entries to map the region (c_add_directory_entries is the Haskell wrapper for</text>
<text top="392" left="173" width="626" height="15" font="0">add_directory_entries—we use the convention of adding a c_ preﬁx for all of</text>
<text top="423" left="173" width="168" height="16" font="0">the C API functions).</text>
<text top="462" left="190" width="550" height="14" font="7">checkMappingType :: Addr Virtual -&gt; PageMapPage -&gt; Fpage Virtual</text>
<text top="489" left="207" width="301" height="14" font="7">-&gt; PhysicalRegion -&gt; H (Maybe Bool)</text>
<text top="515" left="190" width="301" height="14" font="7">checkMappingType vpdir pmp vfp phys</text>
<text top="542" left="207" width="198" height="14" font="7">| fpageSize vfp &gt;= 22 =</text>
<text top="568" left="242" width="95" height="14" font="7">do liftIO $</text>
<text top="595" left="284" width="515" height="14" font="7">c_add_directory_entries vpdir fpw (regionStart phys) 1 perms</text>
<text top="621" left="267" width="163" height="14" font="7">return (Just False)</text>
<text top="662" left="173" width="626" height="16" font="0">Adding a mapping using a page-table is more complicated because we must deter-</text>
<text top="694" left="173" width="626" height="16" font="0">mine whether or not a page-table already exists for the address range we would</text>
<text top="727" left="173" width="626" height="16" font="0">like to modify. We use the C API function find_pt to look for an existing page-</text>
<text top="759" left="173" width="626" height="16" font="0">table. The next step of the algorithm is determined by the result of this function:</text>
<text top="792" left="173" width="626" height="16" font="0">when a page-table is present we modify the page-table entries straightaway using</text>
<text top="826" left="173" width="626" height="15" font="0">mapWithoutAllocation; otherwise we allocate a new page-table along the way</text>
<text top="857" left="173" width="263" height="16" font="0">using mapWithAllocationIfSafe.</text>
<text top="896" left="207" width="112" height="14" font="7">| otherwise =</text>
<text top="923" left="242" width="361" height="14" font="7">do pt_addr &lt;- liftIO $ c_find_pt vpdir fpw</text>
<text top="949" left="267" width="155" height="14" font="7">if pt_addr /= (-1)</text>
<text top="975" left="293" width="490" height="14" font="7">then mapWithoutAllocation (fromIntegral pt_addr) vfp phys</text>
<text top="1002" left="293" width="404" height="14" font="7">else mapWithAllocationIfSafe vpdir pmp vfp phys</text>
<text top="1028" left="190" width="43" height="14" font="7">where</text>
<text top="1055" left="207" width="198" height="14" font="7">fpw = fpageFromWord vfp</text>
</page>
<page number="220" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">198</text>
<text top="163" left="173" width="626" height="16" font="0">We return a Maybe Bool value from checkMappingType that indicates whether or</text>
<text top="195" left="173" width="626" height="16" font="0">not the mapping succeeded (the Maybe component) and whether or not we needed</text>
<text top="228" left="173" width="361" height="16" font="0">to allocate a page-table (the Bool component).</text>
<text top="260" left="199" width="600" height="16" font="0">The deﬁnition for mapWithoutAllocation is a relatively straightforward wrap-</text>
<text top="293" left="173" width="626" height="16" font="0">per for the C function that adds page-table entries. We use a lookup function</text>
<text top="325" left="173" width="626" height="16" font="0">on the state component of the H monad called getHMappedAddress to determine</text>
<text top="358" left="173" width="601" height="16" font="0">where the page-table of interest is mapped in the kernel virtual address-space.</text>
<text top="402" left="181" width="464" height="14" font="7">getHMappedAddress :: Addr Physical -&gt; H (Addr Virtual)</text>
<text top="447" left="173" width="626" height="16" font="0">After we modify the page-table entries, we update the status for the physical region</text>
<text top="479" left="173" width="397" height="16" font="0">using the incrementMappedCount from Section 6.5.</text>
<text top="523" left="181" width="619" height="14" font="7">mapWithoutAllocation :: Addr Physical -&gt; Fpage Virtual -&gt; PhysicalRegion</text>
<text top="549" left="199" width="146" height="14" font="7">-&gt; H (Maybe Bool)</text>
<text top="576" left="181" width="335" height="14" font="7">mapWithoutAllocation pt_addr vfp phys =</text>
<text top="602" left="199" width="318" height="14" font="7">do vptab &lt;- getHMappedAddress pt_addr</text>
<text top="629" left="224" width="464" height="14" font="7">liftIO $ c_add_table_entries vptab (fpageFromWord vfp)</text>
<text top="655" left="319" width="223" height="14" font="7">(regionStart phys) 1 perms</text>
<text top="682" left="224" width="215" height="14" font="7">incrementMappedCount phys</text>
<text top="708" left="224" width="163" height="14" font="7">return (Just False)</text>
<text top="754" left="173" width="626" height="15" font="0">mapWithoutAllocation always succeeds. The result indicates to the caller that</text>
<text top="785" left="173" width="349" height="16" font="0">we did not need to allocate a new page-table.</text>
<text top="818" left="199" width="600" height="16" font="0">The deﬁnition of mapWithAllocationIfSafe is further broken up into pieces</text>
<text top="851" left="173" width="626" height="16" font="0">that handle the extra steps required to allocate a new page-table. This function</text>
<text top="883" left="173" width="626" height="16" font="0">tries to convert the supplied page-map page into a page-table by setting its status</text>
<text top="916" left="173" width="626" height="16" font="0">value to Reserved. If this update fails then the page-map page was not free and</text>
<text top="948" left="173" width="311" height="16" font="0">we cannot use it to allocate a new table.</text>
<text top="992" left="181" width="610" height="14" font="7">mapWithAllocationIfSafe :: Addr Virtual -&gt; PageMapPage -&gt; Fpage Virtual</text>
<text top="1018" left="199" width="301" height="14" font="7">-&gt; PhysicalRegion -&gt; H (Maybe Bool)</text>
<text top="1045" left="181" width="387" height="14" font="7">mapWithAllocationIfSafe vpdir ptab vfp phys =</text>
</page>
<page number="221" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">199</text>
<text top="165" left="199" width="601" height="14" font="7">do safe &lt;- updatePageStatus (regionStart (physicalPage ptab)) Reserved</text>
<text top="192" left="224" width="387" height="14" font="7">if safe then mapWithAllocation vpdir vfp phys</text>
<text top="218" left="293" width="163" height="14" font="7">else return Nothing</text>
<text top="261" left="173" width="626" height="16" font="0">Once we know that the page-map page is safe to use as a page-table, we proceed</text>
<text top="293" left="173" width="626" height="16" font="0">with the installation process. First we install a mapping to the page in kernel-space</text>
<text top="326" left="173" width="626" height="16" font="0">and add a link between the physical and virtual addresses in the HMap dictionary.</text>
<text top="367" left="190" width="584" height="14" font="7">mapWithAllocation :: Addr Virtual -&gt; Fpage Virtual -&gt; PhysicalRegion</text>
<text top="393" left="207" width="146" height="14" font="7">-&gt; H (Maybe Bool)</text>
<text top="420" left="190" width="215" height="14" font="7">mapWithAllocation vpdir =</text>
<text top="446" left="207" width="318" height="14" font="7">do success &lt;- installPageMapPage ptab</text>
<text top="473" left="233" width="241" height="14" font="7">success’ &lt;- addHMapping ptab</text>
<text top="499" left="233" width="189" height="14" font="7">if success &amp;&amp; success’</text>
<text top="526" left="259" width="464" height="14" font="7">then do liftIO $ allocateAndModifyTable vpdir vfp phys</text>
<text top="552" left="327" width="215" height="14" font="7">incrementMappedCount phys</text>
<text top="578" left="327" width="155" height="14" font="7">return (Just True)</text>
<text top="605" left="259" width="163" height="14" font="7">else return Nothing</text>
<text top="647" left="173" width="626" height="16" font="0">If adding the kernel-space mapping for the page-table succeeds, then we proceed</text>
<text top="680" left="173" width="626" height="16" font="0">with the actual installation of the page-table into the appropriate page-directory</text>
<text top="712" left="173" width="406" height="16" font="0">and add the entries that represent the new mapping.</text>
<text top="754" left="190" width="473" height="14" font="7">allocateAndModifyTable :: Addr Virtual -&gt; Fpage Virtual</text>
<text top="780" left="207" width="223" height="14" font="7">-&gt; PhysicalRegion -&gt; IO ()</text>
<text top="806" left="190" width="335" height="14" font="7">allocateAndModifyTable vpdir vfp phys =</text>
<text top="833" left="207" width="275" height="14" font="7">do c_zero_page (mappedAddr ptab)</text>
<text top="859" left="233" width="541" height="14" font="7">c_install_pagetable vpdir fpw (regionStart (physicalPage ptab))</text>
<text top="886" left="233" width="473" height="14" font="7">c_add_table_entries (mappedAddr ptab) (fpageToWord vfp)</text>
<text top="912" left="250" width="223" height="14" font="7">(regionStart phys) 1 perms</text>
<text top="955" left="173" width="626" height="16" font="0">As with mapWithoutAllocation, we increment the reference count for the pages</text>
<text top="987" left="173" width="550" height="16" font="0">of the physical region after the mapping has been successfully installed.</text>
<text top="1020" left="199" width="600" height="16" font="0">The top-level deﬁnition of addMapping kicks oﬀ the process by checking the</text>
<text top="1052" left="173" width="447" height="16" font="0">parameters and invoking the checkMappingType function.</text>
</page>
<page number="222" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">200</text>
<text top="165" left="190" width="473" height="14" font="7">addMapping :: [PageMapPage] -&gt; PageMap -&gt; Fpage Virtual</text>
<text top="192" left="207" width="378" height="14" font="7">-&gt; PhysicalRegion -&gt; Perms -&gt; H (Maybe Bool)</text>
<text top="218" left="190" width="326" height="14" font="7">addMapping [] _ _ _ _ = return Nothing</text>
<text top="245" left="190" width="438" height="14" font="7">addMapping (ptab:_) (PageMap pdir) vfp phys perms =</text>
<text top="271" left="207" width="412" height="14" font="7">do parametersok &lt;- validParameters phys ptab vfp</text>
<text top="297" left="233" width="129" height="14" font="7">if parametersok</text>
<text top="324" left="259" width="335" height="14" font="7">then do vpdir &lt;- getHMappedAddress pdir</text>
<text top="350" left="327" width="189" height="14" font="7">checkMappingType vpdir</text>
<text top="377" left="259" width="163" height="14" font="7">else return Nothing</text>
<text top="422" left="173" width="626" height="16" font="0">The equations demonstrate an additional constraint on the parameters of the</text>
<text top="456" left="173" width="626" height="15" font="0">addMapping function: we require that the client provides at least one potential</text>
<text top="487" left="173" width="626" height="16" font="0">page-table page, regardless of the type of mapping that will be done. Future</text>
<text top="519" left="173" width="460" height="16" font="0">implementations of the interface could relax this constraint.</text>
<text top="552" left="199" width="600" height="16" font="0">The deﬁnition of addMapping demonstrates the algorithm that we use to add</text>
<text top="584" left="173" width="626" height="16" font="0">virtual-to-physical mappings in a safe way. All of the safety checking and validation</text>
<text top="617" left="173" width="626" height="16" font="0">is done in Haskell, while all of the manipulations of the translation table data</text>
<text top="649" left="173" width="626" height="16" font="0">structures are done in C. The implementations of our other mapping functions are</text>
<text top="682" left="173" width="626" height="16" font="0">very similar so we omit their deﬁnitions here. All of the functions of the interface</text>
<text top="714" left="173" width="626" height="16" font="0">use the same basic pattern where safety critical checks are performed in Haskell</text>
<text top="747" left="173" width="449" height="16" font="0">while potentially unsafe computations are performed in C.</text>
<text top="808" left="173" width="26" height="16" font="0">6.7</text>
<text top="808" left="219" width="411" height="16" font="0">THE KERNEL VIRTUAL-ADDRESS SPACE</text>
<text top="859" left="173" width="626" height="16" font="0">As discussed in Section 4.4.3, H allows the client kernel to add kernel mappings that</text>
<text top="891" left="173" width="626" height="16" font="0">are visible in every virtual address-space. The client only has access to a portion</text>
<text top="924" left="173" width="626" height="16" font="0">of the kernel virtual-address space—the rest is reserved by H for the execution</text>
<text top="956" left="173" width="626" height="16" font="0">environment and other H data. In this section, we discuss the techniques that we</text>
<text top="989" left="173" width="626" height="16" font="0">use to implement kernel mappings and the operations available to the client for</text>
<text top="1021" left="173" width="180" height="16" font="0">modifying kernel-space.</text>
</page>
<page number="223" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">201</text>
<text top="163" left="199" width="600" height="16" font="0">The start-up code partitions the kernel virtual-address space into a client-</text>
<text top="195" left="173" width="626" height="16" font="0">controlled area and an H-controlled area based on the amount of memory that</text>
<text top="228" left="173" width="626" height="16" font="0">we need to keep mapped in H. We report this division of kernel-space to the client</text>
<text top="260" left="173" width="626" height="16" font="0">using the same techniques that we employed for lifting the initial regions through</text>
<text top="293" left="173" width="626" height="16" font="0">the interface in Section 6.3: we deﬁne an array in C containing the virtual ﬂex-</text>
<text top="325" left="173" width="626" height="16" font="0">pages that belong to the client-controlled area and convert the array into a Haskell</text>
<text top="358" left="173" width="626" height="16" font="0">list using a small wrapper function. The client reads the list of kernel-mappable</text>
<text top="390" left="173" width="606" height="16" font="0">virtual addresses to determine which kernel-space address it is allowed to map.</text>
<text top="434" left="190" width="438" height="14" font="7">kernelMappableVirtualAddresses :: H [Fpage Virtual]</text>
<text top="479" left="173" width="626" height="16" font="0">We also deﬁne utilities that test whether or not a particular address falls in the</text>
<text top="512" left="173" width="626" height="16" font="0">set of client-controlled addresses. We use this function to validate virtual-address</text>
<text top="544" left="173" width="626" height="16" font="0">values passed to H as parameters; any function that adds a mapping in kernel-space</text>
<text top="577" left="173" width="486" height="16" font="0">must check that the mapping will fall in the appropriate range.</text>
<text top="621" left="190" width="481" height="14" font="7">isKernelMappableVirtualAddress :: Addr Virtual -&gt; H Bool</text>
<text top="666" left="173" width="626" height="16" font="0">The addresses in the client-controlled area may be used for any purpose. The client</text>
<text top="698" left="173" width="626" height="16" font="0">adds a mapping to one of these addresses using an addKernelMapping function</text>
<text top="731" left="173" width="503" height="16" font="0">that behaves similarly to the function for adding a user mapping.</text>
<text top="763" left="199" width="600" height="16" font="0">Allowing the client to add mappings in kernel-space increases the diﬃculty of</text>
<text top="796" left="173" width="626" height="16" font="0">maintaining a consistent view of kernel memory in every address-space. Consis-</text>
<text top="828" left="173" width="626" height="16" font="0">tency between address-spaces is a critical property for the H-controlled portion of</text>
<text top="861" left="173" width="626" height="16" font="0">kernel-space (otherwise we might enter an address-space where the Haskell heap</text>
<text top="893" left="173" width="626" height="16" font="0">is not mapped, for example), but consistency for client-controlled mappings is</text>
<text top="926" left="173" width="626" height="16" font="0">arguably less important. We considered a design that only added new kernel map-</text>
<text top="958" left="173" width="626" height="16" font="0">pings to the current address space, requiring the client kernel to add the mapping in</text>
<text top="991" left="173" width="626" height="16" font="0">other address-spaces explicitly. Ultimately, we decided against this design because</text>
<text top="1023" left="173" width="471" height="16" font="0">we did not want to allow page faults to happen in the kernel.</text>
</page>
<page number="224" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">202</text>
<text top="163" left="199" width="600" height="16" font="0">To enforce consistency for client-controlled mappings, we need a mechanism</text>
<text top="195" left="173" width="626" height="16" font="0">for modifying all of the page-directories at once. Explicitly modifying every page-</text>
<text top="228" left="173" width="626" height="16" font="0">directory in the system every time the client adds a kernel mapping is possible,</text>
<text top="260" left="173" width="626" height="16" font="0">but may not be practical because of the additional per-mapping overhead. Instead,</text>
<text top="293" left="173" width="626" height="16" font="0">we use an implementation technique that guarantees that new mappings will be</text>
<text top="325" left="173" width="626" height="16" font="0">visible in every address-space with a single update. The trick is to ensure that</text>
<text top="358" left="173" width="626" height="16" font="0">the kernel portion of each page-directory is immutable and identical. When we</text>
<text top="390" left="173" width="626" height="16" font="0">allocate a new address-space, it gets initialized with a copy of the values from</text>
<text top="423" left="173" width="626" height="16" font="0">a reference page-directory. Within the reference page directory, the entries that</text>
<text top="455" left="173" width="626" height="16" font="0">correspond to H-controlled addresses are mapped to kernel code and data. The</text>
<text top="488" left="173" width="626" height="16" font="0">client-controlled addresses are mapped to page-tables that we pre-allocate during</text>
<text top="520" left="173" width="626" height="16" font="0">start-up. Because every address-space uses the same page-tables to map the same</text>
<text top="553" left="173" width="626" height="16" font="0">set of addresses, updates to page-table entries will automatically be seen in every</text>
<text top="585" left="173" width="626" height="16" font="0">address-space. Figure 6.6 illustrates this conﬁguration. We avoid the need to</text>
<text top="618" left="173" width="626" height="16" font="0">update page-directories individually, but we pay a cost in (potentially wasted)</text>
<text top="650" left="173" width="578" height="16" font="0">space by allocating the page-tables for kernel-space before they are needed.</text>
<text top="683" left="199" width="600" height="16" font="0">The implementation of addKernelMapping is shown in Figure 6.7. Adding a</text>
<text top="715" left="173" width="626" height="16" font="0">kernel-space mapping is similar to adding a user-space mapping, except that we</text>
<text top="748" left="173" width="626" height="16" font="0">will never need to allocate a page-table and we will never map a region using</text>
<text top="780" left="173" width="478" height="16" font="0">superpage entries. The algorithm contains the following steps:</text>
<text top="824" left="199" width="600" height="17" font="0">• Parameter Validation and Region Splitting: Only kernel-space ad-</text>
<text top="857" left="217" width="588" height="16" font="0">dresses that are in the client-controlled portion of kernel-space may be mapped</text>
<text top="890" left="217" width="582" height="16" font="0">using addKernelMapping. The physical region to which the virtual address</text>
<text top="922" left="217" width="583" height="16" font="0">range will be mapped must be mappable (no page currently in use as a page-</text>
<text top="955" left="217" width="583" height="16" font="0">table, page-directory, or environment page), and the length of the physical</text>
<text top="987" left="217" width="583" height="16" font="0">and virtual regions must be the same. For regions that are larger than 4 MB,</text>
<text top="1021" left="217" width="582" height="15" font="0">addKernelMapping splits the region into a collection of small regions that</text>
<text top="1052" left="217" width="318" height="16" font="0">are all less than or equal to 4 MB in size.</text>
</page>
<page number="225" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">203</text>
<text top="399" left="267" width="86" height="17" font="8">mappings for</text>
<text top="417" left="269" width="81" height="17" font="8">kernel code,</text>
<text top="435" left="257" width="106" height="17" font="8">Haskell heap, H</text>
<text top="453" left="263" width="95" height="17" font="8">code and data</text>
<text top="404" left="448" width="33" height="17" font="8">page</text>
<text top="422" left="449" width="32" height="17" font="8">table</text>
<text top="404" left="554" width="33" height="17" font="8">page</text>
<text top="422" left="555" width="32" height="17" font="8">table</text>
<text top="404" left="660" width="33" height="17" font="8">page</text>
<text top="422" left="661" width="32" height="17" font="8">table</text>
<text top="404" left="508" width="20" height="27" font="10">...</text>
<text top="403" left="614" width="20" height="27" font="10">...</text>
<text top="236" left="427" width="105" height="17" font="8">client-controlled</text>
<text top="254" left="413" width="132" height="17" font="8">virtual memory area</text>
<text top="449" left="425" width="294" height="17" font="8">pre-allocated page-tables for mappable area</text>
<text top="291" left="451" width="47" height="20" font="0">... ...</text>
<text top="165" left="332" width="96" height="17" font="8">page-directory</text>
<text top="200" left="418" width="86" height="17" font="8">kernel-space</text>
<text top="199" left="291" width="74" height="17" font="8">user-space</text>
<text top="514" left="243" width="87" height="16" font="0">Figure 6.6:</text>
<text top="514" left="347" width="382" height="16" font="0">Implementing a consistent view of kernel-space</text>
<text top="549" left="243" width="486" height="16" font="0">across every address-space. The mappings in the H-controlled</text>
<text top="583" left="243" width="486" height="16" font="0">portion of kernel-space (all kernel-space addresses not in the</text>
<text top="618" left="243" width="486" height="16" font="0">client-controlled area) do not change over time, so we can sim-</text>
<text top="653" left="243" width="486" height="16" font="0">ply install these entries in every new page-directory that we cre-</text>
<text top="687" left="243" width="486" height="16" font="0">ate. The mappings for client-controlled addresses may change,</text>
<text top="722" left="243" width="486" height="16" font="0">but they will always be mapped via the same set of page-tables.</text>
<text top="757" left="243" width="486" height="16" font="0">We initialize a page-directory by installing the page-table ad-</text>
<text top="791" left="243" width="486" height="16" font="0">dresses for the shared kernel-space tables. Thus, when any of</text>
<text top="826" left="243" width="486" height="16" font="0">the page-table entries is modiﬁed, the eﬀect will be seen in every</text>
<text top="861" left="243" width="109" height="16" font="0">address-space.</text>
<text top="916" left="199" width="600" height="17" font="0">• Adding Page-Table Entries For Each Region: We use the C API func-</text>
<text top="949" left="217" width="583" height="16" font="0">tion for adding new page-table entries (called c_add_table_entries, see</text>
<text top="982" left="217" width="583" height="16" font="0">Section 6.6) to add the new mappings. We use the reference page-directory</text>
<text top="1014" left="217" width="583" height="16" font="0">to locate the appropriate page-tables to modify for simplicity, though we</text>
<text top="1047" left="217" width="538" height="16" font="0">could copy the appropriate mappings from the current page directory.</text>
</page>
<page number="226" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">204</text>
<text top="203" left="188" width="603" height="10" font="2">addKernelMapping :: PhysicalRegion -&gt; Fpage Virtual -&gt; Perms -&gt; Bool -&gt; H (Maybe KernelMapping)</text>
<text top="225" left="188" width="241" height="10" font="2">addKernelMapping phys vfp perms user =</text>
<text top="248" left="201" width="248" height="10" font="2">do validTarget &lt;- regionIsMappable phys</text>
<text top="271" left="220" width="311" height="10" font="2">mappablefp &lt;- isKernelMappableVirtualFlexpage vfp</text>
<text top="294" left="220" width="419" height="10" font="2">if validTarget &amp;&amp; mappablefp &amp;&amp; (fpageSize vfp == regionSize phys)</text>
<text top="316" left="246" width="165" height="10" font="2">&amp;&amp; length mrs == length rs</text>
<text top="339" left="239" width="273" height="10" font="2">then do vpdir &lt;- systemPageMapMappedAddress</text>
<text top="362" left="290" width="229" height="10" font="2">performMappings vpdir rs (split vfp)</text>
<text top="384" left="239" width="121" height="10" font="2">else return Nothing</text>
<text top="407" left="195" width="235" height="10" font="2">where userbit = if user then 1 else 0</text>
<text top="430" left="233" width="324" height="10" font="2">mrs = map (deriveRegion phys) (split (region phys))</text>
<text top="453" left="233" width="13" height="10" font="2">rs</text>
<text top="453" left="258" width="95" height="10" font="2">= catMaybes mrs</text>
<text top="498" left="195" width="248" height="10" font="2">performMappings vpdir regions vfpages =</text>
<text top="521" left="208" width="324" height="10" font="2">do pt_addrs &lt;- liftIO $ mapM (c_find_pt vpdir) fpws</text>
<text top="543" left="227" width="318" height="10" font="2">zipWithM3_ addKernelMappings pt_addrs regions fpws</text>
<text top="566" left="227" width="140" height="10" font="2">return (Just kmapping)</text>
<text top="589" left="208" width="229" height="10" font="2">where fpws = map fpageToWord vfpages</text>
<text top="612" left="246" width="241" height="10" font="2">kmapping = KernelMapping { kernelFpage</text>
<text top="612" left="506" width="38" height="10" font="2">= vfp,</text>
<text top="634" left="417" width="76" height="10" font="2">kernelRegion</text>
<text top="634" left="506" width="44" height="10" font="2">= phys,</text>
<text top="657" left="417" width="70" height="10" font="2">kernelPerms</text>
<text top="657" left="506" width="51" height="10" font="2">= perms,</text>
<text top="680" left="417" width="305" height="10" font="2">kernelAddress = nullPtr ‘plusPtr‘ fpageStart vfp</text>
<text top="702" left="404" width="6" height="10" font="2">}</text>
<text top="748" left="195" width="229" height="10" font="2">addKernelMappings pt_addr phys fpw =</text>
<text top="771" left="208" width="362" height="10" font="2">if pt_addr == (-1) then error &#34;missing kernel page-table&#34;</text>
<text top="793" left="227" width="324" height="10" font="2">else let vptab = fromIntegral pt_addr + kernelSpace</text>
<text top="816" left="258" width="13" height="10" font="2">in</text>
<text top="816" left="284" width="451" height="10" font="2">liftIO $ c_add_table_entries vptab fpw (regionStart phys) userbit perms</text>
<text top="885" left="173" width="626" height="16" font="0">Figure 6.7: The implementation of the addKernelMapping function. The algo-</text>
<text top="920" left="173" width="626" height="16" font="0">rithm is similar to addMapping, but we avoid the complexity of page-table allo-</text>
<text top="955" left="173" width="626" height="16" font="0">cation because we pre-allocate all of the tables for kernel-space during start-up.</text>
<text top="989" left="173" width="626" height="16" font="0">Unlike addMapping, addKernelMapping may only map regions using page-tables,</text>
<text top="1024" left="173" width="626" height="16" font="0">so the implementation splits large regions into a collection of 4 MB-sized regions</text>
<text top="1059" left="173" width="626" height="16" font="0">before invoking the standard page-table modiﬁcation function (using a function</text>
<text top="1093" left="173" width="279" height="16" font="0">for splitting ﬂexpages called split).</text>
</page>
<page number="227" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">205</text>
<text top="162" left="199" width="600" height="17" font="0">• Constructing a KernelMapping Handle: If the mapping operation is suc-</text>
<text top="195" left="217" width="583" height="16" font="0">cessful, we provide the client kernel with a handle to the memory through</text>
<text top="228" left="217" width="583" height="16" font="0">which the kernel-mapping can be read and written. The handle, represented</text>
<text top="260" left="217" width="583" height="16" font="0">with the type KernelMapping, contains all of the information that is nec-</text>
<text top="293" left="217" width="583" height="16" font="0">essary for H to check the validity of future memory accesses, as well as a</text>
<text top="325" left="217" width="583" height="16" font="0">pointer for actually performing the reads and writes. Neither the pointer nor</text>
<text top="358" left="217" width="432" height="16" font="0">the constructor for the type are observable to the client.</text>
<text top="405" left="173" width="626" height="16" font="0">We do not implement a remove operation on kernel-mappings because of our policy</text>
<text top="438" left="173" width="626" height="16" font="0">that kernel code will not fault. We have no way to revoke or invalidate the kernel-</text>
<text top="470" left="173" width="626" height="16" font="0">mapping handles owned by the client, so there would be no way to protect memory</text>
<text top="503" left="173" width="626" height="16" font="0">accesses if the client could remove kernel mappings. Relaxing the requirement that</text>
<text top="535" left="173" width="626" height="16" font="0">the kernel does not fault or implementing a more elaborate capability system are</text>
<text top="568" left="173" width="626" height="16" font="0">both valid options if there turned out to be a strong use-case for kernel-mapping</text>
<text top="600" left="173" width="64" height="16" font="0">removal.</text>
<text top="662" left="173" width="26" height="16" font="0">6.8</text>
<text top="662" left="219" width="301" height="16" font="0">USER-PROGRAM EXECUTION</text>
<text top="712" left="173" width="626" height="16" font="0">From the perspective of an H-based kernel, executing a user-program is concep-</text>
<text top="745" left="173" width="626" height="16" font="0">tually similar to calling any other H function. The client invokes the execute</text>
<text top="777" left="173" width="626" height="16" font="0">operation from the H interface, supplying a description of the program to be run,</text>
<text top="810" left="173" width="626" height="16" font="0">and at some point later H returns to the client with a description of the interrupt</text>
<text top="842" left="173" width="626" height="16" font="0">that brought us back into kernel-mode. The implementation of execute maintains</text>
<text top="875" left="173" width="626" height="16" font="0">the illusion of simplicity: all of the complexity is handled by an assembly-language</text>
<text top="907" left="173" width="626" height="16" font="0">routine that we call when we wish to start a user program. This routine does not</text>
<text top="940" left="173" width="626" height="16" font="0">return to Haskell until the user-program has executed and produced an interrupt,</text>
<text top="972" left="173" width="626" height="16" font="0">but to the Haskell code, the assembly function behaves the same as any other FFI</text>
<text top="1005" left="173" width="31" height="16" font="0">call.</text>
<text top="1037" left="199" width="600" height="16" font="0">Figure 6.8 illustrates the relationship between each of the components in our</text>
</page>
<page number="228" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">206</text>
<text top="348" left="634" width="37" height="20" font="0">save</text>
<text top="369" left="608" width="91" height="20" font="0">registers in </text>
<text top="390" left="605" width="96" height="20" font="0">fault-context</text>
<text top="232" left="279" width="34" height="20" font="0">user</text>
<text top="253" left="264" width="65" height="20" font="0">program</text>
<text top="170" left="292" width="69" height="16" font="4">user mode</text>
<text top="169" left="535" width="81" height="16" font="4">kernel mode</text>
<text top="379" left="482" width="64" height="20" font="0">interrupt</text>
<text top="400" left="458" width="113" height="20" font="0">handler (ASM)</text>
<text top="209" left="618" width="58" height="20" font="0">Haskell</text>
<text top="231" left="616" width="61" height="20" font="0">execute</text>
<text top="209" left="450" width="104" height="20" font="0">ASM execute</text>
<text top="231" left="485" width="34" height="20" font="0">start</text>
<text top="294" left="525" width="104" height="20" font="0">ASM execute</text>
<text top="315" left="554" width="46" height="20" font="0">return</text>
<text top="361" left="270" width="54" height="16" font="4">interrupt</text>
<text top="443" left="659" width="61" height="16" font="4">hardware</text>
<text top="518" left="243" width="486" height="16" font="0">Figure 6.8: The H mechanism for executing a user program. We</text>
<text top="553" left="243" width="486" height="16" font="0">split the deﬁnition of the H function execute into Haskell and</text>
<text top="587" left="243" width="486" height="16" font="0">assembly-language portions. The assembly-language function is</text>
<text top="622" left="243" width="486" height="16" font="0">in turn split into a “start” component that performs the con-</text>
<text top="657" left="243" width="486" height="16" font="0">text switch to user code and a “return” component that resumes</text>
<text top="691" left="243" width="486" height="16" font="0">Haskell execution as if we were returning from a normal func-</text>
<text top="726" left="243" width="486" height="16" font="0">tion. An interrupt handler written in assembly is responsible for</text>
<text top="761" left="243" width="486" height="16" font="0">saving the register state of the user-program before returning to</text>
<text top="795" left="243" width="60" height="16" font="0">Haskell.</text>
<text top="848" left="173" width="626" height="16" font="0">user-program execution implementation. The Haskell function execute initiates</text>
<text top="881" left="173" width="626" height="16" font="0">the process by calling our execution function written in assembly, which in turn</text>
<text top="913" left="173" width="626" height="16" font="0">context-switches to the user code. When an interrupt occurs, we enter an assembly-</text>
<text top="946" left="173" width="626" height="16" font="0">language handler in kernel-mode that saves the register state of the program and</text>
<text top="978" left="173" width="626" height="16" font="0">returns to Haskell via a special function that behaves as if we were returning from</text>
<text top="1011" left="173" width="626" height="16" font="0">a normal call. In the rest of this section, we will explore each of the components</text>
<text top="1043" left="173" width="408" height="16" font="0">that make up user-program execution in more depth.</text>
</page>
<page number="229" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">207</text>
<text top="163" left="199" width="600" height="16" font="0">The assembly function takes two parameters: a pointer to the program’s saved</text>
<text top="195" left="173" width="626" height="16" font="0">register state and the physical address of the page-directory to install. The FFI</text>
<text top="228" left="173" width="626" height="16" font="0">does not allow us to call assembly functions directly, so we invoke the function via</text>
<text top="260" left="173" width="101" height="16" font="0">a C wrapper.</text>
<text top="304" left="190" width="584" height="14" font="7">extern unsigned asm_execute(unsigned pmap, unsigned* fault_context);</text>
<text top="357" left="190" width="455" height="14" font="7">foreign import ccall unsafe &#34;execution.h asm_execute&#34;</text>
<text top="383" left="207" width="369" height="14" font="7">c_execute :: HWord -&gt; Ptr HWord -&gt; IO HByte</text>
<text top="428" left="173" width="626" height="16" font="0">Within asm_execute, we save the kernel’s register state, set the new page-directory,</text>
<text top="461" left="173" width="626" height="16" font="0">and restore the register state of the user program. Once the proper user state is</text>
<text top="493" left="173" width="626" height="16" font="0">in place, we issue the iretl instruction to return to the user program at the point</text>
<text top="526" left="173" width="193" height="16" font="0">where it was interrupted.</text>
<text top="558" left="199" width="600" height="16" font="0">The FaultContext type introduced in Section 4.5 encapsulates our represen-</text>
<text top="591" left="173" width="626" height="16" font="0">tation of the register state for user programs. We save the register state of user</text>
<text top="624" left="173" width="626" height="16" font="0">programs in blocks of memory that we allocate from the Haskell heap and access</text>
<text top="656" left="173" width="98" height="16" font="0">via a pointer</text>
<text top="654" left="271" width="6" height="11" font="2">3</text>
<text top="656" left="278" width="5" height="16" font="0">.</text>
<text top="700" left="173" width="404" height="14" font="7">newtype FaultContext = FaultContext (Ptr HWord)</text>
<text top="745" left="173" width="626" height="16" font="0">The client cannot observe the internal representation of FaultContexts, but may</text>
<text top="777" left="173" width="626" height="16" font="0">read or write the value of individual registers using the H functions readRegister</text>
<text top="810" left="173" width="383" height="16" font="0">and writeRegister (as explained in Section 4.5).</text>
<text top="842" left="199" width="600" height="16" font="0">When we execute a user process, we install a pointer to the appropriate fault-</text>
<text top="875" left="173" width="626" height="16" font="0">context in the stack pointer ﬁeld (called ESP0) of the task-state-segment (see</text>
<text top="907" left="173" width="626" height="16" font="0">Section 2.1.3). When we switch to kernel-mode upon receiving an interrupt, the</text>
<text top="954" left="193" width="6" height="9" font="3">3</text>
<text top="956" left="200" width="600" height="14" font="4">We choose to allocate FaultContexts from the heap so that FaultContext values can be</text>
<text top="985" left="173" width="626" height="14" font="4">garbage collected. We perform the allocation using the function mallocForeignPtrBytes to</text>
<text top="1014" left="173" width="626" height="13" font="4">avoid the need for a ﬁnalizer—the run-time system will collect the fault-context memory when</text>
<text top="1042" left="173" width="200" height="13" font="4">the pointer is no longer in use.</text>
</page>
<page number="230" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">208</text>
<text top="163" left="173" width="626" height="16" font="0">hardware installs this pointer as the active stack pointer in the ESP register. This</text>
<text top="195" left="173" width="626" height="16" font="0">allows us to save the registers of the running program by pushing the values onto</text>
<text top="228" left="173" width="626" height="16" font="0">the current stack in the interrupt handler. When we resume the user program after</text>
<text top="260" left="173" width="626" height="16" font="0">servicing an interrupt, we pop the saved values oﬀ the stack into the registers and</text>
<text top="293" left="173" width="626" height="16" font="0">the user state is restored. The client has full control over how many stacks H will</text>
<text top="325" left="173" width="626" height="16" font="0">use. For example, the client can allocate a single fault-context on which all user</text>
<text top="358" left="173" width="626" height="16" font="0">programs will run or the client can allocate a distinct fault-context for every user</text>
<text top="390" left="173" width="55" height="16" font="0">thread.</text>
<text top="423" left="199" width="600" height="16" font="0">The H function execute is essentially a Haskell wrapper for the c_execute</text>
<text top="455" left="173" width="626" height="16" font="0">function that sets up all of the user state and returns from the interrupt. The</text>
<text top="488" left="173" width="626" height="16" font="0">client kernel provides execute with a PageMap specifying the page-directory to</text>
<text top="520" left="173" width="626" height="16" font="0">install for the user program and a FaultContext containing the program’s register</text>
<text top="553" left="173" width="626" height="16" font="0">state. execute sets the ESP0 ﬁeld of the task-state-segment to point to the fault-</text>
<text top="585" left="173" width="520" height="16" font="0">context and then invokes c_execute to return to the user program.</text>
<text top="629" left="190" width="421" height="14" font="7">execute :: PageMap -&gt; FaultContext -&gt; H Interrupt</text>
<text top="656" left="190" width="378" height="14" font="7">execute (PageMap pm) fc@(FaultContext fcPtr)</text>
<text top="682" left="207" width="533" height="14" font="7">= do liftIO $ pokeByteOff c_tss_esp0 0 (fcPtr ‘plusPtr‘ fcLen)</text>
<text top="709" left="250" width="318" height="14" font="7">vector &lt;- liftIO $ c_execute pm fcPtr</text>
<text top="735" left="250" width="241" height="14" font="7">code &lt;- readRegister fc Code</text>
<text top="761" left="250" width="378" height="14" font="7">faultAddr &lt;- liftIO $ peek c_last_fault_addr</text>
<text top="788" left="250" width="412" height="14" font="7">return (vectorToInterrupt vector code faultAddr)</text>
<text top="814" left="207" width="43" height="14" font="7">where</text>
<text top="841" left="224" width="86" height="14" font="7">fcLen = 76</text>
<text top="886" left="173" width="626" height="16" font="0">When c_execute returns, we know that the user program has executed and pro-</text>
<text top="918" left="173" width="626" height="16" font="0">duced an interrupt described by vector. We return a high-level description of</text>
<text top="951" left="173" width="626" height="16" font="0">the interrupt that occurred by converting the numeric vector into a value of the</text>
<text top="985" left="173" width="127" height="15" font="0">Interrupt type.</text>
<text top="1027" left="190" width="120" height="14" font="7">data Interrupt</text>
<text top="1053" left="224" width="112" height="14" font="7">= DivideError</text>
</page>
<page number="231" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">209</text>
<text top="165" left="224" width="120" height="14" font="7">| NMIInterrupt</text>
<text top="192" left="224" width="198" height="14" font="7">| ExternalInterrupt IRQ</text>
<text top="218" left="224" width="232" height="14" font="7">| ProgrammedException HByte</text>
<text top="245" left="242" width="26" height="14" font="7">...</text>
<text top="285" left="173" width="626" height="16" font="0">The Interrupt type contains a constructor for representing each of the possible</text>
<text top="318" left="173" width="626" height="16" font="0">results from c_execute. We omit most of the deﬁnition because it is a straight-</text>
<text top="350" left="173" width="494" height="16" font="0">forward encoding of the semantics of the IA32 interrupt vectors.</text>
<text top="411" left="173" width="26" height="16" font="0">6.9</text>
<text top="411" left="219" width="109" height="16" font="0">SUMMARY</text>
<text top="461" left="173" width="626" height="16" font="0">In this chapter, we outlined the techniques employed for implementing the abstrac-</text>
<text top="494" left="173" width="626" height="16" font="0">tion layer, with a particular focus on the mechanisms that allow us to run Haskell</text>
<text top="526" left="173" width="626" height="16" font="0">code on bare metal, to run user-level C programs, and to enforce memory-safety</text>
<text top="559" left="173" width="626" height="16" font="0">in the H operations. An important aspect of the implementation that we have not</text>
<text top="591" left="173" width="626" height="16" font="0">covered is its size: Table 6.3 shows the source lines of code in the abstraction layer,</text>
<text top="624" left="173" width="626" height="16" font="0">broken down by language. The total size of the interface is about 3000 lines of</text>
<text top="656" left="173" width="626" height="16" font="0">code, with more than half of code written in C. We have not made a signiﬁcant</text>
<text top="689" left="173" width="626" height="16" font="0">attempt to optimize the implementations of the H interface operations, so it is</text>
<text top="721" left="173" width="611" height="16" font="0">possible that the size could be decreased with additional implementation eﬀort.</text>
<text top="763" left="282" width="68" height="15" font="7">Purpose</text>
<text top="763" left="413" width="78" height="15" font="7">Language</text>
<text top="763" left="510" width="175" height="15" font="7">Source Lines of Code</text>
<text top="790" left="282" width="113" height="15" font="7">Implementation</text>
<text top="790" left="413" width="51" height="15" font="7">Haskell</text>
<text top="790" left="581" width="33" height="15" font="7">1096</text>
<text top="817" left="282" width="113" height="15" font="7">Implementation</text>
<text top="817" left="413" width="12" height="15" font="7">C</text>
<text top="817" left="581" width="33" height="15" font="7">1633</text>
<text top="844" left="282" width="113" height="15" font="7">Implementation</text>
<text top="844" left="413" width="36" height="15" font="7">ASM</text>
<text top="844" left="585" width="25" height="15" font="7">491</text>
<text top="871" left="282" width="62" height="15" font="7">Interface</text>
<text top="871" left="413" width="51" height="15" font="7">Haskell</text>
<text top="871" left="585" width="25" height="15" font="7">241</text>
<text top="927" left="173" width="626" height="16" font="0">Table 6.3: The source lines of code for H in Haskell, C, and Assembly Language.</text>
<text top="961" left="173" width="626" height="16" font="0">We count the interface code (special modules to be imported by clients that include</text>
<text top="996" left="173" width="626" height="16" font="0">a restricted set of module exports and the H type class instances) separately from</text>
<text top="1031" left="173" width="195" height="16" font="0">the implementation code.</text>
</page>
<page number="232" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">210</text>
<text top="227" left="447" width="77" height="16" font="0">Chapter 7</text>
<text top="277" left="241" width="489" height="16" font="0">CASE STUDY: INTER-PROCESS COMMUNICATION IN L4</text>
<text top="370" left="173" width="626" height="16" font="0">The design of the H interface is only successful if the resulting API is suﬃciently</text>
<text top="402" left="173" width="626" height="16" font="0">expressive to support the construction of operating systems in purely functional</text>
<text top="435" left="173" width="626" height="16" font="0">languages. In this chapter, we demonstrate the expressiveness of our abstraction</text>
<text top="467" left="173" width="626" height="16" font="0">layer by showing how it can be used to implement a version of the L4 microker-</text>
<text top="500" left="173" width="626" height="16" font="0">nel API [62] in Haskell using the operations of the H interface. L4 is a second-</text>
<text top="532" left="173" width="626" height="16" font="0">generation microkernel with several designs and implementations [70, 57, 75, 84].</text>
<text top="565" left="173" width="626" height="16" font="0">The wealth of existing implementations demonstrates that L4 is mature and pop-</text>
<text top="597" left="173" width="626" height="16" font="0">ular enough to make it a “real world” system, and supplies us with a baseline for</text>
<text top="630" left="173" width="362" height="16" font="0">evaluating the performance of our architecture.</text>
<text top="662" left="199" width="600" height="16" font="0">An essential characteristic of L4 is that the kernel only includes features that</text>
<text top="695" left="173" width="626" height="16" font="0">absolutely cannot reside at user-level for functional or security reasons [70]. Many</text>
<text top="727" left="173" width="626" height="16" font="0">features that one typically expects from an operating system, such as device drivers</text>
<text top="760" left="173" width="626" height="16" font="0">and memory management, are instead implemented outside of the kernel as user-</text>
<text top="792" left="173" width="626" height="16" font="0">level servers [38]. To support user-level memory management, L4 must provide</text>
<text top="825" left="173" width="626" height="16" font="0">a sophisticated set of virtual memory management primitives as part of the ker-</text>
<text top="857" left="173" width="626" height="16" font="0">nel API. The L4 virtual memory API is suﬃciently expressive to support a wide</text>
<text top="890" left="173" width="626" height="16" font="0">range of user-level applications, including a port of Linux that runs as a user-level</text>
<text top="922" left="173" width="626" height="16" font="0">server [44] and a platform for secure application execution [30] with GUI sup-</text>
<text top="955" left="173" width="626" height="16" font="0">port [23]. If the primitives of H are suﬃciently general to implement the L4 API,</text>
<text top="987" left="173" width="626" height="16" font="0">then we have reason to be conﬁdent that H could also support the implementation</text>
<text top="1020" left="173" width="130" height="16" font="0">of other systems.</text>
<text top="1052" left="199" width="600" height="16" font="0">We successfully implemented the major system calls of L4 using the H interface.</text>
</page>
<page number="233" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">211</text>
<text top="163" left="173" width="626" height="16" font="0">The implementation is based on the X2 API [62]. Our implementation includes</text>
<text top="195" left="173" width="626" height="16" font="0">address space management, thread management and scheduling, message- and</text>
<text top="228" left="173" width="626" height="16" font="0">memory-based inter-process communication, and the start-up protocols for threads</text>
<text top="260" left="173" width="626" height="16" font="0">and address spaces. Though we do not implement every feature described in the</text>
<text top="293" left="173" width="626" height="16" font="0">API, our kernel is suﬃciently full-featured to allow us to run a realistic L4 program.</text>
<text top="325" left="173" width="626" height="16" font="0">We think that this set of functionality suﬃciently demonstrates the utility of our</text>
<text top="358" left="173" width="626" height="16" font="0">abstraction layer and that a fully API-compliant version of L4 could be completed</text>
<text top="390" left="173" width="378" height="16" font="0">as future work with additional engineering eﬀort.</text>
<text top="423" left="199" width="600" height="16" font="0">In this chapter we will present our implementation of the L4 inter-process com-</text>
<text top="455" left="173" width="626" height="16" font="0">munication (IPC) system call. We choose to focus on this aspect of L4 because it</text>
<text top="488" left="173" width="626" height="16" font="0">is a central service provided by the operating system in a microkernel architecture,</text>
<text top="520" left="173" width="626" height="16" font="0">and has long been used as a benchmark for evaluating the viability of microkernel</text>
<text top="553" left="173" width="626" height="16" font="0">designs and implementations. The original focus of L4 was to demonstrate that</text>
<text top="585" left="173" width="626" height="16" font="0">good performance was possible in a microkernel. IPC performance was the pri-</text>
<text top="618" left="173" width="626" height="16" font="0">mary target [44, 70, 71]. As a result, many modern L4 implementations of IPC are</text>
<text top="650" left="173" width="626" height="16" font="0">ﬁnely tuned. L4 provided a contrast to earlier microkernel designs such as Mach [2]</text>
<text top="683" left="173" width="626" height="16" font="0">whose IPC performance was suﬃciently poor to hinder their adoption. Over time,</text>
<text top="715" left="173" width="626" height="16" font="0">security and separation issues in IPC have become increasingly important in the</text>
<text top="748" left="173" width="626" height="16" font="0">L4 community as well, leading to secure variants of the original design such as</text>
<text top="780" left="173" width="626" height="16" font="0">seL4 [84] and L4.sec [59, 25]. Haskell has previously been used as a prototyping</text>
<text top="813" left="173" width="626" height="16" font="0">tool in the design of an L4 kernel, but never as the implementation language due</text>
<text top="845" left="173" width="225" height="16" font="0">to performance concerns [18].</text>
<text top="878" left="199" width="600" height="16" font="0">Our presentation of IPC includes an explanation of many fundamental con-</text>
<text top="910" left="173" width="626" height="16" font="0">cepts of the L4 design, as necessary to explain the algorithms and data-structures</text>
<text top="943" left="173" width="626" height="16" font="0">that appear in the IPC code. Section 7.1 discusses threads and address spaces.</text>
<text top="975" left="173" width="626" height="16" font="0">Section 7.2 introduces the basic concepts of IPC and the data-structures that we</text>
<text top="1008" left="173" width="626" height="16" font="0">use to represent messages. Section 7.3 discusses an L4-speciﬁc data-structure for</text>
<text top="1040" left="173" width="626" height="16" font="0">managing memory mappings. Section 7.4 describes the monad in which our kernel</text>
</page>
<page number="234" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">212</text>
<text top="163" left="173" width="626" height="16" font="0">runs. Section 7.5 explains how we handle errors that come up during IPC process-</text>
<text top="195" left="173" width="626" height="16" font="0">ing. The remaining sections cover the IPC algorithm itself. Section 7.6 presents</text>
<text top="228" left="173" width="626" height="16" font="0">the rendezvous component of IPC: connecting a sender to a willing receiver. Sec-</text>
<text top="260" left="173" width="626" height="16" font="0">tion 7.7 outlines the process for transferring data from the sender to the receiver.</text>
<text top="293" left="173" width="488" height="16" font="0">The performance of our L4 kernel will be covered in Chapter 8.</text>
<text top="354" left="173" width="26" height="16" font="0">7.1</text>
<text top="354" left="219" width="100" height="16" font="0">THREADS</text>
<text top="404" left="173" width="626" height="16" font="0">Threads are an important abstraction in L4. Each thread is associated with an</text>
<text top="436" left="173" width="626" height="16" font="0">address space that provides the resource context in which the thread will execute.</text>
<text top="469" left="173" width="626" height="16" font="0">The Thread type describes the important features of a thread, such as the address-</text>
<text top="501" left="173" width="413" height="16" font="0">space in which the thread executes, called its parent.</text>
<text top="539" left="190" width="189" height="14" font="7">data Thread = Thread {</text>
<text top="566" left="224" width="52" height="14" font="7">parent</text>
<text top="566" left="310" width="77" height="14" font="7">:: HWord,</text>
<text top="566" left="456" width="241" height="14" font="7">-- Domain owning this thread</text>
<text top="592" left="224" width="69" height="14" font="7">threadId</text>
<text top="592" left="310" width="103" height="14" font="7">:: ThreadId,</text>
<text top="592" left="456" width="172" height="14" font="7">-- global identifier</text>
<text top="619" left="224" width="52" height="14" font="7">halted</text>
<text top="619" left="310" width="69" height="14" font="7">:: Bool,</text>
<text top="619" left="456" width="172" height="14" font="7">-- currently halted?</text>
<text top="645" left="224" width="189" height="14" font="7">scheduler :: ThreadId,</text>
<text top="645" left="456" width="206" height="14" font="7">-- scheduler thread’s ID</text>
<text top="672" left="224" width="69" height="14" font="7">priority</text>
<text top="672" left="310" width="77" height="14" font="7">:: HWord,</text>
<text top="672" left="456" width="258" height="14" font="7">-- priority (set by scheduler)</text>
<text top="698" left="224" width="69" height="14" font="7">timeleft</text>
<text top="698" left="310" width="77" height="14" font="7">:: HWord,</text>
<text top="698" left="456" width="163" height="14" font="7">-- time left to run</text>
<text top="724" left="224" width="198" height="14" font="7">timeslice :: Timeslice,</text>
<text top="724" left="456" width="284" height="14" font="7">-- time to run per time scheduled</text>
<text top="751" left="224" width="60" height="14" font="7">quantum</text>
<text top="751" left="310" width="95" height="14" font="7">:: Quantum,</text>
<text top="751" left="456" width="206" height="14" font="7">-- total time to execute</text>
<text top="777" left="224" width="60" height="14" font="7">context</text>
<text top="777" left="310" width="344" height="14" font="7">:: FaultContext, -- saved register state</text>
<text top="804" left="224" width="60" height="14" font="7">waiting</text>
<text top="804" left="310" width="120" height="14" font="7">:: [ThreadId],</text>
<text top="804" left="456" width="223" height="14" font="7">-- threads sending to this</text>
<text top="830" left="224" width="52" height="14" font="7">status</text>
<text top="830" left="310" width="318" height="14" font="7">:: ThreadStatus, -- ready/waiting/etc</text>
<text top="856" left="224" width="34" height="14" font="7">utcb</text>
<text top="856" left="310" width="60" height="14" font="7">:: UTCB</text>
<text top="856" left="456" width="198" height="14" font="7">-- thread control block</text>
<text top="883" left="207" width="9" height="14" font="7">}</text>
<text top="922" left="173" width="626" height="16" font="0">The threadId is a unique global identiﬁer for the thread. halted, scheduler,</text>
<text top="956" left="173" width="626" height="15" font="0">priority, timeleft, timeslice, and quantum are parameters related to thread</text>
<text top="987" left="173" width="626" height="16" font="0">scheduling that we ignore in our discussion of IPC. A thread’s context contains</text>
<text top="1020" left="173" width="626" height="16" font="0">the register state from the last time the thread was suspended (see Section 4.5).</text>
<text top="1052" left="173" width="626" height="16" font="0">The waiting queue stores the identiﬁers of threads that are waiting to send a</text>
</page>
<page number="235" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">213</text>
<text top="163" left="173" width="626" height="16" font="0">message to this thread; we will cover this topic in Section 7.6. The status ﬁeld</text>
<text top="195" left="173" width="626" height="16" font="0">contains information about the execution state of the thread, for example, whether</text>
<text top="228" left="173" width="626" height="16" font="0">it is runnable, inactive, or blocked waiting to send an IPC message. utcb stores</text>
<text top="260" left="173" width="522" height="16" font="0">the location of the thread’s user-level thread control block (UTCB).</text>
<text top="293" left="199" width="600" height="16" font="0">Every thread in the system has a UTCB, which is a structure in memory</text>
<text top="325" left="173" width="626" height="16" font="0">that is accessible to both the thread and the kernel. The thread uses the UTCB</text>
<text top="358" left="173" width="626" height="16" font="0">to communicate system call parameters to the kernel—such as the data to be</text>
<text top="390" left="173" width="626" height="16" font="0">transferred by an IPC—and the kernel uses the UTCB to pass results back to the</text>
<text top="423" left="173" width="626" height="16" font="0">thread—such as an error code or the incoming data from an incoming message.</text>
<text top="455" left="173" width="626" height="16" font="0">The UTCB also contains conﬁguration information about the thread, such as its</text>
<text top="488" left="173" width="626" height="16" font="0">pager, interrupt handler, and global identiﬁer. We deﬁne a datatype where each</text>
<text top="520" left="173" width="330" height="16" font="0">constructor represents a ﬁeld in the UTCB</text>
<text top="518" left="503" width="6" height="11" font="2">1</text>
<text top="520" left="510" width="5" height="16" font="0">.</text>
<text top="561" left="181" width="120" height="14" font="7">data UTCBField</text>
<text top="588" left="199" width="103" height="14" font="7">= MyGlobalId</text>
<text top="588" left="362" width="112" height="14" font="7">| ProcessorNo</text>
<text top="588" left="525" width="163" height="14" font="7">| UserDefinedHandle</text>
<text top="614" left="199" width="60" height="14" font="7">| Pager</text>
<text top="614" left="362" width="309" height="14" font="7">| ExceptionHandler | COPPreemptFlags</text>
<text top="641" left="199" width="95" height="14" font="7">| ErrorCode</text>
<text top="641" left="362" width="120" height="14" font="7">| XferTimeouts</text>
<text top="641" left="525" width="155" height="14" font="7">| IntendedReceiver</text>
<text top="667" left="199" width="120" height="14" font="7">| ActualSender</text>
<text top="667" left="362" width="112" height="14" font="7">| ThreadWord0</text>
<text top="667" left="525" width="112" height="14" font="7">| ThreadWord1</text>
<text top="693" left="199" width="43" height="14" font="7">| MR1</text>
<text top="693" left="259" width="43" height="14" font="7">| MR2</text>
<text top="693" left="319" width="43" height="14" font="7">| MR3</text>
<text top="693" left="379" width="43" height="14" font="7">| MR4</text>
<text top="693" left="439" width="43" height="14" font="7">| MR5</text>
<text top="693" left="499" width="43" height="14" font="7">| MR6</text>
<text top="693" left="559" width="43" height="14" font="7">| MR7</text>
<text top="693" left="620" width="43" height="14" font="7">| MR8</text>
<text top="693" left="680" width="43" height="14" font="7">| MR9</text>
<text top="693" left="740" width="52" height="14" font="7">| MR10</text>
<text top="720" left="199" width="593" height="14" font="7">| MR11 | MR12 | MR13 | MR14 | MR15 | MR16 | MR17 | MR18 | MR19 | MR20</text>
<text top="746" left="199" width="593" height="14" font="7">| MR21 | MR22 | MR23 | MR24 | MR25 | MR26 | MR27 | MR28 | MR29 | MR30</text>
<text top="773" left="199" width="593" height="14" font="7">| MR31 | MR32 | MR33 | MR34 | MR35 | MR36 | MR37 | MR38 | MR39 | MR40</text>
<text top="799" left="199" width="593" height="14" font="7">| MR41 | MR42 | MR43 | MR44 | MR45 | MR46 | MR47 | MR48 | MR49 | MR50</text>
<text top="826" left="199" width="593" height="14" font="7">| MR51 | MR52 | MR53 | MR54 | MR55 | MR56 | MR57 | MR58 | MR59 | MR60</text>
<text top="852" left="199" width="172" height="14" font="7">| MR61 | MR62 | MR63</text>
<text top="878" left="199" width="43" height="14" font="7">| BR0</text>
<text top="905" left="199" width="120" height="14" font="7">| InvalidField</text>
<text top="947" left="173" width="626" height="16" font="0">The collection of ﬁelds that begin with MR are called message registers. As we</text>
<text top="979" left="173" width="626" height="16" font="0">will see in Section 7.2, the message registers are the locations that are used for</text>
<text top="1023" left="193" width="6" height="9" font="3">1</text>
<text top="1026" left="200" width="600" height="13" font="4">We do not implement the buﬀer register ﬁelds of the UTCB because we do not implement</text>
<text top="1054" left="173" width="285" height="13" font="4">the string item functionality of the L4 API.</text>
</page>
<page number="236" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">214</text>
<text top="163" left="173" width="626" height="16" font="0">data transfer during an IPC message. BR0 is a buﬀer register that stores an IPC</text>
<text top="195" left="173" width="626" height="16" font="0">parameter called the acceptor. We access the ﬁelds of a UTCB using the functions</text>
<text top="229" left="173" width="294" height="15" font="0">readUTCBField and writeUTCBField.</text>
<text top="272" left="181" width="558" height="14" font="7">readUTCBField :: (KernelMemory m) =&gt; UTCB -&gt; UTCBField -&gt; m HWord</text>
<text top="298" left="181" width="619" height="14" font="7">writeUTCBField :: (KernelMemory m) =&gt; UTCB -&gt; UTCBField -&gt; HWord -&gt; m ()</text>
<text top="343" left="173" width="626" height="16" font="0">These functions provide direct access to the memory that stores each UTCB using</text>
<text top="376" left="173" width="529" height="16" font="0">the KernelMemory portion of the H API (see Sections 6.2 and 4.4.3).</text>
<text top="408" left="199" width="600" height="16" font="0">Essentially, each address space consists of a PageMap (see Section 4.4.1) that de-</text>
<text top="441" left="173" width="626" height="16" font="0">scribes the memory mappings available in that space. Internally, we track some ad-</text>
<text top="473" left="173" width="626" height="16" font="0">ditional information about each address space in a data-structure called a Domain.</text>
<text top="517" left="190" width="189" height="14" font="7">data Domain = Domain {</text>
<text top="543" left="327" width="43" height="14" font="7">space</text>
<text top="543" left="456" width="95" height="14" font="7">:: PageMap,</text>
<text top="570" left="327" width="69" height="14" font="7">domainId</text>
<text top="570" left="456" width="77" height="14" font="7">:: HWord,</text>
<text top="596" left="327" width="86" height="14" font="7">privileged</text>
<text top="596" left="456" width="69" height="14" font="7">:: Bool,</text>
<text top="623" left="327" width="86" height="14" font="7">numThreads</text>
<text top="623" left="456" width="60" height="14" font="7">:: Int,</text>
<text top="649" left="327" width="77" height="14" font="7">numActive</text>
<text top="649" left="456" width="52" height="14" font="7">:: Int</text>
<text top="675" left="310" width="9" height="14" font="7">}</text>
<text top="720" left="173" width="626" height="16" font="0">The space ﬁeld contains the page-map for the address-space. domainId is a unique</text>
<text top="753" left="173" width="626" height="16" font="0">identiﬁer for the space. We include this feature for implementation purposes—</text>
<text top="785" left="173" width="626" height="16" font="0">address spaces do not have global identiﬁers that are visible through the L4 API.</text>
<text top="818" left="173" width="626" height="16" font="0">Instead, address spaces are referred to by a space speciﬁer, the thread identiﬁer</text>
<text top="851" left="173" width="626" height="16" font="0">of a thread associated with the address space of interest. A privileged address</text>
<text top="883" left="173" width="626" height="16" font="0">space has extra rights in an L4-based system, for example, certain system calls like</text>
<text top="916" left="173" width="626" height="16" font="0">thread creation may only be performed by a thread in a privileged address space.</text>
<text top="948" left="173" width="626" height="16" font="0">The number of threads, numThreads, tracks the count of threads whose parent is</text>
<text top="981" left="173" width="626" height="16" font="0">this domain. Some of these threads may be inactive, so we separately track the</text>
<text top="1013" left="173" width="626" height="16" font="0">number of active threads, numActive. The kernel frees a domain when it no longer</text>
<text top="1046" left="173" width="164" height="16" font="0">contains any threads.</text>
</page>
<page number="237" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">215</text>
<text top="163" left="173" width="26" height="16" font="0">7.2</text>
<text top="163" left="219" width="152" height="16" font="0">IPC MESSAGES</text>
<text top="213" left="173" width="626" height="16" font="0">Threads communicate using the IPC system call of the L4 API. IPC in L4 is</text>
<text top="246" left="173" width="626" height="16" font="0">synchronous, so both the sender and the receiver must invoke the IPC system call</text>
<text top="278" left="173" width="626" height="16" font="0">before a message transfer can proceed. There are two potential phases to every</text>
<text top="311" left="173" width="626" height="16" font="0">IPC operation: a send and a receive. Any given IPC request may include just a</text>
<text top="343" left="173" width="626" height="16" font="0">send, just a receive, or both. One of the arguments to IPC is the identiﬁer of the</text>
<text top="376" left="173" width="626" height="16" font="0">thread the caller wishes to communicate with. When a thread is sending an IPC,</text>
<text top="408" left="173" width="626" height="16" font="0">it must specify the identiﬁer of the intended receiver. Receiving threads have more</text>
<text top="441" left="173" width="626" height="16" font="0">leeway. A receiver may indicate a speciﬁc sender in its request using the intended</text>
<text top="473" left="173" width="575" height="16" font="0">sender’s identiﬁer or the receiver may specify one of two special identiﬁers:</text>
<text top="520" left="199" width="576" height="17" font="0">• anythread is a thread identiﬁer that matches any thread in the system.</text>
<text top="567" left="199" width="600" height="17" font="0">• anylocalthread is a thread identiﬁer that matches any thread in the same</text>
<text top="601" left="217" width="225" height="16" font="0">address space as the receiver.</text>
<text top="648" left="173" width="626" height="16" font="0">There is a third constant of the thread identiﬁer called nilthread that does not</text>
<text top="681" left="173" width="626" height="16" font="0">match any thread. One use of nilthread is to indicate to the kernel which phases</text>
<text top="713" left="173" width="626" height="16" font="0">of IPC a particular call should include, for example, setting the receiver argument</text>
<text top="746" left="173" width="378" height="16" font="0">to nilthread requests an IPC with no send phase.</text>
<text top="778" left="199" width="600" height="16" font="0">The IPC mechanism allows for both direct data transfer and memory sharing.</text>
<text top="811" left="173" width="626" height="16" font="0">In a typical L4-based system, a user-level pager controls all non-kernel memory and</text>
<text top="843" left="173" width="626" height="16" font="0">acts as the memory manager for the rest of the system. This pager makes use of the</text>
<text top="876" left="173" width="626" height="16" font="0">memory sharing facilities of IPC to map memory into other address spaces. I/O</text>
<text top="908" left="173" width="626" height="16" font="0">and interrupts are handled by user-level servers as well; the kernel merely provides</text>
<text top="941" left="173" width="626" height="16" font="0">support for getting the information to the appropriate handler thread. When</text>
<text top="973" left="173" width="626" height="16" font="0">an interrupt occurs, the kernel catches the event and creates an IPC message on</text>
<text top="1006" left="173" width="626" height="16" font="0">behalf of the faulting thread. The message is sent to the appropriate handler for</text>
<text top="1038" left="173" width="626" height="16" font="0">the interrupt type, which might be diﬀerent from thread to thread. The message</text>
</page>
<page number="238" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">216</text>
<text top="163" left="173" width="626" height="16" font="0">contains data that describes the fault or event, but unlike normal messages, the</text>
<text top="195" left="173" width="626" height="16" font="0">data is passed directly in the message and is not read from the message registers</text>
<text top="228" left="173" width="626" height="16" font="0">of the sending thread. When the handler thread is done processing the event, the</text>
<text top="260" left="173" width="626" height="16" font="0">handler sends a message back to the faulting thread, which is caught by the kernel.</text>
<text top="293" left="173" width="626" height="16" font="0">The kernel completes the processing of the interrupt, for example, by restarting</text>
<text top="325" left="173" width="150" height="16" font="0">the faulting thread.</text>
<text top="358" left="199" width="600" height="16" font="0">Each of the special message types has diﬀerent processing requirements in the</text>
<text top="390" left="173" width="626" height="16" font="0">kernel. The L4 manual deﬁnes a protocol that characterizes the interactions be-</text>
<text top="423" left="173" width="626" height="16" font="0">tween the kernel (acting on behalf of the faulting thread) and the user-level fault</text>
<text top="455" left="173" width="626" height="16" font="0">handler. We introduce a datatype in our L4 implementation to represent the dif-</text>
<text top="488" left="173" width="326" height="16" font="0">ferent kinds of messages that may be sent.</text>
<text top="532" left="190" width="112" height="14" font="7">data SendType</text>
<text top="532" left="345" width="77" height="14" font="7">= FromMRs</text>
<text top="558" left="345" width="103" height="14" font="7">| SInterrupt</text>
<text top="585" left="345" width="258" height="14" font="7">| SPageFault HWord HWord Perms</text>
<text top="611" left="345" width="206" height="14" font="7">| SException HWord HWord</text>
<text top="637" left="345" width="86" height="14" font="7">| SPreempt</text>
<text top="637" left="456" width="43" height="14" font="7">Clock</text>
<text top="682" left="173" width="626" height="16" font="0">A message sent FromMRs is a normal message. (MR is an abbreviation for message</text>
<text top="715" left="173" width="626" height="16" font="0">register.) Each thread in L4 has 64 memory-mapped message registers that the</text>
<text top="747" left="173" width="626" height="16" font="0">thread may use to pass data in an IPC message. During the course of a normal</text>
<text top="780" left="173" width="626" height="16" font="0">IPC operation, the data being sent is transferred from the message registers of the</text>
<text top="812" left="173" width="626" height="16" font="0">sending thread to the message registers of the receiver. An SInterrupt message is</text>
<text top="845" left="173" width="626" height="16" font="0">the message the kernel sends when an I/O interrupt occurs. There is one interrupt</text>
<text top="877" left="173" width="626" height="16" font="0">handler thread per I/O interrupt, so no extra information about the nature of the</text>
<text top="910" left="173" width="626" height="16" font="0">interrupt is needed. The interrupt is disabled until the kernel receives a response</text>
<text top="942" left="173" width="626" height="16" font="0">from the handler thread. An SPageFault message notiﬁes the memory manager</text>
<text top="975" left="173" width="626" height="16" font="0">of a thread that the thread page faulted. The kernel sends the pager the address</text>
<text top="1007" left="173" width="626" height="16" font="0">where the fault occurred, the instruction pointer of the faulting thread, and the</text>
<text top="1040" left="173" width="626" height="16" font="0">type of fault (read or write). SException alerts a thread’s exception handler. The</text>
</page>
<page number="239" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">217</text>
<text top="163" left="173" width="626" height="16" font="0">message carries the interrupt vector of the exception and the error code. The ﬁnal</text>
<text top="195" left="173" width="626" height="16" font="0">message type is SPreempt, which notiﬁes the scheduler of a thread that the thread</text>
<text top="228" left="173" width="626" height="16" font="0">has been preempted because it exhausted its available time to run. The message</text>
<text top="260" left="173" width="404" height="16" font="0">contains the time at which the preemption occurred.</text>
<text top="293" left="199" width="600" height="16" font="0">We also deﬁne a type to describe the kinds of messages that may be received.</text>
<text top="325" left="173" width="446" height="16" font="0">Most of the receive messages have an analog in SendType.</text>
<text top="369" left="190" width="137" height="14" font="7">data ReceiveType</text>
<text top="369" left="345" width="60" height="14" font="7">= ToMRs</text>
<text top="369" left="465" width="180" height="14" font="7">-- normal IPC message</text>
<text top="396" left="345" width="103" height="14" font="7">| RInterrupt</text>
<text top="396" left="465" width="249" height="14" font="7">-- interrupt response message</text>
<text top="422" left="345" width="103" height="14" font="7">| RPageFault</text>
<text top="422" left="465" width="258" height="14" font="7">-- page fault response message</text>
<text top="448" left="345" width="103" height="14" font="7">| RException</text>
<text top="448" left="465" width="249" height="14" font="7">-- exception response message</text>
<text top="475" left="345" width="86" height="14" font="7">| RStartup</text>
<text top="475" left="465" width="318" height="14" font="7">-- IP/SP of a new thread for start up</text>
<text top="521" left="173" width="626" height="15" font="0">ToMRs describes a normal message where the payload of the message will be trans-</text>
<text top="552" left="173" width="626" height="16" font="0">ferred into the message registers of the receiver. RPageFault, RInterrupt, and</text>
<text top="586" left="173" width="626" height="15" font="0">RException are the replies to SPageFault, SInterrupt, and SException, respec-</text>
<text top="617" left="173" width="626" height="16" font="0">tively. The RStartup message is sent to a thread by its pager when the thread</text>
<text top="650" left="173" width="626" height="16" font="0">begins executing. The start-up message contains the initial stack pointer and in-</text>
<text top="682" left="173" width="626" height="16" font="0">struction pointer values for the receiving thread. The kernel uses these values to</text>
<text top="715" left="173" width="335" height="16" font="0">set the appropriate registers of the receiver.</text>
<text top="747" left="199" width="600" height="16" font="0">The message registers contain the payload of an IPC message for both direct</text>
<text top="780" left="173" width="626" height="16" font="0">data transfer messages and memory sharing requests. In the case of a direct data</text>
<text top="812" left="173" width="626" height="16" font="0">transfer, the contents of the message registers are untyped from the perspective</text>
<text top="845" left="173" width="626" height="16" font="0">of the kernel—it simply moves the data from the sender to the receiver. In the</text>
<text top="877" left="173" width="626" height="16" font="0">case of a memory sharing request, the message registers contain descriptions of the</text>
<text top="910" left="173" width="626" height="16" font="0">mapping operation to be performed. The kernel must process these typed items</text>
<text top="942" left="173" width="626" height="16" font="0">and modify the address space of the receiver as appropriate for the request before</text>
<text top="975" left="173" width="469" height="16" font="0">copying the descriptions into the receiver’s message registers.</text>
</page>
<page number="240" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">218</text>
<text top="163" left="199" width="600" height="16" font="0">There are two data structures in L4 that describe memory sharing requests:</text>
<text top="195" left="173" width="214" height="16" font="0">map items and grant items</text>
<text top="193" left="387" width="6" height="11" font="2">2</text>
<text top="195" left="394" width="405" height="16" font="0">. A thread requests to share memory with another</text>
<text top="228" left="173" width="626" height="16" font="0">thread by sending an IPC message with one or more of these data structures stored</text>
<text top="260" left="173" width="626" height="16" font="0">in its message registers. A map item requires two message registers for storage</text>
<text top="293" left="173" width="626" height="16" font="0">and contains: a ﬂexpage that describes the region to be mapped, the permissions</text>
<text top="325" left="173" width="626" height="16" font="0">to attach to the memory when it is mapped in the address space of the receiving</text>
<text top="358" left="173" width="626" height="16" font="0">thread, and a send base parameter that is used to reconcile any diﬀerences between</text>
<text top="390" left="173" width="626" height="16" font="0">the amount of memory that the sender is trying to map and the amount of memory</text>
<text top="423" left="173" width="626" height="16" font="0">that the receiver is willing to receive. The receiver speciﬁes the window in which</text>
<text top="455" left="173" width="626" height="16" font="0">to add the new mappings in a parameter called the acceptor. The acceptor is a</text>
<text top="488" left="173" width="626" height="16" font="0">ﬂexpage that indicates the starting address where mappings will be placed as well</text>
<text top="520" left="173" width="626" height="16" font="0">as a maximum amount of memory to map. Grant items are very similar to map</text>
<text top="553" left="173" width="626" height="16" font="0">items but have diﬀerent semantics. When a thread sends a grant item to another</text>
<text top="585" left="173" width="605" height="16" font="0">thread it gives up its own rights to the memory being sent during the transfer.</text>
<text top="618" left="199" width="600" height="16" font="0">The function reconcileFpages calculates the actual send window and receive</text>
<text top="650" left="173" width="626" height="16" font="0">window to use for a memory sharing operation based on the value of the map or</text>
<text top="683" left="173" width="626" height="16" font="0">grant item, the acceptor of the receiver, and the send base speciﬁed by the sender.</text>
<text top="727" left="190" width="550" height="14" font="7">reconcileFpages :: HWord -&gt; HWord -&gt; HWord -&gt; (L4Fpage, L4Fpage)</text>
<text top="772" left="173" width="626" height="16" font="0">We introduce the type L4Fpage to describe the send and receive windows. In L4,</text>
<text top="804" left="173" width="626" height="16" font="0">a ﬂexpage is conceptually similar to the ﬂexpages described in H, except that an</text>
<text top="837" left="173" width="618" height="16" font="0">L4 ﬂexpage also includes a set of permissions to attach to the region of memory.</text>
<text top="881" left="190" width="593" height="14" font="7">data L4Fpage = L4Fpage { vflexpage :: Fpage Virtual, perms :: Perms }</text>
<text top="926" left="173" width="626" height="16" font="0">The result of reconcileFpages is a new source region and a new destination</text>
<text top="958" left="173" width="626" height="16" font="0">region that are guaranteed to have the same size. If no reconciliation is possible</text>
<text top="1004" left="193" width="6" height="9" font="3">2</text>
<text top="1006" left="200" width="600" height="13" font="4">The API describes a third request type for copying large blocks of data called a string item,</text>
<text top="1035" left="173" width="285" height="13" font="4">but we do not implement this functionality.</text>
</page>
<page number="241" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">219</text>
<text top="163" left="173" width="626" height="16" font="0">(for example, because the receiver is not willing to accept any memory mappings),</text>
<text top="195" left="173" width="626" height="16" font="0">then this guarantee is satisﬁed by returning nilpage as both the send and receive</text>
<text top="228" left="173" width="63" height="16" font="0">window.</text>
<text top="260" left="199" width="600" height="16" font="0">The kernel reads the acceptor and the message data parameters to IPC from</text>
<text top="293" left="173" width="626" height="16" font="0">thread UTCBs. The other parameters to the system call—the intended IPC part-</text>
<text top="325" left="173" width="626" height="16" font="0">ner, the amount of time the caller is willing to wait for the operation to complete,</text>
<text top="358" left="173" width="626" height="16" font="0">and the type of the message (its SendType or RecvType)—are packaged up into</text>
<text top="390" left="173" width="626" height="16" font="0">an IPCType value that describes the request being made. In some cases these pa-</text>
<text top="423" left="173" width="626" height="16" font="0">rameters will be read from registers when the IPC system call interrupt is received</text>
<text top="455" left="173" width="626" height="16" font="0">by the kernel, while in other cases the message will be created by the kernel in</text>
<text top="488" left="173" width="346" height="16" font="0">response to other events, such as page faults.</text>
<text top="525" left="190" width="189" height="14" font="7">data IPCType = Sending</text>
<text top="525" left="405" width="77" height="14" font="7">{ partner</text>
<text top="525" left="516" width="103" height="14" font="7">:: ThreadId,</text>
<text top="551" left="422" width="60" height="14" font="7">timeout</text>
<text top="551" left="516" width="95" height="14" font="7">:: Timeout,</text>
<text top="577" left="422" width="43" height="14" font="7">stype</text>
<text top="577" left="516" width="112" height="14" font="7">:: SendType }</text>
<text top="604" left="302" width="180" height="14" font="7">| Receiving { partner</text>
<text top="604" left="516" width="103" height="14" font="7">:: ThreadId,</text>
<text top="630" left="422" width="60" height="14" font="7">timeout</text>
<text top="630" left="516" width="95" height="14" font="7">:: Timeout,</text>
<text top="657" left="422" width="43" height="14" font="7">rtype</text>
<text top="657" left="516" width="137" height="14" font="7">:: ReceiveType }</text>
<text top="695" left="173" width="626" height="16" font="0">In our implementation, we only allow two possible timeout values: zero and inﬁnity</text>
<text top="727" left="173" width="626" height="16" font="0">(any non-zero value). A zero timeout indicates that the thread is not willing to</text>
<text top="760" left="173" width="626" height="16" font="0">block waiting for the IPC; the system call will return if the intended partner is not</text>
<text top="792" left="173" width="626" height="16" font="0">ready. An inﬁnite timeout indicates that the thread will block indeﬁnitely; when</text>
<text top="825" left="173" width="626" height="16" font="0">the intended partner makes a matching request the thread will wake up. The L4</text>
<text top="857" left="173" width="626" height="16" font="0">API allows for clock-triggered timeouts where the kernel wakes up a blocked thread</text>
<text top="890" left="173" width="626" height="16" font="0">after a certain amount of time, but our current implementation does not support</text>
<text top="922" left="173" width="201" height="16" font="0">this aspect of the L4 API.</text>
<text top="955" left="199" width="600" height="16" font="0">An IPCType value captures basic information about an IPC message, whether</text>
<text top="987" left="173" width="626" height="16" font="0">that IPC occurs immediately following a system call request or at some point later</text>
<text top="1020" left="173" width="626" height="16" font="0">when the partner for the operation makes their IPC request. The status ﬁeld</text>
<text top="1052" left="173" width="626" height="16" font="0">of the Thread data structure indicates the current state of the thread: blocked</text>
</page>
<page number="242" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">220</text>
<text top="163" left="173" width="626" height="16" font="0">waiting for an IPC, ready to run, halted, or inactive. When an IPC operation gets</text>
<text top="195" left="173" width="626" height="16" font="0">blocked because the partner is not ready, the kernel saves the IPCType for later</text>
<text top="228" left="173" width="512" height="16" font="0">use. We encode these possible states with the ThreadStatus type.</text>
<text top="272" left="190" width="241" height="14" font="7">data ThreadStatus = Runnable</text>
<text top="298" left="345" width="146" height="14" font="7">| Blocked IPCType</text>
<text top="325" left="345" width="86" height="14" font="7">| Inactive</text>
<text top="351" left="345" width="69" height="14" font="7">| Halted</text>
<text top="396" left="173" width="626" height="16" font="0">The parameter of the Blocked constructor describes the pending IPC, whereas</text>
<text top="430" left="173" width="596" height="15" font="0">Runnable, Inactive and Halted threads do not need any additional context.</text>
<text top="490" left="173" width="26" height="16" font="0">7.3</text>
<text top="490" left="219" width="268" height="16" font="0">THE MAPPING DATABASE</text>
<text top="540" left="173" width="626" height="16" font="0">The mapping database is an L4-speciﬁc kernel data structure that records the</text>
<text top="573" left="173" width="626" height="16" font="0">relationships between memory mappings that are shared by user threads. This</text>
<text top="605" left="173" width="626" height="16" font="0">structure helps us to manage the relatively complex address-space interactions</text>
<text top="638" left="173" width="626" height="16" font="0">that are possible using the L4 API. For example, a thread running in an address</text>
<text top="670" left="173" width="626" height="16" font="0">space may map memory to another address-space that may in turn share the</text>
<text top="703" left="173" width="626" height="16" font="0">mapping with additional parties. At some later point, the original thread may</text>
<text top="735" left="173" width="626" height="16" font="0">wish to revoke access to the memory from the other address spaces, including the</text>
<text top="768" left="173" width="626" height="16" font="0">derived mappings that it has no direct knowledge of. The mapping database is a</text>
<text top="800" left="173" width="626" height="16" font="0">tree that captures all of the relevant information for performing such a revocation.</text>
<text top="833" left="173" width="626" height="16" font="0">Revocation corresponds to the L4 system call unmap but is also necessary during</text>
<text top="865" left="173" width="626" height="16" font="0">IPC because the API allows threads to add a new mapping in an area of virtual</text>
<text top="898" left="173" width="622" height="16" font="0">memory that is already mapped (implicitly removing the original mapping ﬁrst).</text>
<text top="930" left="199" width="600" height="16" font="0">We represent the mapping database as a list of trees. Each tree describes a</text>
<text top="963" left="173" width="626" height="16" font="0">memory mapping—the physical area occupied by the mapping, the address-space</text>
<text top="995" left="173" width="626" height="16" font="0">to which the memory is mapped, the virtual address region where the mapping lies,</text>
<text top="1028" left="173" width="626" height="16" font="0">and the permissions with which the memory is mapped—as well as any mappings</text>
</page>
<page number="243" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">221</text>
<text top="163" left="173" width="626" height="16" font="0">that have been derived from it through sharing. The tree datatype, MapTree, is a</text>
<text top="195" left="173" width="488" height="16" font="0">record containing a ﬁeld for each of these pieces of information.</text>
<text top="231" left="190" width="223" height="14" font="7">type MappingDB = [MapTree]</text>
<text top="284" left="190" width="206" height="14" font="7">data MapTree = MapTree {</text>
<text top="311" left="336" width="69" height="14" font="7">mtregion</text>
<text top="311" left="431" width="155" height="14" font="7">:: PhysicalRegion,</text>
<text top="337" left="336" width="189" height="14" font="7">ownerSpace :: PageMap,</text>
<text top="364" left="336" width="43" height="14" font="7">varea</text>
<text top="364" left="431" width="146" height="14" font="7">:: Fpage Virtual,</text>
<text top="390" left="336" width="60" height="14" font="7">mtperms</text>
<text top="390" left="431" width="77" height="14" font="7">:: Perms,</text>
<text top="416" left="336" width="69" height="14" font="7">children</text>
<text top="416" left="431" width="103" height="14" font="7">:: [MapTree]</text>
<text top="443" left="319" width="9" height="14" font="7">}</text>
<text top="480" left="173" width="626" height="16" font="0">The elements of the top-level list of trees correspond to the regions of physical</text>
<text top="513" left="173" width="626" height="16" font="0">memory that the kernel maps into user-space directly, rather than as the result</text>
<text top="545" left="173" width="626" height="16" font="0">of a sharing request. In L4, all free memory is initially mapped to a privileged</text>
<text top="578" left="173" width="315" height="16" font="0">memory manager address-space called σ</text>
<text top="584" left="488" width="6" height="11" font="2">0</text>
<text top="578" left="503" width="296" height="16" font="0">by the kernel. The children of a tree</text>
<text top="610" left="173" width="487" height="16" font="0">identify mappings of a region from one user-process to another.</text>
<text top="643" left="199" width="600" height="16" font="0">There are three basic operations on the mapping database, which correspond</text>
<text top="675" left="173" width="626" height="16" font="0">to the three system call requests that user threads may use to aﬀect memory</text>
<text top="708" left="173" width="78" height="16" font="0">mappings:</text>
<text top="746" left="199" width="600" height="17" font="0">• shareMapping: Sharing a mapping is used to handle a map item request</text>
<text top="780" left="217" width="583" height="16" font="0">through IPC—it maps a speciﬁed region of memory to some target address-</text>
<text top="812" left="217" width="583" height="16" font="0">space without modifying the source address-space. In terms of the mapping</text>
<text top="845" left="217" width="583" height="16" font="0">database, sharing a mapping corresponds to adding a new entry to the chil-</text>
<text top="877" left="217" width="215" height="16" font="0">dren of the source mapping.</text>
<text top="921" left="199" width="600" height="17" font="0">• replaceMapping: Replacing a mapping is used to handle a grant item</text>
<text top="955" left="217" width="582" height="16" font="0">request through IPC—it maps a speciﬁed region of memory to some target</text>
<text top="987" left="217" width="583" height="16" font="0">address-space and removes it from the source address-space. In terms of the</text>
<text top="1020" left="217" width="583" height="16" font="0">mapping database, replacing a mapping corresponds to transferring control</text>
<text top="1052" left="217" width="547" height="16" font="0">of a node in the tree, including of the children, to a new address space.</text>
</page>
<page number="244" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">222</text>
<text top="162" left="199" width="600" height="17" font="0">• restrictMapping: Restricting a mapping reduces the permissions that are</text>
<text top="195" left="217" width="583" height="16" font="0">attached to a particular region of memory, possibly to zero (unmapping the</text>
<text top="228" left="217" width="583" height="16" font="0">memory). The unmap system call relies on this functionality. In terms of</text>
<text top="260" left="217" width="583" height="16" font="0">the mapping database, restricting a mapping modiﬁes the permissions on an</text>
<text top="293" left="217" width="232" height="16" font="0">existing node and its children.</text>
<text top="340" left="173" width="626" height="16" font="0">Each of these operations is predicated on the assumption that the source address-</text>
<text top="373" left="173" width="626" height="16" font="0">space owns the memory that corresponds to the mappings that are being manip-</text>
<text top="405" left="173" width="626" height="16" font="0">ulated. For example, to map the page at virtual-address x from address-space A</text>
<text top="438" left="173" width="626" height="16" font="0">to B , there must be a node in the mapping database with A as the owner space</text>
<text top="470" left="173" width="626" height="16" font="0">and page x as a sub-region of the virtual area. If a requested mapping database</text>
<text top="503" left="173" width="626" height="16" font="0">operation is valid, then the mapping database operations update both the page-</text>
<text top="535" left="173" width="626" height="16" font="0">maps of the address-spaces (using the H API) and the database as appropriate.</text>
<text top="568" left="173" width="626" height="16" font="0">In the remainder of this section we will examine the types and behavior of these</text>
<text top="600" left="173" width="170" height="16" font="0">functions individually.</text>
<text top="633" left="199" width="600" height="16" font="0">In addition to the three operations that correspond directly to L4 system calls,</text>
<text top="665" left="173" width="626" height="16" font="0">we introduce a fourth operation for initializing the mapping database. We install</text>
<text top="698" left="173" width="626" height="16" font="0">the kernel-to-user virtual-memory mappings (those regions of memory directly</text>
<text top="730" left="173" width="626" height="16" font="0">mapped to a user address-space from the kernel) with the function mapRegion.</text>
<text top="763" left="173" width="626" height="16" font="0">Without this step, there would be no user-level mappings available for threads to</text>
<text top="795" left="173" width="614" height="16" font="0">share. The primary use for mapRegion is to set up the initial state of sigma</text>
<text top="802" left="787" width="6" height="11" font="2">0</text>
<text top="795" left="794" width="5" height="16" font="0">,</text>
<text top="828" left="173" width="626" height="16" font="0">which receives mappings to all available physical memory during the kernel initial-</text>
<text top="860" left="173" width="626" height="16" font="0">ization process. Because the memory mapped by mapRegion passes directly from</text>
<text top="893" left="173" width="626" height="16" font="0">the kernel to a user, the mapping does not need to be derivable from an existing</text>
<text top="925" left="173" width="626" height="16" font="0">user-space mapping. In fact, the opposite constraint holds: mapRegion will only</text>
<text top="958" left="173" width="626" height="16" font="0">respect the semantics of the mapping database if the memory being mapped does</text>
<text top="990" left="173" width="392" height="16" font="0">not overlap any existing mappings in the database.</text>
<text top="1023" left="199" width="600" height="16" font="0">The type of mapRegion reﬂects the fact that the operation potentially modiﬁes</text>
</page>
<page number="245" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">223</text>
<text top="163" left="173" width="626" height="16" font="0">the mapping database structure as well as the user-level portion of an address-</text>
<text top="195" left="173" width="626" height="16" font="0">space (recall that the UserMemory type class encapsulates user-level mapping func-</text>
<text top="228" left="173" width="626" height="16" font="0">tions from H). The mapping database is accessed within the implementation of</text>
<text top="262" left="173" width="626" height="15" font="0">mapRegion through a state component that is present in the L4 kernel monad (see</text>
<text top="293" left="173" width="222" height="16" font="0">Section 7.4 for more details).</text>
<text top="335" left="190" width="438" height="14" font="7">mapRegion :: (StateMonad MappingDB m, UserMemory m)</text>
<text top="361" left="207" width="533" height="14" font="7">=&gt; [PageMapPage] -&gt; PageMap -&gt; Fpage Virtual -&gt; PhysicalRegion</text>
<text top="388" left="233" width="223" height="14" font="7">-&gt; Perms -&gt; m (Maybe Bool)</text>
<text top="431" left="173" width="626" height="16" font="0">The arguments to mapRegion are: a list of page-map pages to use for page-table</text>
<text top="463" left="173" width="626" height="16" font="0">allocation (if necessary), the page-map to modify, a virtual-ﬂexpage that describes</text>
<text top="496" left="173" width="626" height="16" font="0">where to install the mapping, a region that corresponds to the physical memory</text>
<text top="528" left="173" width="626" height="16" font="0">to be mapped, and the permissions to attach to the mapping. The result indicates</text>
<text top="561" left="173" width="626" height="16" font="0">whether or not the operation completed successfully. We omit the code for this</text>
<text top="593" left="173" width="439" height="16" font="0">(and the other mapping database operations) for brevity.</text>
<text top="627" left="199" width="600" height="15" font="0">shareMapping and replaceMapping each add a memory mapping to a target</text>
<text top="658" left="173" width="626" height="16" font="0">address-space that is derived from an existing mapping in a source address-space.</text>
<text top="691" left="173" width="626" height="16" font="0">The only diﬀerence is in the eﬀect that the operations have on the source address-</text>
<text top="723" left="173" width="626" height="16" font="0">space when adding the mapping. As such, the type signatures for the two functions</text>
<text top="756" left="173" width="153" height="16" font="0">appear very similar.</text>
<text top="798" left="190" width="129" height="14" font="7">shareMapping ::</text>
<text top="824" left="199" width="593" height="14" font="7">(StateMonad MappingDB m, StateMonad [PhysicalRegion] m, UserMemory m)</text>
<text top="851" left="207" width="515" height="14" font="7">=&gt; [PageMapPage] -&gt; PageMap -&gt; L4Fpage -&gt; PageMap -&gt; L4Fpage</text>
<text top="877" left="242" width="146" height="14" font="7">-&gt; m (Maybe Bool)</text>
<text top="930" left="190" width="146" height="14" font="7">replaceMapping ::</text>
<text top="956" left="199" width="593" height="14" font="7">(StateMonad MappingDB m, StateMonad [PhysicalRegion] m, UserMemory m)</text>
<text top="983" left="207" width="515" height="14" font="7">=&gt; [PageMapPage] -&gt; PageMap -&gt; L4Fpage -&gt; PageMap -&gt; L4Fpage</text>
<text top="1009" left="242" width="146" height="14" font="7">-&gt; m (Maybe Bool)</text>
<text top="1052" left="173" width="626" height="16" font="0">As with mapRegion, the ﬁrst argument to both functions is a list of pages that</text>
</page>
<page number="246" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">224</text>
<text top="163" left="173" width="626" height="16" font="0">H may use for page-tables as necessary. The ﬁrst page-map and L4Fpage de-</text>
<text top="195" left="173" width="626" height="16" font="0">scribe the source of the mapping and the second describe the target. The imple-</text>
<text top="228" left="173" width="626" height="16" font="0">mentation searches the mapping database for a tree whose owner space matches</text>
<text top="260" left="173" width="626" height="16" font="0">the source page-map and whose virtual area contains the requested range in the</text>
<text top="294" left="173" width="626" height="15" font="0">L4Fpage. The permissions are automatically downgraded if the operation attempts</text>
<text top="325" left="173" width="626" height="16" font="0">to share/replace a mapping with greater permissions than the source itself has.</text>
<text top="358" left="173" width="626" height="16" font="0">The result indicates whether or not the operation succeeded. Failure stems from</text>
<text top="390" left="173" width="626" height="16" font="0">an invalid source mapping or a list of potential page-tables that is not suﬃcient to</text>
<text top="423" left="173" width="626" height="16" font="0">complete the operation. Any existing mappings in the target virtual area will be</text>
<text top="455" left="173" width="389" height="16" font="0">implicitly removed by the share/replace operation.</text>
<text top="488" left="199" width="600" height="16" font="0">The function restrictMapping modiﬁes the permissions attached to an ex-</text>
<text top="520" left="173" width="626" height="16" font="0">isting mapping, including all of the derived mappings. Reducing the permissions</text>
<text top="553" left="173" width="626" height="16" font="0">on a mapping to nothing removes that mapping. The permission restriction may</text>
<text top="585" left="173" width="626" height="16" font="0">be applied to the source mapping and all derived mappings, or just the derived</text>
<text top="618" left="173" width="386" height="16" font="0">mappings while leaving the source mapping alone.</text>
<text top="655" left="190" width="155" height="14" font="7">restrictMapping ::</text>
<text top="682" left="207" width="593" height="14" font="7">(StateMonad MappingDB m, StateMonad [PhysicalRegion] m, UserMemory m)</text>
<text top="708" left="216" width="524" height="14" font="7">=&gt; PageMap -&gt; Fpage Virtual -&gt; Perms -&gt; Bool -&gt; m MappingInfo</text>
<text top="746" left="173" width="626" height="16" font="0">The type for restrictMapping is similar to the operations so far: the page-map</text>
<text top="779" left="173" width="626" height="16" font="0">speciﬁes the address-space, the virtual ﬂexpage speciﬁes the area to modify, and</text>
<text top="811" left="173" width="626" height="16" font="0">the permissions value speciﬁes the new permissions. The additional components</text>
<text top="844" left="173" width="626" height="16" font="0">of the type are the Boolean value to control source mapping restriction and the</text>
<text top="878" left="173" width="626" height="15" font="0">MappingInfo result which describes the current state of the accessed and dirty bits</text>
<text top="909" left="173" width="170" height="16" font="0">of the memory region.</text>
<text top="969" left="173" width="26" height="16" font="0">7.4</text>
<text top="969" left="219" width="485" height="16" font="0">MANAGING STATE WITH THE KERNEL MONAD</text>
<text top="1020" left="173" width="626" height="16" font="0">Our L4 kernel runs in an extension of the H monad called Kernel. This monad</text>
<text top="1052" left="173" width="626" height="16" font="0">captures the side eﬀecting behaviors that are speciﬁc to L4 and not provided by</text>
</page>
<page number="247" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">225</text>
<text top="163" left="173" width="626" height="16" font="0">H. These behaviors could include any side eﬀects that are available in Haskell, but</text>
<text top="195" left="173" width="626" height="16" font="0">in our implementation we only use the state monad. We introduce several state</text>
<text top="228" left="173" width="626" height="16" font="0">components that correspond to key kernel data structures and add them onto the</text>
<text top="260" left="173" width="462" height="16" font="0">H monad using the monad transformer for the state monad.</text>
<text top="319" left="173" width="41" height="16" font="0">7.4.1</text>
<text top="319" left="234" width="229" height="16" font="0">Kernel Memory Allocator</text>
<text top="363" left="173" width="626" height="16" font="0">The foundation of the Kernel monad is an allocator that tracks the free mem-</text>
<text top="396" left="173" width="626" height="16" font="0">ory available to the kernel. There are two components to the allocator monad: a</text>
<text top="428" left="173" width="626" height="16" font="0">list of virtual addresses and a list of page-sized physical regions. The virtual ad-</text>
<text top="461" left="173" width="626" height="16" font="0">dresses represent locations in kernel-space where we are allowed to add mappings.</text>
<text top="493" left="173" width="626" height="16" font="0">The initial state is derived from the kernelMappableVirtualAddresses constant</text>
<text top="526" left="173" width="626" height="16" font="0">in H. The physical regions represent free pages of physical memory. This pool</text>
<text top="558" left="173" width="626" height="16" font="0">is initialized using a portion of the physical memory given to the kernel by the</text>
<text top="592" left="173" width="203" height="15" font="0">initialRegions function.</text>
<text top="628" left="181" width="498" height="14" font="7">type Allocator = ST [Addr Virtual] (ST [PhysicalRegion] H)</text>
<text top="667" left="173" width="626" height="16" font="0">We deﬁne wrapper functions on the standard state monad get and set operations</text>
<text top="700" left="173" width="626" height="16" font="0">(which read and write to the state component, respectively) for allocating and</text>
<text top="732" left="173" width="340" height="16" font="0">freeing virtual addresses and physical pages.</text>
<text top="770" left="181" width="515" height="14" font="7">allocMappableVirtualAddress :: (StateMonad [Addr Virtual] m)</text>
<text top="796" left="199" width="232" height="14" font="7">=&gt; m (Maybe (Addr Virtual))</text>
<text top="822" left="181" width="223" height="14" font="7">freeMappableVirtualAddress</text>
<text top="822" left="422" width="275" height="14" font="7">:: (StateMonad [Addr Virtual] m)</text>
<text top="849" left="199" width="198" height="14" font="7">=&gt; Addr Virtual -&gt; m ()</text>
<text top="902" left="181" width="524" height="14" font="7">allocPhysicalPage :: (StateMonad [PhysicalRegion] m, Debug m)</text>
<text top="928" left="199" width="232" height="14" font="7">=&gt; m (Maybe PhysicalRegion)</text>
<text top="955" left="181" width="137" height="14" font="7">freePhysicalPage</text>
<text top="955" left="336" width="369" height="14" font="7">:: (StateMonad [PhysicalRegion] m, Debug m)</text>
<text top="981" left="199" width="215" height="14" font="7">=&gt; PhysicalRegion -&gt; m ()</text>
<text top="1020" left="173" width="626" height="16" font="0">The most common use for the virtual-address allocator is to ﬁnd a location to map</text>
<text top="1052" left="173" width="626" height="16" font="0">page-table and page-directory pages so that the pages may be read and written by</text>
</page>
<page number="248" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">226</text>
<text top="163" left="173" width="626" height="16" font="0">H. Similarly, the most common use for the physical page allocator is to allocate</text>
<text top="195" left="173" width="626" height="16" font="0">memory to back page-tables and page-directories. Thus, a typical pattern is to</text>
<text top="228" left="173" width="626" height="16" font="0">allocate a physical page and a virtual-address together. allocPageMapPage com-</text>
<text top="260" left="173" width="626" height="16" font="0">bines the two operations into a single function and produces a PageMapPage that is</text>
<text top="293" left="173" width="626" height="16" font="0">ready to supply as an argument to H (recall from Section 4.4.1 that a PageMapPage</text>
<text top="325" left="173" width="544" height="16" font="0">combines a free physical page with a kernel-mappable virtual address).</text>
<text top="369" left="181" width="163" height="14" font="7">allocPageMapPage ::</text>
<text top="396" left="199" width="601" height="14" font="7">(StateMonad [PhysicalRegion] m, StateMonad [Addr Virtual] m, Paging m)</text>
<text top="422" left="207" width="206" height="14" font="7">=&gt; m (Maybe PageMapPage)</text>
<text top="448" left="190" width="137" height="14" font="7">allocPageMapPage</text>
<text top="475" left="207" width="86" height="14" font="7">= do mpage</text>
<text top="475" left="310" width="172" height="14" font="7">&lt;- allocPhysicalPage</text>
<text top="501" left="250" width="318" height="14" font="7">mvaddr &lt;- allocMappableVirtualAddress</text>
<text top="528" left="250" width="198" height="14" font="7">case (mpage, mvaddr) of</text>
<text top="554" left="267" width="473" height="14" font="7">(Just page, Just vaddr) -&gt; createPageMapPage page vaddr</text>
<text top="581" left="267" width="155" height="14" font="7">(Nothing, Nothing)</text>
<text top="581" left="473" width="146" height="14" font="7">-&gt; return Nothing</text>
<text top="607" left="267" width="180" height="14" font="7">(Nothing, Just vaddr)</text>
<text top="607" left="473" width="326" height="14" font="7">-&gt; do freeMappableVirtualAddress vaddr</text>
<text top="633" left="525" width="120" height="14" font="7">return Nothing</text>
<text top="660" left="267" width="172" height="14" font="7">(Just page, Nothing)</text>
<text top="660" left="473" width="232" height="14" font="7">-&gt; do freePhysicalPage page</text>
<text top="686" left="525" width="120" height="14" font="7">return Nothing</text>
<text top="731" left="173" width="398" height="16" font="0">Conversely, freePageMapPage frees a PageMapPage.</text>
<text top="775" left="181" width="155" height="14" font="7">freePageMapPage ::</text>
<text top="802" left="199" width="515" height="14" font="7">(StateMonad [PhysicalRegion] m, StateMonad [Addr Virtual] m)</text>
<text top="828" left="207" width="189" height="14" font="7">=&gt; PageMapPage -&gt; m ()</text>
<text top="854" left="190" width="515" height="14" font="7">freePageMapPage pmp = do freePhysicalPage (physicalPage pmp)</text>
<text top="881" left="405" width="369" height="14" font="7">freeMappableVirtualAddress (mappedAddr pmp)</text>
<text top="926" left="173" width="626" height="16" font="0">The result of allocPageMapPage is a Maybe value because of the possibility that</text>
<text top="958" left="173" width="534" height="16" font="0">either the physical memory pool or the virtual-address pool is empty.</text>
</page>
<page number="249" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">227</text>
<text top="163" left="173" width="41" height="16" font="0">7.4.2</text>
<text top="163" left="234" width="112" height="16" font="0">Kernel State</text>
<text top="207" left="173" width="626" height="16" font="0">We build on the allocator monad to manage the rest of the L4 state. We divide the</text>
<text top="239" left="173" width="626" height="16" font="0">state into two components: the mapping database and a System data structure</text>
<text top="272" left="173" width="299" height="16" font="0">that stores all of the other kernel data.</text>
<text top="316" left="190" width="412" height="14" font="7">type Kernel = ST System (ST MappingDB Allocator)</text>
<text top="361" left="173" width="626" height="16" font="0">The System data structure tracks various information about the kernel, such as the</text>
<text top="393" left="173" width="626" height="16" font="0">queue of runnable threads, the identiﬁer of the thread that is currently executing,</text>
<text top="426" left="173" width="166" height="16" font="0">and the system clock.</text>
<text top="470" left="190" width="189" height="14" font="7">data System = System {</text>
<text top="496" left="327" width="69" height="14" font="7">runnable</text>
<text top="496" left="413" width="120" height="14" font="7">:: [ThreadId],</text>
<text top="522" left="327" width="60" height="14" font="7">current</text>
<text top="522" left="413" width="103" height="14" font="7">:: ThreadId,</text>
<text top="549" left="327" width="43" height="14" font="7">clock</text>
<text top="549" left="413" width="77" height="14" font="7">:: Clock,</text>
<text top="575" left="327" width="284" height="14" font="7">threadMap :: Map ThreadId Thread,</text>
<text top="602" left="327" width="249" height="14" font="7">domainMap :: Map HWord Domain</text>
<text top="628" left="310" width="9" height="14" font="7">}</text>
<text top="673" left="173" width="626" height="16" font="0">The threadMap and domainMap ﬁelds are essential: they track the state of every</text>
<text top="706" left="173" width="626" height="16" font="0">thread and address-space in the system. Recall from Section 7.1 that a Thread</text>
<text top="738" left="173" width="626" height="16" font="0">describes a thread’s state and a Domain describes an address-space’s state. The</text>
<text top="772" left="173" width="626" height="15" font="0">threadMap maps global thread identiﬁers to thread structures using Haskell’s built-</text>
<text top="803" left="173" width="626" height="16" font="0">in dictionary type, Map. The domainMap is the analog for address-spaces and maps</text>
<text top="836" left="173" width="626" height="16" font="0">domain identiﬁers to domain structures. We access the mapping database and</text>
<text top="868" left="173" width="591" height="16" font="0">system state components using the standard monad operations get and set.</text>
<text top="930" left="173" width="26" height="16" font="0">7.5</text>
<text top="930" left="219" width="193" height="16" font="0">ERROR HANDLING</text>
<text top="980" left="173" width="626" height="16" font="0">During the process of performing an IPC, various error conditions might occur</text>
<text top="1013" left="173" width="626" height="16" font="0">that should be reported to the calling thread. For example, if a thread requests to</text>
<text top="1045" left="173" width="626" height="16" font="0">send a message to a thread that does not exist, then we report that no partner can</text>
</page>
<page number="250" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">228</text>
<text top="163" left="173" width="626" height="16" font="0">be found. We introduce a datatype that categorizes the possible error conditions,</text>
<text top="195" left="173" width="353" height="16" font="0">including a value for the absence of any error.</text>
<text top="239" left="190" width="198" height="14" font="7">data IPCError = NoError</text>
<text top="266" left="310" width="77" height="14" font="7">| Timeout</text>
<text top="292" left="310" width="95" height="14" font="7">| NoPartner</text>
<text top="318" left="310" width="86" height="14" font="7">| Canceled</text>
<text top="345" left="310" width="86" height="14" font="7">| Protocol</text>
<text top="391" left="173" width="626" height="15" font="0">NoError corresponds to a successful IPC operation. A Timeout error occurs when</text>
<text top="422" left="173" width="626" height="16" font="0">the intended partner is not waiting for a message but the sender or receiver speciﬁed</text>
<text top="455" left="173" width="626" height="16" font="0">they did not wish to wait. A NoPartner error occurs when the speciﬁed partner</text>
<text top="487" left="173" width="626" height="16" font="0">does not exist. A pending IPC may be aborted through an L4 system call named</text>
<text top="520" left="173" width="626" height="16" font="0">exchange registers, resulting in the Canceled error being sent to the thread that</text>
<text top="552" left="173" width="626" height="16" font="0">was blocked waiting. A Protocol violation happens when the kernel is expecting</text>
<text top="585" left="173" width="626" height="16" font="0">one of the special messages described by SendType and RecvType but the format</text>
<text top="617" left="173" width="367" height="16" font="0">of the message being processed does not match.</text>
<text top="650" left="199" width="600" height="16" font="0">When the sending thread encounters an error, we communicate information</text>
<text top="682" left="173" width="626" height="16" font="0">about the problem to the user program by writing an error descriptor value in the</text>
<text top="715" left="173" width="626" height="16" font="0">error code ﬁeld of the thread’s UTCB. We signal that the thread should check this</text>
<text top="747" left="173" width="626" height="16" font="0">error code by setting a bit in message register zero (stored in the machine register</text>
<text top="780" left="173" width="626" height="16" font="0">ESI on IA32). If the thread was running at the time of the IPC, then we restart</text>
<text top="812" left="173" width="626" height="16" font="0">the thread. Most of the functionality for signaling the error is implemented in the</text>
<text top="845" left="173" width="626" height="16" font="0">function setError; this allows us to share common code between the functions</text>
<text top="877" left="173" width="626" height="16" font="0">that signal sender errors and receiver errors. The HWord argument named recv</text>
<text top="910" left="173" width="626" height="16" font="0">distinguishes a call to setError from a sending thread (recv value of 0) from a</text>
<text top="942" left="173" width="336" height="16" font="0">call by a receiving thread (recv value of 1).</text>
</page>
<page number="251" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">229</text>
<text top="165" left="190" width="558" height="14" font="7">setError :: (StateMonad System m, Execution m, KernelMemory m) =&gt;</text>
<text top="192" left="207" width="369" height="14" font="7">Thread -&gt; Bool -&gt; HWord -&gt; IPCError -&gt; m ()</text>
<text top="218" left="190" width="232" height="14" font="7">setError t running recv err</text>
<text top="245" left="207" width="515" height="14" font="7">= let ecode = ((fromIntegral (fromEnum err)) &lt;&lt;&lt; 4) .|. recv</text>
<text top="271" left="224" width="17" height="14" font="7">in</text>
<text top="271" left="259" width="361" height="14" font="7">do writeUTCBField (utcb t) ErrorCode ecode</text>
<text top="297" left="284" width="301" height="14" font="7">mr0 &lt;- readRegister (context t) ESI</text>
<text top="324" left="284" width="387" height="14" font="7">writeRegister (context t) ESI (setBit mr0 15)</text>
<text top="350" left="284" width="198" height="14" font="7">restartThread t running</text>
<text top="393" left="190" width="567" height="14" font="7">sendError :: (StateMonad System m, Execution m, KernelMemory m) =&gt;</text>
<text top="419" left="207" width="395" height="14" font="7">Thread -&gt; Bool -&gt; SendType -&gt; IPCError -&gt; m ()</text>
<text top="445" left="190" width="515" height="14" font="7">sendError st running FromMRs err = setError st running 0 err</text>
<text top="472" left="190" width="395" height="14" font="7">sendError t running _ _ = stopThread t running</text>
<text top="518" left="173" width="391" height="16" font="0">Receiver errors are handled in much the same way.</text>
<text top="559" left="190" width="567" height="14" font="7">recvError :: (StateMonad System m, Execution m, KernelMemory m) =&gt;</text>
<text top="585" left="207" width="421" height="14" font="7">Thread -&gt; Bool -&gt; ReceiveType -&gt; IPCError -&gt; m ()</text>
<text top="612" left="190" width="498" height="14" font="7">recvError rt running ToMRs err = setError rt running 1 err</text>
<text top="638" left="190" width="395" height="14" font="7">recvError t running _ _ = stopThread t running</text>
<text top="681" left="173" width="626" height="16" font="0">The Enum instance of the ErrorCode type maps error code constructors to the</text>
<text top="713" left="173" width="626" height="16" font="0">appropriate numeric value to be stored in the UTCB. By using this technique, we</text>
<text top="746" left="173" width="626" height="16" font="0">will only have to update one place in the code if the mapping ever changes and we</text>
<text top="778" left="173" width="626" height="16" font="0">reduce the potential for mistakes that could be caused by using the wrong hard-</text>
<text top="811" left="173" width="626" height="16" font="0">coded error code value. However, we do introduce the construction and destruction</text>
<text top="843" left="173" width="626" height="16" font="0">of unnecessary values (and in turn garbage) that are not essential for the compu-</text>
<text top="876" left="173" width="626" height="16" font="0">tation. Perhaps deﬁning error code constants at the top-level would be a better</text>
<text top="908" left="173" width="600" height="16" font="0">trade oﬀ between functional style and performance in future design iterations.</text>
<text top="969" left="173" width="26" height="16" font="0">7.6</text>
<text top="969" left="219" width="237" height="16" font="0">THREAD RENDEZVOUS</text>
<text top="1020" left="173" width="626" height="16" font="0">The rendezvous component of IPC handles all aspects of the operation except for</text>
<text top="1052" left="173" width="626" height="16" font="0">the actual transfer of data. The primary task is to locate a partner for the thread</text>
</page>
<page number="252" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">230</text>
<text top="163" left="173" width="626" height="16" font="0">making the request. When a partner cannot be found, the rendezvous algorithm</text>
<text top="195" left="173" width="626" height="16" font="0">either saves the state of the thread so that it can complete the operation later</text>
<text top="228" left="173" width="626" height="16" font="0">or else sets an error code and resumes the thread. We organize the code so that</text>
<text top="260" left="173" width="626" height="16" font="0">the rendezvous portion of the code always stores any error that occurs, even if it</text>
<text top="293" left="173" width="241" height="16" font="0">occurs during message transfer.</text>
<text top="325" left="199" width="600" height="16" font="0">Recall from Section 7.2 that each IPC message potentially includes a send</text>
<text top="358" left="173" width="626" height="16" font="0">phase, a receive phase, or both. In our implementation, we deﬁne a top-level</text>
<text top="390" left="173" width="312" height="16" font="0">function that corresponds to each phase.</text>
<text top="434" left="190" width="326" height="14" font="7">send :: Thread -&gt; IPCType -&gt; Kernel ()</text>
<text top="461" left="190" width="326" height="14" font="7">recv :: Thread -&gt; IPCType -&gt; Kernel ()</text>
<text top="506" left="173" width="626" height="16" font="0">The Thread argument describes the state of the calling thread. The IPCType</text>
<text top="538" left="173" width="626" height="16" font="0">contains the parameters. Here there is an invariant that is not captured in the</text>
<text top="571" left="173" width="626" height="16" font="0">type: send should only be invoked with a IPCType value that matches the Sending</text>
<text top="603" left="173" width="540" height="16" font="0">constructor and recv should only be invoked with a Receiving value.</text>
<text top="636" left="199" width="600" height="16" font="0">Sending threads must specify the global thread identiﬁer of the intended re-</text>
<text top="668" left="173" width="214" height="16" font="0">ceiver as a parameter to IPC</text>
<text top="666" left="387" width="6" height="11" font="2">3</text>
<text top="668" left="394" width="405" height="16" font="0">. Receivers may specify a global identiﬁer, any-thread,</text>
<text top="701" left="173" width="626" height="16" font="0">or any-local-thread. Because of these diﬀerences, the partner location protocol is</text>
<text top="733" left="173" width="626" height="16" font="0">diﬀerent for send and recv. In the send operation, we simply read the Thread</text>
<text top="766" left="173" width="626" height="16" font="0">structure of the intended receiver from the thread-map and check if that thread is</text>
<text top="798" left="173" width="626" height="16" font="0">waiting to receive a message from the sender. If the intended receiver is waiting to</text>
<text top="831" left="173" width="626" height="16" font="0">receive a message from the sender, then we try to transfer the message, possibly</text>
<text top="863" left="173" width="626" height="16" font="0">getting an error. If the receiver is not waiting, then the operation cannot proceed.</text>
<text top="896" left="173" width="626" height="16" font="0">If the sender speciﬁed an inﬁnite timeout, then we block the thread and return</text>
<text top="928" left="173" width="626" height="16" font="0">to the scheduler; otherwise we signal an error and resume the thread. Figure 7.1</text>
<text top="961" left="173" width="190" height="16" font="0">shows the code for send.</text>
<text top="1003" left="193" width="6" height="9" font="3">3</text>
<text top="1005" left="200" width="600" height="13" font="4">We do not implement communication via local thread identiﬁers, although communication</text>
<text top="1034" left="173" width="397" height="13" font="4">between local threads is still supported via global identiﬁers.</text>
</page>
<page number="253" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">231</text>
<text top="238" left="188" width="241" height="10" font="2">send :: Thread -&gt; IPCType -&gt; Kernel ()</text>
<text top="260" left="188" width="241" height="10" font="2">send st send@(Sending to tout stype) =</text>
<text top="283" left="201" width="146" height="10" font="2">do mrt &lt;- readThread to</text>
<text top="306" left="220" width="70" height="10" font="2">case mrt of</text>
<text top="329" left="233" width="279" height="10" font="2">Nothing -&gt; sendError st True stype NoPartner</text>
<text top="351" left="233" width="191" height="10" font="2">Just rt -&gt; case (status rt) of</text>
<text top="374" left="315" width="324" height="10" font="2">Blocked (Receiving rid _ rtype) | idmatch rt rid -&gt;</text>
<text top="397" left="328" width="292" height="10" font="2">do ipcerr &lt;- transferMessage st stype rt rtype</text>
<text top="419" left="347" width="127" height="10" font="2">if ipcerr == NoError</text>
<text top="442" left="366" width="254" height="10" font="2">then do insertThread rt{status=Runnable}</text>
<text top="465" left="417" width="216" height="10" font="2">insertRunnable rt{status=Runnable}</text>
<text top="488" left="417" width="241" height="10" font="2">nextPhase st{status=Blocked send} True</text>
<text top="510" left="366" width="248" height="10" font="2">else do recvError rt False rtype ipcerr</text>
<text top="533" left="417" width="108" height="10" font="2">sendError st True</text>
<text top="533" left="538" width="76" height="10" font="2">stype ipcerr</text>
<text top="556" left="315" width="6" height="10" font="2">_</text>
<text top="556" left="335" width="241" height="10" font="2">-&gt; {- partner not blocked receiving -}</text>
<text top="578" left="328" width="95" height="10" font="2">if tout == Zero</text>
<text top="601" left="347" width="241" height="10" font="2">then sendError st True stype NoPartner</text>
<text top="624" left="347" width="279" height="10" font="2">else do insertThread st{status=Blocked send}</text>
<text top="647" left="398" width="184" height="10" font="2">let ws’ = waiting rt ++ [sid]</text>
<text top="669" left="398" width="191" height="10" font="2">insertThread rt{waiting = ws’}</text>
<text top="692" left="398" width="25" height="10" font="2">done</text>
<text top="715" left="201" width="32" height="10" font="2">where</text>
<text top="737" left="214" width="108" height="10" font="2">sid = threadId st</text>
<text top="760" left="214" width="102" height="10" font="2">idmatch rt rid =</text>
<text top="760" left="328" width="114" height="10" font="2">(rid == anythread)</text>
<text top="783" left="309" width="95" height="10" font="2">|| (rid == sid)</text>
<text top="806" left="309" width="292" height="10" font="2">|| (rid == anylocal &amp;&amp; parent st == parent rt)</text>
<text top="875" left="173" width="626" height="16" font="0">Figure 7.1: The send phase of an IPC operation. This function locates the speciﬁed</text>
<text top="910" left="173" width="626" height="16" font="0">receiver and saves any errors that occur to the sender’s message registers. Mes-</text>
<text top="944" left="173" width="626" height="16" font="0">sage transfer, which we will cover in Section 7.7, is handled by transferMessage.</text>
<text top="979" left="173" width="626" height="16" font="0">The nextPhase utility restarts the sending thread or initiates a receive phase, as</text>
<text top="1014" left="173" width="94" height="16" font="0">appropriate.</text>
</page>
<page number="254" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">232</text>
<text top="163" left="199" width="600" height="16" font="0">We introduce a utility called nextPhase to handle restarting the sending thread</text>
<text top="195" left="173" width="626" height="16" font="0">once the send phase completes. The code for this function is shown in Figure 7.2.</text>
<text top="228" left="173" width="626" height="16" font="0">For send-only IPCs, we resume executing the sending thread immediately. Other-</text>
<text top="260" left="173" width="626" height="16" font="0">wise, we initiate the receive phase of the IPC request as appropriate for the message</text>
<text top="293" left="173" width="626" height="16" font="0">type being processed. If the send was a normal transfer from message registers,</text>
<text top="325" left="173" width="626" height="16" font="0">then the receive parameters come directly from the message registers of the caller</text>
<text top="358" left="173" width="626" height="16" font="0">as well. In all other cases, the kernel forges the parameters for the receive opera-</text>
<text top="390" left="173" width="626" height="16" font="0">tion because it is acting on behalf of a faulting or otherwise incapacitated thread.</text>
<text top="423" left="173" width="626" height="16" font="0">As we saw in the discussion of SendType and RecvType in Section 7.2, many of the</text>
<text top="455" left="173" width="626" height="16" font="0">message types come in pairs: SInterrupt/RInterrupt, SPageFault/RPageFault,</text>
<text top="488" left="173" width="626" height="16" font="0">and SException/RException. In these cases, nextPhase generates a receive re-</text>
<text top="520" left="173" width="626" height="16" font="0">quest of the appropriate type based on information from the current message. An</text>
<text top="554" left="173" width="626" height="15" font="0">SPreempt message does not have a receive phase, but causes the kernel to stop</text>
<text top="585" left="173" width="626" height="16" font="0">the running thread. Senders without a receive phase are restarted immediately or</text>
<text top="618" left="173" width="289" height="16" font="0">added to the kernel’s runnable queue.</text>
<text top="650" left="199" width="600" height="16" font="0">The algorithmic outline for recv is similar to send: locate a sending thread,</text>
<text top="683" left="173" width="626" height="16" font="0">transfer the message to the receiver, signal any error that occurs, and restart the</text>
<text top="715" left="173" width="626" height="16" font="0">sender and receiver. The key diﬀerence between the two phases is that partner</text>
<text top="748" left="173" width="626" height="16" font="0">location is more complicated in the receive phase because threads may request to</text>
<text top="780" left="173" width="626" height="16" font="0">receive a message from a speciﬁc thread (described by its global identiﬁer), any</text>
<text top="813" left="173" width="320" height="16" font="0">local thread, or any thread in the system.</text>
<text top="845" left="199" width="600" height="16" font="0">The ﬁrst step in the receive algorithm is to locate a partner that is waiting to</text>
<text top="878" left="173" width="626" height="16" font="0">send a message to this thread. The receiver may specify a speciﬁc thread as the</text>
<text top="910" left="173" width="626" height="16" font="0">sender using its global ID or the receiver may request to receive from a broader</text>
<text top="943" left="173" width="626" height="16" font="0">group of threads (either any thread in the system or any thread in the thread’s</text>
<text top="975" left="173" width="626" height="16" font="0">local address space). The locatePartner function looks up the Thread structure</text>
<text top="1008" left="173" width="626" height="16" font="0">for a thread that matches the speciﬁcation of the receiving thread. If the receiver</text>
<text top="1040" left="173" width="626" height="16" font="0">speciﬁed a speciﬁc sender, then we read the structure that corresponds to that</text>
</page>
<page number="255" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">233</text>
<text top="302" left="201" width="254" height="10" font="2">nextPhase :: Thread -&gt; Bool -&gt; Kernel ()</text>
<text top="325" left="201" width="121" height="10" font="2">nextPhase t running</text>
<text top="348" left="214" width="127" height="10" font="2">= case (status t) of</text>
<text top="370" left="239" width="235" height="10" font="2">Blocked (Sending pid _ SInterrupt) -&gt;</text>
<text top="393" left="252" width="432" height="10" font="2">insertThread t{status = Blocked (Receiving pid Infinite RInterrupt)}</text>
<text top="416" left="239" width="286" height="10" font="2">Blocked (Sending pid _ (SPageFault _ _ _)) -&gt;</text>
<text top="438" left="252" width="432" height="10" font="2">insertThread t{status = Blocked (Receiving pid Infinite RPageFault)}</text>
<text top="461" left="239" width="286" height="10" font="2">Blocked (Sending pid _ (SException _ _ _)) -&gt;</text>
<text top="484" left="252" width="432" height="10" font="2">insertThread t{status = Blocked (Receiving pid Infinite RException)}</text>
<text top="507" left="239" width="114" height="10" font="2">Blocked (Sending _</text>
<text top="507" left="373" width="191" height="10" font="2">_ FromMRs) | not (halted t) -&gt;</text>
<text top="529" left="252" width="248" height="10" font="2">do from &lt;- readRegister (context t) EDX</text>
<text top="552" left="271" width="127" height="10" font="2">if from == nilthread</text>
<text top="575" left="290" width="178" height="10" font="2">then restartThread t running</text>
<text top="597" left="290" width="279" height="10" font="2">else do tout &lt;- readRegister (context t) ECX</text>
<text top="620" left="341" width="311" height="10" font="2">let rcv = Receiving from (recvTimeout tout) ToMRs</text>
<text top="643" left="366" width="13" height="10" font="2">t’</text>
<text top="643" left="392" width="171" height="10" font="2">= t{ status = Blocked rcv }</text>
<text top="666" left="341" width="95" height="10" font="2">insertThread t’</text>
<text top="688" left="341" width="305" height="10" font="2">if running then recv t’ rcv else insertThread t’</text>
<text top="711" left="239" width="114" height="10" font="2">Blocked (Sending _</text>
<text top="711" left="373" width="114" height="10" font="2">_ (SPreempt _)) -&gt;</text>
<text top="734" left="252" width="127" height="10" font="2">stopThread t running</text>
<text top="756" left="239" width="178" height="10" font="2">_ -&gt; restartThread t running</text>
<text top="845" left="173" width="626" height="16" font="0">Figure 7.2: Restart a sending thread by initiating a receive phase or resuming the</text>
<text top="880" left="173" width="626" height="16" font="0">thread’s execution. The steps to take are determined by the type of the message</text>
<text top="915" left="173" width="626" height="16" font="0">that was just sent and whether or not the sending thread was running at the time</text>
<text top="949" left="173" width="209" height="16" font="0">the message was processed.</text>
</page>
<page number="256" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">234</text>
<text top="203" left="188" width="241" height="10" font="2">recv :: Thread -&gt; IPCType -&gt; Kernel ()</text>
<text top="225" left="188" width="254" height="10" font="2">recv rt recv@(Receiving from tout rtype)</text>
<text top="248" left="201" width="159" height="10" font="2">= do mst &lt;- locatePartner</text>
<text top="271" left="233" width="70" height="10" font="2">case mst of</text>
<text top="294" left="246" width="127" height="10" font="2">Nothing -&gt; noPartner</text>
<text top="316" left="246" width="165" height="10" font="2">Just st -&gt; checkPartner st</text>
<text top="339" left="201" width="32" height="10" font="2">where</text>
<text top="362" left="214" width="451" height="10" font="2">noPartner :: (StateMonad System m, Execution m, KernelMemory m) =&gt; m ()</text>
<text top="384" left="214" width="267" height="10" font="2">noPartner | from == anythread = timeout rt</text>
<text top="407" left="277" width="197" height="10" font="2">| from == anylocal = timeout rt</text>
<text top="430" left="277" width="299" height="10" font="2">| otherwise = recvError rt True rtype NoPartner</text>
<text top="475" left="214" width="470" height="10" font="2">timeout :: (StateMonad System m, Execution m, KernelMemory m) =&gt; Thread -&gt;</text>
<text top="475" left="697" width="25" height="10" font="2">m ()</text>
<text top="498" left="214" width="387" height="10" font="2">timeout rt | tout == Zero = recvError rt True rtype NoPartner</text>
<text top="521" left="284" width="337" height="10" font="2">| otherwise = do insertThread rt{status=Blocked recv}</text>
<text top="543" left="392" width="25" height="10" font="2">done</text>
<text top="589" left="214" width="222" height="10" font="2">checkPartner :: Thread -&gt; Kernel ()</text>
<text top="612" left="214" width="95" height="10" font="2">checkPartner st</text>
<text top="634" left="227" width="235" height="10" font="2">= do mrt’ &lt;- readThread (threadId rt)</text>
<text top="657" left="258" width="146" height="10" font="2">let rt’ = fromJust mrt’</text>
<text top="680" left="258" width="140" height="10" font="2">let rid = threadId rt’</text>
<text top="702" left="258" width="121" height="10" font="2">case (status st) of</text>
<text top="725" left="271" width="286" height="10" font="2">Blocked (Sending sid _ stype) | sid == rid -&gt;</text>
<text top="748" left="284" width="299" height="10" font="2">do ipcerr &lt;- transferMessage st stype rt’ rtype</text>
<text top="771" left="303" width="127" height="10" font="2">if ipcerr == NoError</text>
<text top="793" left="322" width="191" height="10" font="2">then do restartThread rt’ True</text>
<text top="816" left="373" width="114" height="10" font="2">nextPhase st False</text>
<text top="839" left="322" width="248" height="10" font="2">else do recvError rt’ True rtype ipcerr</text>
<text top="861" left="373" width="197" height="10" font="2">sendError st False stype ipcerr</text>
<text top="884" left="271" width="95" height="10" font="2">_ -&gt; timeout rt</text>
<text top="973" left="173" width="626" height="16" font="0">Figure 7.3: The receive phase of an IPC operation. This function locates a sender</text>
<text top="1008" left="173" width="626" height="16" font="0">by looking up a speciﬁed thread or searching the receiver’s waiting queue. When</text>
<text top="1042" left="173" width="626" height="16" font="0">a sender can be found, checkPartner transfers a message from the sender and</text>
<text top="1077" left="173" width="484" height="16" font="0">stores any errors that occur in both threads’ message registers.</text>
</page>
<page number="257" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">235</text>
<text top="163" left="173" width="626" height="16" font="0">thread identiﬁer. If the receiver speciﬁed a broader group of senders, then we</text>
<text top="195" left="173" width="502" height="16" font="0">search the receiver’s waiting queue to ﬁnd an appropriate thread.</text>
<text top="239" left="190" width="515" height="14" font="7">locatePartner :: (StateMonad System m) =&gt; m (Maybe ThreadId)</text>
<text top="266" left="190" width="112" height="14" font="7">locatePartner</text>
<text top="292" left="207" width="146" height="14" font="7">| isGlobalId from</text>
<text top="292" left="379" width="146" height="14" font="7">= readThread from</text>
<text top="318" left="207" width="361" height="14" font="7">| from == anythread = findAny (waiting rt)</text>
<text top="345" left="207" width="155" height="14" font="7">| from == anylocal</text>
<text top="345" left="379" width="232" height="14" font="7">= findLocal (waiting rt) []</text>
<text top="371" left="207" width="95" height="14" font="7">| otherwise</text>
<text top="371" left="379" width="137" height="14" font="7">= return Nothing</text>
<text top="416" left="173" width="626" height="16" font="0">We use the functions findAny and findLocal to search the waiting queue. findAny</text>
<text top="449" left="173" width="626" height="16" font="0">returns the ﬁrst thread identiﬁer in the waiting queue of the receiver. findLocal</text>
<text top="481" left="173" width="626" height="16" font="0">returns the ﬁrst identiﬁer where the thread belongs to the same domain as the</text>
<text top="514" left="173" width="128" height="16" font="0">receiving thread.</text>
<text top="558" left="190" width="60" height="14" font="7">findAny</text>
<text top="558" left="276" width="515" height="14" font="7">:: (StateMonad System m) =&gt; [ThreadId] -&gt; m (Maybe ThreadId)</text>
<text top="584" left="190" width="601" height="14" font="7">findLocal :: (StateMonad System m) =&gt; [ThreadId] -&gt; m (Maybe ThreadId)</text>
<text top="629" left="173" width="626" height="16" font="0">The result of locatePartner is a Maybe Thread to reﬂect the fact that the receiver</text>
<text top="662" left="173" width="626" height="16" font="0">might have speciﬁed the identiﬁer of a thread that does not exist or that the waiting</text>
<text top="694" left="173" width="442" height="16" font="0">queue might be empty (or not contain any local threads).</text>
<text top="727" left="199" width="453" height="16" font="0">The remainder of the code for recv is shown in Figure 7.3.</text>
<text top="788" left="173" width="26" height="16" font="0">7.7</text>
<text top="788" left="219" width="218" height="16" font="0">MESSAGE TRANSFER</text>
<text top="839" left="173" width="626" height="16" font="0">Once the kernel identiﬁes a sender and receiver that are ready to communicate</text>
<text top="871" left="173" width="626" height="16" font="0">via IPC, we are ready to transfer the message from the sender to the receiver.</text>
<text top="904" left="173" width="626" height="16" font="0">In some cases a message transfer simply involves moving data from one location</text>
<text top="936" left="173" width="626" height="16" font="0">to another, but in other situations IPC requires more involved processing by the</text>
<text top="969" left="173" width="626" height="16" font="0">kernel. For example, a thread start-up message signals the kernel to set a thread’s</text>
<text top="1001" left="173" width="626" height="16" font="0">EIP and ESP registers to particular values. Even during normal message transfers,</text>
<text top="1034" left="173" width="626" height="16" font="0">L4 allows users to send typed items to map or grant memory; these items cause</text>
</page>
<page number="258" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">236</text>
<text top="163" left="173" width="626" height="16" font="0">the kernel to modify the address-space of the receiving thread (and sometimes the</text>
<text top="195" left="173" width="365" height="16" font="0">sender as well in the case of a grant operation).</text>
<text top="228" left="199" width="600" height="16" font="0">To handle the complexity of the message transfer operation, we divide the</text>
<text top="260" left="173" width="617" height="16" font="0">implementation into three functions that handle diﬀerent aspects of the process.</text>
<text top="307" left="199" width="600" height="17" font="0">• transferUntyped copies data from the message registers of the sender to</text>
<text top="340" left="217" width="583" height="16" font="0">the message registers of the receiver. This data is not processed by the kernel</text>
<text top="373" left="217" width="87" height="16" font="0">in any way.</text>
<text top="419" left="199" width="600" height="17" font="0">• transferTyped copies typed items from the sender’s message registers to</text>
<text top="453" left="217" width="583" height="16" font="0">the receiver’s message registers. Each typed item corresponds to a memory</text>
<text top="485" left="217" width="582" height="16" font="0">sharing request that potentially aﬀects the address-spaces of the threads and</text>
<text top="518" left="217" width="583" height="16" font="0">the mapping database. We introduce a utility called transferTypedItem</text>
<text top="550" left="217" width="583" height="16" font="0">to handle the processing. transferTyped invokes this utility for each typed</text>
<text top="583" left="217" width="583" height="16" font="0">item being sent and copies the ones that are successfully processed to the</text>
<text top="615" left="217" width="63" height="16" font="0">receiver.</text>
<text top="662" left="199" width="600" height="17" font="0">• transferMessage is the top-level message transfer function. This function</text>
<text top="695" left="217" width="583" height="16" font="0">checks that the type of message being sent and the type of message being re-</text>
<text top="728" left="217" width="583" height="16" font="0">ceived are compatible, and if they are, transferMessage performs any type-</text>
<text top="760" left="217" width="582" height="16" font="0">speciﬁc kernel processing (such as setting EIP). transferMessage invokes</text>
<text top="793" left="217" width="583" height="16" font="0">functions for copying untyped and typed items from the message registers as</text>
<text top="825" left="217" width="404" height="16" font="0">appropriate for the type of message being processed.</text>
<text top="873" left="173" width="626" height="16" font="0">The message transfer function succeeds even when the kernel cannot copy the</text>
<text top="905" left="173" width="626" height="16" font="0">entire message because some of the memory sharing requests were not valid. The</text>
<text top="938" left="173" width="626" height="16" font="0">only failures we encounter in our implementation at this stage are protocol errors;</text>
<text top="970" left="173" width="626" height="16" font="0">these occur when a special message is being sent but the format does not match</text>
<text top="1003" left="173" width="271" height="16" font="0">the format speciﬁed in the L4 API.</text>
<text top="1035" left="199" width="600" height="16" font="0">The transferMessage function takes the sending thread, the type of message</text>
</page>
<page number="259" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">237</text>
<text top="163" left="173" width="626" height="16" font="0">being sent, the receiving thread, and the type of message being received as param-</text>
<text top="195" left="173" width="41" height="16" font="0">eters.</text>
<text top="239" left="190" width="533" height="14" font="7">transferMessage :: Thread -&gt; SendType -&gt; Thread -&gt; ReceiveType</text>
<text top="266" left="370" width="155" height="14" font="7">-&gt; Kernel IPCError</text>
<text top="311" left="173" width="626" height="16" font="0">We introduce one equation for each valid combination of send-type and receive-</text>
<text top="343" left="173" width="626" height="16" font="0">type. Any invalid combinations are caught by a catch-all equation that returns a</text>
<text top="376" left="173" width="111" height="16" font="0">protocol error.</text>
<text top="408" left="199" width="600" height="16" font="0">The ﬁrst equation implements normal message transfer. A description of the</text>
<text top="441" left="173" width="626" height="16" font="0">message is available through the ESI register of the sender, which semantically</text>
<text top="473" left="173" width="167" height="16" font="0">corresponds to MR0.</text>
<text top="473" left="358" width="441" height="16" font="0">This descriptor contains the number of untyped words</text>
<text top="506" left="173" width="395" height="16" font="0">and the number of typed items to be processed.</text>
<text top="507" left="586" width="213" height="15" font="0">transferMessage uses the</text>
<text top="540" left="173" width="562" height="15" font="0">transferUntyped and transferTyped functions to perform the transfer.</text>
<text top="582" left="190" width="301" height="14" font="7">transferMessage st FromMRs rt ToMRs</text>
<text top="608" left="207" width="301" height="14" font="7">= do -- read message information --</text>
<text top="635" left="250" width="309" height="14" font="7">mr0 &lt;- readRegister (context st) ESI</text>
<text top="661" left="250" width="189" height="14" font="7">-- transfer message --</text>
<text top="688" left="250" width="524" height="14" font="7">mrt &lt;- transferUntyped (utcb st) (utcb rt) MR1 (mr0 .&amp;. 0x3f)</text>
<text top="714" left="250" width="447" height="14" font="7">t’ &lt;- transferTyped st rt mrt ((mr0 &gt;&gt;&gt; 6) .&amp;. 0x3f)</text>
<text top="740" left="250" width="266" height="14" font="7">-- store updated message tag --</text>
<text top="767" left="250" width="378" height="14" font="7">let mr0’ = mr0 .&amp;. 0xffff003f .|. (t’ &lt;&lt;&lt; 6)</text>
<text top="793" left="250" width="258" height="14" font="7">-- store sender information --</text>
<text top="820" left="250" width="378" height="14" font="7">writeRegister (context rt) ECX (threadId st)</text>
<text top="846" left="250" width="301" height="14" font="7">writeRegister (context rt) ESI mr0’</text>
<text top="873" left="250" width="120" height="14" font="7">return NoError</text>
<text top="918" left="173" width="626" height="16" font="0">The kernel writes the message descriptor into the receiver’s register, updating the</text>
<text top="950" left="173" width="626" height="16" font="0">number of typed items to reﬂect the number of items that were successfully shared.</text>
<text top="983" left="173" width="515" height="16" font="0">The global identiﬁer of the sender is also passed on to the receiver.</text>
<text top="1015" left="199" width="600" height="16" font="0">To send a page fault message, the kernel writes information describing the fault</text>
<text top="1048" left="173" width="626" height="16" font="0">into the message registers of the receiver. This information includes the address</text>
</page>
<page number="260" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">238</text>
<text top="163" left="173" width="626" height="16" font="0">of the fault, the instruction pointer of the faulting thread, and the permissions</text>
<text top="195" left="173" width="626" height="16" font="0">with which the location was accessed. In addition to transferring the page fault</text>
<text top="228" left="173" width="626" height="16" font="0">data, the kernel constructs a message descriptor for the message and saves it in</text>
<text top="260" left="173" width="149" height="16" font="0">the receiver’s MR0.</text>
<text top="302" left="190" width="455" height="14" font="7">transferMessage st (SPageFault addr eip rwx) rt ToMRs</text>
<text top="328" left="207" width="421" height="14" font="7">= let mr0 = (0xffe &lt;&lt;&lt; 20) .|. (rwx &lt;&lt;&lt; 16) .|. 2</text>
<text top="355" left="224" width="17" height="14" font="7">in</text>
<text top="355" left="259" width="318" height="14" font="7">do writeRegister (context rt) ESI mr0</text>
<text top="381" left="284" width="378" height="14" font="7">writeRegister (context rt) ECX (threadId st)</text>
<text top="407" left="284" width="284" height="14" font="7">writeUTCBField (utcb rt) MR1 addr</text>
<text top="434" left="284" width="275" height="14" font="7">writeUTCBField (utcb rt) MR2 eip</text>
<text top="460" left="284" width="361" height="14" font="7">writeUTCBField (utcb rt) MR3 (threadId st)</text>
<text top="487" left="284" width="309" height="14" font="7">writeUTCBField (utcb st) BR0 (1&lt;&lt;&lt;4)</text>
<text top="513" left="284" width="120" height="14" font="7">return NoError</text>
<text top="556" left="173" width="626" height="16" font="0">The mapping from page fault data to registers is part of an L4 protocol that the</text>
<text top="588" left="173" width="347" height="16" font="0">page fault handler uses to parse the message.</text>
<text top="621" left="199" width="600" height="16" font="0">After processing a page fault, the handler responds by sending a reply to the</text>
<text top="653" left="173" width="626" height="16" font="0">faulting thread. Again, the format is speciﬁed by an L4 protocol. The kernel</text>
<text top="686" left="173" width="626" height="16" font="0">expects a message with a single typed item (which corresponds to two typed-item</text>
<text top="718" left="173" width="626" height="16" font="0">words). This typed item speciﬁes a map or grant item to add to the receiver’s</text>
<text top="751" left="173" width="626" height="16" font="0">address-space that will service the page fault. The kernel processes the typed item</text>
<text top="783" left="173" width="430" height="16" font="0">as with any other using the transferTypedItem utility.</text>
<text top="825" left="190" width="344" height="14" font="7">transferMessage st FromMRs rt RPageFault</text>
<text top="851" left="207" width="352" height="14" font="7">= do mr0 &lt;- readRegister (context st) ESI</text>
<text top="877" left="250" width="258" height="14" font="7">if ((mr0 &gt;&gt;&gt; 6) .&amp;. 0x3f) /= 2</text>
<text top="904" left="276" width="172" height="14" font="7">then return Protocol</text>
<text top="930" left="276" width="412" height="14" font="7">else do mti &lt;- transferTypedItem st MR1 rt False</text>
<text top="957" left="345" width="95" height="14" font="7">case mti of</text>
<text top="983" left="362" width="223" height="14" font="7">Nothing -&gt; return Protocol</text>
<text top="1010" left="362" width="52" height="14" font="7">Just _</text>
<text top="1010" left="431" width="146" height="14" font="7">-&gt; return NoError</text>
<text top="1052" left="173" width="626" height="16" font="0">A protocol error occurs if the message being sent does not have the right format</text>
</page>
<page number="261" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">239</text>
<text top="163" left="173" width="409" height="16" font="0">or if the typed item cannot be processed successfully.</text>
<text top="195" left="199" width="600" height="16" font="0">The remaining equations for transferMessage rely on similar implementation</text>
<text top="228" left="173" width="626" height="16" font="0">techniques to those we have examined so far. For messages being sent in response to</text>
<text top="260" left="173" width="626" height="16" font="0">a fault or exception to a handler, the kernel writes information describing the fault</text>
<text top="293" left="173" width="626" height="16" font="0">into the message registers of the receiver. For messages being sent from message</text>
<text top="325" left="173" width="626" height="16" font="0">registers, the kernel reads the parameters from the registers, checks that they obey</text>
<text top="358" left="173" width="626" height="16" font="0">the appropriate protocol, and updates the receiving thread as appropriate for the</text>
<text top="390" left="173" width="329" height="16" font="0">message type. We omit the complete code.</text>
<text top="423" left="199" width="600" height="16" font="0">The kernel transfers untyped data between threads using transferUntyped.</text>
<text top="455" left="173" width="626" height="16" font="0">This function transfers one untyped item at a time from a speciﬁed source UTCB to</text>
<text top="488" left="173" width="626" height="16" font="0">a speciﬁed destination UTCB. The ﬁeld being copied and the number of remaining</text>
<text top="520" left="173" width="388" height="16" font="0">untyped items in the message are also parameters.</text>
<text top="560" left="190" width="550" height="14" font="7">transferUntyped :: (KernelMemory m) =&gt; UTCB -&gt; UTCB -&gt; UTCBField</text>
<text top="587" left="207" width="198" height="14" font="7">-&gt; HWord -&gt; m UTCBField</text>
<text top="613" left="190" width="284" height="14" font="7">transferUntyped sutcb rutcb f num</text>
<text top="639" left="207" width="86" height="14" font="7">| num &lt;= 0</text>
<text top="639" left="310" width="86" height="14" font="7">= return f</text>
<text top="666" left="207" width="387" height="14" font="7">| otherwise = do val &lt;- readUTCBField sutcb f</text>
<text top="692" left="353" width="223" height="14" font="7">writeUTCBField rutcb f val</text>
<text top="719" left="353" width="395" height="14" font="7">transferUntyped sutcb rutcb (succ f) (num - 1)</text>
<text top="760" left="173" width="626" height="16" font="0">When the number of remaining items reaches zero, transferUntyped returns the</text>
<text top="792" left="173" width="626" height="16" font="0">next ﬁeld where data should be copied from. This will be the starting point for</text>
<text top="825" left="173" width="626" height="16" font="0">transferring typed items. To transfer an untyped item, the function reads a value</text>
<text top="857" left="173" width="585" height="16" font="0">from the UTCB of the source and writes it to the UTCB of the destination.</text>
<text top="890" left="199" width="600" height="16" font="0">The algorithm for transferring typed items is conceptually similar, but is made</text>
<text top="922" left="173" width="626" height="16" font="0">more complicated by the possibility that transferring a typed item can fail. Be-</text>
<text top="955" left="173" width="626" height="16" font="0">cause of this potential failure, we must track the number of typed items that are</text>
<text top="987" left="173" width="626" height="16" font="0">successfully processed so that we can supply this number to the receiver. We must</text>
<text top="1020" left="173" width="626" height="16" font="0">also track the source message register UTCB ﬁeld and the destination message</text>
<text top="1052" left="173" width="626" height="16" font="0">register UTCB ﬁeld separately, because they will not necessarily be the same. We</text>
</page>
<page number="262" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">240</text>
<text top="163" left="173" width="626" height="16" font="0">implement transferTyped using a recursive helper function that tracks all of the</text>
<text top="195" left="173" width="160" height="16" font="0">relevant information.</text>
<text top="239" left="181" width="593" height="14" font="7">transferTyped :: (StateMonad System m, StateMonad [PhysicalRegion] m,</text>
<text top="266" left="336" width="447" height="14" font="7">StateMonad [Addr Virtual] m, StateMonad MappingDB m,</text>
<text top="292" left="336" width="412" height="14" font="7">KernelMemory m, Paging m, UserMemory m, Debug m)</text>
<text top="318" left="345" width="447" height="14" font="7">=&gt; Thread -&gt; Thread -&gt; UTCBField -&gt; HWord -&gt; m HWord</text>
<text top="345" left="181" width="447" height="14" font="7">transferTyped st rt f num = transferTyped’ f f num 0</text>
<text top="371" left="199" width="43" height="14" font="7">where</text>
<text top="398" left="216" width="223" height="14" font="7">transferTyped’ sf rf n acc</text>
<text top="424" left="233" width="69" height="14" font="7">| n &lt;= 0</text>
<text top="424" left="336" width="103" height="14" font="7">= return acc</text>
<text top="451" left="233" width="95" height="14" font="7">| otherwise</text>
<text top="477" left="267" width="404" height="14" font="7">= do mti &lt;- transferTypedItem st sf rt (n /= 0)</text>
<text top="503" left="310" width="95" height="14" font="7">case mti of</text>
<text top="530" left="327" width="412" height="14" font="7">Nothing -&gt; transferTyped’ (next sf) rf (n-1) acc</text>
<text top="556" left="327" width="129" height="14" font="7">Just (w1,w2) -&gt;</text>
<text top="583" left="345" width="284" height="14" font="7">do writeUTCBField (utcb rt) rf w1</text>
<text top="609" left="370" width="318" height="14" font="7">writeUTCBField (utcb rt) (succ rf) w2</text>
<text top="636" left="370" width="412" height="14" font="7">transferTyped’ (next sf) (next rf) (n-1) (acc+1)</text>
<text top="662" left="216" width="155" height="14" font="7">next = succ . succ</text>
<text top="707" left="173" width="626" height="16" font="0">Typed items are processed using transferTypedItem, which is shown in Fig-</text>
<text top="739" left="173" width="626" height="16" font="0">ure 7.4. When a transfer succeeds, transferTyped copies the map or grant item</text>
<text top="772" left="173" width="626" height="16" font="0">into the UTCB ﬁelds of the receiver. In any case, we continue processing the</text>
<text top="804" left="173" width="412" height="16" font="0">message until we reach the end of the typed item list.</text>
<text top="866" left="173" width="26" height="16" font="0">7.8</text>
<text top="866" left="219" width="109" height="16" font="0">SUMMARY</text>
<text top="916" left="173" width="626" height="16" font="0">In this chapter we provided a basic overview of our L4 implementation and an</text>
<text top="949" left="173" width="626" height="16" font="0">in-depth look at our approach to IPC. We will cover the performance of IPC in</text>
<text top="981" left="173" width="626" height="16" font="0">Chapter 8. Table 7.1 describes the size of our L4 kernel, in source lines of code,</text>
<text top="1014" left="173" width="626" height="16" font="0">overall and for our IPC implementation alone. The overall line count includes all of</text>
<text top="1046" left="173" width="626" height="16" font="0">the code (outside of H) in the implementation. This includes our implementation</text>
</page>
<page number="263" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">241</text>
<text top="210" left="188" width="127" height="10" font="2">transferTypedItem ::</text>
<text top="233" left="201" width="514" height="10" font="2">(StateMonad System m, StateMonad [PhysicalRegion] m, StateMonad [Addr Virtual] m,</text>
<text top="256" left="208" width="457" height="10" font="2">StateMonad MappingDB m, KernelMemory m, Paging m, UserMemory m, Debug m)</text>
<text top="278" left="214" width="426" height="10" font="2">=&gt; Thread -&gt; UTCBField -&gt; Thread -&gt; Bool -&gt; m (Maybe (HWord,HWord))</text>
<text top="301" left="188" width="197" height="10" font="2">transferTypedItem st si rt more</text>
<text top="324" left="208" width="57" height="10" font="2">= do base</text>
<text top="324" left="296" width="184" height="10" font="2">&lt;- readUTCBField (utcb st) si</text>
<text top="346" left="239" width="32" height="10" font="2">fpage</text>
<text top="346" left="296" width="229" height="10" font="2">&lt;- readUTCBField (utcb st) (succ si)</text>
<text top="369" left="239" width="248" height="10" font="2">acceptor &lt;- readUTCBField (utcb rt) BR0</text>
<text top="392" left="239" width="438" height="10" font="2">let (snd, rcv) = reconcileFpages fpage acceptor (base .&amp;. 0xfffffc00)</text>
<text top="415" left="239" width="184" height="10" font="2">msd &lt;- readDomain (parent st)</text>
<text top="437" left="239" width="184" height="10" font="2">mrd &lt;- readDomain (parent rt)</text>
<text top="460" left="239" width="114" height="10" font="2">case (msd, mrd) of</text>
<text top="483" left="252" width="133" height="10" font="2">(Just sd, Just rd) -&gt;</text>
<text top="505" left="265" width="171" height="10" font="2">do mpmp &lt;- allocPageMapPage</text>
<text top="528" left="284" width="76" height="10" font="2">case mpmp of</text>
<text top="551" left="296" width="159" height="10" font="2">Nothing -&gt; return Nothing</text>
<text top="574" left="296" width="70" height="10" font="2">Just pmp -&gt;</text>
<text top="596" left="309" width="457" height="10" font="2">do b &lt;- mapFunction (testBit base 1) [pmp] (space sd) snd (space rd) rcv</text>
<text top="619" left="328" width="57" height="10" font="2">case b of</text>
<text top="642" left="341" width="159" height="10" font="2">Nothing -&gt; return Nothing</text>
<text top="664" left="341" width="229" height="10" font="2">Just False -&gt; do freePageMapPage pmp</text>
<text top="687" left="449" width="349" height="10" font="2">return (Just (setBitTo base 0 more, l4FpageToWord rcv))</text>
<text top="710" left="341" width="432" height="10" font="2">Just True -&gt; return (Just (setBitTo base 0 more, l4FpageToWord rcv))</text>
<text top="733" left="252" width="121" height="10" font="2">_ -&gt; return Nothing</text>
<text top="755" left="201" width="32" height="10" font="2">where</text>
<text top="778" left="214" width="368" height="10" font="2">mapFunction b = if b then replaceMapping else shareMapping</text>
<text top="867" left="173" width="626" height="16" font="0">Figure 7.4: Process a single map or grant item. This function uses the operations of</text>
<text top="902" left="173" width="626" height="16" font="0">the mapping database (and in turn H) to modify the address space of the receiving</text>
<text top="936" left="173" width="626" height="16" font="0">thread (in the case of map and grant) and the address space of the sender (in the</text>
<text top="971" left="173" width="626" height="16" font="0">case of grant). The result is an updated typed item that reﬂects any changes</text>
<text top="1006" left="173" width="626" height="16" font="0">made to the mapping area due to a mismatch between the sent ﬂexpage and the</text>
<text top="1040" left="173" width="145" height="16" font="0">receiver’s acceptor.</text>
</page>
<page number="264" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">242</text>
<text top="163" left="173" width="626" height="16" font="0">of thread scheduling, thread creation and deletion, and address-space management.</text>
<text top="237" left="319" width="95" height="15" font="7">Description</text>
<text top="237" left="473" width="175" height="15" font="7">Source Lines of Code</text>
<text top="264" left="319" width="71" height="15" font="7">L4 Kernel</text>
<text top="264" left="544" width="33" height="15" font="7">2119</text>
<text top="291" left="319" width="29" height="15" font="7">IPC</text>
<text top="291" left="548" width="25" height="15" font="7">320</text>
<text top="318" left="319" width="135" height="15" font="7">Mapping Database</text>
<text top="318" left="548" width="25" height="15" font="7">242</text>
<text top="373" left="173" width="626" height="16" font="0">Table 7.1: The source lines of code for our L4 implementation. Source lines of</text>
<text top="408" left="173" width="348" height="16" font="0">code do not include blank lines or comments.</text>
<text top="461" left="173" width="626" height="16" font="0">All of the code was written in Haskell using the H interface; no extra foreign calls</text>
<text top="494" left="173" width="626" height="16" font="0">or potentially unsafe primitives were needed. The total lines of code is just over</text>
<text top="526" left="173" width="626" height="16" font="0">2,100. Even when combined with the size of the primitives for H (presented in</text>
<text top="559" left="173" width="626" height="16" font="0">Section 6.9), the size of the kernel is around 5,300 lines of code. Typical C/C++</text>
<text top="591" left="173" width="626" height="16" font="0">implementations of L4 are around 10,000 lines of code, though this is not truly</text>
<text top="624" left="173" width="626" height="16" font="0">a fair comparison because these other kernels may be more portable or support</text>
<text top="656" left="173" width="626" height="16" font="0">more of the API. Using Haskell does not seem to be a tremendous advantage or</text>
<text top="689" left="173" width="459" height="16" font="0">disadvantage when it comes to code size in this application.</text>
</page>
<page number="265" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">243</text>
<text top="228" left="447" width="77" height="16" font="0">Chapter 8</text>
<text top="279" left="373" width="227" height="16" font="0">PERFORMANCE RESULTS</text>
<text top="371" left="173" width="626" height="16" font="0">In designing and implementing the H interface, our focus is on the safety prop-</text>
<text top="404" left="173" width="626" height="16" font="0">erties of the interface rather than the performance. However, performance is an</text>
<text top="436" left="173" width="626" height="16" font="0">important characteristic of systems software and we must address the performance</text>
<text top="469" left="173" width="626" height="16" font="0">costs that come with our approach to safety. In this chapter, we will evaluate</text>
<text top="501" left="173" width="626" height="16" font="0">the performance of H in the context of the L4 inter-process communication im-</text>
<text top="534" left="173" width="626" height="16" font="0">plementation. We choose to analyze the performance of L4, rather than directly</text>
<text top="566" left="173" width="300" height="16" font="0">examining H, for the following reasons:</text>
<text top="607" left="199" width="600" height="17" font="0">• Comparability: L4 has numerous implementations which allows us to eval-</text>
<text top="640" left="217" width="583" height="16" font="0">uate our performance results against an equivalent system that does not</text>
<text top="673" left="217" width="583" height="16" font="0">contain the safety overheads introduced by an H and that is written in a</text>
<text top="705" left="217" width="583" height="16" font="0">low-level language. There is no directly comparable system to H, so an eval-</text>
<text top="738" left="217" width="440" height="16" font="0">uation of the H primitives in isolation would be artiﬁcial.</text>
<text top="782" left="199" width="600" height="17" font="0">• Relevance: The H interface allows programmers to construct operating</text>
<text top="816" left="217" width="582" height="16" font="0">systems in Haskell. Even if the H primitives are fast, we must consider the</text>
<text top="848" left="217" width="583" height="16" font="0">overheads that stem from writing our operating system on top of the interface</text>
<text top="881" left="217" width="582" height="16" font="0">using Haskell. By using a kernel-level benchmark, we can observe the cost</text>
<text top="913" left="217" width="232" height="16" font="0">of the architecture as a whole.</text>
<text top="955" left="173" width="626" height="16" font="0">By comparing to an optimized C system that does not contain the same kinds of</text>
<text top="987" left="173" width="626" height="16" font="0">safety checks or the additional indirection of a low-level abstraction layer, we can</text>
<text top="1020" left="173" width="626" height="16" font="0">provide an initial estimate of the performance cost of an H-based system compared</text>
<text top="1052" left="173" width="455" height="16" font="0">to a traditional approach to systems software development.</text>
</page>
<page number="266" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">244</text>
<text top="163" left="199" width="600" height="16" font="0">Our goal is to analyze the performance of an H-based system, rather than to</text>
<text top="195" left="173" width="626" height="16" font="0">demonstrate that our L4 kernel achieves performance on par with a production</text>
<text top="228" left="173" width="626" height="16" font="0">C kernel. Neither H nor our implementation of L4 were implemented with per-</text>
<text top="260" left="173" width="626" height="16" font="0">formance or optimization as a priority, so we expect poor performance to start.</text>
<text top="293" left="173" width="626" height="16" font="0">The initial results demonstrate that it is feasible to implement operating systems</text>
<text top="325" left="173" width="626" height="16" font="0">in a safe language without introducing memory-safety violations and to quantify</text>
<text top="358" left="173" width="626" height="16" font="0">the costs of a naive approach to implementing such systems. Much as the L4</text>
<text top="390" left="173" width="626" height="16" font="0">architects demonstrated that microkernels could perform well through targeted</text>
<text top="423" left="173" width="626" height="16" font="0">optimization [70, 71], it might be possible that turning a similar eye to kernels</text>
<text top="455" left="173" width="626" height="16" font="0">built using the H architecture (as well as further research into compiling functional</text>
<text top="488" left="173" width="626" height="16" font="0">languages) will allow us to increase performance and ultimately demonstrate the</text>
<text top="520" left="173" width="302" height="16" font="0">viability of the safe language approach.</text>
<text top="553" left="199" width="600" height="16" font="0">To demonstrate that our initial results do not reﬂect the best possible per-</text>
<text top="585" left="173" width="626" height="16" font="0">formance reachable with our approach, we devote a portion of this chapter to</text>
<text top="618" left="173" width="626" height="16" font="0">optimization techniques for an H-based system. The optimizations improve the</text>
<text top="650" left="173" width="626" height="16" font="0">performance of our IPC implementation signiﬁcantly. We focus our optimization</text>
<text top="683" left="173" width="626" height="16" font="0">energy on the IPC implementation discussed in the previous chapter as a proof of</text>
<text top="715" left="173" width="626" height="16" font="0">concept, but we use general Haskell optimization techniques that can be applied</text>
<text top="748" left="173" width="152" height="16" font="0">to the entire kernel.</text>
<text top="780" left="199" width="600" height="16" font="0">The remainder of this chapter presents our performance analysis. Section 8.1</text>
<text top="813" left="173" width="626" height="16" font="0">describes the mechanisms we use to evaluate IPC, the environment in which we</text>
<text top="845" left="173" width="626" height="16" font="0">run our tests, and the proﬁling techniques we use to measure the Haskell run-time</text>
<text top="878" left="173" width="626" height="16" font="0">system behavior. Section 8.2 presents our initial results. Section 8.3 demonstrates</text>
<text top="910" left="173" width="626" height="16" font="0">techniques for optimizing the key components of an H-based system: the algorithms</text>
<text top="943" left="173" width="626" height="16" font="0">that run on top of the interface, the interface itself, and the code generated by the</text>
<text top="975" left="173" width="626" height="16" font="0">Haskell compiler. Section 8.4 summarizes the eﬀects of our optimizations and our</text>
<text top="1008" left="173" width="211" height="16" font="0">overall performance results.</text>
</page>
<page number="267" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">245</text>
<text top="163" left="173" width="26" height="16" font="0">8.1</text>
<text top="163" left="219" width="452" height="16" font="0">TEST CONSTRUCTION AND MEASUREMENT</text>
<text top="198" left="219" width="159" height="16" font="0">ENVIRONMENT</text>
<text top="248" left="173" width="626" height="16" font="0">The starting point for our performance evaluation is a standard L4 benchmark</text>
<text top="280" left="173" width="626" height="16" font="0">called ping-pong. This benchmark measures IPC performance by creating two</text>
<text top="313" left="173" width="626" height="16" font="0">threads—“ping” and “pong”—and calculating the average time it takes for these</text>
<text top="345" left="173" width="626" height="16" font="0">threads to send and receive a series of IPC messages of diﬀerent sizes. Ping-pong</text>
<text top="378" left="173" width="626" height="16" font="0">can be conﬁgured such that either the threads run in diﬀerent address spaces (an</text>
<text top="410" left="173" width="626" height="16" font="0">inter-address-space measurement); or the threads run in the same address space</text>
<text top="443" left="173" width="626" height="16" font="0">but communicate using the normal IPC system call; or the threads run in the same</text>
<text top="475" left="173" width="626" height="16" font="0">address space and communicate using a special IPC call that is optimized for local</text>
<text top="508" left="173" width="593" height="16" font="0">communication. All of our measurements use the inter-address-space variant.</text>
<text top="540" left="199" width="600" height="16" font="0">Ping-pong reports two statistics about IPC: the average number of CPU cycles</text>
<text top="573" left="173" width="626" height="16" font="0">taken and the average time per message. The cycle count is measured using the</text>
<text top="605" left="173" width="626" height="16" font="0">IA32 instruction rdtsc, which reads the processor’s time-stamp counter register.</text>
<text top="638" left="173" width="626" height="16" font="0">The initial value of the time-stamp counter after a processor reset is zero. Subse-</text>
<text top="670" left="173" width="626" height="16" font="0">quently, the processor increments the time-stamp counter on every clock cycle [53].</text>
<text top="703" left="173" width="626" height="16" font="0">The elapsed time is measured using the L4 system call SystemClock, which reads</text>
<text top="735" left="173" width="626" height="16" font="0">L4’s internal clock. We implement the L4 clock in our kernel by conﬁguring a</text>
<text top="768" left="173" width="626" height="16" font="0">timer at a particular frequency and incrementing the clock appropriately on each</text>
<text top="800" left="173" width="120" height="16" font="0">timer interrupt.</text>
<text top="833" left="199" width="600" height="16" font="0">The source code for our experiments comes from the University of Karlsruhe</text>
<text top="865" left="173" width="626" height="16" font="0">Pistachio distribution of L4 [63]. The following pseudo-code describes the basic</text>
<text top="898" left="173" width="163" height="16" font="0">algorithm of the test:</text>
<text top="942" left="190" width="309" height="14" font="7">create two threads &#34;ping&#34; and &#34;pong&#34;</text>
<text top="968" left="190" width="215" height="14" font="7">for i = 0, 4, 8, ..., 60:</text>
<text top="995" left="224" width="189" height="14" font="7">read clock/cycle count</text>
<text top="1021" left="224" width="146" height="14" font="7">for ROUNDS times:</text>
<text top="1047" left="242" width="326" height="14" font="7">send i words of data from ping to pong</text>
</page>
<page number="268" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">246</text>
<text top="165" left="242" width="326" height="14" font="7">send i words of data from pong to ping</text>
<text top="192" left="224" width="189" height="14" font="7">read clock/cycle count</text>
<text top="218" left="224" width="421" height="14" font="7">compute average cycles and time taken per message</text>
<text top="263" left="173" width="626" height="16" font="0">The loop-variable i controls the amount of data that is transferred by each message</text>
<text top="296" left="173" width="626" height="16" font="0">(in words). We measure the average IPC time for payloads in the range 0 to 60</text>
<text top="328" left="173" width="626" height="16" font="0">words, incrementing the size by 4 words with each loop. ROUNDS controls the</text>
<text top="361" left="173" width="626" height="16" font="0">number of IPC messages that are sent with each payload size. The original source</text>
<text top="393" left="173" width="626" height="16" font="0">code for ping-pong uses a ROUNDS value of 128K. The original source also uses a</text>
<text top="426" left="173" width="626" height="16" font="0">32-bit cycle counter, so we lower the number of ROUNDS in our Haskell benchmarks</text>
<text top="458" left="173" width="245" height="16" font="0">to avoid problems with overﬂow</text>
<text top="456" left="418" width="6" height="11" font="2">1</text>
<text top="458" left="425" width="5" height="16" font="0">.</text>
<text top="491" left="199" width="600" height="16" font="0">We run our experiments on an HP Mini 110 net-book with a 1.66 GHz Atom</text>
<text top="523" left="173" width="626" height="16" font="0">N455 processor with a 512 KB L2 cache and 1 GB of RAM. Our platform during</text>
<text top="556" left="173" width="626" height="16" font="0">development and optimization was a VirtualBox [92] machine with 256 MB of</text>
<text top="588" left="173" width="626" height="16" font="0">RAM running on a 2.33 GHz MacBook Pro. The VirtualBox environment was</text>
<text top="621" left="173" width="626" height="16" font="0">beneﬁcial because it provided fast feedback about changes to the code and made it</text>
<text top="653" left="173" width="626" height="16" font="0">easy to set up new tests. In particular, VirtualBox was very useful for identifying</text>
<text top="686" left="173" width="626" height="16" font="0">the optimal garbage collector settings for the L4 kernel because of the sheer number</text>
<text top="718" left="173" width="626" height="16" font="0">of tests that needed to be evaluated. We discuss the details of the garbage collector</text>
<text top="751" left="173" width="626" height="16" font="0">experiments in Section 8.2.3—these are the only experiments where we will report</text>
<text top="783" left="173" width="465" height="16" font="0">results collected on a virtual platform rather than hardware.</text>
<text top="816" left="199" width="600" height="16" font="0">For all of the experiments, we set the Haskell heap size to 16 MB. Other pa-</text>
<text top="848" left="173" width="626" height="16" font="0">rameters of the garbage collector vary across the test suite. For the initial mea-</text>
<text top="881" left="173" width="626" height="16" font="0">surements, the garbage collector is conﬁgured with the default settings of GHC</text>
<text top="926" left="193" width="6" height="9" font="3">1</text>
<text top="929" left="200" width="434" height="13" font="4">On a 1.66 GHz processor, the 32-bit cycle counter will wrap every 2</text>
<text top="926" left="633" width="12" height="9" font="3">32</text>
<text top="928" left="647" width="152" height="14" font="4">∗(1/1, 660, 000, 000), or</text>
<text top="957" left="173" width="626" height="13" font="4">2.59, seconds. We must choose a value for ROUNDS such that all of the IPC calls will complete</text>
<text top="986" left="173" width="626" height="13" font="4">in less than this amount of time. In our experiments we used a value of 7,128. We decided against</text>
<text top="1015" left="173" width="626" height="13" font="4">changing the source to use a 64-bit cycle counter to minimize the changes to the test harness;</text>
<text top="1044" left="173" width="524" height="14" font="4">the benchmark is already parameterized by ROUNDS so that was a minor change.</text>
</page>
<page number="269" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">247</text>
<text top="163" left="173" width="147" height="16" font="0">(version 6.8.2) [31].</text>
<text top="195" left="199" width="600" height="16" font="0">In the rest of this section, we will provide a closer look at the code being</text>
<text top="228" left="173" width="626" height="16" font="0">evaluated and the Haskell-speciﬁc mechanisms we put in place for measuring our</text>
<text top="260" left="173" width="626" height="16" font="0">kernel. Section 8.1.1 explores the steps taken through the kernel during each IPC</text>
<text top="293" left="173" width="626" height="16" font="0">request; these are the aspects of our implementation that will be measured by</text>
<text top="325" left="173" width="626" height="16" font="0">our experiments. Section 8.1.2 discusses the extensions that we make to H, L4,</text>
<text top="358" left="173" width="626" height="16" font="0">and ping-pong to obtain more detailed information about the performance of our</text>
<text top="390" left="173" width="582" height="16" font="0">Haskell kernel, including the percentage of time spent in garbage collection.</text>
<text top="450" left="173" width="41" height="16" font="0">8.1.1</text>
<text top="450" left="234" width="252" height="16" font="0">Anatomy of an IPC Request</text>
<text top="494" left="173" width="626" height="16" font="0">In this section, we review the steps that an IPC request takes on its way into</text>
<text top="527" left="173" width="626" height="16" font="0">the Haskell kernel as well as the basic components of our IPC implementation.</text>
<text top="559" left="173" width="626" height="16" font="0">Section 6.8 and Chapter 7 cover these topics, respectively. We review the steps</text>
<text top="592" left="173" width="626" height="16" font="0">here in preparation to evaluate the performance of the IPC implementation: we</text>
<text top="624" left="173" width="626" height="16" font="0">will measure the number of cycles that our kernel spends in each phase of the</text>
<text top="657" left="173" width="626" height="16" font="0">implementation in Section 8.2.1. These ﬁne-grained measurements are the starting</text>
<text top="689" left="173" width="626" height="16" font="0">point of our performance analysis. Each phase of the algorithm is a potential</text>
<text top="722" left="173" width="626" height="16" font="0">source of ineﬃciency—and an opportunity for optimization. Figure 8.1 illustrates</text>
<text top="754" left="173" width="524" height="16" font="0">the path of an IPC and the connections between each of the phases.</text>
<text top="812" left="173" width="163" height="16" font="0">Context-Switching</text>
<text top="812" left="354" width="446" height="16" font="0">A user program sends an IPC message by invoking the</text>
<text top="844" left="173" width="626" height="16" font="0">appropriate system call via the IA32 instruction INT n. Control transfers back to H</text>
<text top="877" left="173" width="626" height="16" font="0">via a kernel-mode interrupt handler that gets invoked by the hardware. We resume</text>
<text top="909" left="173" width="626" height="16" font="0">execution in H midway through the execute function—recall from Section 6.8 that</text>
<text top="943" left="173" width="626" height="15" font="0">execute runs a user program by calling out to C—and then we return a description</text>
<text top="974" left="173" width="626" height="16" font="0">of the interrupt to the client kernel. Between the moment when the user program</text>
<text top="1007" left="173" width="626" height="16" font="0">issued the system call interrupt and the moment when the client kernel receives the</text>
</page>
<page number="270" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">248</text>
<text top="523" left="415" width="54" height="15" font="13">hardware</text>
<text top="177" left="233" width="25" height="15" font="13">user</text>
<text top="193" left="222" width="48" height="15" font="13">program</text>
<text top="325" left="223" width="48" height="15" font="13">interrupt</text>
<text top="435" left="323" width="51" height="15" font="13">interrupt </text>
<text top="450" left="327" width="43" height="15" font="13">handler</text>
<text top="466" left="317" width="64" height="15" font="13">(assembly)</text>
<text top="383" left="318" width="60" height="15" font="13">C wrapper</text>
<text top="334" left="306" width="83" height="15" font="13">execute return</text>
<text top="311" left="453" width="62" height="15" font="13">scheduling</text>
<text top="327" left="472" width="25" height="15" font="13">loop</text>
<text top="393" left="438" width="94" height="15" font="13">interrupt decode</text>
<text top="451" left="471" width="28" height="15" font="13">send</text>
<text top="444" left="594" width="40" height="15" font="13">sender</text>
<text top="460" left="580" width="67" height="15" font="13">rendezvous</text>
<text top="331" left="706" width="44" height="15" font="13">transfer</text>
<text top="346" left="705" width="46" height="15" font="13">untyped</text>
<text top="236" left="462" width="42" height="15" font="13">receive</text>
<text top="229" left="595" width="37" height="15" font="13">restart</text>
<text top="244" left="595" width="37" height="15" font="13">thread</text>
<text top="255" left="316" width="60" height="15" font="13">C wrapper</text>
<text top="176" left="322" width="51" height="15" font="13">switch to</text>
<text top="192" left="316" width="61" height="15" font="13">user mode</text>
<text top="310" left="310" width="74" height="15" font="13">execute start</text>
<text top="351" left="591" width="44" height="15" font="13">transfer</text>
<text top="366" left="587" width="53" height="15" font="13">message</text>
<text top="382" left="600" width="25" height="15" font="13">start</text>
<text top="300" left="591" width="44" height="15" font="13">transfer</text>
<text top="316" left="587" width="53" height="15" font="13">message</text>
<text top="331" left="596" width="34" height="15" font="13">return</text>
<text top="601" left="204" width="564" height="16" font="0">Figure 8.1: The ﬂow of execution through the kernel when a user program</text>
<text top="635" left="204" width="564" height="16" font="0">issues an IPC request. The interrupt handler passes control back to H</text>
<text top="670" left="204" width="564" height="16" font="0">which then returns to the client kernel. The client kernel handles the IPC</text>
<text top="705" left="204" width="564" height="16" font="0">request, invokes the scheduler to restart the user program, and calls H to</text>
<text top="739" left="204" width="307" height="16" font="0">switch the processor back to user-mode.</text>
<text top="796" left="173" width="626" height="16" font="0">interrupt information the program passes through an assembly language interrupt-</text>
<text top="828" left="173" width="626" height="16" font="0">handler, a C wrapper for that assembly function, and then ﬁnally enters Haskell.</text>
<text top="861" left="173" width="626" height="16" font="0">The program travels through a similar path in reverse when we return to user-</text>
<text top="893" left="173" width="626" height="16" font="0">mode. We refer to each transition from a user-mode C program to a kernel-mode</text>
<text top="926" left="173" width="380" height="16" font="0">Haskell kernel (or vice versa) as a context switch.</text>
<text top="958" left="199" width="600" height="16" font="0">In Section 8.2.1 we will measure the cost of context switches indirectly by</text>
<text top="991" left="173" width="626" height="16" font="0">computing the diﬀerence between the total time for each IPC and the time that</text>
<text top="1023" left="173" width="626" height="16" font="0">is spent in the Haskell kernel. This technique provides an approximation of the</text>
</page>
<page number="271" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">249</text>
<text top="163" left="173" width="626" height="16" font="0">context-switching cost, but also includes other overheads that have nothing to do</text>
<text top="195" left="173" width="626" height="16" font="0">with context switching. Laziness is one culprit: any computation that has not been</text>
<text top="228" left="173" width="626" height="16" font="0">forced by the time we return to C will be executed before we return to user-mode.</text>
<text top="260" left="173" width="626" height="16" font="0">Thus, it can appear that certain costs are part of context-switching even though</text>
<text top="293" left="173" width="626" height="16" font="0">they originated in a diﬀerent area of the program. In Section 8.2.2 we examine a</text>
<text top="325" left="173" width="626" height="16" font="0">test that speciﬁcally targets context-switching time so that we can obtain a more</text>
<text top="358" left="173" width="176" height="16" font="0">accurate measurement.</text>
<text top="416" left="173" width="95" height="16" font="0">Scheduling</text>
<text top="416" left="285" width="514" height="16" font="0">The scheduling loop manages the execution of user programs. Each</text>
<text top="448" left="173" width="626" height="16" font="0">time we enter the loop, we look for a runnable user thread, load its saved state,</text>
<text top="481" left="173" width="626" height="16" font="0">and run the thread using the execute function from H. When execute returns,</text>
<text top="513" left="173" width="626" height="16" font="0">we decode the interrupt that we received from the user thread and invoke the</text>
<text top="546" left="173" width="259" height="16" font="0">appropriate handler in the kernel.</text>
<text top="578" left="199" width="600" height="16" font="0">The interrupt decoding portion of the scheduling loop is ineﬃcient: at the</text>
<text top="611" left="173" width="626" height="16" font="0">assembly language level we knew precisely which interrupt had occurred but the</text>
<text top="643" left="173" width="626" height="16" font="0">process of returning via execute requires us to decode the interrupt again. We</text>
<text top="676" left="173" width="626" height="16" font="0">could reduce the time spent in scheduling by invoking the appropriate Haskell</text>
<text top="708" left="173" width="626" height="16" font="0">handlers directly without going via execute. Such an approach would require</text>
<text top="741" left="173" width="626" height="16" font="0">some re-architecting of H, but would be feasible if the extra scheduling time turns</text>
<text top="773" left="173" width="626" height="16" font="0">out to be a bottleneck. We measure the scheduling time by subtracting the total</text>
<text top="806" left="173" width="626" height="16" font="0">time spent in the IPC system call handler from the time spent in the Haskell kernel.</text>
<text top="863" left="173" width="170" height="16" font="0">Sender Rendezvous</text>
<text top="863" left="360" width="439" height="16" font="0">The rest of the phases that an IPC request passes through</text>
<text top="896" left="173" width="626" height="16" font="0">are steps in the IPC implementation itself, rather than kernel overheads. In general,</text>
<text top="928" left="173" width="626" height="16" font="0">the path of a particular IPC might vary depending on the type of the IPC request</text>
<text top="961" left="173" width="626" height="16" font="0">(send-only, receive-only, or send-and-receive) and on whether or not the desired</text>
<text top="993" left="173" width="626" height="16" font="0">partner is ready to send or receive. In the IPC messages produced by ping-pong,</text>
<text top="1026" left="173" width="626" height="16" font="0">there is no such variety. Every message is a send-and-receive request and the tests</text>
</page>
<page number="272" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">250</text>
<text top="163" left="173" width="626" height="16" font="0">are structured such that the sender always succeeds in transferring a message while</text>
<text top="195" left="173" width="626" height="16" font="0">the receiver always waits. We take advantage of these patterns when structuring</text>
<text top="228" left="173" width="626" height="16" font="0">our IPC proﬁling points and focus our measurements more heavily on the steps of</text>
<text top="260" left="173" width="294" height="16" font="0">the send phase of the implementation.</text>
<text top="293" left="199" width="600" height="16" font="0">The sender rendezvous phase of IPC is where the sending thread attempts to</text>
<text top="325" left="173" width="626" height="16" font="0">locate the intended receiver of its IPC message. The kernel must look up the cur-</text>
<text top="358" left="173" width="626" height="16" font="0">rent status of the intended receiver to verify that that thread is waiting to receive</text>
<text top="390" left="173" width="626" height="16" font="0">a message from the sending thread. The algorithm is not inherently complex, but</text>
<text top="423" left="173" width="594" height="16" font="0">involves a number of state monad accesses and data structure manipulations.</text>
<text top="481" left="173" width="153" height="16" font="0">Transfer Message</text>
<text top="481" left="344" width="455" height="16" font="0">The transfer message phase performs the real work of IPC.</text>
<text top="513" left="173" width="626" height="16" font="0">It determines the type of IPC message being sent, coordinates the transfer of the</text>
<text top="546" left="173" width="626" height="16" font="0">untyped words and typed data from the sender to the receiver (as appropriate</text>
<text top="578" left="173" width="626" height="16" font="0">for the message type), and updates the message registers of the receiver with a</text>
<text top="611" left="173" width="626" height="16" font="0">description of the message. For evaluation purposes, we measure the time spent</text>
<text top="643" left="173" width="626" height="16" font="0">in transfer message and the time spent in the transfer untyped phase (the phase</text>
<text top="676" left="173" width="316" height="16" font="0">that transfers untyped words) separately.</text>
<text top="733" left="173" width="157" height="16" font="0">Transfer Untyped</text>
<text top="733" left="347" width="452" height="16" font="0">The transfer untyped phase copies the untyped words of a</text>
<text top="766" left="173" width="626" height="16" font="0">message from the sender to the receiver. Most of the cost of an IPC message comes</text>
<text top="798" left="173" width="626" height="16" font="0">from this phase, and we will take an in-depth look at the cost of our implementation</text>
<text top="831" left="173" width="109" height="16" font="0">in Section 8.3.</text>
<text top="888" left="173" width="138" height="16" font="0">Thread Restart</text>
<text top="888" left="329" width="470" height="16" font="0">Once the kernel transfers a message from the sender to the</text>
<text top="921" left="173" width="626" height="16" font="0">receiver, both threads are ready to run again. The receiver automatically be-</text>
<text top="953" left="173" width="626" height="16" font="0">comes runnable—there is no other state the thread can enter. The sender becomes</text>
<text top="986" left="173" width="626" height="16" font="0">runnable unless their IPC request also included a receive phase. In that case, the</text>
<text top="1018" left="173" width="626" height="16" font="0">kernel constructs the appropriate receive request and invokes the receive phase of</text>
<text top="1051" left="173" width="626" height="16" font="0">the implementation. The thread restart cost is the time between the completion</text>
</page>
<page number="273" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">251</text>
<text top="163" left="173" width="626" height="16" font="0">of the transfer message phase and the start of the receive phase (all send requests</text>
<text top="195" left="173" width="390" height="16" font="0">in the ping-pong test also include a receive phase).</text>
<text top="253" left="173" width="127" height="16" font="0">Receive Phase</text>
<text top="253" left="317" width="482" height="16" font="0">The receive phase encompasses all of the work done to receive</text>
<text top="286" left="173" width="626" height="16" font="0">a message. In the ping-pong tests, we know by construction that the messages are</text>
<text top="318" left="173" width="626" height="16" font="0">always transferred in the send phase and that the receiver always blocks. Thus,</text>
<text top="351" left="173" width="626" height="16" font="0">our measurements of the receive phase examine the cost of searching for an accept-</text>
<text top="383" left="173" width="626" height="16" font="0">able sender and blocking when such a sender is not found. There is an inherent</text>
<text top="416" left="173" width="626" height="16" font="0">ineﬃciency in our implementation with respect to this benchmark: we know that</text>
<text top="448" left="173" width="626" height="16" font="0">the sender cannot complete its receive phase because the intended partner of the</text>
<text top="481" left="173" width="626" height="16" font="0">receive phase just became runnable (the intended sender is the thread that was</text>
<text top="513" left="173" width="626" height="16" font="0">the receiver in the last message transfer). All of the computation spent looking</text>
<text top="546" left="173" width="626" height="16" font="0">up the sender is wasted. A future optimization would be to prioritize the thread</text>
<text top="578" left="173" width="626" height="16" font="0">that just unblocked (because it is runnable) or to check if the receive phase will be</text>
<text top="611" left="173" width="626" height="16" font="0">pointless in advance. There are papers that study these kinds of trade-oﬀs for L4</text>
<text top="643" left="173" width="164" height="16" font="0">implementations [80].</text>
<text top="703" left="173" width="41" height="16" font="0">8.1.2</text>
<text top="703" left="234" width="281" height="16" font="0">Haskell Proﬁling on Bare Metal</text>
<text top="747" left="173" width="626" height="16" font="0">The ping-pong benchmark from Pistachio [63] reports two statistics about the pro-</text>
<text top="779" left="173" width="626" height="16" font="0">gram under test: the average cycles taken per message transfer and the average</text>
<text top="812" left="173" width="626" height="16" font="0">time taken per message transfer (in microseconds). The cycle count is collected</text>
<text top="844" left="173" width="626" height="16" font="0">via rdtsc and the microsecond count is determined by querying the L4 System-</text>
<text top="877" left="173" width="626" height="16" font="0">Clock system call. In a Haskell program, there are additional sources of potential</text>
<text top="909" left="173" width="626" height="16" font="0">ineﬃciencies that are not easily measured using the existing system calls or hard-</text>
<text top="942" left="173" width="626" height="16" font="0">ware functions, such as the amount of time spent in garbage collection. To help</text>
<text top="974" left="173" width="626" height="16" font="0">us understand our performance results more deeply, we extended our H and L4</text>
<text top="1007" left="173" width="626" height="16" font="0">implementations to support the collection of rdtsc-style cycle counts from within</text>
<text top="1039" left="173" width="626" height="16" font="0">Haskell and to support some simple garbage collection proﬁling. This section will</text>
</page>
<page number="274" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">252</text>
<text top="163" left="173" width="363" height="16" font="0">cover some details of these proﬁling extensions.</text>
<text top="195" left="199" width="600" height="16" font="0">Note that the standard distribution of GHC includes sophisticated proﬁling</text>
<text top="228" left="173" width="626" height="16" font="0">tools for understanding the performance of Haskell programs [91]. Unfortunately,</text>
<text top="260" left="173" width="626" height="16" font="0">our bare metal port of the GHC run-time system cannot support the usual proﬁling</text>
<text top="293" left="173" width="626" height="16" font="0">mechanisms, because they rely heavily on OS-level timing facilities for collecting</text>
<text top="325" left="173" width="626" height="16" font="0">data and on an underlying ﬁle system for reporting the data. Ultimately, adapting</text>
<text top="358" left="173" width="626" height="16" font="0">the real proﬁling tools to work in a bare metal environment would be a valuable</text>
<text top="390" left="173" width="626" height="16" font="0">exercise that would greatly improve our ability to understand the performance of</text>
<text top="423" left="173" width="626" height="16" font="0">Haskell kernels. The proﬁling tools presented here are a stop-gap to enable us to</text>
<text top="455" left="173" width="495" height="16" font="0">collect data without spending too much extra engineering eﬀort.</text>
<text top="513" left="173" width="257" height="16" font="0">Garbage Collection Proﬁling</text>
<text top="513" left="447" width="352" height="16" font="0">Dynamic memory management with garbage</text>
<text top="546" left="173" width="626" height="16" font="0">collection is a key mechanism for enforcing memory-safety in Haskell, but it is</text>
<text top="578" left="173" width="626" height="16" font="0">important to understand the overheads that it introduces. We implement basic</text>
<text top="611" left="173" width="626" height="16" font="0">garbage collection proﬁling tools that allow us to determine how much of our exe-</text>
<text top="643" left="173" width="626" height="16" font="0">cution time is being spent on garbage collection, the eﬀect of various optimizations</text>
<text top="676" left="173" width="626" height="16" font="0">on the garbage collection behavior of the program, and the impact of diﬀerent run-</text>
<text top="708" left="173" width="626" height="16" font="0">time system parameter settings. To implement these tools, we must extend the</text>
<text top="741" left="173" width="626" height="16" font="0">run-time system of GHC to track the information of interest. This information is</text>
<text top="773" left="173" width="626" height="16" font="0">in turn exported via H and L4 so that we can query the garbage collection statistics</text>
<text top="806" left="173" width="155" height="16" font="0">from user programs.</text>
<text top="838" left="199" width="600" height="16" font="0">In GHC, garbage collection occurs in a run-time system function that is called</text>
<text top="872" left="173" width="626" height="15" font="0">GarbageCollect. Because of the proﬁling tools that are normally part of GHC,</text>
<text top="903" left="173" width="626" height="16" font="0">the GarbageCollect function already contains hooks to support statistics gather-</text>
<text top="936" left="173" width="626" height="16" font="0">ing and program proﬁling. At the start of every garbage collection, the function</text>
<text top="970" left="173" width="626" height="15" font="0">stat_startGC is called. Normally, this function starts any garbage collection re-</text>
<text top="1001" left="173" width="626" height="16" font="0">lated statistics gathering. At the end of every garbage collection, an analogous</text>
<text top="1033" left="173" width="243" height="16" font="0">function, stat_endGC, is called.</text>
</page>
<page number="275" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">253</text>
<text top="165" left="190" width="223" height="14" font="7">void GarbageCollect(...) {</text>
<text top="192" left="207" width="189" height="14" font="7">... initialization ...</text>
<text top="218" left="207" width="129" height="14" font="7">stat_startGC();</text>
<text top="245" left="207" width="241" height="14" font="7">.. do garbage collection ...</text>
<text top="271" left="207" width="112" height="14" font="7">stat_endGC();</text>
<text top="297" left="207" width="137" height="14" font="7">... clean up ...</text>
<text top="324" left="190" width="9" height="14" font="7">}</text>
<text top="369" left="173" width="626" height="16" font="0">We add our proﬁling instrumentation to stat_startGC and stat_endGC to guar-</text>
<text top="401" left="173" width="626" height="16" font="0">antee that the code is called exactly once per garbage collection. We introduce</text>
<text top="434" left="173" width="626" height="16" font="0">a run-time system variable that counts the number of garbage collections (incre-</text>
<text top="466" left="173" width="626" height="16" font="0">mented in stat_startGC) and a variable that accumulates the number of cycles</text>
<text top="499" left="173" width="626" height="16" font="0">spent in garbage collection throughout the life of the system. We compute the</text>
<text top="531" left="173" width="626" height="16" font="0">cycle count by querying rdtsc once in stat_startGC and once in stat_endGC</text>
<text top="564" left="173" width="352" height="16" font="0">and adding the diﬀerence to our accumulator.</text>
<text top="596" left="199" width="600" height="16" font="0">To collect the garbage collection statistics, we need to export the values of our</text>
<text top="629" left="173" width="626" height="16" font="0">counters through the H interface to the client kernel. We export the run-time</text>
<text top="661" left="173" width="626" height="16" font="0">system accessor functions to the client by adding straightforward FFI wrappers of</text>
<text top="694" left="173" width="626" height="16" font="0">the functions to the H interface. These H functions allow the client to query the</text>
<text top="726" left="173" width="519" height="16" font="0">garbage collection statistics, but do not introduce any safety issues.</text>
<text top="770" left="190" width="438" height="14" font="7">foreign import ccall unsafe &#34;getGarbageCollections&#34;</text>
<text top="797" left="207" width="301" height="14" font="7">getGarbageCollections :: IO HWord64</text>
<text top="849" left="190" width="258" height="14" font="7">getNumCollections :: H HWord64</text>
<text top="876" left="190" width="430" height="14" font="7">getNumCollections = liftIO $ getGarbageCollections</text>
<text top="929" left="190" width="438" height="14" font="7">foreign import ccall unsafe &#34;stat_getElapsedGCTime&#34;</text>
<text top="955" left="207" width="258" height="14" font="7">getElapsedGCTime :: IO HWord64</text>
<text top="1008" left="190" width="258" height="14" font="7">getCollectionTime :: H HWord64</text>
<text top="1034" left="190" width="387" height="14" font="7">getCollectionTime = liftIO $ getElapsedGCTime</text>
</page>
<page number="276" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">254</text>
<text top="163" left="173" width="626" height="16" font="0">We also add two new system calls to our L4 kernel so that user programs can</text>
<text top="195" left="173" width="626" height="16" font="0">query the current number of garbage collections and the time spent in garbage</text>
<text top="228" left="173" width="626" height="16" font="0">collection throughout the kernel’s execution so far. Our version of ping-pong uses</text>
<text top="260" left="173" width="626" height="16" font="0">these system calls to integrate garbage collection statistics into the experimental</text>
<text top="293" left="173" width="293" height="16" font="0">results that are reported for each test.</text>
<text top="351" left="173" width="168" height="16" font="0">In-Kernel Proﬁling</text>
<text top="351" left="358" width="441" height="16" font="0">Haskell programs do not have access to the normal hard-</text>
<text top="383" left="173" width="626" height="16" font="0">ware mechanisms for taking timing measurements without making a foreign func-</text>
<text top="416" left="173" width="626" height="16" font="0">tion call. But client kernels are not allowed to invoke the foreign functions directly,</text>
<text top="448" left="173" width="626" height="16" font="0">so we extend H with an interface to the rdtsc counter to allow in-kernel proﬁling</text>
<text top="481" left="173" width="626" height="16" font="0">measurements. The in-kernel proﬁling tools allow us to start and stop cycle count</text>
<text top="513" left="173" width="626" height="16" font="0">measurements at any point in our Haskell code so that we can obtain ﬁne-grained</text>
<text top="546" left="173" width="626" height="16" font="0">information about where time is being spent. To support in-kernel proﬁling, we</text>
<text top="578" left="173" width="475" height="16" font="0">add three new functions to the Debug class of the H interface:</text>
<text top="622" left="190" width="284" height="14" font="7">startMeasurement :: HWord -&gt; H ()</text>
<text top="648" left="190" width="129" height="14" font="7">stopMeasurement</text>
<text top="648" left="336" width="137" height="14" font="7">:: HWord -&gt; H ()</text>
<text top="675" left="190" width="129" height="14" font="7">readMeasurement</text>
<text top="675" left="336" width="180" height="14" font="7">:: HWord -&gt; H HWord32</text>
<text top="720" left="173" width="626" height="16" font="0">Each function takes a word as a parameter: this word is an identiﬁer for the mea-</text>
<text top="752" left="173" width="626" height="16" font="0">surement being taken. We allow a ﬁxed number of simultaneous measurements;</text>
<text top="785" left="173" width="626" height="16" font="0">the maximum is arbitrarily set to eight. The semantics of each function is straight-</text>
<text top="817" left="173" width="626" height="16" font="0">forward: startMeasurement starts the timer for a particular measurement using</text>
<text top="851" left="173" width="626" height="15" font="0">rdtsc; stopMeasurement stops a measurement; and readMeasurement returns the</text>
<text top="882" left="173" width="626" height="16" font="0">average number of cycles taken for a particular measurement. The counter is reset</text>
<text top="915" left="173" width="626" height="16" font="0">every time that the measurement is read. Although this is not a good design for a</text>
<text top="947" left="173" width="516" height="16" font="0">general proﬁling suite, it was well-suited to our particular use-case.</text>
<text top="980" left="199" width="600" height="16" font="0">We implement the measurement functions in C so that we can access the rdtsc</text>
<text top="1012" left="173" width="337" height="16" font="0">counter using inline assembly instructions.</text>
<text top="1012" left="526" width="273" height="16" font="0">The H functions that are exposed</text>
<text top="1045" left="173" width="626" height="16" font="0">to client kernels simply lift the C functions into Haskell. As with the garbage</text>
</page>
<page number="277" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">255</text>
<text top="163" left="173" width="626" height="16" font="0">collection proﬁling functions, we add a system call that allows the user program</text>
<text top="195" left="173" width="626" height="16" font="0">to call the readMeasurement function so that we can report the results of in-</text>
<text top="228" left="173" width="626" height="16" font="0">kernel proﬁling from the user-level program. This approach minimizes the extent</text>
<text top="260" left="173" width="626" height="16" font="0">to which the proﬁling extensions impact the performance results. By designing</text>
<text top="294" left="173" width="626" height="15" font="0">readMeasurement to compute the average cycle count and clear the counter, we</text>
<text top="325" left="173" width="457" height="16" font="0">only needed to expose one primitive to user-level programs.</text>
<text top="387" left="173" width="26" height="16" font="0">8.2</text>
<text top="387" left="219" width="262" height="16" font="0">INITIAL MEASUREMENTS</text>
<text top="437" left="173" width="626" height="16" font="0">The initial measurements of our L4 kernel using ping-pong reﬂect the performance</text>
<text top="470" left="173" width="626" height="16" font="0">of a naive H-based operating system without any optimization. We choose these</text>
<text top="502" left="173" width="626" height="16" font="0">measurements as our starting point to provide a baseline against which to compare</text>
<text top="535" left="173" width="626" height="16" font="0">our optimized implementations. Section 8.2.1 presents the initial results for the</text>
<text top="567" left="173" width="626" height="16" font="0">Haskell kernel including a breakdown of the time spent in each phase of IPC.</text>
<text top="600" left="173" width="626" height="16" font="0">Section 8.2.2 takes an in-depth look at the cost of context-switching between a</text>
<text top="632" left="173" width="626" height="16" font="0">kernel written in Haskell and a user program written C. Section 8.2.3 examines the</text>
<text top="665" left="173" width="626" height="16" font="0">role of garbage collection in the initial results and provides a comparison between</text>
<text top="697" left="173" width="312" height="16" font="0">diﬀerent run-time system conﬁgurations.</text>
<text top="757" left="173" width="41" height="16" font="0">8.2.1</text>
<text top="757" left="234" width="210" height="16" font="0">Ping-Pong Performance</text>
<text top="801" left="173" width="626" height="16" font="0">We expect there to be costs that accompany the use of an H-based architecture.</text>
<text top="834" left="173" width="626" height="16" font="0">The additional dynamic checks that we include in the H primitives to enforce</text>
<text top="866" left="173" width="626" height="16" font="0">memory-safety, the abstraction barrier that we place between the client kernel</text>
<text top="899" left="173" width="626" height="16" font="0">and the machine, and our choice of Haskell as an implementation language are</text>
<text top="931" left="173" width="626" height="16" font="0">all potential drains on performance. We compare the performance of our kernel</text>
<text top="964" left="173" width="626" height="16" font="0">to the Pistachio distribution [63] of L4 to obtain a real measure of the cost of</text>
<text top="996" left="173" width="626" height="16" font="0">safety in our approach. Pistachio is written in C++ and is highly optimized,</text>
<text top="1029" left="173" width="626" height="16" font="0">so it serves as a reasonable representative of the “typical” approach to operating</text>
</page>
<page number="278" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">256</text>
<text top="163" left="173" width="626" height="16" font="0">systems. Furthermore, Pistachio is based on the same version of the L4 API as our</text>
<text top="195" left="173" width="626" height="16" font="0">implementation (X2 [62]), so the two kernels are directly comparable in terms of</text>
<text top="228" left="173" width="626" height="16" font="0">functionality. We use the Pistachio implementation of ping-pong for all of our IPC</text>
<text top="260" left="173" width="626" height="16" font="0">measurements. Table 8.1 shows the results from running the inter-address-space</text>
<text top="293" left="173" width="569" height="16" font="0">variant of ping-pong on Pistachio for a one-way IPC on our test platform.</text>
<text top="340" left="401" width="48" height="13" font="4">Words</text>
<text top="340" left="472" width="49" height="13" font="4">Cycles</text>
<text top="340" left="550" width="16" height="13" font="4">µs</text>
<text top="369" left="442" width="7" height="13" font="4">0</text>
<text top="369" left="486" width="34" height="13" font="4">1,270</text>
<text top="369" left="539" width="27" height="13" font="4">0.76</text>
<text top="399" left="442" width="7" height="13" font="4">4</text>
<text top="399" left="486" width="34" height="13" font="4">1,332</text>
<text top="399" left="539" width="27" height="13" font="4">0.80</text>
<text top="428" left="442" width="7" height="13" font="4">8</text>
<text top="428" left="486" width="34" height="13" font="4">1,337</text>
<text top="428" left="539" width="27" height="13" font="4">0.80</text>
<text top="457" left="435" width="15" height="13" font="4">12</text>
<text top="457" left="486" width="34" height="13" font="4">1,348</text>
<text top="457" left="539" width="27" height="13" font="4">0.81</text>
<text top="487" left="435" width="15" height="13" font="4">16</text>
<text top="487" left="486" width="34" height="13" font="4">1,354</text>
<text top="487" left="539" width="27" height="13" font="4">0.81</text>
<text top="516" left="435" width="15" height="13" font="4">20</text>
<text top="516" left="486" width="34" height="13" font="4">1,365</text>
<text top="516" left="539" width="27" height="13" font="4">0.82</text>
<text top="545" left="435" width="15" height="13" font="4">24</text>
<text top="545" left="486" width="34" height="13" font="4">1,371</text>
<text top="545" left="539" width="27" height="13" font="4">0.82</text>
<text top="574" left="435" width="15" height="13" font="4">28</text>
<text top="574" left="486" width="34" height="13" font="4">1,379</text>
<text top="574" left="539" width="27" height="13" font="4">0.82</text>
<text top="604" left="435" width="15" height="13" font="4">32</text>
<text top="604" left="486" width="34" height="13" font="4">1,389</text>
<text top="604" left="539" width="27" height="13" font="4">0.83</text>
<text top="633" left="435" width="15" height="13" font="4">36</text>
<text top="633" left="486" width="34" height="13" font="4">1,395</text>
<text top="633" left="539" width="27" height="13" font="4">0.83</text>
<text top="662" left="435" width="15" height="13" font="4">40</text>
<text top="662" left="486" width="34" height="13" font="4">1,405</text>
<text top="662" left="539" width="27" height="13" font="4">0.84</text>
<text top="692" left="435" width="15" height="13" font="4">44</text>
<text top="692" left="486" width="34" height="13" font="4">1,410</text>
<text top="692" left="539" width="27" height="13" font="4">0.84</text>
<text top="721" left="435" width="15" height="13" font="4">48</text>
<text top="721" left="486" width="34" height="13" font="4">1,422</text>
<text top="721" left="539" width="27" height="13" font="4">0.85</text>
<text top="750" left="435" width="15" height="13" font="4">52</text>
<text top="750" left="486" width="34" height="13" font="4">1,427</text>
<text top="750" left="539" width="27" height="13" font="4">0.85</text>
<text top="779" left="435" width="15" height="13" font="4">56</text>
<text top="779" left="486" width="34" height="13" font="4">1,435</text>
<text top="779" left="539" width="27" height="13" font="4">0.86</text>
<text top="809" left="435" width="15" height="13" font="4">60</text>
<text top="809" left="486" width="34" height="13" font="4">1,446</text>
<text top="809" left="539" width="27" height="13" font="4">0.86</text>
<text top="845" left="173" width="626" height="16" font="0">Table 8.1: Result of running ping-pong on Pistachio in our experimental envi-</text>
<text top="879" left="173" width="626" height="16" font="0">ronment. Ping-pong tests the average number of cycles and average time in mi-</text>
<text top="914" left="173" width="626" height="16" font="0">croseconds required to send various numbers of words over IPC (from 0 to 60 in</text>
<text top="949" left="173" width="129" height="16" font="0">increments of 4).</text>
<text top="1003" left="199" width="600" height="16" font="0">To test the Haskell kernel, we run a slightly modiﬁed version of ping-pong that</text>
<text top="1036" left="173" width="626" height="16" font="0">reports garbage collection statistics in addition to the standard results. We use</text>
</page>
<page number="279" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">257</text>
<text top="163" left="173" width="626" height="16" font="0">the garbage collection proﬁling from Section 8.1.2 to calculate the total number</text>
<text top="195" left="173" width="626" height="16" font="0">of garbage collections that occur during all IPC messages of a certain size (for</text>
<text top="228" left="173" width="626" height="16" font="0">example, 321 garbage collections occur when testing IPC with a payload of zero</text>
<text top="260" left="173" width="626" height="16" font="0">words). We use a total count of garbage collections rather than an average per</text>
<text top="293" left="173" width="626" height="16" font="0">message because the number of collections per message is less than one. Table 8.2</text>
<text top="325" left="173" width="205" height="16" font="0">presents our initial results.</text>
<text top="358" left="199" width="600" height="16" font="0">We expected the performance of our initial implementation to be poor, but</text>
<text top="390" left="173" width="626" height="16" font="0">even so these results are a bit disappointing. Examining the data, we see that our</text>
<text top="423" left="173" width="626" height="16" font="0">kernel takes roughly 30,000 additional cycles for every additional 4 words of data</text>
<text top="455" left="173" width="626" height="16" font="0">that we transfer. When we do not transfer any words of data, the Haskell kernel</text>
<text top="488" left="173" width="626" height="16" font="0">is 67 times worse than Pistachio, but by the time we reach 60 words our kernel is</text>
<text top="520" left="173" width="626" height="16" font="0">368 times worse. We might expect a high cost for using the H interface, but would</text>
<text top="553" left="173" width="626" height="16" font="0">not expect such a large number of cycles to be spent for each word transferred.</text>
<text top="585" left="173" width="626" height="16" font="0">This suggests that something costly is happening in the routine that transfers data</text>
<text top="618" left="173" width="281" height="16" font="0">between the sender and the receiver.</text>
<text top="650" left="199" width="600" height="16" font="0">Our understanding of the algorithmic structure of the code suggests that we</text>
<text top="683" left="173" width="626" height="16" font="0">should examine the transferUntyped function that copies untyped words from</text>
<text top="715" left="173" width="626" height="16" font="0">the sender to the receiver. We use the in-kernel proﬁling tools introduced in Sec-</text>
<text top="748" left="173" width="626" height="16" font="0">tion 8.1.2 to calculate the number of cycles that are spent in that function (on</text>
<text top="780" left="173" width="626" height="16" font="0">average). We also measure the average cycles spent in the other phases of IPC</text>
<text top="813" left="173" width="626" height="16" font="0">discussed in Section 8.1.1: overhead/context-switching, scheduling, sender ren-</text>
<text top="845" left="173" width="626" height="16" font="0">dezvous, transfer message, thread restart, receive phase, and garbage collection.</text>
<text top="878" left="173" width="626" height="16" font="0">The measurements for these phases are shown in Table 8.3. By measuring each</text>
<text top="910" left="173" width="626" height="16" font="0">phase of the algorithm, we can determine the most proﬁtable places to spend our</text>
<text top="943" left="173" width="626" height="16" font="0">optimization energy and learn more about the behavior of our program. Note that</text>
<text top="975" left="173" width="626" height="16" font="0">the total cycles per IPC is worse for the measurements that use in-kernel proﬁling;</text>
<text top="1008" left="173" width="572" height="16" font="0">this slowdown is due to the cost of the proﬁling measurements themselves.</text>
</page>
<page number="280" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">258</text>
<text top="168" left="352" width="48" height="13" font="4">Words</text>
<text top="168" left="423" width="49" height="13" font="4">Cycles</text>
<text top="168" left="497" width="16" height="13" font="4">µs</text>
<text top="168" left="532" width="33" height="13" font="4">GCs</text>
<text top="167" left="587" width="28" height="14" font="4">× P</text>
<text top="197" left="393" width="7" height="13" font="4">0</text>
<text top="197" left="430" width="42" height="13" font="4">85,223</text>
<text top="197" left="497" width="15" height="13" font="4">53</text>
<text top="197" left="542" width="22" height="13" font="4">321</text>
<text top="197" left="600" width="15" height="13" font="4">67</text>
<text top="226" left="393" width="7" height="13" font="4">4</text>
<text top="226" left="422" width="49" height="13" font="4">119,324</text>
<text top="226" left="497" width="15" height="13" font="4">73</text>
<text top="226" left="542" width="22" height="13" font="4">451</text>
<text top="226" left="600" width="15" height="13" font="4">90</text>
<text top="256" left="393" width="7" height="13" font="4">8</text>
<text top="256" left="422" width="49" height="13" font="4">149,068</text>
<text top="256" left="497" width="15" height="13" font="4">89</text>
<text top="256" left="542" width="22" height="13" font="4">583</text>
<text top="256" left="593" width="22" height="13" font="4">111</text>
<text top="285" left="385" width="15" height="13" font="4">12</text>
<text top="285" left="422" width="49" height="13" font="4">178,781</text>
<text top="285" left="490" width="22" height="13" font="4">106</text>
<text top="285" left="542" width="22" height="13" font="4">715</text>
<text top="285" left="593" width="22" height="13" font="4">133</text>
<text top="314" left="385" width="15" height="13" font="4">16</text>
<text top="314" left="422" width="49" height="13" font="4">208,498</text>
<text top="314" left="490" width="22" height="13" font="4">126</text>
<text top="314" left="542" width="22" height="13" font="4">845</text>
<text top="314" left="593" width="22" height="13" font="4">154</text>
<text top="343" left="385" width="15" height="13" font="4">20</text>
<text top="343" left="422" width="49" height="13" font="4">237,995</text>
<text top="343" left="490" width="22" height="13" font="4">142</text>
<text top="343" left="542" width="22" height="13" font="4">978</text>
<text top="343" left="593" width="22" height="13" font="4">174</text>
<text top="373" left="385" width="15" height="13" font="4">24</text>
<text top="373" left="422" width="49" height="13" font="4">267,410</text>
<text top="373" left="490" width="22" height="13" font="4">162</text>
<text top="373" left="531" width="34" height="13" font="4">1,109</text>
<text top="373" left="593" width="22" height="13" font="4">195</text>
<text top="402" left="385" width="15" height="13" font="4">28</text>
<text top="402" left="422" width="49" height="13" font="4">296,954</text>
<text top="402" left="490" width="22" height="13" font="4">179</text>
<text top="402" left="531" width="34" height="13" font="4">1,240</text>
<text top="402" left="593" width="22" height="13" font="4">215</text>
<text top="431" left="385" width="15" height="13" font="4">32</text>
<text top="431" left="422" width="49" height="13" font="4">326,074</text>
<text top="431" left="490" width="22" height="13" font="4">195</text>
<text top="431" left="531" width="34" height="13" font="4">1,373</text>
<text top="431" left="593" width="22" height="13" font="4">235</text>
<text top="461" left="385" width="15" height="13" font="4">36</text>
<text top="461" left="422" width="49" height="13" font="4">355,614</text>
<text top="461" left="490" width="22" height="13" font="4">215</text>
<text top="461" left="531" width="34" height="13" font="4">1,503</text>
<text top="461" left="593" width="22" height="13" font="4">255</text>
<text top="490" left="385" width="15" height="13" font="4">40</text>
<text top="490" left="422" width="49" height="13" font="4">385,259</text>
<text top="490" left="490" width="22" height="13" font="4">232</text>
<text top="490" left="531" width="34" height="13" font="4">1,635</text>
<text top="490" left="593" width="22" height="13" font="4">274</text>
<text top="519" left="385" width="15" height="13" font="4">44</text>
<text top="519" left="422" width="49" height="13" font="4">414,741</text>
<text top="519" left="490" width="22" height="13" font="4">251</text>
<text top="519" left="531" width="34" height="13" font="4">1,766</text>
<text top="519" left="593" width="22" height="13" font="4">294</text>
<text top="549" left="385" width="15" height="13" font="4">48</text>
<text top="549" left="422" width="49" height="13" font="4">444,155</text>
<text top="549" left="490" width="22" height="13" font="4">268</text>
<text top="549" left="531" width="34" height="13" font="4">1,897</text>
<text top="549" left="593" width="22" height="13" font="4">312</text>
<text top="578" left="385" width="15" height="13" font="4">52</text>
<text top="578" left="422" width="49" height="13" font="4">473,276</text>
<text top="578" left="490" width="22" height="13" font="4">285</text>
<text top="578" left="531" width="34" height="13" font="4">2,030</text>
<text top="578" left="593" width="22" height="13" font="4">332</text>
<text top="607" left="385" width="15" height="13" font="4">56</text>
<text top="607" left="422" width="49" height="13" font="4">502,743</text>
<text top="607" left="490" width="22" height="13" font="4">301</text>
<text top="607" left="531" width="34" height="13" font="4">2,160</text>
<text top="607" left="593" width="22" height="13" font="4">350</text>
<text top="636" left="385" width="15" height="13" font="4">60</text>
<text top="636" left="422" width="49" height="13" font="4">532,215</text>
<text top="636" left="490" width="22" height="13" font="4">318</text>
<text top="636" left="531" width="34" height="13" font="4">2,292</text>
<text top="636" left="593" width="22" height="13" font="4">368</text>
<text top="672" left="173" width="626" height="16" font="0">Table 8.2: Initial results for our Haskell implementation of L4 on H. The table</text>
<text top="707" left="173" width="626" height="16" font="0">shows the number of words transferred over IPC, the average cycles taken per</text>
<text top="742" left="173" width="626" height="16" font="0">message, the average time in microseconds per message, and the total number of</text>
<text top="776" left="173" width="626" height="16" font="0">garbage collections that occurred during the test (not per IPC). The ﬁnal column is</text>
<text top="811" left="173" width="626" height="16" font="0">the ratio between the average cycles taken for a particular test and the equivalent</text>
<text top="846" left="173" width="626" height="16" font="0">result from Pistachio (see Table 8.1 for the full results). This number indicates</text>
<text top="880" left="173" width="571" height="16" font="0">how many times slower our implementation is than the Pistachio baseline.</text>
<text top="932" left="199" width="600" height="16" font="0">The results in Table 8.3 conﬁrm that our implementation of transferUntyped</text>
<text top="964" left="173" width="626" height="16" font="0">is the source of the high cost for transferring each word. The base cost of execut-</text>
<text top="997" left="173" width="626" height="16" font="0">ing transferUntyped when no data is transferred is 3,530 cycles. This increases</text>
<text top="1029" left="173" width="626" height="16" font="0">by roughly 30,000 cycles for every 4 words to a peak of 450,265 cycles when 60</text>
</page>
<page number="281" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">259</text>
<text top="168" left="184" width="48" height="13" font="4">Words</text>
<text top="168" left="270" width="26" height="13" font="4">OH</text>
<text top="168" left="325" width="31" height="13" font="4">Sch.</text>
<text top="168" left="386" width="22" height="13" font="4">SR</text>
<text top="168" left="441" width="28" height="13" font="4">TM</text>
<text top="168" left="511" width="25" height="13" font="4">TU</text>
<text top="168" left="565" width="31" height="13" font="4">Rst.</text>
<text top="168" left="622" width="34" height="13" font="4">Rcv.</text>
<text top="168" left="691" width="26" height="13" font="4">GC</text>
<text top="168" left="749" width="39" height="13" font="4">Total</text>
<text top="197" left="225" width="7" height="13" font="4">0</text>
<text top="197" left="262" width="34" height="13" font="4">6,789</text>
<text top="197" left="315" width="42" height="13" font="4">26,194</text>
<text top="197" left="375" width="34" height="13" font="4">7,903</text>
<text top="197" left="427" width="42" height="13" font="4">14,710</text>
<text top="197" left="502" width="34" height="13" font="4">3,530</text>
<text top="197" left="555" width="42" height="13" font="4">16,395</text>
<text top="197" left="615" width="42" height="13" font="4">24,085</text>
<text top="197" left="683" width="34" height="13" font="4">1,471</text>
<text top="197" left="739" width="49" height="13" font="4">101,077</text>
<text top="226" left="225" width="7" height="13" font="4">4</text>
<text top="226" left="262" width="34" height="13" font="4">7,184</text>
<text top="226" left="315" width="42" height="13" font="4">26,486</text>
<text top="226" left="375" width="34" height="13" font="4">7,895</text>
<text top="226" left="427" width="42" height="13" font="4">14,732</text>
<text top="226" left="495" width="42" height="13" font="4">35,996</text>
<text top="226" left="555" width="42" height="13" font="4">17,035</text>
<text top="226" left="615" width="42" height="13" font="4">24,127</text>
<text top="226" left="683" width="34" height="13" font="4">2,041</text>
<text top="226" left="739" width="49" height="13" font="4">135,496</text>
<text top="256" left="225" width="7" height="13" font="4">8</text>
<text top="256" left="262" width="34" height="13" font="4">7,552</text>
<text top="256" left="315" width="42" height="13" font="4">26,191</text>
<text top="256" left="375" width="34" height="13" font="4">8,057</text>
<text top="256" left="427" width="42" height="13" font="4">14,849</text>
<text top="256" left="495" width="42" height="13" font="4">65,945</text>
<text top="256" left="555" width="42" height="13" font="4">17,032</text>
<text top="256" left="615" width="42" height="13" font="4">24,310</text>
<text top="256" left="683" width="34" height="13" font="4">2,639</text>
<text top="256" left="739" width="49" height="13" font="4">166,575</text>
<text top="285" left="218" width="15" height="13" font="4">12</text>
<text top="285" left="262" width="34" height="13" font="4">7,986</text>
<text top="285" left="315" width="42" height="13" font="4">25,808</text>
<text top="285" left="375" width="34" height="13" font="4">7,948</text>
<text top="285" left="427" width="42" height="13" font="4">14,998</text>
<text top="285" left="495" width="42" height="13" font="4">95,358</text>
<text top="285" left="555" width="42" height="13" font="4">17,103</text>
<text top="285" left="615" width="42" height="13" font="4">24,456</text>
<text top="285" left="683" width="34" height="13" font="4">3,191</text>
<text top="285" left="739" width="49" height="13" font="4">196,848</text>
<text top="314" left="218" width="15" height="13" font="4">16</text>
<text top="314" left="262" width="34" height="13" font="4">8,375</text>
<text top="314" left="315" width="42" height="13" font="4">25,497</text>
<text top="314" left="375" width="34" height="13" font="4">7,920</text>
<text top="314" left="427" width="42" height="13" font="4">14,850</text>
<text top="314" left="487" width="49" height="13" font="4">125,435</text>
<text top="314" left="555" width="42" height="13" font="4">17,148</text>
<text top="314" left="615" width="42" height="13" font="4">24,395</text>
<text top="314" left="683" width="34" height="13" font="4">3,728</text>
<text top="314" left="739" width="49" height="13" font="4">227,348</text>
<text top="343" left="218" width="15" height="13" font="4">20</text>
<text top="343" left="262" width="34" height="13" font="4">8,974</text>
<text top="343" left="315" width="42" height="13" font="4">25,098</text>
<text top="343" left="375" width="34" height="13" font="4">7,953</text>
<text top="343" left="427" width="42" height="13" font="4">15,114</text>
<text top="343" left="487" width="49" height="13" font="4">154,878</text>
<text top="343" left="555" width="42" height="13" font="4">17,120</text>
<text top="343" left="615" width="42" height="13" font="4">24,510</text>
<text top="343" left="683" width="34" height="13" font="4">4,350</text>
<text top="343" left="739" width="49" height="13" font="4">257,997</text>
<text top="373" left="218" width="15" height="13" font="4">24</text>
<text top="373" left="262" width="34" height="13" font="4">9,423</text>
<text top="373" left="315" width="42" height="13" font="4">24,698</text>
<text top="373" left="375" width="34" height="13" font="4">8,009</text>
<text top="373" left="427" width="42" height="13" font="4">15,144</text>
<text top="373" left="487" width="49" height="13" font="4">184,812</text>
<text top="373" left="555" width="42" height="13" font="4">17,253</text>
<text top="373" left="615" width="42" height="13" font="4">24,505</text>
<text top="373" left="683" width="34" height="13" font="4">4,930</text>
<text top="373" left="739" width="49" height="13" font="4">288,774</text>
<text top="402" left="218" width="15" height="13" font="4">28</text>
<text top="402" left="255" width="42" height="13" font="4">10,137</text>
<text top="402" left="315" width="42" height="13" font="4">24,131</text>
<text top="402" left="375" width="34" height="13" font="4">8,058</text>
<text top="402" left="427" width="42" height="13" font="4">15,161</text>
<text top="402" left="487" width="49" height="13" font="4">214,211</text>
<text top="402" left="555" width="42" height="13" font="4">17,284</text>
<text top="402" left="615" width="42" height="13" font="4">24,493</text>
<text top="402" left="683" width="34" height="13" font="4">5,540</text>
<text top="402" left="739" width="49" height="13" font="4">319,015</text>
<text top="431" left="218" width="15" height="13" font="4">32</text>
<text top="431" left="255" width="42" height="13" font="4">10,668</text>
<text top="431" left="315" width="42" height="13" font="4">23,505</text>
<text top="431" left="375" width="34" height="13" font="4">8,037</text>
<text top="431" left="427" width="42" height="13" font="4">15,122</text>
<text top="431" left="487" width="49" height="13" font="4">243,620</text>
<text top="431" left="555" width="42" height="13" font="4">17,290</text>
<text top="431" left="615" width="42" height="13" font="4">24,555</text>
<text top="431" left="683" width="34" height="13" font="4">6,102</text>
<text top="431" left="739" width="49" height="13" font="4">348,899</text>
<text top="461" left="218" width="15" height="13" font="4">36</text>
<text top="461" left="255" width="42" height="13" font="4">11,425</text>
<text top="461" left="315" width="42" height="13" font="4">22,872</text>
<text top="461" left="375" width="34" height="13" font="4">7,982</text>
<text top="461" left="427" width="42" height="13" font="4">15,145</text>
<text top="461" left="487" width="49" height="13" font="4">273,235</text>
<text top="461" left="555" width="42" height="13" font="4">17,336</text>
<text top="461" left="615" width="42" height="13" font="4">24,583</text>
<text top="461" left="683" width="34" height="13" font="4">6,621</text>
<text top="461" left="739" width="49" height="13" font="4">379,199</text>
<text top="490" left="218" width="15" height="13" font="4">40</text>
<text top="490" left="255" width="42" height="13" font="4">12,259</text>
<text top="490" left="315" width="42" height="13" font="4">22,127</text>
<text top="490" left="375" width="34" height="13" font="4">7,997</text>
<text top="490" left="427" width="42" height="13" font="4">15,058</text>
<text top="490" left="487" width="49" height="13" font="4">303,063</text>
<text top="490" left="555" width="42" height="13" font="4">17,515</text>
<text top="490" left="615" width="42" height="13" font="4">24,634</text>
<text top="490" left="683" width="34" height="13" font="4">7,185</text>
<text top="490" left="739" width="49" height="13" font="4">409,838</text>
<text top="519" left="218" width="15" height="13" font="4">44</text>
<text top="519" left="255" width="42" height="13" font="4">12,967</text>
<text top="519" left="315" width="42" height="13" font="4">21,579</text>
<text top="519" left="375" width="34" height="13" font="4">8,028</text>
<text top="519" left="427" width="42" height="13" font="4">15,213</text>
<text top="519" left="487" width="49" height="13" font="4">332,575</text>
<text top="519" left="555" width="42" height="13" font="4">17,291</text>
<text top="519" left="615" width="42" height="13" font="4">24,464</text>
<text top="519" left="683" width="34" height="13" font="4">7,775</text>
<text top="519" left="739" width="49" height="13" font="4">439,892</text>
<text top="549" left="218" width="15" height="13" font="4">48</text>
<text top="549" left="255" width="42" height="13" font="4">13,979</text>
<text top="549" left="315" width="42" height="13" font="4">20,528</text>
<text top="549" left="375" width="34" height="13" font="4">7,962</text>
<text top="549" left="427" width="42" height="13" font="4">15,306</text>
<text top="549" left="487" width="49" height="13" font="4">362,215</text>
<text top="549" left="555" width="42" height="13" font="4">17,319</text>
<text top="549" left="615" width="42" height="13" font="4">24,695</text>
<text top="549" left="683" width="34" height="13" font="4">8,410</text>
<text top="549" left="739" width="49" height="13" font="4">470,414</text>
<text top="578" left="218" width="15" height="13" font="4">52</text>
<text top="578" left="255" width="42" height="13" font="4">14,622</text>
<text top="578" left="315" width="42" height="13" font="4">20,131</text>
<text top="578" left="375" width="34" height="13" font="4">8,119</text>
<text top="578" left="427" width="42" height="13" font="4">15,148</text>
<text top="578" left="487" width="49" height="13" font="4">391,677</text>
<text top="578" left="555" width="42" height="13" font="4">17,310</text>
<text top="578" left="615" width="42" height="13" font="4">24,652</text>
<text top="578" left="683" width="34" height="13" font="4">8,921</text>
<text top="578" left="739" width="49" height="13" font="4">500,580</text>
<text top="607" left="218" width="15" height="13" font="4">56</text>
<text top="607" left="255" width="42" height="13" font="4">15,606</text>
<text top="607" left="315" width="42" height="13" font="4">19,147</text>
<text top="607" left="375" width="34" height="13" font="4">8,143</text>
<text top="607" left="427" width="42" height="13" font="4">15,180</text>
<text top="607" left="487" width="49" height="13" font="4">420,793</text>
<text top="607" left="555" width="42" height="13" font="4">17,303</text>
<text top="607" left="615" width="42" height="13" font="4">24,661</text>
<text top="607" left="683" width="34" height="13" font="4">9,501</text>
<text top="607" left="739" width="49" height="13" font="4">530,334</text>
<text top="636" left="218" width="15" height="13" font="4">60</text>
<text top="636" left="255" width="42" height="13" font="4">16,771</text>
<text top="636" left="315" width="42" height="13" font="4">18,007</text>
<text top="636" left="375" width="34" height="13" font="4">7,991</text>
<text top="636" left="427" width="42" height="13" font="4">15,289</text>
<text top="636" left="487" width="49" height="13" font="4">450,265</text>
<text top="636" left="555" width="42" height="13" font="4">17,312</text>
<text top="636" left="615" width="42" height="13" font="4">24,742</text>
<text top="636" left="675" width="42" height="13" font="4">10,079</text>
<text top="636" left="739" width="49" height="13" font="4">560,456</text>
<text top="695" left="173" width="626" height="16" font="0">Table 8.3: A breakdown of the cycles spent in each phase of the IPC implemen-</text>
<text top="729" left="173" width="626" height="16" font="0">tation. OH stands for overhead and includes the time spent to context-switch</text>
<text top="764" left="173" width="626" height="16" font="0">between the Haskell kernel and the C user program. Sch. is the time spent in the</text>
<text top="799" left="173" width="626" height="16" font="0">scheduling loop. SR stands for send rendezvous, TM stands for transfer message,</text>
<text top="833" left="173" width="626" height="16" font="0">and TU stands for transfer untyped. Rst. describes the phase of IPC spent restart-</text>
<text top="868" left="173" width="626" height="16" font="0">ing the thread. Rcv. is the time spent in the receive phase of the IPC operation.</text>
<text top="903" left="173" width="392" height="16" font="0">The phases are explained in detail in Section 8.1.1.</text>
<text top="954" left="173" width="626" height="16" font="0">words are transferred. These results indicate that transferUntyped is an ap-</text>
<text top="986" left="173" width="626" height="16" font="0">propriate place to start our performance analysis. Copying data should have a</text>
<text top="1019" left="173" width="626" height="16" font="0">relatively low, constant cost, so there should be hope to improve the performance</text>
<text top="1051" left="173" width="626" height="16" font="0">of transferUntyped through optimization. Section 8.3 will provide a detailed</text>
</page>
<page number="282" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">260</text>
<text top="163" left="173" width="626" height="16" font="0">walk-through of the transferUntyped implementation and show that our original</text>
<text top="195" left="173" width="626" height="16" font="0">implementation has (and realizable) opportunities for optimization of its perfor-</text>
<text top="228" left="173" width="54" height="16" font="0">mance.</text>
<text top="288" left="173" width="41" height="16" font="0">8.2.2</text>
<text top="288" left="234" width="216" height="16" font="0">Context-Switching Time</text>
<text top="332" left="173" width="626" height="16" font="0">Before moving on to optimization, we will take a closer look at some of the base</text>
<text top="364" left="173" width="626" height="16" font="0">costs involved in our Haskell kernel. This section examines the cost of context-</text>
<text top="397" left="173" width="626" height="16" font="0">switching between the Haskell kernel and a user program written in C. In the</text>
<text top="429" left="173" width="626" height="16" font="0">previous section, we measured the cycles spent for “context-switching”. This mea-</text>
<text top="462" left="173" width="626" height="16" font="0">surement provides a rough estimate of how many cycles our L4 implementation</text>
<text top="494" left="173" width="626" height="16" font="0">requires to enter and leave the kernel, but it also includes other overheads such as</text>
<text top="527" left="173" width="626" height="16" font="0">the cycles required for the proﬁling functions and misattributed costs due to lazi-</text>
<text top="559" left="173" width="626" height="16" font="0">ness. To isolate the actual time taken to switch between the user and the kernel,</text>
<text top="592" left="173" width="568" height="16" font="0">we created a new test speciﬁcally to measure the cost of context-switches.</text>
<text top="624" left="199" width="600" height="16" font="0">The context-switch test works much like ping-pong except that the user pro-</text>
<text top="657" left="173" width="626" height="16" font="0">gram invokes a “no-op” system call instead of IPC. The interrupt passes through</text>
<text top="689" left="173" width="626" height="16" font="0">assembly to H to the Haskell kernel as explained in Section 4.5. In the kernel, the</text>
<text top="722" left="173" width="626" height="16" font="0">interrupt handler returns immediately. As in ping-pong, we execute the no-op sys-</text>
<text top="754" left="173" width="626" height="16" font="0">tem call several thousand times and compute the average cycles per context-switch</text>
<text top="787" left="173" width="626" height="16" font="0">using rdtsc. Over 115,000 tests, the average number of cycles taken for a context</text>
<text top="819" left="173" width="626" height="16" font="0">switch is 3,289 cycles. This reﬂects the path of a single crossing from user-to-kernel</text>
<text top="852" left="173" width="626" height="16" font="0">mode or kernel-to-user mode—the round-trip of a system call requires two such</text>
<text top="884" left="173" width="626" height="16" font="0">switches. The context-switch time is consistent with the overhead of transferring</text>
<text top="917" left="173" width="412" height="16" font="0">zero words of data that we measured in Section 8.2.1.</text>
<text top="949" left="199" width="600" height="16" font="0">We perform the context switch from Haskell to C using an optimized version of</text>
<text top="982" left="173" width="626" height="16" font="0">the execute primitive from Section 4.5. Recall that the original deﬁnition of the</text>
<text top="1016" left="173" width="626" height="15" font="0">execute primitive returns an Interrupt data structure to describe the user event</text>
<text top="1047" left="173" width="306" height="16" font="0">that brought control back to the kernel:</text>
</page>
<page number="283" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">261</text>
<text top="165" left="190" width="421" height="14" font="7">execute :: PageMap -&gt; FaultContext -&gt; H Interrupt</text>
<text top="206" left="173" width="626" height="16" font="0">Creating the Interrupt data structure is wasteful because it introduces an addi-</text>
<text top="238" left="173" width="626" height="16" font="0">tional case-split on the interrupt vector and allocates extra space. Context-switches</text>
<text top="271" left="173" width="626" height="16" font="0">via this primitive take an average of 3,517 cycles. Our alternative primitive, called</text>
<text top="305" left="173" width="626" height="15" font="0">executeWithoutAllocation, returns the interrupt vector that caused the switch</text>
<text top="336" left="173" width="233" height="16" font="0">to kernel model as a raw byte:</text>
<text top="375" left="190" width="533" height="14" font="7">executeWithoutAllocation :: PageMap -&gt; FaultContext -&gt; H HByte</text>
<text top="415" left="173" width="626" height="16" font="0">For page fault handling, we also need to add a primitive that accesses the address</text>
<text top="447" left="173" width="226" height="16" font="0">where the last fault occurred:</text>
<text top="486" left="190" width="266" height="14" font="7">readLastFaultAddress :: H HWord</text>
<text top="527" left="173" width="626" height="16" font="0">All of the other information contained in an Interrupt, such as the error code of</text>
<text top="559" left="173" width="393" height="16" font="0">a fault, is accessible through existing H operations.</text>
<text top="592" left="199" width="600" height="16" font="0">Switching to the non-allocating version of execute reduced the overall context-</text>
<text top="624" left="173" width="626" height="16" font="0">switch time by roughly 7% and the time spent in garbage collection by 20%. We use</text>
<text top="657" left="173" width="626" height="16" font="0">the alternative primitive in all of our tests (including our initial results). Despite</text>
<text top="689" left="173" width="626" height="16" font="0">these improvements, it does not appear that the use of an Interrupt structure is</text>
<text top="722" left="173" width="626" height="16" font="0">the most signiﬁcant bottleneck in context switching. Pistachio completes an entire</text>
<text top="754" left="173" width="626" height="16" font="0">IPC in less time than a single switch into the Haskell kernel takes, so we know that</text>
<text top="787" left="173" width="626" height="16" font="0">we are a long way from the limits imposed by the machine. There are no obvious</text>
<text top="819" left="173" width="626" height="16" font="0">bottlenecks in the code, so it is not clear whether the context-switching overhead</text>
<text top="852" left="173" width="626" height="16" font="0">is inherent in our use of Haskell or if it is simply a product of the H design for</text>
<text top="884" left="173" width="626" height="16" font="0">executing user code. Further analysis and improvement of the context-switching</text>
<text top="917" left="173" width="333" height="16" font="0">time is an interesting topic for future work.</text>
<text top="976" left="173" width="41" height="16" font="0">8.2.3</text>
<text top="976" left="234" width="292" height="16" font="0">The Eﬀect of Garbage Collection</text>
<text top="1020" left="173" width="626" height="16" font="0">Garbage collection is an inherent cost for a Haskell kernel. In the results of Ta-</text>
<text top="1052" left="173" width="626" height="16" font="0">ble 8.3, we saw that garbage collection did not appear to be a signiﬁcant bottleneck</text>
</page>
<page number="284" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">262</text>
<text top="163" left="173" width="626" height="16" font="0">in IPC when compared to the other phases of the algorithm. As another perspec-</text>
<text top="195" left="173" width="626" height="16" font="0">tive on the cost of garbage collection, Table 8.4 compares the average time spent</text>
<text top="228" left="173" width="626" height="16" font="0">in garbage collection to the average time spent in IPC overall (measured in mi-</text>
<text top="260" left="173" width="626" height="16" font="0">croseconds) for each of the IPC payloads. In most cases, garbage collection takes</text>
<text top="293" left="173" width="234" height="16" font="0">less than 2% of the total time.</text>
<text top="338" left="283" width="48" height="13" font="4">Words</text>
<text top="338" left="353" width="116" height="13" font="4">GC µs Per IPC</text>
<text top="338" left="487" width="84" height="13" font="4">µs Per IPC</text>
<text top="338" left="594" width="91" height="13" font="4">Time in GC</text>
<text top="367" left="324" width="7" height="13" font="4">0</text>
<text top="367" left="442" width="27" height="13" font="4">0.73</text>
<text top="367" left="557" width="15" height="13" font="4">53</text>
<text top="367" left="645" width="39" height="13" font="4">1.38%</text>
<text top="396" left="324" width="7" height="13" font="4">4</text>
<text top="396" left="442" width="27" height="13" font="4">1.05</text>
<text top="396" left="557" width="15" height="13" font="4">73</text>
<text top="396" left="645" width="39" height="13" font="4">1.45%</text>
<text top="425" left="324" width="7" height="13" font="4">8</text>
<text top="425" left="442" width="27" height="13" font="4">1.36</text>
<text top="425" left="557" width="15" height="13" font="4">89</text>
<text top="425" left="645" width="39" height="13" font="4">1.52%</text>
<text top="455" left="316" width="15" height="13" font="4">12</text>
<text top="455" left="442" width="27" height="13" font="4">1.68</text>
<text top="455" left="549" width="22" height="13" font="4">106</text>
<text top="455" left="645" width="39" height="13" font="4">1.58%</text>
<text top="484" left="316" width="15" height="13" font="4">16</text>
<text top="484" left="442" width="27" height="13" font="4">2.04</text>
<text top="484" left="549" width="22" height="13" font="4">126</text>
<text top="484" left="645" width="39" height="13" font="4">1.62%</text>
<text top="513" left="316" width="15" height="13" font="4">20</text>
<text top="513" left="442" width="27" height="13" font="4">2.40</text>
<text top="513" left="549" width="22" height="13" font="4">142</text>
<text top="513" left="645" width="39" height="13" font="4">1.69%</text>
<text top="543" left="316" width="15" height="13" font="4">24</text>
<text top="543" left="442" width="27" height="13" font="4">2.70</text>
<text top="543" left="549" width="22" height="13" font="4">162</text>
<text top="543" left="645" width="39" height="13" font="4">1.67%</text>
<text top="572" left="316" width="15" height="13" font="4">28</text>
<text top="572" left="442" width="27" height="13" font="4">3.04</text>
<text top="572" left="549" width="22" height="13" font="4">179</text>
<text top="572" left="645" width="39" height="13" font="4">1.70%</text>
<text top="601" left="316" width="15" height="13" font="4">32</text>
<text top="601" left="442" width="27" height="13" font="4">3.34</text>
<text top="601" left="549" width="22" height="13" font="4">195</text>
<text top="601" left="645" width="39" height="13" font="4">1.70%</text>
<text top="630" left="316" width="15" height="13" font="4">36</text>
<text top="630" left="442" width="27" height="13" font="4">3.74</text>
<text top="630" left="549" width="22" height="13" font="4">215</text>
<text top="630" left="645" width="39" height="13" font="4">1.74%</text>
<text top="660" left="316" width="15" height="13" font="4">40</text>
<text top="660" left="442" width="27" height="13" font="4">4.06</text>
<text top="660" left="549" width="22" height="13" font="4">232</text>
<text top="660" left="645" width="39" height="13" font="4">1.75%</text>
<text top="689" left="316" width="15" height="13" font="4">44</text>
<text top="689" left="442" width="27" height="13" font="4">4.41</text>
<text top="689" left="549" width="22" height="13" font="4">251</text>
<text top="689" left="645" width="39" height="13" font="4">1.76%</text>
<text top="718" left="316" width="15" height="13" font="4">48</text>
<text top="718" left="442" width="27" height="13" font="4">4.73</text>
<text top="718" left="549" width="22" height="13" font="4">268</text>
<text top="718" left="645" width="39" height="13" font="4">1.77%</text>
<text top="748" left="316" width="15" height="13" font="4">52</text>
<text top="748" left="442" width="27" height="13" font="4">5.06</text>
<text top="748" left="549" width="22" height="13" font="4">285</text>
<text top="748" left="645" width="39" height="13" font="4">1.78%</text>
<text top="777" left="316" width="15" height="13" font="4">56</text>
<text top="777" left="442" width="27" height="13" font="4">5.39</text>
<text top="777" left="549" width="22" height="13" font="4">301</text>
<text top="777" left="645" width="39" height="13" font="4">1.79%</text>
<text top="806" left="316" width="15" height="13" font="4">60</text>
<text top="806" left="442" width="27" height="13" font="4">5.68</text>
<text top="806" left="549" width="22" height="13" font="4">318</text>
<text top="806" left="645" width="39" height="13" font="4">1.79%</text>
<text top="842" left="173" width="626" height="16" font="0">Table 8.4: Portion of time spent in garbage collection in our initial results. By</text>
<text top="877" left="173" width="626" height="16" font="0">comparing the average number of microseconds spent in garbage collection to the</text>
<text top="912" left="173" width="626" height="16" font="0">average number of microseconds spent in IPC overall, we see that garbage collection</text>
<text top="946" left="173" width="268" height="16" font="0">is only 1–2% of our total IPC cost.</text>
<text top="1002" left="199" width="600" height="16" font="0">While 2% of IPC execution time may not seem signiﬁcant, garbage collection</text>
<text top="1035" left="173" width="626" height="16" font="0">is still important because of secondary eﬀects that are not obvious from garbage</text>
</page>
<page number="285" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">263</text>
<text top="163" left="173" width="626" height="16" font="0">collection proﬁling alone. In a garbage collected language, the programmer does</text>
<text top="195" left="173" width="626" height="16" font="0">not typically control the placement of data structures in memory and they may</text>
<text top="228" left="173" width="626" height="16" font="0">be moved during garbage collection to another address. From an algorithmic per-</text>
<text top="260" left="173" width="626" height="16" font="0">spective the programmer does not care—their program produces the same result</text>
<text top="293" left="173" width="626" height="16" font="0">no matter where their data structures live. But from a performance perspective</text>
<text top="325" left="173" width="626" height="16" font="0">the results might be very diﬀerent: moving the data structures of the running pro-</text>
<text top="358" left="173" width="626" height="16" font="0">gram can have signiﬁcant cache eﬀects that are invisible to the programmer except</text>
<text top="390" left="173" width="123" height="16" font="0">through testing.</text>
<text top="423" left="199" width="600" height="16" font="0">GHC allows the user to control many conﬁguration settings for the run-time</text>
<text top="455" left="173" width="626" height="16" font="0">system [91]. We experimented with two of these parameters in an attempt to</text>
<text top="488" left="173" width="626" height="16" font="0">understand the eﬀects of garbage collection and to identify the optimum garbage</text>
<text top="520" left="173" width="626" height="16" font="0">collector settings for the L4 kernel. The “-A” ﬂag controls the size of the initial</text>
<text top="553" left="173" width="626" height="16" font="0">allocation area and has a default size of 256 KB. The “-g” ﬂag controls the number</text>
<text top="585" left="173" width="343" height="16" font="0">of generations and has a default setting of 2.</text>
<text top="618" left="199" width="600" height="16" font="0">Figures 8.2 and 8.3 illustrate the impact that various garbage collection settings</text>
<text top="650" left="173" width="210" height="16" font="0">have on IPC performance.</text>
<text top="650" left="399" width="400" height="16" font="0">We vary the allocation area used by the collector</text>
<text top="683" left="173" width="626" height="16" font="0">between 256 KB and 4096 KB in combination with either 2, 3, or 4 generations.</text>
<text top="715" left="173" width="626" height="16" font="0">We then compare the best ﬁt line for the data produced by each test. The best-ﬁt</text>
<text top="748" left="173" width="626" height="16" font="0">line takes the form a + bn, where a is the base cost (in cycles) and b is the cost</text>
<text top="780" left="173" width="626" height="16" font="0">of transferring each additional word. Figure 8.2 illustrates the impact the garbage</text>
<text top="813" left="173" width="626" height="16" font="0">collection settings have on the base. Four generations and an allocation area of</text>
<text top="845" left="173" width="626" height="16" font="0">4096 KB clearly produces the lowest base cost, most likely because fewer garbage</text>
<text top="878" left="173" width="626" height="16" font="0">collections are performed. Figure 8.3 describes the changes to the gradient of the</text>
<text top="910" left="173" width="626" height="16" font="0">best ﬁt line with each setting. In this case the combination of four generations with</text>
<text top="943" left="173" width="626" height="16" font="0">a 4096 KB allocation area has the worst gradient while a setting of two generations</text>
<text top="975" left="173" width="461" height="16" font="0">with a 512 KB allocation area has the lowest cost per word.</text>
<text top="1008" left="199" width="600" height="16" font="0">The graphs alone do not indicate which settings are the best, but they provide</text>
<text top="1040" left="173" width="626" height="16" font="0">us with a guide to the data sets. Using the graphs to navigate the results, we</text>
</page>
<page number="286" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="14" size="10" family="Times" color="#000000"/>
	<fontspec id="15" size="10" family="Times" color="#000000"/>
<text top="111" left="729" width="26" height="16" font="0">264</text>
<text top="545" left="246" width="12" height="15" font="14">2 </text>
<text top="613" left="274" width="12" height="15" font="14">3 </text>
<text top="687" left="308" width="12" height="15" font="14">4 </text>
<text top="589" left="678" width="47" height="15" font="14">50,000 </text>
<text top="547" left="682" width="47" height="15" font="14">55,000 </text>
<text top="503" left="687" width="47" height="15" font="14">60,000 </text>
<text top="458" left="692" width="47" height="15" font="14">65,000 </text>
<text top="410" left="697" width="47" height="15" font="14">70,000 </text>
<text top="360" left="702" width="47" height="15" font="14">75,000 </text>
<text top="620" left="623" width="27" height="15" font="14">256 </text>
<text top="639" left="558" width="27" height="15" font="14">512 </text>
<text top="659" left="488" width="35" height="15" font="14">1024 </text>
<text top="679" left="420" width="35" height="15" font="14">2048 </text>
<text top="700" left="350" width="35" height="15" font="14">4096 </text>
<text top="586" left="230" width="3" height="15" font="15"><b>g</b></text>
<text top="594" left="233" width="3" height="15" font="15"><b>e</b></text>
<text top="601" left="236" width="3" height="15" font="15"><b>n</b></text>
<text top="609" left="239" width="3" height="15" font="15"><b>e</b></text>
<text top="617" left="242" width="7" height="20" font="15"><b>rat</b></text>
<text top="635" left="249" width="4" height="18" font="15"><b>io</b></text>
<text top="647" left="253" width="3" height="15" font="15"><b>n</b></text>
<text top="655" left="256" width="4" height="21" font="15"><b>s </b></text>
<text top="446" left="757" width="0" height="15" font="15"><b>cy</b></text>
<text top="461" left="757" width="0" height="15" font="15"><b>cl</b></text>
<text top="473" left="757" width="0" height="15" font="15"><b>es </b></text>
<text top="722" left="452" width="33" height="15" font="15"><b>GC al</b></text>
<text top="712" left="485" width="32" height="15" font="15"><b>locat</b></text>
<text top="702" left="517" width="24" height="15" font="15"><b>ion </b></text>
<text top="695" left="541" width="33" height="15" font="15"><b>area </b></text>
<text top="685" left="573" width="30" height="15" font="15"><b>(KB)</b></text>
<text top="676" left="603" width="4" height="15" font="15"><b> </b></text>
<text top="678" left="687" width="95" height="15" font="14">70,000-75,000 </text>
<text top="698" left="687" width="95" height="15" font="14">65,000-70,000 </text>
<text top="719" left="687" width="95" height="15" font="14">60,000-65,000 </text>
<text top="739" left="687" width="95" height="15" font="14">55,000-60,000 </text>
<text top="760" left="687" width="95" height="15" font="14">50,000-55,000 </text>
<text top="832" left="173" width="626" height="16" font="0">Figure 8.2: The eﬀect of garbage collector allocation area size and number of gener-</text>
<text top="867" left="173" width="626" height="16" font="0">ations on IPC. These tests measure the base-line cost, where no data is transferred</text>
<text top="902" left="173" width="626" height="16" font="0">(a 0 word IPC). For a best-ﬁt line of the form a + bn found using linear regression,</text>
<text top="936" left="173" width="626" height="16" font="0">this ﬁgure represents the impact of the parameter settings on the base number of</text>
<text top="971" left="173" width="138" height="16" font="0">cycles per IPC, a.</text>
</page>
<page number="287" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="16" size="9" family="Times" color="#000000"/>
<text top="111" left="729" width="26" height="16" font="0">265</text>
<text top="721" left="342" width="12" height="14" font="2">2 </text>
<text top="654" left="289" width="12" height="14" font="2">3 </text>
<text top="593" left="245" width="12" height="14" font="2">4 </text>
<text top="597" left="704" width="34" height="14" font="2">2600 </text>
<text top="571" left="706" width="34" height="14" font="2">2700 </text>
<text top="544" left="708" width="34" height="14" font="2">2800 </text>
<text top="517" left="710" width="34" height="14" font="2">2900 </text>
<text top="490" left="712" width="34" height="14" font="2">3000 </text>
<text top="461" left="714" width="34" height="14" font="2">3100 </text>
<text top="433" left="716" width="34" height="14" font="2">3200 </text>
<text top="403" left="719" width="34" height="14" font="2">3300 </text>
<text top="374" left="721" width="34" height="14" font="2">3400 </text>
<text top="343" left="723" width="34" height="14" font="2">3500 </text>
<text top="730" left="388" width="27" height="14" font="2">256 </text>
<text top="704" left="457" width="27" height="14" font="2">512 </text>
<text top="681" left="520" width="34" height="14" font="2">1024 </text>
<text top="656" left="584" width="34" height="14" font="2">2048 </text>
<text top="633" left="647" width="34" height="14" font="2">4096 </text>
<text top="650" left="246" width="9" height="21" font="16"><b>ge</b></text>
<text top="664" left="255" width="9" height="21" font="16"><b>ne</b></text>
<text top="677" left="264" width="10" height="19" font="16"><b>rat</b></text>
<text top="693" left="274" width="7" height="18" font="16"><b>io</b></text>
<text top="704" left="281" width="8" height="21" font="16"><b>ns</b></text>
<text top="717" left="290" width="2" height="14" font="16"><b> </b></text>
<text top="416" left="768" width="0" height="14" font="16"><b>cy</b></text>
<text top="431" left="768" width="0" height="14" font="16"><b>cl</b></text>
<text top="442" left="768" width="0" height="14" font="16"><b>es </b></text>
<text top="747" left="504" width="21" height="14" font="16"><b>GC </b></text>
<text top="739" left="525" width="22" height="14" font="16"><b>allo</b></text>
<text top="730" left="547" width="19" height="14" font="16"><b>cat</b></text>
<text top="722" left="566" width="19" height="14" font="16"><b>ion</b></text>
<text top="714" left="585" width="24" height="14" font="16"><b> are</b></text>
<text top="705" left="609" width="34" height="14" font="16"><b>a (KB</b></text>
<text top="691" left="643" width="10" height="14" font="16"><b>) </b></text>
<text top="667" left="713" width="70" height="14" font="2">3400-3500 </text>
<text top="687" left="713" width="70" height="14" font="2">3300-3400 </text>
<text top="708" left="713" width="70" height="14" font="2">3200-3300 </text>
<text top="728" left="713" width="70" height="14" font="2">3100-3200 </text>
<text top="749" left="713" width="70" height="14" font="2">3000-3100 </text>
<text top="769" left="713" width="70" height="14" font="2">2900-3000 </text>
<text top="790" left="713" width="70" height="14" font="2">2800-2900 </text>
<text top="810" left="713" width="70" height="14" font="2">2700-2800 </text>
<text top="831" left="713" width="70" height="14" font="2">2600-2700 </text>
<text top="896" left="173" width="626" height="16" font="0">Figure 8.3: The eﬀect of garbage collector allocation area size and number of</text>
<text top="931" left="173" width="626" height="16" font="0">generations on IPC. For a best-ﬁt line of the form a + bn, this ﬁgure represents</text>
<text top="965" left="173" width="626" height="16" font="0">the impact of the parameter settings on the additional cycles needed per word of</text>
<text top="1000" left="173" width="148" height="16" font="0">data transferred, b.</text>
</page>
<page number="288" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">266</text>
<text top="163" left="173" width="626" height="16" font="0">determined that an allocation area that is 512 KB large and two generations lead</text>
<text top="195" left="173" width="626" height="16" font="0">to the best performance for our L4 kernel. Even though garbage collection was only</text>
<text top="228" left="173" width="626" height="16" font="0">2% of our overall IPC time, changing the garbage collection settings improved IPC</text>
<text top="260" left="173" width="626" height="16" font="0">time by 7–12% and reduced garbage collection time by 53%. This is likely due to</text>
<text top="293" left="173" width="626" height="16" font="0">the secondary eﬀects of reduced garbage collection, such as better cache behavior</text>
<text top="325" left="173" width="626" height="16" font="0">in the client kernel. We will use the optimal settings for all of our experiments</text>
<text top="358" left="173" width="268" height="16" font="0">throughout the rest of the chapter.</text>
<text top="420" left="173" width="26" height="16" font="0">8.3</text>
<text top="420" left="219" width="270" height="16" font="0">OPTIMIZING THE KERNEL</text>
<text top="470" left="173" width="626" height="16" font="0">The performance results for our Haskell kernel indicate a high base cost for our</text>
<text top="502" left="173" width="626" height="16" font="0">approach to safety—which includes writing the client-kernel in Haskell, accessing</text>
<text top="535" left="173" width="626" height="16" font="0">hardware through an additional layer of indirection, and adding safety checks that</text>
<text top="567" left="173" width="626" height="16" font="0">are not always present in other kernel implementations—as well as a signiﬁcant</text>
<text top="600" left="173" width="626" height="16" font="0">per-word overhead in the implementation of transfer untyped. Not all of these</text>
<text top="632" left="173" width="626" height="16" font="0">costs are inherent—they indicate areas in need of optimization. In this section,</text>
<text top="665" left="173" width="626" height="16" font="0">we will examine the code of transferUntyped to identify the sources of that</text>
<text top="697" left="173" width="626" height="16" font="0">function’s poor performance and to illustrate techniques for optimizing an H-based</text>
<text top="730" left="173" width="626" height="16" font="0">system. Though we examine the techniques in the context of the transfer untyped</text>
<text top="762" left="173" width="626" height="16" font="0">phase, they use general mechanisms for optimizing Haskell programs that should</text>
<text top="795" left="173" width="626" height="16" font="0">apply equally well to all aspects of the L4 implementation, but that would require</text>
<text top="827" left="173" width="221" height="16" font="0">additional engineering eﬀort.</text>
<text top="860" left="199" width="600" height="16" font="0">The source of performance ineﬃciencies in a Haskell program is often less obvi-</text>
<text top="892" left="173" width="626" height="16" font="0">ous than in a program written in a lower-level language because Haskell programs</text>
<text top="925" left="173" width="626" height="16" font="0">are garbage collected, lazily evaluated, and written in a source language that is</text>
<text top="957" left="173" width="626" height="16" font="0">much more abstract than the machine they will eventually run on. In an H-based</text>
<text top="990" left="173" width="626" height="16" font="0">system, there are additional subtleties because issues might lie in the interface</text>
<text top="1022" left="173" width="626" height="16" font="0">implementation, the kernel implementation, or in the design of the interface itself.</text>
</page>
<page number="289" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">267</text>
<text top="163" left="173" width="626" height="16" font="0">We identify three aspects of the L4 implementation to focus on when optimizing</text>
<text top="195" left="173" width="82" height="16" font="0">our kernel:</text>
<text top="242" left="199" width="600" height="17" font="0">• Algorithm Design: An advantage of Haskell is that the language facil-</text>
<text top="275" left="217" width="583" height="16" font="0">itates abstraction and allows the programmer to create concise programs</text>
<text top="308" left="217" width="582" height="16" font="0">that are easy to understand. However, the choice of abstractions can signiﬁ-</text>
<text top="340" left="217" width="583" height="16" font="0">cantly aﬀect performance. For example, the programmer might make heavy</text>
<text top="373" left="217" width="583" height="16" font="0">use of datatypes; this technique could potentially hurt performance due to</text>
<text top="405" left="217" width="412" height="16" font="0">construction/destruction time and garbage collection.</text>
<text top="452" left="199" width="600" height="17" font="0">• Interface Design: In designing the primitives of the H interface, we at-</text>
<text top="485" left="217" width="583" height="16" font="0">tempted to anticipate the needs of operating systems implementers and to</text>
<text top="518" left="217" width="583" height="16" font="0">create the minimum suﬃcient interface. Unfortunately, a primitive will not</text>
<text top="550" left="217" width="582" height="16" font="0">always be the most performant abstraction on the ﬁrst attempt. This point</text>
<text top="583" left="217" width="582" height="16" font="0">is illustrated by the original execute function, which creates an unnecessary</text>
<text top="615" left="217" width="583" height="16" font="0">data structure and increases our context-switching time. Once we see how the</text>
<text top="648" left="217" width="582" height="16" font="0">primitives get used in kernel implementations, we can revise the design and</text>
<text top="680" left="217" width="566" height="16" font="0">implementation of the primitives to eliminate unanticipated ineﬃciencies.</text>
<text top="727" left="199" width="600" height="17" font="0">• Quality of Generated Code: GHC allows the programmer to annotate</text>
<text top="760" left="217" width="583" height="16" font="0">their Haskell code to control many facets of their compiled program, such as</text>
<text top="793" left="217" width="583" height="16" font="0">the inlining behavior of the compiler on certain functions, the representation</text>
<text top="825" left="217" width="583" height="16" font="0">of datatypes, and the strictness of function parameters. Targeted use of these</text>
<text top="858" left="217" width="580" height="16" font="0">annotations can signiﬁcantly improve the performance of Haskell programs.</text>
<text top="905" left="173" width="626" height="16" font="0">Attention to each of these categories is essential for achieving good performance. In</text>
<text top="938" left="173" width="626" height="16" font="0">the rest of this section, we examine the algorithmic complexity of the transfer un-</text>
<text top="970" left="173" width="626" height="16" font="0">typed function (Section 8.3.1), the H facilities for copying memory (Section 8.3.2),</text>
<text top="1003" left="173" width="531" height="16" font="0">and the use of compiler annotations within H and L4 (Section 8.3.3).</text>
</page>
<page number="290" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">268</text>
<text top="163" left="173" width="41" height="16" font="0">8.3.1</text>
<text top="163" left="234" width="326" height="16" font="0">Identifying Algorithmic Ineﬃciencies</text>
<text top="207" left="173" width="626" height="16" font="0">In the L4 implementation, we employ a coding style that makes heavy use of</text>
<text top="239" left="173" width="626" height="16" font="0">abstractions to capture common patterns and emphasize code clarity. This cod-</text>
<text top="272" left="173" width="626" height="16" font="0">ing style is extremely beneﬁcial during development: abstractions enable better</text>
<text top="304" left="173" width="626" height="16" font="0">type-based documentation, improve debugging, and allow localized changes to the</text>
<text top="337" left="173" width="626" height="16" font="0">implementation. Unfortunately, choosing the wrong abstractions can create sig-</text>
<text top="370" left="173" width="626" height="16" font="0">niﬁcant performance issues. Our initial experiments show that removing certain</text>
<text top="402" left="173" width="626" height="16" font="0">abstractions improves the performance of IPC. Abstraction itself is not to blame;</text>
<text top="435" left="173" width="626" height="16" font="0">the problem is that we designed many of our abstractions before we understood</text>
<text top="467" left="173" width="614" height="16" font="0">the ways in which the abstractions would be used in the kernel implementation.</text>
<text top="500" left="199" width="600" height="16" font="0">As a simple example, consider the implementation of transferUntyped. We</text>
<text top="532" left="173" width="626" height="16" font="0">deﬁne the message transfer function as a recursive function that transfers one word</text>
<text top="565" left="173" width="626" height="16" font="0">of data per call. The parameters to the function are the sender’s UTCB structure,</text>
<text top="597" left="173" width="626" height="16" font="0">the receiver’s UTCB structure, the UTCB ﬁeld currently being transferred (recall</text>
<text top="630" left="173" width="626" height="16" font="0">from Section 7.1 that we deﬁned a datatype with one constructor per UTCB ﬁeld</text>
<text top="662" left="173" width="626" height="16" font="0">to document the mapping between ﬁeld names and addresses), and the number of</text>
<text top="695" left="173" width="218" height="16" font="0">remaining words to transfer.</text>
<text top="738" left="190" width="550" height="14" font="7">transferUntyped :: (KernelMemory m) =&gt; UTCB -&gt; UTCB -&gt; UTCBField</text>
<text top="765" left="207" width="198" height="14" font="7">-&gt; HWord -&gt; m UTCBField</text>
<text top="791" left="190" width="284" height="14" font="7">transferUntyped sutcb rutcb f num</text>
<text top="818" left="207" width="86" height="14" font="7">| num &lt;= 0</text>
<text top="818" left="310" width="86" height="14" font="7">= return f</text>
<text top="844" left="207" width="387" height="14" font="7">| otherwise = do val &lt;- readUTCBField sutcb f</text>
<text top="870" left="353" width="223" height="14" font="7">writeUTCBField rutcb f val</text>
<text top="897" left="353" width="395" height="14" font="7">transferUntyped sutcb rutcb (succ f) (num - 1)</text>
<text top="942" left="173" width="626" height="16" font="0">We use the utility functions readUTCBField and writeUTCBField to access the</text>
<text top="974" left="173" width="626" height="16" font="0">thread UTCBs. Each iteration of transferUntyped moves one word and makes</text>
<text top="1007" left="173" width="626" height="16" font="0">a tail recursive call, incrementing the ﬁeld being accessed and decrementing the</text>
<text top="1039" left="173" width="626" height="16" font="0">number of words left to transfer (the function returns when there are no words</text>
</page>
<page number="291" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">269</text>
<text top="163" left="173" width="626" height="16" font="0">left). This code seems innocuous enough and the algorithm being implemented</text>
<text top="195" left="173" width="626" height="16" font="0">by the function is clear, but the per-word transfer cost of more than 7,000 cycles</text>
<text top="228" left="173" width="626" height="16" font="0">indicates that something costly is happening under the surface. By examining the</text>
<text top="260" left="173" width="626" height="16" font="0">deﬁnitions of the read and write operations on UTCB structure, the issues will</text>
<text top="293" left="173" width="148" height="16" font="0">become more clear.</text>
<text top="325" left="199" width="600" height="16" font="0">Each UTCB structure is a pair containing the KernelMapping through which</text>
<text top="358" left="173" width="626" height="16" font="0">we can access the UTCB memory and an Addr Virtual describing the location</text>
<text top="390" left="173" width="626" height="16" font="0">of the UTCB (because each kernel-mapping can contain more than one UTCB</text>
<text top="423" left="173" width="81" height="16" font="0">structure).</text>
<text top="467" left="190" width="352" height="14" font="7">type UTCB = (KernelMapping, Addr Virtual)</text>
<text top="512" left="173" width="626" height="16" font="0">To read a ﬁeld from a UTCB, we use the H function readWordAtOffset (intro-</text>
<text top="544" left="173" width="180" height="16" font="0">duced in Section 4.4.3).</text>
<text top="588" left="190" width="137" height="14" font="7">readWordAtOffset</text>
<text top="588" left="345" width="318" height="14" font="7">:: KernelMapping -&gt; Offset -&gt; H HWord</text>
<text top="635" left="173" width="626" height="15" font="0">readWordAtOffset reads the value stored at a particular oﬀset in a region of mem-</text>
<text top="666" left="173" width="626" height="16" font="0">ory mapped in kernel-space. The oﬀset must lie in the ﬁrst page of the mapped</text>
<text top="698" left="173" width="626" height="16" font="0">region (arbitrary oﬀsets are read with readKernelMapping); the Offset type cap-</text>
<text top="731" left="173" width="626" height="16" font="0">tures the intended bounds on the oﬀset. The utility readUTCBField is a straight-</text>
<text top="763" left="173" width="626" height="16" font="0">forward wrapper for readWordAtOffset. The function extracts the kernel mapping</text>
<text top="796" left="173" width="626" height="16" font="0">that we will read from the supplied UTCB, computes the oﬀset into the kernel map-</text>
<text top="828" left="173" width="626" height="16" font="0">ping where the UTCB lies, and adds the UTCB oﬀset to the oﬀset of the message</text>
<text top="861" left="173" width="593" height="16" font="0">register being accessed to produce an appropriate call to readWordAtOffset.</text>
<text top="904" left="190" width="558" height="14" font="7">readUTCBField :: (KernelMemory m) =&gt; UTCB -&gt; UTCBField -&gt; m HWord</text>
<text top="931" left="190" width="206" height="14" font="7">readUTCBField utcb field</text>
<text top="957" left="207" width="249" height="14" font="7">= readWordAtOffset (fst utcb)</text>
<text top="984" left="242" width="498" height="14" font="7">(Offset (fromIntegral (utcbOffset utcb + fromEnum field)))</text>
<text top="1029" left="173" width="474" height="16" font="0">There are a few things that we should notice about this code:</text>
</page>
<page number="292" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">270</text>
<text top="162" left="199" width="600" height="17" font="0">• We read from the same KernelMapping each time we call readUTCBField</text>
<text top="195" left="217" width="583" height="16" font="0">during the transfer untyped phase of IPC (the kernel-mapping describes</text>
<text top="228" left="217" width="583" height="16" font="0">the sender’s UTCB, which does not change). Despite this consistency, we</text>
<text top="260" left="217" width="583" height="16" font="0">will take the ﬁrst element of the sender UTCB pair to ﬁnd the appropriate</text>
<text top="294" left="217" width="409" height="15" font="0">KernelMapping every single time we transfer a word.</text>
<text top="339" left="199" width="600" height="17" font="0">• We recompute the oﬀset of the sender’s UTCB within the kernel-mapping</text>
<text top="373" left="217" width="563" height="16" font="0">for each word transferred as well, even though this value is also constant.</text>
<text top="419" left="199" width="600" height="17" font="0">• The UTCBField datatype adds ineﬃciency: we allocate unnecessary values</text>
<text top="453" left="217" width="583" height="16" font="0">and incur costs to convert ﬁeld names back and forth to integer oﬀsets. A</text>
<text top="485" left="217" width="583" height="16" font="0">datatype seemed like a nice abstraction for keeping track of the UTCB oﬀsets,</text>
<text top="518" left="217" width="583" height="16" font="0">and had nice implications for safety, but we are not getting any beneﬁt from</text>
<text top="550" left="217" width="453" height="16" font="0">the abstraction here, just the cost of destructing the value.</text>
<text top="598" left="173" width="626" height="16" font="0">The code for writeUTCBField has exactly the same problems, plus the additional</text>
<text top="630" left="173" width="626" height="16" font="0">cost of checking whether or not the writeWordAtOffset function succeeded. Mak-</text>
<text top="663" left="173" width="626" height="16" font="0">ing this check is wasteful because we do not do anything useful when a failure does</text>
<text top="695" left="173" width="626" height="16" font="0">occur. writeWordAtOffset only fails if the client writes to a read-only page; once</text>
<text top="728" left="173" width="626" height="16" font="0">our initial testing conﬁrms that the UTCB pages are conﬁgured correctly, we can</text>
<text top="760" left="173" width="333" height="16" font="0">be sure that this check will always succeed.</text>
<text top="804" left="181" width="619" height="14" font="7">writeUTCBField :: (KernelMemory m) =&gt; UTCB -&gt; UTCBField -&gt; HWord -&gt; m ()</text>
<text top="831" left="181" width="249" height="14" font="7">writeUTCBField utcb field val</text>
<text top="857" left="199" width="232" height="14" font="7">= do b &lt;- writeWordAtOffset</text>
<text top="883" left="302" width="86" height="14" font="7">(fst utcb)</text>
<text top="910" left="302" width="498" height="14" font="7">(Offset (fromIntegral (utcbOffset utcb + fromEnum field)))</text>
<text top="936" left="302" width="26" height="14" font="7">val</text>
<text top="963" left="242" width="481" height="14" font="7">if b then return () else error &#34;error: utcb write error&#34;</text>
<text top="1008" left="173" width="626" height="16" font="0">The readUTCBField and writeUTCBField functions demonstrate how important it</text>
<text top="1040" left="173" width="626" height="16" font="0">is to consider abstractions in the ﬁnal context in which they will be called. Neither</text>
</page>
<page number="293" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">271</text>
<text top="163" left="173" width="626" height="16" font="0">function is problematic in and of itself (though the safety checks do make these</text>
<text top="195" left="173" width="626" height="16" font="0">operations more expensive that a normal read or write in C); the performance</text>
<text top="228" left="173" width="509" height="16" font="0">issues stem from the fact that we invoke these functions in a loop.</text>
<text top="260" left="199" width="600" height="16" font="0">To avoid the repeated computations of our initial implementation, we break the</text>
<text top="293" left="173" width="626" height="16" font="0">abstractions for reading/writing UTCB ﬁelds and inline the calls to the functions</text>
<text top="327" left="173" width="629" height="15" font="0">readWordAtOffset and writeWordAtOffset in the deﬁnition of transferUntyped.</text>
<text top="358" left="173" width="626" height="16" font="0">We also eliminate the use of UTCBField values in the data transfer loop by incre-</text>
<text top="390" left="173" width="626" height="16" font="0">menting the oﬀsets directly. We remove the argument of type UTCBField from</text>
<text top="423" left="173" width="626" height="16" font="0">the transferUntyped function because it is unnecessary; the untyped words al-</text>
<text top="455" left="173" width="626" height="16" font="0">ways start at MR1. Ultimately we would like to remove the UTCBField abstraction</text>
<text top="488" left="173" width="626" height="16" font="0">from the kernel entirely, but for now we leave the rest of the implementation alone</text>
<text top="520" left="173" width="626" height="16" font="0">and return a UTCBField value from transferUntyped for compatibility with the</text>
<text top="553" left="173" width="142" height="16" font="0">existing interfaces.</text>
<text top="591" left="190" width="515" height="14" font="7">transferUntyped :: (KernelMemory m) =&gt; UTCB -&gt; UTCB -&gt; HWord</text>
<text top="617" left="207" width="120" height="14" font="7">-&gt; m UTCBField</text>
<text top="643" left="190" width="301" height="14" font="7">transferUntyped sutcb rutcb numleft</text>
<text top="670" left="207" width="473" height="14" font="7">= transferUntypedItem (sutcboff+1) (rutcboff+1) numleft</text>
<text top="696" left="207" width="43" height="14" font="7">where</text>
<text top="723" left="224" width="524" height="14" font="7">utcbOffset utcb = ((mask (snd utcb) utcbalign) + 256) ‘div‘ 4</text>
<text top="749" left="224" width="172" height="14" font="7">rutcbloc = fst rutcb</text>
<text top="776" left="224" width="232" height="14" font="7">rutcboff = utcbOffset rutcb</text>
<text top="802" left="224" width="172" height="14" font="7">sutcbloc = fst sutcb</text>
<text top="828" left="224" width="232" height="14" font="7">sutcboff = utcbOffset sutcb</text>
<text top="855" left="224" width="361" height="14" font="7">transferUntypedItem readaddr writeaddr num</text>
<text top="881" left="242" width="86" height="14" font="7">| num &lt;= 0</text>
<text top="908" left="276" width="473" height="14" font="7">= return (toEnum (fromIntegral (writeaddr - rutcboff)))</text>
<text top="934" left="242" width="95" height="14" font="7">| otherwise</text>
<text top="960" left="276" width="473" height="14" font="7">= do val &lt;- readWordAtOffset sutcbloc (Offset readaddr)</text>
<text top="987" left="319" width="421" height="14" font="7">writeWordAtOffset rutcbloc (Offset writeaddr) val</text>
<text top="1013" left="319" width="464" height="14" font="7">transferUntypedItem (readaddr+1) (writeaddr+1) (num-1)</text>
<text top="1052" left="173" width="626" height="16" font="0">The structure of the algorithm is the same as the original implementation, but we</text>
</page>
<page number="294" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">272</text>
<text top="163" left="173" width="626" height="16" font="0">now use a helper function to implement the recursion. The helper function copies</text>
<text top="195" left="173" width="626" height="16" font="0">a word of data from a speciﬁc source oﬀset to a speciﬁc destination oﬀset until all</text>
<text top="228" left="173" width="271" height="16" font="0">of the words have been transferred.</text>
<text top="260" left="199" width="600" height="16" font="0">The performance improvement we see when moving to the inlined version of</text>
<text top="293" left="173" width="626" height="16" font="0">untyped data transfer is staggering. Table 8.5 shows the average cycles and mi-</text>
<text top="325" left="173" width="626" height="16" font="0">croseconds per IPC, the speedup of the new implementation over the original</text>
<text top="358" left="173" width="626" height="16" font="0">implementation, and the comparison to Pistachio. Because we are targeting the</text>
<text top="390" left="173" width="626" height="16" font="0">function that copies words from the sender to the receiver, the impact of the new</text>
<text top="423" left="173" width="626" height="16" font="0">algorithm is more pronounced as we transfer more words. The cycle count speedup</text>
<text top="455" left="173" width="626" height="16" font="0">is 22% when transferring just 4 words—increasing to 75% for the peak of 60 mes-</text>
<text top="488" left="173" width="626" height="16" font="0">sage registers. The total time spent in garbage collection for all tests decreased by</text>
<text top="520" left="173" width="626" height="16" font="0">64% in the optimized version. See Section 8.4 for a graphical comparison of all of</text>
<text top="553" left="173" width="328" height="16" font="0">the optimizations discussed in this section.</text>
<text top="585" left="199" width="600" height="16" font="0">Inspired by the improvements we achieved through inlining, we decided to</text>
<text top="618" left="173" width="626" height="16" font="0">experiment with the H read and write functions themselves. Our implementa-</text>
<text top="650" left="173" width="626" height="16" font="0">tion of transferUntyped uses the read/writeWordAtOffset operations from H,</text>
<text top="683" left="173" width="626" height="16" font="0">but these functions require us to allocate Offset values for describing the oﬀset</text>
<text top="715" left="173" width="626" height="16" font="0">we would like to access. H provides additional read and write functions called</text>
<text top="749" left="173" width="626" height="15" font="0">readKernelMapping and writeKernelMapping that take normal words as oﬀsets</text>
<text top="780" left="173" width="60" height="16" font="0">instead:</text>
<text top="824" left="190" width="146" height="14" font="7">readKernelMapping</text>
<text top="824" left="353" width="309" height="14" font="7">:: KernelMapping -&gt; HWord -&gt; H HWord</text>
<text top="851" left="190" width="541" height="14" font="7">writeKernelMapping :: KernelMapping -&gt; HWord -&gt; HWord -&gt; H Bool</text>
<text top="897" left="173" width="626" height="15" font="0">readKernelMapping and writeKernelMapping may access any oﬀset within a</text>
<text top="930" left="173" width="429" height="15" font="0">KernelMapping, not just an oﬀset within the ﬁrst page.</text>
<text top="961" left="199" width="600" height="16" font="0">We reimplemented transferUntyped to use the functions readKernelMapping</text>
<text top="993" left="173" width="626" height="16" font="0">and writeKernelMapping for transferring data from the sender to the receiver,</text>
<text top="1026" left="173" width="626" height="16" font="0">hoping to save cycles on the construction, destruction, and garbage collection of</text>
</page>
<page number="295" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">273</text>
<text top="288" left="315" width="48" height="13" font="4">Words</text>
<text top="288" left="386" width="49" height="13" font="4">Cycles</text>
<text top="288" left="453" width="16" height="13" font="4">µs</text>
<text top="288" left="487" width="33" height="13" font="4">GCs</text>
<text top="288" left="542" width="64" height="13" font="4">Speedup</text>
<text top="287" left="624" width="28" height="14" font="4">× P</text>
<text top="317" left="356" width="7" height="13" font="4">0</text>
<text top="317" left="393" width="42" height="13" font="4">86,336</text>
<text top="317" left="453" width="15" height="13" font="4">52</text>
<text top="317" left="497" width="22" height="13" font="4">323</text>
<text top="317" left="581" width="25" height="13" font="4">-1%</text>
<text top="317" left="637" width="15" height="13" font="4">68</text>
<text top="346" left="356" width="7" height="13" font="4">4</text>
<text top="346" left="393" width="42" height="13" font="4">92,505</text>
<text top="346" left="453" width="15" height="13" font="4">56</text>
<text top="346" left="497" width="22" height="13" font="4">339</text>
<text top="346" left="578" width="27" height="13" font="4">22%</text>
<text top="346" left="637" width="15" height="13" font="4">69</text>
<text top="376" left="356" width="7" height="13" font="4">8</text>
<text top="376" left="393" width="42" height="13" font="4">95,295</text>
<text top="376" left="453" width="15" height="13" font="4">57</text>
<text top="376" left="497" width="22" height="13" font="4">357</text>
<text top="376" left="578" width="27" height="13" font="4">36%</text>
<text top="376" left="637" width="15" height="13" font="4">71</text>
<text top="405" left="348" width="15" height="13" font="4">12</text>
<text top="405" left="393" width="42" height="13" font="4">98,775</text>
<text top="405" left="453" width="15" height="13" font="4">60</text>
<text top="405" left="497" width="22" height="13" font="4">374</text>
<text top="405" left="578" width="27" height="13" font="4">45%</text>
<text top="405" left="637" width="15" height="13" font="4">73</text>
<text top="434" left="348" width="15" height="13" font="4">16</text>
<text top="434" left="385" width="49" height="13" font="4">101,386</text>
<text top="434" left="453" width="15" height="13" font="4">61</text>
<text top="434" left="497" width="22" height="13" font="4">390</text>
<text top="434" left="578" width="27" height="13" font="4">51%</text>
<text top="434" left="637" width="15" height="13" font="4">75</text>
<text top="464" left="348" width="15" height="13" font="4">20</text>
<text top="464" left="385" width="49" height="13" font="4">104,362</text>
<text top="464" left="453" width="15" height="13" font="4">63</text>
<text top="464" left="497" width="22" height="13" font="4">406</text>
<text top="464" left="578" width="27" height="13" font="4">56%</text>
<text top="464" left="637" width="15" height="13" font="4">76</text>
<text top="493" left="348" width="15" height="13" font="4">24</text>
<text top="493" left="385" width="49" height="13" font="4">107,497</text>
<text top="493" left="453" width="15" height="13" font="4">64</text>
<text top="493" left="497" width="22" height="13" font="4">423</text>
<text top="493" left="578" width="27" height="13" font="4">60%</text>
<text top="493" left="637" width="15" height="13" font="4">78</text>
<text top="522" left="348" width="15" height="13" font="4">28</text>
<text top="522" left="385" width="49" height="13" font="4">110,250</text>
<text top="522" left="453" width="15" height="13" font="4">67</text>
<text top="522" left="497" width="22" height="13" font="4">440</text>
<text top="522" left="578" width="27" height="13" font="4">63%</text>
<text top="522" left="637" width="15" height="13" font="4">80</text>
<text top="551" left="348" width="15" height="13" font="4">32</text>
<text top="551" left="385" width="49" height="13" font="4">113,421</text>
<text top="551" left="453" width="15" height="13" font="4">68</text>
<text top="551" left="497" width="22" height="13" font="4">457</text>
<text top="551" left="578" width="27" height="13" font="4">65%</text>
<text top="551" left="637" width="15" height="13" font="4">82</text>
<text top="581" left="348" width="15" height="13" font="4">36</text>
<text top="581" left="385" width="49" height="13" font="4">116,303</text>
<text top="581" left="453" width="15" height="13" font="4">70</text>
<text top="581" left="497" width="22" height="13" font="4">473</text>
<text top="581" left="578" width="27" height="13" font="4">67%</text>
<text top="581" left="637" width="15" height="13" font="4">83</text>
<text top="610" left="348" width="15" height="13" font="4">40</text>
<text top="610" left="385" width="49" height="13" font="4">119,165</text>
<text top="610" left="453" width="15" height="13" font="4">73</text>
<text top="610" left="497" width="22" height="13" font="4">491</text>
<text top="610" left="578" width="27" height="13" font="4">69%</text>
<text top="610" left="637" width="15" height="13" font="4">85</text>
<text top="639" left="348" width="15" height="13" font="4">44</text>
<text top="639" left="385" width="49" height="13" font="4">122,169</text>
<text top="639" left="453" width="15" height="13" font="4">74</text>
<text top="639" left="497" width="22" height="13" font="4">507</text>
<text top="639" left="578" width="27" height="13" font="4">71%</text>
<text top="639" left="637" width="15" height="13" font="4">87</text>
<text top="669" left="348" width="15" height="13" font="4">48</text>
<text top="669" left="385" width="49" height="13" font="4">125,564</text>
<text top="669" left="453" width="15" height="13" font="4">75</text>
<text top="669" left="497" width="22" height="13" font="4">523</text>
<text top="669" left="578" width="27" height="13" font="4">72%</text>
<text top="669" left="637" width="15" height="13" font="4">88</text>
<text top="698" left="348" width="15" height="13" font="4">52</text>
<text top="698" left="385" width="49" height="13" font="4">127,909</text>
<text top="698" left="453" width="15" height="13" font="4">77</text>
<text top="698" left="497" width="22" height="13" font="4">540</text>
<text top="698" left="578" width="27" height="13" font="4">73%</text>
<text top="698" left="637" width="15" height="13" font="4">90</text>
<text top="727" left="348" width="15" height="13" font="4">56</text>
<text top="727" left="385" width="49" height="13" font="4">130,726</text>
<text top="727" left="453" width="15" height="13" font="4">80</text>
<text top="727" left="497" width="22" height="13" font="4">561</text>
<text top="727" left="578" width="27" height="13" font="4">74%</text>
<text top="727" left="637" width="15" height="13" font="4">91</text>
<text top="756" left="348" width="15" height="13" font="4">60</text>
<text top="756" left="385" width="49" height="13" font="4">134,316</text>
<text top="756" left="453" width="15" height="13" font="4">81</text>
<text top="756" left="497" width="22" height="13" font="4">573</text>
<text top="756" left="578" width="27" height="13" font="4">75%</text>
<text top="756" left="637" width="15" height="13" font="4">93</text>
<text top="793" left="173" width="626" height="16" font="0">Table 8.5: The result of inlining the read/write word functions from the H interface</text>
<text top="828" left="173" width="626" height="16" font="0">directly into our inner loop. The speedup column compares the cycles per message</text>
<text top="863" left="173" width="626" height="16" font="0">in the inlined implementation to the performance of the unoptimized version. As</text>
<text top="897" left="173" width="626" height="16" font="0">in Table 8.2, the “× P” column indicates how many times slower the algorithm</text>
<text top="932" left="173" width="218" height="16" font="0">under test is than Pistachio.</text>
</page>
<page number="296" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">274</text>
<text top="164" left="173" width="626" height="15" font="0">Offset values. The new code was exactly the same as our optimized implementa-</text>
<text top="195" left="173" width="626" height="16" font="0">tion except for the use of these functions. Surprisingly, this simple change was up to</text>
<text top="228" left="173" width="626" height="16" font="0">5 times slower than the version using readWordAtOffset and writeWordAtOffset,</text>
<text top="260" left="173" width="626" height="16" font="0">most likely due to the fact that the bounds checks are based on dynamic constants</text>
<text top="293" left="173" width="369" height="16" font="0">stored in records rather than static constants.</text>
<text top="293" left="557" width="242" height="16" font="0">It is also possible that we are</text>
<text top="325" left="173" width="626" height="16" font="0">not paying a high cost for Offset values anyway because of compiler optimiza-</text>
<text top="358" left="173" width="626" height="16" font="0">tions. Finally, there are implementation diﬀerences that make readWordAtOffset</text>
<text top="390" left="173" width="626" height="16" font="0">and writeWordAtOffset more strict. We will see an example in the next section</text>
<text top="423" left="173" width="626" height="16" font="0">where strictness alone causes a similar performance disparity between two small</text>
<text top="455" left="173" width="626" height="16" font="0">functions. Our experiment demonstrates that subtle choices in the API design and</text>
<text top="488" left="173" width="626" height="16" font="0">implementation can signiﬁcantly impact the performance of the client kernel. In</text>
<text top="520" left="173" width="626" height="16" font="0">the next section we will speciﬁcally examine the eﬀects of an optimization at the</text>
<text top="553" left="173" width="429" height="16" font="0">interface level to improve our performance even further.</text>
<text top="613" left="173" width="41" height="16" font="0">8.3.2</text>
<text top="613" left="234" width="454" height="16" font="0">Role of H Primitive Design in Performance Results</text>
<text top="657" left="173" width="626" height="16" font="0">The design choices we make in the H interface strongly inﬂuence the algorithms</text>
<text top="689" left="173" width="626" height="16" font="0">that will be used in the client kernel because the client cannot access low-level</text>
<text top="722" left="173" width="626" height="16" font="0">hardware features via any other mechanism. Sometimes our design choices aﬀect</text>
<text top="754" left="173" width="626" height="16" font="0">the memory-safety argument for H in an essential way and therefore cannot be</text>
<text top="787" left="173" width="626" height="16" font="0">optimized signiﬁcantly. More often though, the design decisions reﬂect an attempt</text>
<text top="819" left="173" width="626" height="16" font="0">to anticipate the needs of kernel implementers, and they do not need to be set</text>
<text top="852" left="173" width="626" height="16" font="0">in stone. In this section, we describe the addition of a new primitive to the H</text>
<text top="884" left="173" width="626" height="16" font="0">interface to demonstrate the impact of interface design on performance and the</text>
<text top="917" left="173" width="343" height="16" font="0">ease with which we can extend the interface.</text>
<text top="949" left="199" width="600" height="16" font="0">In our previous deﬁnitions of transferUntyped, we always copied one word of</text>
<text top="982" left="173" width="626" height="16" font="0">data at a time from the sender to the receiver using the read and write functions</text>
<text top="1014" left="173" width="626" height="16" font="0">of the H interface. In each call to read or write, we must check that the oﬀset</text>
<text top="1047" left="173" width="626" height="16" font="0">being accessed falls within the ﬁrst page of the KernelMapping argument in order</text>
</page>
<page number="297" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">275</text>
<text top="163" left="173" width="626" height="16" font="0">for the access to be safe. (The kernel-mapping may be longer than one page, but</text>
<text top="195" left="173" width="626" height="16" font="0">these functions are optimized to use static checks; every kernel-mapping is at least</text>
<text top="228" left="173" width="626" height="16" font="0">one page long.) The writeWordAtOffset performs an additional check on the</text>
<text top="260" left="173" width="626" height="16" font="0">permissions of the mapping to ensure that we do not page fault in kernel-mode.</text>
<text top="293" left="173" width="626" height="16" font="0">Thus, we incur two checks for every word we read and three for every word we</text>
<text top="325" left="173" width="44" height="16" font="0">write.</text>
<text top="367" left="190" width="137" height="14" font="7">readWordAtOffset</text>
<text top="367" left="345" width="318" height="14" font="7">:: KernelMapping -&gt; Offset -&gt; H HWord</text>
<text top="394" left="190" width="335" height="14" font="7">readWordAtOffset km off@(Offset offset)</text>
<text top="420" left="207" width="309" height="14" font="7">| off &gt;= minBound &amp;&amp; off &lt;= maxBound</text>
<text top="446" left="224" width="541" height="14" font="7">= liftIO $ peekElemOff (kernelAddress km) (fromIntegral offset)</text>
<text top="473" left="207" width="146" height="14" font="7">| otherwise = ...</text>
<text top="526" left="190" width="541" height="14" font="7">writeWordAtOffset :: KernelMapping -&gt; Offset -&gt; HWord -&gt; H Bool</text>
<text top="552" left="190" width="395" height="14" font="7">writeWordAtOffset km off@(Offset offset) value</text>
<text top="579" left="207" width="576" height="14" font="7">| (kernelPerms km) .&amp;. w /= 0 &amp;&amp; off &gt;= minBound &amp;&amp; off &lt;= maxBound</text>
<text top="605" left="224" width="112" height="14" font="7">= do liftIO $</text>
<text top="631" left="284" width="498" height="14" font="7">pokeElemOff (kernelAddress km) (fromIntegral offset) value</text>
<text top="658" left="267" width="95" height="14" font="7">return True</text>
<text top="684" left="207" width="146" height="14" font="7">| otherwise = ...</text>
<text top="727" left="173" width="626" height="16" font="0">The bounds checks are necessary to enforce memory-safety, but the sheer number</text>
<text top="760" left="173" width="626" height="16" font="0">of checks we perform during an IPC transfer suggests that we do not have the right</text>
<text top="792" left="173" width="476" height="16" font="0">interface primitive for the kernels that we want to implement.</text>
<text top="825" left="199" width="600" height="16" font="0">The heart of the problem is that we must validate every memory access inde-</text>
<text top="857" left="173" width="626" height="16" font="0">pendently. If we copy the data in a block, rather than one word at a time, we can</text>
<text top="890" left="173" width="626" height="16" font="0">validate the entire data transfer with just a few bounds checks. We do not need</text>
<text top="922" left="173" width="626" height="16" font="0">to check every intermediate memory access if the starting and ending oﬀsets both</text>
<text top="955" left="173" width="626" height="16" font="0">fall within the bounds of the kernel mapping that is being accessed. Recogniz-</text>
<text top="987" left="173" width="626" height="16" font="0">ing this, we introduce a new H primitive called memcopy, similar to the standard</text>
<text top="1021" left="173" width="626" height="15" font="0">memcopy operation available in C, that provides the ability to copy multiple words</text>
<text top="1052" left="173" width="626" height="16" font="0">from a source kernel-mapping to a destination kernel-mapping with a single call.</text>
</page>
<page number="298" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">276</text>
<text top="163" left="173" width="626" height="16" font="0">The safety guarantees are exactly the same as with a bulk copy implemented via</text>
<text top="195" left="173" width="337" height="16" font="0">multiple calls to read/writeWordAtOffset.</text>
<text top="239" left="190" width="86" height="14" font="7">memcopy ::</text>
<text top="266" left="207" width="558" height="14" font="7">KernelMapping -&gt; HWord -&gt; KernelMapping -&gt; HWord -&gt; HWord -&gt; H ()</text>
<text top="292" left="190" width="361" height="14" font="7">memcopy source sstart dest dstart numwords</text>
<text top="318" left="207" width="284" height="14" font="7">| ((kernelPerms dest) .&amp;. w) == 0</text>
<text top="345" left="224" width="232" height="14" font="7">|| sstart &lt; 0 || dstart &lt; 0</text>
<text top="371" left="224" width="301" height="14" font="7">|| sstart + numwords &gt; pageSize - 1</text>
<text top="398" left="224" width="301" height="14" font="7">|| dstart + numwords &gt; pageSize - 1</text>
<text top="424" left="224" width="301" height="14" font="7">= error &#34;bad parameters to memcopy&#34;</text>
<text top="451" left="207" width="95" height="14" font="7">| otherwise</text>
<text top="477" left="224" width="344" height="14" font="7">= liftIO $ loop soffset doffset numwords</text>
<text top="503" left="259" width="43" height="14" font="7">where</text>
<text top="530" left="276" width="309" height="14" font="7">loop :: Int -&gt; Int -&gt; HWord -&gt; IO ()</text>
<text top="556" left="276" width="318" height="14" font="7">loop s d n = if n == 0 then return ()</text>
<text top="583" left="413" width="335" height="14" font="7">else do val &lt;- peekElemOff sourceaddr s</text>
<text top="609" left="482" width="223" height="14" font="7">pokeElemOff destaddr d val</text>
<text top="636" left="482" width="189" height="14" font="7">loop (s+1) (d+1) (n-1)</text>
<text top="662" left="276" width="284" height="14" font="7">sourceaddr = kernelAddress source</text>
<text top="688" left="276" width="69" height="14" font="7">destaddr</text>
<text top="688" left="370" width="172" height="14" font="7">= kernelAddress dest</text>
<text top="715" left="276" width="60" height="14" font="7">soffset</text>
<text top="715" left="370" width="180" height="14" font="7">= fromIntegral sstart</text>
<text top="741" left="276" width="60" height="14" font="7">doffset</text>
<text top="741" left="370" width="180" height="14" font="7">= fromIntegral dstart</text>
<text top="786" left="173" width="626" height="16" font="0">The memcopy function takes ﬁve arguments. The ﬁrst two describe the source of</text>
<text top="819" left="173" width="626" height="16" font="0">the data to be copied: the source includes the KernelMapping where the data</text>
<text top="851" left="173" width="626" height="16" font="0">will be read from and the oﬀset from which to begin copying data. Similarly, the</text>
<text top="884" left="173" width="626" height="16" font="0">destination includes the KernelMapping where the data will be written to and</text>
<text top="916" left="173" width="626" height="16" font="0">the oﬀset where memcopy should begin writing. The ﬁnal argument speciﬁes the</text>
<text top="949" left="173" width="194" height="16" font="0">number of words to copy.</text>
<text top="981" left="199" width="600" height="16" font="0">We redeﬁned transferUntyped yet again to use memcopy instead of the per-</text>
<text top="1014" left="173" width="626" height="16" font="0">word read and write functions that we used to copy data between the sender</text>
<text top="1046" left="173" width="626" height="16" font="0">and the receiver in the optimized version of Section 8.3.1. Table 8.6 shows the</text>
</page>
<page number="299" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">277</text>
<text top="168" left="315" width="48" height="13" font="4">Words</text>
<text top="168" left="385" width="49" height="13" font="4">Cycles</text>
<text top="168" left="452" width="16" height="13" font="4">µs</text>
<text top="168" left="487" width="33" height="13" font="4">GCs</text>
<text top="168" left="542" width="64" height="13" font="4">Speedup</text>
<text top="167" left="624" width="28" height="14" font="4">× P</text>
<text top="197" left="356" width="7" height="13" font="4">0</text>
<text top="197" left="392" width="42" height="13" font="4">90,776</text>
<text top="197" left="453" width="15" height="13" font="4">56</text>
<text top="197" left="497" width="22" height="13" font="4">336</text>
<text top="197" left="581" width="25" height="13" font="4">-5%</text>
<text top="197" left="637" width="15" height="13" font="4">71</text>
<text top="226" left="356" width="7" height="13" font="4">4</text>
<text top="226" left="392" width="42" height="13" font="4">91,408</text>
<text top="226" left="453" width="15" height="13" font="4">54</text>
<text top="226" left="497" width="22" height="13" font="4">336</text>
<text top="226" left="586" width="20" height="13" font="4">1%</text>
<text top="226" left="637" width="15" height="13" font="4">69</text>
<text top="256" left="356" width="7" height="13" font="4">8</text>
<text top="256" left="392" width="42" height="13" font="4">91,510</text>
<text top="256" left="453" width="15" height="13" font="4">56</text>
<text top="256" left="497" width="22" height="13" font="4">336</text>
<text top="256" left="586" width="20" height="13" font="4">4%</text>
<text top="256" left="637" width="15" height="13" font="4">68</text>
<text top="285" left="348" width="15" height="13" font="4">12</text>
<text top="285" left="392" width="42" height="13" font="4">91,470</text>
<text top="285" left="453" width="15" height="13" font="4">54</text>
<text top="285" left="497" width="22" height="13" font="4">336</text>
<text top="285" left="586" width="20" height="13" font="4">7%</text>
<text top="285" left="637" width="15" height="13" font="4">68</text>
<text top="314" left="348" width="15" height="13" font="4">16</text>
<text top="314" left="392" width="42" height="13" font="4">92,193</text>
<text top="314" left="453" width="15" height="13" font="4">56</text>
<text top="314" left="497" width="22" height="13" font="4">340</text>
<text top="314" left="586" width="20" height="13" font="4">9%</text>
<text top="314" left="637" width="15" height="13" font="4">68</text>
<text top="343" left="348" width="15" height="13" font="4">20</text>
<text top="343" left="392" width="42" height="13" font="4">92,348</text>
<text top="343" left="453" width="15" height="13" font="4">56</text>
<text top="343" left="497" width="22" height="13" font="4">341</text>
<text top="343" left="578" width="27" height="13" font="4">12%</text>
<text top="343" left="637" width="15" height="13" font="4">68</text>
<text top="373" left="348" width="15" height="13" font="4">24</text>
<text top="373" left="392" width="42" height="13" font="4">92,659</text>
<text top="373" left="453" width="15" height="13" font="4">56</text>
<text top="373" left="497" width="22" height="13" font="4">343</text>
<text top="373" left="578" width="27" height="13" font="4">14%</text>
<text top="373" left="637" width="15" height="13" font="4">68</text>
<text top="402" left="348" width="15" height="13" font="4">28</text>
<text top="402" left="392" width="42" height="13" font="4">92,922</text>
<text top="402" left="453" width="15" height="13" font="4">56</text>
<text top="402" left="497" width="22" height="13" font="4">345</text>
<text top="402" left="578" width="27" height="13" font="4">16%</text>
<text top="402" left="637" width="15" height="13" font="4">67</text>
<text top="431" left="348" width="15" height="13" font="4">32</text>
<text top="431" left="392" width="42" height="13" font="4">93,236</text>
<text top="431" left="453" width="15" height="13" font="4">56</text>
<text top="431" left="497" width="22" height="13" font="4">347</text>
<text top="431" left="578" width="27" height="13" font="4">18%</text>
<text top="431" left="637" width="15" height="13" font="4">67</text>
<text top="461" left="348" width="15" height="13" font="4">36</text>
<text top="461" left="392" width="42" height="13" font="4">93,556</text>
<text top="461" left="453" width="15" height="13" font="4">56</text>
<text top="461" left="497" width="22" height="13" font="4">349</text>
<text top="461" left="578" width="27" height="13" font="4">20%</text>
<text top="461" left="637" width="15" height="13" font="4">67</text>
<text top="490" left="348" width="15" height="13" font="4">40</text>
<text top="490" left="392" width="42" height="13" font="4">93,651</text>
<text top="490" left="453" width="15" height="13" font="4">57</text>
<text top="490" left="497" width="22" height="13" font="4">351</text>
<text top="490" left="578" width="27" height="13" font="4">21%</text>
<text top="490" left="637" width="15" height="13" font="4">67</text>
<text top="519" left="348" width="15" height="13" font="4">44</text>
<text top="519" left="392" width="42" height="13" font="4">94,024</text>
<text top="519" left="453" width="15" height="13" font="4">56</text>
<text top="519" left="497" width="22" height="13" font="4">352</text>
<text top="519" left="578" width="27" height="13" font="4">23%</text>
<text top="519" left="637" width="15" height="13" font="4">67</text>
<text top="549" left="348" width="15" height="13" font="4">48</text>
<text top="549" left="392" width="42" height="13" font="4">94,353</text>
<text top="549" left="453" width="15" height="13" font="4">56</text>
<text top="549" left="497" width="22" height="13" font="4">354</text>
<text top="549" left="578" width="27" height="13" font="4">25%</text>
<text top="549" left="637" width="15" height="13" font="4">66</text>
<text top="578" left="348" width="15" height="13" font="4">52</text>
<text top="578" left="392" width="42" height="13" font="4">94,572</text>
<text top="578" left="453" width="15" height="13" font="4">57</text>
<text top="578" left="497" width="22" height="13" font="4">355</text>
<text top="578" left="578" width="27" height="13" font="4">26%</text>
<text top="578" left="637" width="15" height="13" font="4">66</text>
<text top="607" left="348" width="15" height="13" font="4">56</text>
<text top="607" left="392" width="42" height="13" font="4">94,805</text>
<text top="607" left="453" width="15" height="13" font="4">57</text>
<text top="607" left="497" width="22" height="13" font="4">357</text>
<text top="607" left="578" width="27" height="13" font="4">27%</text>
<text top="607" left="637" width="15" height="13" font="4">66</text>
<text top="636" left="348" width="15" height="13" font="4">60</text>
<text top="636" left="392" width="42" height="13" font="4">94,768</text>
<text top="636" left="453" width="15" height="13" font="4">57</text>
<text top="636" left="497" width="22" height="13" font="4">359</text>
<text top="636" left="578" width="27" height="13" font="4">29%</text>
<text top="636" left="637" width="15" height="13" font="4">66</text>
<text top="672" left="173" width="626" height="16" font="0">Table 8.6: Performance of IPC when using a multi-word copy to transfer IPC</text>
<text top="707" left="173" width="626" height="16" font="0">messages instead of individual read/write word functions. The speedup column</text>
<text top="742" left="173" width="535" height="16" font="0">compares these results to the inlined implementation in Section 8.3.1.</text>
<text top="793" left="173" width="626" height="16" font="0">performance of IPC after this change, including a calculation of the speedup of</text>
<text top="826" left="173" width="626" height="16" font="0">IPC compared to the previously optimized results. As we transfer more words, the</text>
<text top="858" left="173" width="626" height="16" font="0">impact of the multi-word copy becomes more signiﬁcant. This is to be expected</text>
<text top="891" left="173" width="626" height="16" font="0">because the issue with the old primitives was the high per-word transfer cost that</text>
<text top="923" left="173" width="626" height="16" font="0">they imposed on IPC. The cost of the memcopy version is higher when we do not</text>
<text top="956" left="173" width="626" height="16" font="0">transfer any words because the implementation unnecessarily incurs the checking</text>
<text top="988" left="173" width="626" height="16" font="0">cost when no data will be transferred. This is easily ﬁxable by modifying the caller</text>
<text top="1021" left="173" width="626" height="16" font="0">of transferUntyped—the new version should only be called when there is actually</text>
</page>
<page number="300" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">278</text>
<text top="163" left="173" width="191" height="16" font="0">data to be copied across.</text>
<text top="195" left="199" width="600" height="16" font="0">Though the memcopy operation is speciﬁc to the transferUntyped routine,</text>
<text top="228" left="173" width="626" height="16" font="0">adding a new primitive to optimize the performance of a common operation is a</text>
<text top="260" left="173" width="626" height="16" font="0">general technique for optimizing an interface. This is one of the generic techniques</text>
<text top="293" left="173" width="626" height="16" font="0">that we will consider when pursuing future eﬀorts to improve the performance of</text>
<text top="325" left="173" width="25" height="16" font="0">L4.</text>
<text top="385" left="173" width="41" height="16" font="0">8.3.3</text>
<text top="385" left="234" width="460" height="16" font="0">Using Compiler Pragmas to Fine-Tune Performance</text>
<text top="429" left="173" width="626" height="16" font="0">GHC performs many optimizations while compiling Haskell code that are not al-</text>
<text top="462" left="173" width="626" height="16" font="0">ways obvious to the programmer from looking at the source. To give the pro-</text>
<text top="494" left="173" width="626" height="16" font="0">grammer more control over the program that will actually run, GHC provides a</text>
<text top="527" left="173" width="626" height="16" font="0">wealth of compiler annotations that inﬂuence the behavior of the compiler directly</text>
<text top="559" left="173" width="626" height="16" font="0">and indirectly during the optimization phase. In this section, we examine a few</text>
<text top="592" left="173" width="626" height="16" font="0">of the techniques for controlling the behavior of GHC-generated code: strictness</text>
<text top="624" left="173" width="626" height="16" font="0">annotations, data structure unpacking, and inlining pragmas. The full selection</text>
<text top="657" left="173" width="626" height="16" font="0">of annotations is described in the GHC user’s manual [91]. We apply these tech-</text>
<text top="689" left="173" width="626" height="16" font="0">niques to our kernel, focusing on the transfer untyped phase of IPC, and examine</text>
<text top="722" left="173" width="186" height="16" font="0">the performance results.</text>
<text top="754" left="199" width="600" height="16" font="0">Strictness annotations are a very powerful, albeit subtle, mechanism for con-</text>
<text top="787" left="173" width="626" height="16" font="0">trolling the behavior of a Haskell program. They allow the programmer to force</text>
<text top="819" left="173" width="626" height="16" font="0">the evaluation of a value whose computation might otherwise be delayed until a</text>
<text top="852" left="173" width="626" height="16" font="0">later point in the program. A strictness annotation is written !. Some changes to</text>
<text top="884" left="173" width="626" height="16" font="0">the strictness of a Haskell program inherently improve performance, but the real</text>
<text top="917" left="173" width="626" height="16" font="0">importance of strictness annotations comes from the secondary eﬀects that they</text>
<text top="949" left="173" width="626" height="16" font="0">induce. Properly placed strictness annotations can enable better function inlining</text>
<text top="982" left="173" width="626" height="16" font="0">and more constructor elimination by the compiler. The presence or absence of</text>
<text top="1014" left="173" width="626" height="16" font="0">those optimizations can be signiﬁcant. For example, a bug in our initial imple-</text>
<text top="1047" left="173" width="626" height="16" font="0">mentations of readWordAtOffset and writeWordAtOffset made those functions</text>
</page>
<page number="301" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">279</text>
<text top="163" left="173" width="626" height="16" font="0">lazy in the Offset parameter (recall that these functions take a KernelMapping</text>
<text top="195" left="173" width="626" height="16" font="0">and the Offset in that mapping to access). This strictness diﬀerence alone slowed</text>
<text top="228" left="173" width="626" height="16" font="0">down our version of transferUntyped with these functions inlined (presented in</text>
<text top="260" left="173" width="626" height="16" font="0">Section 8.3.1) by up to 248%. The garbage collection time in the lazier version</text>
<text top="293" left="173" width="573" height="16" font="0">went up by 220%. All because of a strictness diﬀerence in two parameters!</text>
<text top="325" left="199" width="600" height="16" font="0">To illustrate the use of strictness annotations in a Haskell program, we will</text>
<text top="358" left="173" width="626" height="16" font="0">examine the deﬁnition of memcopy that we presented in the previous section. We</text>
<text top="390" left="173" width="557" height="16" font="0">focus on the deﬁnition of the inner loop that actually transfers the data.</text>
<text top="431" left="190" width="309" height="14" font="7">loop :: Int -&gt; Int -&gt; HWord -&gt; IO ()</text>
<text top="457" left="190" width="335" height="14" font="7">loop !s !d n = if n == 0 then return ()</text>
<text top="483" left="319" width="335" height="14" font="7">else do val &lt;- peekElemOff sourceaddr s</text>
<text top="510" left="388" width="223" height="14" font="7">pokeElemOff destaddr d val</text>
<text top="536" left="388" width="189" height="14" font="7">loop (s+1) (d+1) (n-1)</text>
<text top="578" left="173" width="626" height="16" font="0">Our original deﬁnition of loop did not include strictness annotations on s and d.</text>
<text top="610" left="173" width="626" height="16" font="0">Although it appeared that we were creating a strict function that uses the source</text>
<text top="643" left="173" width="626" height="16" font="0">address s to read a value and the destination address d to write a value, we were</text>
<text top="675" left="173" width="626" height="16" font="0">actually building a delayed computation (called a thunk). We need to force the</text>
<text top="708" left="173" width="626" height="16" font="0">evaluation of s and d explicitly, as shown in the new deﬁnition of loop, because</text>
<text top="740" left="173" width="577" height="16" font="0">otherwise these values will not actually be demanded within the loop code.</text>
<text top="773" left="199" width="600" height="16" font="0">Another annotation available with GHC is the UNPACK pragma. We use unpack</text>
<text top="805" left="173" width="626" height="16" font="0">annotations to signal the compiler to unpack the contents of a constructor ﬁeld</text>
<text top="838" left="173" width="626" height="16" font="0">into the constructor itself, eﬀectively eliminating a level of indirection. Unpacking</text>
<text top="870" left="173" width="626" height="16" font="0">is the analog of inlining for data structures. This pragma is always used in con-</text>
<text top="903" left="173" width="626" height="16" font="0">junction with a strictness annotation. As an example, consider the deﬁnition of</text>
<text top="935" left="173" width="571" height="16" font="0">the KernelMapping datatype that we rely on in the deﬁnition of memcopy.</text>
<text top="975" left="190" width="309" height="14" font="7">data KernelMapping = KernelMapping {</text>
<text top="1002" left="388" width="95" height="14" font="7">kernelFpage</text>
<text top="1002" left="508" width="292" height="14" font="7">:: {-# UNPACK #-}!(Fpage Virtual),</text>
<text top="1028" left="388" width="103" height="14" font="7">kernelRegion</text>
<text top="1028" left="508" width="284" height="14" font="7">:: {-# UNPACK #-}!PhysicalRegion,</text>
<text top="1055" left="388" width="95" height="14" font="7">kernelPerms</text>
<text top="1055" left="508" width="206" height="14" font="7">:: {-# UNPACK #-}!Perms,</text>
</page>
<page number="302" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">280</text>
<text top="165" left="388" width="369" height="14" font="7">kernelAddress :: {-# UNPACK #-}!(Ptr HWord)</text>
<text top="192" left="362" width="9" height="14" font="7">}</text>
<text top="231" left="173" width="626" height="16" font="0">Each ﬁeld of the KernelMapping record can be unpacked to inline the deﬁnition</text>
<text top="263" left="173" width="626" height="16" font="0">and unbox the value into the deﬁnition of KernelMapping. Thus, when we access</text>
<text top="296" left="173" width="626" height="16" font="0">a ﬁeld of KernelMapping, such as kernelFpage, we will be able to use the value</text>
<text top="328" left="173" width="626" height="16" font="0">of the ﬁeld directly. Unpacking is not always a win though: if an unpacked data</text>
<text top="361" left="173" width="626" height="16" font="0">structure is used in an unoptimized function, the values may have to be reboxed</text>
<text top="393" left="173" width="187" height="16" font="0">before they can be used.</text>
<text top="426" left="199" width="600" height="16" font="0">The ﬁnal compiler pragma we will discuss in this section allows the programmer</text>
<text top="458" left="173" width="626" height="16" font="0">to specify inlining behavior for a particular function. For example, we could specify</text>
<text top="496" left="190" width="189" height="14" font="7">{-# INLINE memcopy #-}</text>
<text top="535" left="173" width="407" height="16" font="0">to tell the compiler to inline the memcopy function or</text>
<text top="573" left="190" width="206" height="14" font="7">{-# NOINLINE memcopy #-}</text>
<text top="612" left="173" width="626" height="16" font="0">to signal that we would not like memcopy to be inlined. In our experience, the</text>
<text top="645" left="173" width="626" height="16" font="0">compiler typically does a much better job inlining when you do not use an INLINE</text>
<text top="677" left="173" width="626" height="16" font="0">pragma. For example, in the memcopy example, we observed a performance degra-</text>
<text top="710" left="173" width="313" height="16" font="0">dation when we added an inline pragma.</text>
<text top="742" left="199" width="600" height="16" font="0">Despite the bad results we experienced by explicitly inlining memcopy, there are</text>
<text top="775" left="173" width="626" height="16" font="0">places in our L4 implementation where inlining pragmas are helpful. For example,</text>
<text top="807" left="173" width="626" height="16" font="0">the L4 kernel utilizes a plethora of state monad get/set variants for accessing</text>
<text top="840" left="173" width="626" height="16" font="0">speciﬁc components of the L4 state. These functions cannot always be inlined</text>
<text top="872" left="173" width="626" height="16" font="0">because of overloading. The readThread utility reads a Thread structure from</text>
<text top="905" left="173" width="626" height="16" font="0">the thread map of the L4 system state using its thread id. We can add an inline</text>
<text top="937" left="173" width="271" height="16" font="0">pragma to the deﬁnition as follows.</text>
<text top="975" left="190" width="215" height="14" font="7">{-# INLINE readThread #-}</text>
<text top="1002" left="190" width="576" height="14" font="7">readThread :: (StateMonad System m) =&gt; ThreadId -&gt; m (Maybe Thread)</text>
<text top="1028" left="190" width="266" height="14" font="7">readThread !tid = do sys &lt;- get</text>
<text top="1055" left="370" width="412" height="14" font="7">return (lookup (identifier tid) (threadMap sys))</text>
</page>
<page number="303" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">281</text>
<text top="168" left="315" width="48" height="13" font="4">Words</text>
<text top="168" left="385" width="49" height="13" font="4">Cycles</text>
<text top="168" left="452" width="16" height="13" font="4">µs</text>
<text top="168" left="487" width="33" height="13" font="4">GCs</text>
<text top="168" left="542" width="64" height="13" font="4">Speedup</text>
<text top="167" left="624" width="28" height="14" font="4">× P</text>
<text top="197" left="356" width="7" height="13" font="4">0</text>
<text top="197" left="392" width="42" height="13" font="4">77,233</text>
<text top="197" left="453" width="15" height="13" font="4">46</text>
<text top="197" left="497" width="22" height="13" font="4">269</text>
<text top="197" left="578" width="27" height="13" font="4">15%</text>
<text top="197" left="637" width="15" height="13" font="4">61</text>
<text top="226" left="356" width="7" height="13" font="4">4</text>
<text top="226" left="392" width="42" height="13" font="4">77,875</text>
<text top="226" left="453" width="15" height="13" font="4">47</text>
<text top="226" left="497" width="22" height="13" font="4">272</text>
<text top="226" left="578" width="27" height="13" font="4">15%</text>
<text top="226" left="637" width="15" height="13" font="4">58</text>
<text top="256" left="356" width="7" height="13" font="4">8</text>
<text top="256" left="392" width="42" height="13" font="4">78,356</text>
<text top="256" left="453" width="15" height="13" font="4">47</text>
<text top="256" left="497" width="22" height="13" font="4">273</text>
<text top="256" left="578" width="27" height="13" font="4">14%</text>
<text top="256" left="637" width="15" height="13" font="4">59</text>
<text top="285" left="348" width="15" height="13" font="4">12</text>
<text top="285" left="392" width="42" height="13" font="4">78,691</text>
<text top="285" left="453" width="15" height="13" font="4">47</text>
<text top="285" left="497" width="22" height="13" font="4">275</text>
<text top="285" left="578" width="27" height="13" font="4">14%</text>
<text top="285" left="637" width="15" height="13" font="4">58</text>
<text top="314" left="348" width="15" height="13" font="4">16</text>
<text top="314" left="392" width="42" height="13" font="4">79,485</text>
<text top="314" left="453" width="15" height="13" font="4">47</text>
<text top="314" left="497" width="22" height="13" font="4">277</text>
<text top="314" left="578" width="27" height="13" font="4">14%</text>
<text top="314" left="637" width="15" height="13" font="4">59</text>
<text top="343" left="348" width="15" height="13" font="4">20</text>
<text top="343" left="392" width="42" height="13" font="4">79,993</text>
<text top="343" left="453" width="15" height="13" font="4">49</text>
<text top="343" left="497" width="22" height="13" font="4">280</text>
<text top="343" left="578" width="27" height="13" font="4">13%</text>
<text top="343" left="637" width="15" height="13" font="4">59</text>
<text top="373" left="348" width="15" height="13" font="4">24</text>
<text top="373" left="392" width="42" height="13" font="4">80,342</text>
<text top="373" left="453" width="15" height="13" font="4">49</text>
<text top="373" left="497" width="22" height="13" font="4">281</text>
<text top="373" left="578" width="27" height="13" font="4">13%</text>
<text top="373" left="637" width="15" height="13" font="4">59</text>
<text top="402" left="348" width="15" height="13" font="4">28</text>
<text top="402" left="392" width="42" height="13" font="4">80,386</text>
<text top="402" left="453" width="15" height="13" font="4">49</text>
<text top="402" left="497" width="22" height="13" font="4">282</text>
<text top="402" left="578" width="27" height="13" font="4">13%</text>
<text top="402" left="637" width="15" height="13" font="4">58</text>
<text top="431" left="348" width="15" height="13" font="4">32</text>
<text top="431" left="392" width="42" height="13" font="4">81,160</text>
<text top="431" left="453" width="15" height="13" font="4">49</text>
<text top="431" left="497" width="22" height="13" font="4">284</text>
<text top="431" left="578" width="27" height="13" font="4">13%</text>
<text top="431" left="637" width="15" height="13" font="4">58</text>
<text top="461" left="348" width="15" height="13" font="4">36</text>
<text top="461" left="392" width="42" height="13" font="4">81,852</text>
<text top="461" left="453" width="15" height="13" font="4">49</text>
<text top="461" left="497" width="22" height="13" font="4">285</text>
<text top="461" left="578" width="27" height="13" font="4">13%</text>
<text top="461" left="637" width="15" height="13" font="4">59</text>
<text top="490" left="348" width="15" height="13" font="4">40</text>
<text top="490" left="392" width="42" height="13" font="4">82,386</text>
<text top="490" left="453" width="15" height="13" font="4">50</text>
<text top="490" left="497" width="22" height="13" font="4">288</text>
<text top="490" left="578" width="27" height="13" font="4">12%</text>
<text top="490" left="637" width="15" height="13" font="4">59</text>
<text top="519" left="348" width="15" height="13" font="4">44</text>
<text top="519" left="392" width="42" height="13" font="4">82,795</text>
<text top="519" left="453" width="15" height="13" font="4">50</text>
<text top="519" left="497" width="22" height="13" font="4">289</text>
<text top="519" left="578" width="27" height="13" font="4">12%</text>
<text top="519" left="637" width="15" height="13" font="4">59</text>
<text top="549" left="348" width="15" height="13" font="4">48</text>
<text top="549" left="392" width="42" height="13" font="4">83,372</text>
<text top="549" left="453" width="15" height="13" font="4">50</text>
<text top="549" left="497" width="22" height="13" font="4">291</text>
<text top="549" left="578" width="27" height="13" font="4">12%</text>
<text top="549" left="637" width="15" height="13" font="4">59</text>
<text top="578" left="348" width="15" height="13" font="4">52</text>
<text top="578" left="392" width="42" height="13" font="4">83,827</text>
<text top="578" left="453" width="15" height="13" font="4">50</text>
<text top="578" left="497" width="22" height="13" font="4">293</text>
<text top="578" left="578" width="27" height="13" font="4">11%</text>
<text top="578" left="637" width="15" height="13" font="4">59</text>
<text top="607" left="348" width="15" height="13" font="4">56</text>
<text top="607" left="392" width="42" height="13" font="4">84,428</text>
<text top="607" left="453" width="15" height="13" font="4">52</text>
<text top="607" left="497" width="22" height="13" font="4">295</text>
<text top="607" left="578" width="27" height="13" font="4">11%</text>
<text top="607" left="637" width="15" height="13" font="4">59</text>
<text top="636" left="348" width="15" height="13" font="4">60</text>
<text top="636" left="392" width="42" height="13" font="4">84,766</text>
<text top="636" left="453" width="15" height="13" font="4">50</text>
<text top="636" left="497" width="22" height="13" font="4">296</text>
<text top="636" left="578" width="27" height="13" font="4">11%</text>
<text top="636" left="637" width="15" height="13" font="4">59</text>
<text top="672" left="173" width="626" height="16" font="0">Table 8.7: Performance of IPC when using strictness annotations and compiler</text>
<text top="707" left="173" width="626" height="16" font="0">pragmas for datatype unpacking and inlining in the essential components that</text>
<text top="742" left="173" width="626" height="16" font="0">aﬀect IPC. The speedup column compares these results to the multi-word copy</text>
<text top="776" left="173" width="248" height="16" font="0">implementation in Section 8.3.2.</text>
<text top="828" left="173" width="626" height="16" font="0">Our experiments indicate that explicitly inlining readThread improves the overall</text>
<text top="860" left="173" width="626" height="16" font="0">performance of IPC. We also add a strictness annotation to the thread identiﬁer</text>
<text top="893" left="173" width="446" height="16" font="0">argument to prevent the computation from being delayed.</text>
<text top="925" left="199" width="600" height="16" font="0">Table 8.7 summarizes the results of a variety of small optimizations through</text>
<text top="958" left="173" width="626" height="16" font="0">compiler annotations. The most signiﬁcant changes are making the inner loop of</text>
<text top="992" left="173" width="626" height="15" font="0">memcopy strict and using unpacked strict ﬁelds in the data structures that memcopy</text>
</page>
<page number="304" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">282</text>
<text top="163" left="173" width="626" height="16" font="0">relies on. This is the only area where we invested focused eﬀort on optimiza-</text>
<text top="195" left="173" width="626" height="16" font="0">tion. We also added strictness annotations to some of the scheduling and state</text>
<text top="228" left="173" width="626" height="16" font="0">monad read/write utilities, but we did not optimize the calling code of any of</text>
<text top="260" left="173" width="626" height="16" font="0">these functions so the optimizations will have limited impact. We observe modest</text>
<text top="293" left="173" width="626" height="16" font="0">performance improvements over the unoptimized memcopy-based implementation</text>
<text top="325" left="173" width="626" height="16" font="0">in Section 8.3.2. Our ﬁnal results indicate that our kernel is about 60 times slower</text>
<text top="358" left="173" width="626" height="16" font="0">than Pistachio, although there is still plenty of room for improvement by optimiz-</text>
<text top="390" left="173" width="217" height="16" font="0">ing the other phases of IPC.</text>
<text top="423" left="199" width="600" height="16" font="0">So far, our optimization eﬀorts have mostly aﬀected the transfer untyped phase</text>
<text top="455" left="173" width="626" height="16" font="0">of IPC. Though we focused on optimizing the transfer of untyped words, the com-</text>
<text top="488" left="173" width="626" height="16" font="0">piler annotations do impact the performance of other phases of IPC. A diﬃcult</text>
<text top="520" left="173" width="626" height="16" font="0">aspect of optimizing Haskell code by trying to control the compiler is that the an-</text>
<text top="553" left="173" width="626" height="16" font="0">notations do not always improve performance. Table 8.8 shows the breakdown of</text>
<text top="585" left="173" width="626" height="16" font="0">the cycles spent in each phase of IPC: many parts of IPC are faster than the origi-</text>
<text top="618" left="173" width="626" height="16" font="0">nal implementation but some are slower. These results are comparable to Table 8.3</text>
<text top="650" left="173" width="626" height="16" font="0">in Section 8.2.1. One notable result is that the overhead is much lower and more</text>
<text top="683" left="173" width="626" height="16" font="0">consistent than in the initial measurements. In general, the increased strictness</text>
<text top="715" left="173" width="626" height="16" font="0">we added through our annotations made the cost per phase much more consistent,</text>
<text top="748" left="173" width="562" height="16" font="0">even in phases where the performance got worse (such as thread restart).</text>
<text top="810" left="173" width="26" height="16" font="0">8.4</text>
<text top="810" left="219" width="109" height="16" font="0">SUMMARY</text>
<text top="860" left="173" width="626" height="16" font="0">Sections 8.3.1, 8.3.2, and 8.3.3 describe incremental optimizations to our original</text>
<text top="892" left="173" width="626" height="16" font="0">IPC implementation. In this section, we evaluate the overall eﬀectiveness of our</text>
<text top="925" left="173" width="626" height="16" font="0">optimization techniques by comparing the performance of each variant of IPC. We</text>
<text top="957" left="173" width="626" height="16" font="0">also compare the cycles spent in each phase of IPC in our ﬁnal implementation to</text>
<text top="990" left="173" width="350" height="16" font="0">the initial IPC breakdown from Section 8.2.1.</text>
<text top="1022" left="199" width="600" height="16" font="0">Figure 8.4 illustrates the performance of each IPC algorithm. Figure 8.4(a)</text>
</page>
<page number="305" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">283</text>
<text top="202" left="202" width="48" height="13" font="4">Words</text>
<text top="202" left="280" width="26" height="13" font="4">OH</text>
<text top="202" left="336" width="31" height="13" font="4">Sch.</text>
<text top="202" left="397" width="22" height="13" font="4">SR</text>
<text top="202" left="451" width="28" height="13" font="4">TM</text>
<text top="202" left="498" width="25" height="13" font="4">TU</text>
<text top="202" left="552" width="31" height="13" font="4">Rst.</text>
<text top="202" left="609" width="34" height="13" font="4">Rcv.</text>
<text top="202" left="670" width="26" height="13" font="4">GC</text>
<text top="202" left="720" width="39" height="13" font="4">Total</text>
<text top="231" left="243" width="7" height="13" font="4">0</text>
<text top="231" left="273" width="34" height="13" font="4">3,102</text>
<text top="231" left="325" width="42" height="13" font="4">22,742</text>
<text top="231" left="385" width="34" height="13" font="4">6,140</text>
<text top="231" left="438" width="42" height="13" font="4">17,549</text>
<text top="231" left="501" width="22" height="13" font="4">474</text>
<text top="231" left="542" width="42" height="13" font="4">18,412</text>
<text top="231" left="602" width="42" height="13" font="4">16,688</text>
<text top="231" left="673" width="22" height="13" font="4">920</text>
<text top="231" left="718" width="42" height="13" font="4">86,027</text>
<text top="260" left="243" width="7" height="13" font="4">4</text>
<text top="260" left="273" width="34" height="13" font="4">3,143</text>
<text top="260" left="325" width="42" height="13" font="4">22,605</text>
<text top="260" left="385" width="34" height="13" font="4">6,073</text>
<text top="260" left="438" width="42" height="13" font="4">18,408</text>
<text top="260" left="501" width="22" height="13" font="4">482</text>
<text top="260" left="542" width="42" height="13" font="4">18,456</text>
<text top="260" left="602" width="42" height="13" font="4">16,686</text>
<text top="260" left="673" width="22" height="13" font="4">932</text>
<text top="260" left="718" width="42" height="13" font="4">86,785</text>
<text top="289" left="243" width="7" height="13" font="4">8</text>
<text top="289" left="273" width="34" height="13" font="4">2,600</text>
<text top="289" left="325" width="42" height="13" font="4">22,779</text>
<text top="289" left="385" width="34" height="13" font="4">6,069</text>
<text top="289" left="438" width="42" height="13" font="4">18,759</text>
<text top="289" left="501" width="22" height="13" font="4">490</text>
<text top="289" left="542" width="42" height="13" font="4">18,574</text>
<text top="289" left="602" width="42" height="13" font="4">16,593</text>
<text top="289" left="673" width="22" height="13" font="4">948</text>
<text top="289" left="718" width="42" height="13" font="4">86,812</text>
<text top="319" left="236" width="15" height="13" font="4">12</text>
<text top="319" left="273" width="34" height="13" font="4">2,790</text>
<text top="319" left="325" width="42" height="13" font="4">22,712</text>
<text top="319" left="385" width="34" height="13" font="4">6,150</text>
<text top="319" left="438" width="42" height="13" font="4">19,209</text>
<text top="319" left="501" width="22" height="13" font="4">489</text>
<text top="319" left="542" width="42" height="13" font="4">18,583</text>
<text top="319" left="602" width="42" height="13" font="4">16,597</text>
<text top="319" left="673" width="22" height="13" font="4">941</text>
<text top="319" left="718" width="42" height="13" font="4">87,471</text>
<text top="348" left="236" width="15" height="13" font="4">16</text>
<text top="348" left="273" width="34" height="13" font="4">2,120</text>
<text top="348" left="325" width="42" height="13" font="4">22,990</text>
<text top="348" left="385" width="34" height="13" font="4">5,973</text>
<text top="348" left="438" width="42" height="13" font="4">20,510</text>
<text top="348" left="501" width="22" height="13" font="4">507</text>
<text top="348" left="542" width="42" height="13" font="4">18,810</text>
<text top="348" left="602" width="42" height="13" font="4">16,418</text>
<text top="348" left="673" width="22" height="13" font="4">917</text>
<text top="348" left="718" width="42" height="13" font="4">88,245</text>
<text top="377" left="236" width="15" height="13" font="4">20</text>
<text top="377" left="273" width="34" height="13" font="4">3,075</text>
<text top="377" left="325" width="42" height="13" font="4">22,865</text>
<text top="377" left="385" width="34" height="13" font="4">6,085</text>
<text top="377" left="438" width="42" height="13" font="4">20,398</text>
<text top="377" left="501" width="22" height="13" font="4">493</text>
<text top="377" left="542" width="42" height="13" font="4">18,557</text>
<text top="377" left="602" width="42" height="13" font="4">16,644</text>
<text top="377" left="673" width="22" height="13" font="4">931</text>
<text top="377" left="718" width="42" height="13" font="4">89,048</text>
<text top="407" left="236" width="15" height="13" font="4">24</text>
<text top="407" left="273" width="34" height="13" font="4">2,754</text>
<text top="407" left="325" width="42" height="13" font="4">22,760</text>
<text top="407" left="385" width="34" height="13" font="4">6,077</text>
<text top="407" left="438" width="42" height="13" font="4">20,800</text>
<text top="407" left="501" width="22" height="13" font="4">485</text>
<text top="407" left="542" width="42" height="13" font="4">18,564</text>
<text top="407" left="602" width="42" height="13" font="4">16,612</text>
<text top="407" left="673" width="22" height="13" font="4">940</text>
<text top="407" left="718" width="42" height="13" font="4">88,992</text>
<text top="436" left="236" width="15" height="13" font="4">28</text>
<text top="436" left="273" width="34" height="13" font="4">2,654</text>
<text top="436" left="325" width="42" height="13" font="4">22,859</text>
<text top="436" left="385" width="34" height="13" font="4">6,115</text>
<text top="436" left="438" width="42" height="13" font="4">21,252</text>
<text top="436" left="501" width="22" height="13" font="4">482</text>
<text top="436" left="542" width="42" height="13" font="4">18,500</text>
<text top="436" left="602" width="42" height="13" font="4">16,607</text>
<text top="436" left="673" width="22" height="13" font="4">977</text>
<text top="436" left="718" width="42" height="13" font="4">89,446</text>
<text top="465" left="236" width="15" height="13" font="4">32</text>
<text top="465" left="273" width="34" height="13" font="4">2,657</text>
<text top="465" left="325" width="42" height="13" font="4">22,953</text>
<text top="465" left="385" width="34" height="13" font="4">6,064</text>
<text top="465" left="438" width="42" height="13" font="4">21,681</text>
<text top="465" left="501" width="22" height="13" font="4">486</text>
<text top="465" left="542" width="42" height="13" font="4">18,529</text>
<text top="465" left="602" width="42" height="13" font="4">16,617</text>
<text top="465" left="673" width="22" height="13" font="4">974</text>
<text top="465" left="718" width="42" height="13" font="4">89,961</text>
<text top="495" left="236" width="15" height="13" font="4">36</text>
<text top="495" left="273" width="34" height="13" font="4">2,788</text>
<text top="495" left="325" width="42" height="13" font="4">22,803</text>
<text top="495" left="385" width="34" height="13" font="4">6,150</text>
<text top="495" left="438" width="42" height="13" font="4">22,180</text>
<text top="495" left="501" width="22" height="13" font="4">481</text>
<text top="495" left="542" width="42" height="13" font="4">18,439</text>
<text top="495" left="602" width="42" height="13" font="4">16,615</text>
<text top="495" left="673" width="22" height="13" font="4">979</text>
<text top="495" left="718" width="42" height="13" font="4">90,435</text>
<text top="524" left="236" width="15" height="13" font="4">40</text>
<text top="524" left="273" width="34" height="13" font="4">2,932</text>
<text top="524" left="325" width="42" height="13" font="4">22,757</text>
<text top="524" left="385" width="34" height="13" font="4">6,079</text>
<text top="524" left="438" width="42" height="13" font="4">22,639</text>
<text top="524" left="501" width="22" height="13" font="4">479</text>
<text top="524" left="542" width="42" height="13" font="4">18,477</text>
<text top="524" left="602" width="42" height="13" font="4">16,591</text>
<text top="524" left="673" width="22" height="13" font="4">990</text>
<text top="524" left="718" width="42" height="13" font="4">90,944</text>
<text top="553" left="236" width="15" height="13" font="4">44</text>
<text top="553" left="273" width="34" height="13" font="4">2,487</text>
<text top="553" left="325" width="42" height="13" font="4">22,782</text>
<text top="553" left="385" width="34" height="13" font="4">6,096</text>
<text top="553" left="438" width="42" height="13" font="4">23,033</text>
<text top="553" left="501" width="22" height="13" font="4">496</text>
<text top="553" left="542" width="42" height="13" font="4">18,598</text>
<text top="553" left="602" width="42" height="13" font="4">16,641</text>
<text top="553" left="673" width="22" height="13" font="4">984</text>
<text top="553" left="718" width="42" height="13" font="4">91,117</text>
<text top="582" left="236" width="15" height="13" font="4">48</text>
<text top="582" left="273" width="34" height="13" font="4">2,710</text>
<text top="582" left="325" width="42" height="13" font="4">22,724</text>
<text top="582" left="385" width="34" height="13" font="4">6,139</text>
<text top="582" left="438" width="42" height="13" font="4">23,669</text>
<text top="582" left="501" width="22" height="13" font="4">494</text>
<text top="582" left="542" width="42" height="13" font="4">18,526</text>
<text top="582" left="602" width="42" height="13" font="4">16,622</text>
<text top="582" left="673" width="22" height="13" font="4">988</text>
<text top="582" left="718" width="42" height="13" font="4">91,872</text>
<text top="612" left="236" width="15" height="13" font="4">52</text>
<text top="612" left="273" width="34" height="13" font="4">2,749</text>
<text top="612" left="325" width="42" height="13" font="4">22,797</text>
<text top="612" left="385" width="34" height="13" font="4">6,019</text>
<text top="612" left="438" width="42" height="13" font="4">24,084</text>
<text top="612" left="501" width="22" height="13" font="4">484</text>
<text top="612" left="542" width="42" height="13" font="4">18,568</text>
<text top="612" left="602" width="42" height="13" font="4">16,609</text>
<text top="612" left="673" width="22" height="13" font="4">995</text>
<text top="612" left="718" width="42" height="13" font="4">92,305</text>
<text top="641" left="236" width="15" height="13" font="4">56</text>
<text top="641" left="273" width="34" height="13" font="4">2,620</text>
<text top="641" left="325" width="42" height="13" font="4">22,803</text>
<text top="641" left="385" width="34" height="13" font="4">6,126</text>
<text top="641" left="438" width="42" height="13" font="4">24,531</text>
<text top="641" left="501" width="22" height="13" font="4">500</text>
<text top="641" left="542" width="42" height="13" font="4">18,642</text>
<text top="641" left="602" width="42" height="13" font="4">16,591</text>
<text top="641" left="662" width="34" height="13" font="4">1,008</text>
<text top="641" left="718" width="42" height="13" font="4">92,821</text>
<text top="670" left="236" width="15" height="13" font="4">60</text>
<text top="670" left="273" width="34" height="13" font="4">3,247</text>
<text top="670" left="325" width="42" height="13" font="4">22,867</text>
<text top="670" left="385" width="34" height="13" font="4">6,096</text>
<text top="670" left="438" width="42" height="13" font="4">25,214</text>
<text top="670" left="501" width="22" height="13" font="4">483</text>
<text top="670" left="542" width="42" height="13" font="4">18,668</text>
<text top="670" left="602" width="42" height="13" font="4">16,601</text>
<text top="670" left="662" width="34" height="13" font="4">1,006</text>
<text top="670" left="718" width="42" height="13" font="4">94,182</text>
<text top="706" left="173" width="626" height="16" font="0">Table 8.8: A breakdown of the cycles spent in each phase of the optimized IPC im-</text>
<text top="741" left="173" width="626" height="16" font="0">plementation. Our optimization eﬀorts targeted the transfer untyped (TU) phase</text>
<text top="776" left="173" width="626" height="16" font="0">of the algorithm, and we see a signiﬁcant reduction in the number of cycles as</text>
<text top="810" left="173" width="626" height="16" font="0">compared to the original breakdown we saw in Table 8.3. OH stands for overhead</text>
<text top="845" left="173" width="626" height="16" font="0">and includes the time spent to context-switch between the Haskell kernel and the</text>
<text top="880" left="173" width="626" height="16" font="0">C user program. Sch. is the time spent in the scheduling loop. SR stands for send</text>
<text top="914" left="173" width="626" height="16" font="0">rendezvous, TM stands for transfer message, and TU stands for transfer untyped.</text>
<text top="949" left="173" width="626" height="16" font="0">Rst. describes the phase of IPC spent restarting the thread. Rcv. is the time spent</text>
<text top="984" left="173" width="626" height="16" font="0">in the receive phase of the IPC operation. The phases are explained in detail in</text>
<text top="1018" left="173" width="102" height="16" font="0">Section 8.1.1.</text>
</page>
<page number="306" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">284</text>
<text top="419" left="217" width="34" height="14" font="2">10,000	  </text>
<text top="387" left="212" width="39" height="14" font="2">110,000	  </text>
<text top="355" left="212" width="39" height="14" font="2">210,000	  </text>
<text top="323" left="212" width="39" height="14" font="2">310,000	  </text>
<text top="292" left="212" width="39" height="14" font="2">410,000	  </text>
<text top="260" left="212" width="39" height="14" font="2">510,000	  </text>
<text top="228" left="212" width="39" height="14" font="2">610,000	  </text>
<text top="436" left="269" width="8" height="14" font="2">0	  </text>
<text top="436" left="296" width="8" height="14" font="2">4	  </text>
<text top="436" left="323" width="8" height="14" font="2">8	  </text>
<text top="436" left="346" width="335" height="14" font="2">12	   16	   20	   24	   28	   32	   36	   40	   44	   48	   52	   56	   60	  </text>
<text top="333" left="205" width="0" height="14" font="16"><b>cy</b></text>
<text top="323" left="205" width="0" height="14" font="16"><b>cl</b></text>
<text top="316" left="205" width="0" height="14" font="16"><b>es</b></text>
<text top="306" left="205" width="0" height="14" font="16"><b>	  </b></text>
<text top="452" left="423" width="103" height="14" font="16"><b>IPC	  words	  transferred	  </b></text>
<text top="293" left="735" width="37" height="12" font="3">baseline	  </text>
<text top="318" left="735" width="31" height="12" font="3">inlined	  </text>
<text top="342" left="735" width="43" height="12" font="3">memcopy	  </text>
<text top="367" left="735" width="43" height="12" font="3">op8mized	  </text>
<text top="379" left="735" width="43" height="12" font="3">memcopy	  </text>
<text top="505" left="307" width="369" height="13" font="4">(a) All experiments, including the unoptimized baseline.</text>
<text top="738" left="215" width="33" height="14" font="2">60,000	  </text>
<text top="716" left="215" width="33" height="14" font="2">70,000	  </text>
<text top="694" left="215" width="33" height="14" font="2">80,000	  </text>
<text top="671" left="215" width="33" height="14" font="2">90,000	  </text>
<text top="649" left="209" width="39" height="14" font="2">100,000	  </text>
<text top="627" left="209" width="39" height="14" font="2">110,000	  </text>
<text top="605" left="209" width="39" height="14" font="2">120,000	  </text>
<text top="583" left="209" width="39" height="14" font="2">130,000	  </text>
<text top="560" left="209" width="39" height="14" font="2">140,000	  </text>
<text top="755" left="266" width="8" height="14" font="2">0	  </text>
<text top="755" left="293" width="8" height="14" font="2">4	  </text>
<text top="755" left="320" width="8" height="14" font="2">8	  </text>
<text top="755" left="344" width="337" height="14" font="2">12	   16	   20	   24	   28	   32	   36	   40	   44	   48	   52	   56	   60	  </text>
<text top="658" left="202" width="0" height="14" font="16"><b>cy</b></text>
<text top="648" left="202" width="0" height="14" font="16"><b>cl</b></text>
<text top="641" left="202" width="0" height="14" font="16"><b>es</b></text>
<text top="631" left="202" width="0" height="14" font="16"><b>	  </b></text>
<text top="772" left="421" width="102" height="14" font="16"><b>IPC	  words	  transferred	  </b></text>
<text top="626" left="736" width="30" height="12" font="3">inlined	  </text>
<text top="659" left="736" width="43" height="12" font="3">memcopy	  </text>
<text top="692" left="736" width="43" height="12" font="3">op7mized	  </text>
<text top="704" left="736" width="43" height="12" font="3">memcopy	  </text>
<text top="826" left="312" width="359" height="13" font="4">(b) The results of the optimized IPC implementations.</text>
<text top="864" left="173" width="626" height="16" font="0">Figure 8.4: The eﬀects of each optimization presented in this chapter on the overall</text>
<text top="899" left="173" width="507" height="16" font="0">performance of IPC as measured by the ping-pong benchmark.</text>
<text top="899" left="696" width="103" height="16" font="0">Figure 8.4(a)</text>
<text top="933" left="173" width="626" height="16" font="0">demonstrates that all of our optimizations achieve an improvement over the initial,</text>
<text top="968" left="173" width="626" height="16" font="0">unoptimized implementation. Figure 8.4(b) focuses on the optimizations alone to</text>
<text top="1003" left="173" width="444" height="16" font="0">more clearly demonstrate the eﬀects of each modiﬁcation.</text>
</page>
<page number="307" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">285</text>
<text top="163" left="173" width="626" height="16" font="0">includes our initial results. From this graph, it is clear that each algorithm pro-</text>
<text top="195" left="173" width="626" height="16" font="0">vides an improvement over the unoptimized implementation. Figure 8.4(b) only</text>
<text top="228" left="173" width="626" height="16" font="0">shows the optimized versions to make a comparison between these three versions</text>
<text top="260" left="173" width="626" height="16" font="0">easier. As one would hope, each subsequent optimization performs better than</text>
<text top="293" left="173" width="626" height="16" font="0">the previous implementation. Note, however, that the cost per word is higher</text>
<text top="325" left="173" width="626" height="16" font="0">in the optimized memcopy implementation than in the normal implementation of</text>
<text top="358" left="173" width="626" height="16" font="0">memcopy; it appears from the graph that if enough words are transferred then</text>
<text top="390" left="173" width="626" height="16" font="0">memcopy will eventually outperform the optimized version. This phenomenon is</text>
<text top="423" left="173" width="626" height="16" font="0">likely caused by unexpected side eﬀects from our unpacked data structures. Un-</text>
<text top="455" left="173" width="626" height="16" font="0">packing data type deﬁnitions has the potential to speed up computations, but can</text>
<text top="488" left="173" width="626" height="16" font="0">cause a slowdown when the calling code is not also optimized. Because we fo-</text>
<text top="520" left="173" width="626" height="16" font="0">cused on a single routine, we may have introduced additional ineﬃciencies in other</text>
<text top="553" left="173" width="626" height="16" font="0">phases of the IPC algorithm. The per-phase breakdown of IPC costs in Table 8.8</text>
<text top="585" left="173" width="239" height="16" font="0">is consistent with this analysis.</text>
<text top="618" left="199" width="600" height="16" font="0">Figure 8.5 illustrates the performance change between the the initial IPC mea-</text>
<text top="650" left="173" width="626" height="16" font="0">surement and the most optimized version. Each line in the graph represents a</text>
<text top="683" left="173" width="626" height="16" font="0">single phase of the IPC algorithm. The x-axis is the number of message regis-</text>
<text top="715" left="173" width="626" height="16" font="0">ters that were sent in a particular test and the y-axis is the ratio between the</text>
<text top="748" left="173" width="626" height="16" font="0">ﬁnal results and the initial results. Even though each optimization pass improved</text>
<text top="780" left="173" width="626" height="16" font="0">the overall IPC performance, some phases of the algorithm perform worse in the</text>
<text top="813" left="173" width="140" height="16" font="0">optimized version.</text>
<text top="845" left="199" width="600" height="16" font="0">Unsurprisingly, the transfer untyped phase where we spent all of our optimiza-</text>
<text top="878" left="173" width="626" height="16" font="0">tion energy performs much better in the optimized implementation than in the</text>
<text top="910" left="173" width="626" height="16" font="0">initial implementation. The time spent on garbage collection and overhead is also</text>
<text top="943" left="173" width="626" height="16" font="0">lower. The reduction in overhead may be due to the increased strictness of the</text>
<text top="975" left="173" width="626" height="16" font="0">optimized program. In the original implementation, any computations that were</text>
<text top="1008" left="173" width="626" height="16" font="0">delayed due to laziness were ultimately forced when we switched back to user-mode</text>
<text top="1040" left="173" width="626" height="16" font="0">(if not before). As such, computations that had nothing to do with overhead or</text>
</page>
<page number="308" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="17" size="7" family="Times" color="#000000"/>
	<fontspec id="18" size="7" family="Times" color="#000000"/>
<text top="111" left="729" width="26" height="16" font="0">286</text>
<text top="391" left="213" width="25" height="12" font="17">0.00 </text>
<text top="337" left="213" width="25" height="12" font="17">0.01 </text>
<text top="282" left="213" width="25" height="12" font="17">0.10 </text>
<text top="227" left="213" width="25" height="12" font="17">1.00 </text>
<text top="173" left="207" width="31" height="12" font="17">10.00 </text>
<text top="406" left="241" width="9" height="12" font="17">0 </text>
<text top="406" left="269" width="9" height="12" font="17">4 </text>
<text top="406" left="298" width="9" height="12" font="17">8 </text>
<text top="406" left="323" width="15" height="12" font="17">12 </text>
<text top="406" left="352" width="15" height="12" font="17">16 </text>
<text top="406" left="380" width="15" height="12" font="17">20 </text>
<text top="406" left="409" width="15" height="12" font="17">24 </text>
<text top="406" left="438" width="15" height="12" font="17">28 </text>
<text top="406" left="466" width="15" height="12" font="17">32 </text>
<text top="406" left="495" width="15" height="12" font="17">36 </text>
<text top="406" left="523" width="15" height="12" font="17">40 </text>
<text top="406" left="552" width="15" height="12" font="17">44 </text>
<text top="406" left="580" width="15" height="12" font="17">48 </text>
<text top="406" left="609" width="15" height="12" font="17">52 </text>
<text top="406" left="638" width="15" height="12" font="17">56 </text>
<text top="406" left="666" width="15" height="12" font="17">60 </text>
<text top="349" left="198" width="0" height="12" font="18"><b>cy</b></text>
<text top="338" left="198" width="0" height="12" font="18"><b>cl</b></text>
<text top="329" left="198" width="0" height="12" font="18"><b>e</b></text>
<text top="322" left="198" width="0" height="12" font="18"><b>s </b></text>
<text top="313" left="198" width="0" height="12" font="18"><b>af</b></text>
<text top="303" left="198" width="0" height="12" font="18"><b>te</b></text>
<text top="292" left="198" width="0" height="12" font="18"><b>r </b></text>
<text top="284" left="198" width="0" height="12" font="18"><b>÷</b></text>
<text top="276" left="198" width="0" height="12" font="18"><b> c</b></text>
<text top="267" left="198" width="0" height="12" font="18"><b>y</b></text>
<text top="261" left="198" width="0" height="12" font="18"><b>cl</b></text>
<text top="252" left="198" width="0" height="12" font="18"><b>e</b></text>
<text top="246" left="198" width="0" height="12" font="18"><b>s </b></text>
<text top="237" left="198" width="0" height="12" font="18"><b>b</b></text>
<text top="230" left="198" width="0" height="12" font="18"><b>e</b></text>
<text top="224" left="198" width="0" height="12" font="18"><b>fo</b></text>
<text top="213" left="198" width="0" height="12" font="18"><b>re</b></text>
<text top="202" left="198" width="0" height="12" font="18"><b> </b></text>
<text top="423" left="397" width="123" height="12" font="18"><b>IPC words transferred </b></text>
<text top="244" left="714" width="44" height="11" font="11">overhead </text>
<text top="260" left="714" width="50" height="11" font="11">scheduling </text>
<text top="275" left="714" width="77" height="11" font="11">send rendezvous </text>
<text top="291" left="714" width="80" height="11" font="11">transfer message </text>
<text top="307" left="714" width="77" height="11" font="11">transfer untyped </text>
<text top="323" left="714" width="64" height="11" font="11">thread restart </text>
<text top="339" left="714" width="35" height="11" font="11">receive </text>
<text top="355" left="714" width="39" height="11" font="11">GC time </text>
<text top="473" left="288" width="409" height="13" font="4">(a) Performance improvement/degradation of each IPC phase.</text>
<text top="700" left="208" width="19" height="12" font="17">0.0 </text>
<text top="682" left="208" width="19" height="12" font="17">0.2 </text>
<text top="664" left="208" width="19" height="12" font="17">0.4 </text>
<text top="646" left="208" width="19" height="12" font="17">0.6 </text>
<text top="628" left="208" width="19" height="12" font="17">0.8 </text>
<text top="610" left="208" width="19" height="12" font="17">1.0 </text>
<text top="592" left="208" width="19" height="12" font="17">1.2 </text>
<text top="574" left="208" width="19" height="12" font="17">1.4 </text>
<text top="556" left="208" width="19" height="12" font="17">1.6 </text>
<text top="538" left="208" width="19" height="12" font="17">1.8 </text>
<text top="519" left="208" width="19" height="12" font="17">2.0 </text>
<text top="715" left="230" width="10" height="12" font="17">0 </text>
<text top="715" left="259" width="10" height="12" font="17">4 </text>
<text top="715" left="288" width="10" height="12" font="17">8 </text>
<text top="715" left="314" width="16" height="12" font="17">12 </text>
<text top="715" left="343" width="16" height="12" font="17">16 </text>
<text top="715" left="372" width="16" height="12" font="17">20 </text>
<text top="715" left="401" width="16" height="12" font="17">24 </text>
<text top="715" left="431" width="16" height="12" font="17">28 </text>
<text top="715" left="460" width="16" height="12" font="17">32 </text>
<text top="715" left="489" width="16" height="12" font="17">36 </text>
<text top="715" left="518" width="16" height="12" font="17">40 </text>
<text top="715" left="547" width="16" height="12" font="17">44 </text>
<text top="715" left="576" width="16" height="12" font="17">48 </text>
<text top="715" left="605" width="16" height="12" font="17">52 </text>
<text top="715" left="634" width="16" height="12" font="17">56 </text>
<text top="715" left="663" width="16" height="12" font="17">60 </text>
<text top="677" left="200" width="0" height="12" font="18"><b>cy</b></text>
<text top="665" left="200" width="0" height="12" font="18"><b>cl</b></text>
<text top="657" left="200" width="0" height="12" font="18"><b>e</b></text>
<text top="650" left="200" width="0" height="12" font="18"><b>s </b></text>
<text top="641" left="200" width="0" height="12" font="18"><b>af</b></text>
<text top="631" left="200" width="0" height="12" font="18"><b>te</b></text>
<text top="620" left="200" width="0" height="12" font="18"><b>r </b></text>
<text top="612" left="200" width="0" height="12" font="18"><b>÷</b></text>
<text top="604" left="200" width="0" height="12" font="18"><b> c</b></text>
<text top="595" left="200" width="0" height="12" font="18"><b>y</b></text>
<text top="589" left="200" width="0" height="12" font="18"><b>cl</b></text>
<text top="580" left="200" width="0" height="12" font="18"><b>e</b></text>
<text top="573" left="200" width="0" height="12" font="18"><b>s </b></text>
<text top="565" left="200" width="0" height="12" font="18"><b>b</b></text>
<text top="558" left="200" width="0" height="12" font="18"><b>e</b></text>
<text top="552" left="200" width="0" height="12" font="18"><b>fo</b></text>
<text top="541" left="200" width="0" height="12" font="18"><b>re</b></text>
<text top="530" left="200" width="0" height="12" font="18"><b> </b></text>
<text top="733" left="391" width="123" height="12" font="18"><b>IPC words transferred </b></text>
<text top="575" left="712" width="45" height="11" font="11">overhead </text>
<text top="590" left="712" width="51" height="11" font="11">scheduling </text>
<text top="606" left="712" width="79" height="11" font="11">send rendezvous </text>
<text top="622" left="712" width="81" height="11" font="11">transfer message </text>
<text top="638" left="712" width="66" height="11" font="11">thread restart </text>
<text top="654" left="712" width="35" height="11" font="11">receive </text>
<text top="670" left="712" width="39" height="11" font="11">GC time </text>
<text top="783" left="336" width="311" height="13" font="4">(b) Performance change in unoptimized phases.</text>
<text top="821" left="173" width="626" height="16" font="0">Figure 8.5: The overall eﬀect of optimization on each phase of the IPC algorithm.</text>
<text top="856" left="173" width="626" height="16" font="0">Figure 8.5(a) illustrates the ratio between the cycles taken per IPC in the ﬁnal</text>
<text top="890" left="173" width="626" height="16" font="0">implementation and the original implementation. Transfer untyped—the function</text>
<text top="925" left="173" width="626" height="16" font="0">where we focused our optimization energy—improves dramatically while the im-</text>
<text top="960" left="173" width="626" height="16" font="0">pact on other phases varies (some perform slightly better and some perform slightly</text>
<text top="994" left="173" width="626" height="16" font="0">worse). Figure 8.5(b) focuses on the phases of IPC other than transfer untyped.</text>
<text top="1029" left="173" width="626" height="16" font="0">We see the most improvement in the number of cycles taken for overhead and</text>
<text top="1064" left="173" width="142" height="16" font="0">garbage collection.</text>
</page>
<page number="309" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">287</text>
<text top="163" left="173" width="626" height="16" font="0">context-switching could appear in this phase of IPC. The portions of IPC devoted</text>
<text top="195" left="173" width="626" height="16" font="0">to sender rendezvous and the receive phase also improve somewhat, while thread</text>
<text top="228" left="173" width="626" height="16" font="0">restart is not particularly eﬀected. Scheduling is faster on small numbers of mes-</text>
<text top="260" left="173" width="626" height="16" font="0">sage registers and slower for large numbers of message registers. Transfer message</text>
<text top="293" left="173" width="626" height="16" font="0">is the only phase that performs signiﬁcantly worse in the optimized version—this</text>
<text top="325" left="173" width="626" height="16" font="0">is the obvious place to look next for further optimization opportunities. Because</text>
<text top="358" left="173" width="626" height="16" font="0">transfer message is using all of the same data structures as transfer untyped, but</text>
<text top="390" left="173" width="626" height="16" font="0">is not optimized to allow the kernel to make use of the strictness and unpacking</text>
<text top="423" left="173" width="626" height="16" font="0">annotations, the performance of this routine is the most negatively aﬀected by</text>
<text top="455" left="173" width="626" height="16" font="0">the changes we made to improve the performance of transfer untyped. Further</text>
<text top="488" left="173" width="440" height="16" font="0">improvements to transferUntyped may also be possible.</text>
<text top="520" left="199" width="600" height="16" font="0">The techniques we presented in Section 8.3 demonstrate that it is possible to</text>
<text top="553" left="173" width="626" height="16" font="0">improve the performance of an H-based system dramatically through targeted op-</text>
<text top="585" left="173" width="626" height="16" font="0">timization. Section 8.3.1 examined the algorithmic behavior of the untyped data</text>
<text top="618" left="173" width="626" height="16" font="0">transfer function and conﬁrmed that we can obtain large performance improve-</text>
<text top="650" left="173" width="626" height="16" font="0">ments through refactoring. The rest of the L4 kernel is coded in a similar style</text>
<text top="683" left="173" width="626" height="16" font="0">and makes heavy use of abstractions throughout: both in functions that capture</text>
<text top="715" left="173" width="626" height="16" font="0">common patterns (potentially introducing redundant computation) and in data</text>
<text top="748" left="173" width="626" height="16" font="0">structures that provide type-based documentation to help eliminate mistakes (in-</text>
<text top="780" left="173" width="626" height="16" font="0">creasing the cost of storing and manipulating simple data like words). Now that</text>
<text top="813" left="173" width="626" height="16" font="0">we have working H interface and L4 implementations, there is potential to recon-</text>
<text top="845" left="173" width="626" height="16" font="0">sider these abstractions to increase performance. Further performance gains may</text>
<text top="878" left="173" width="626" height="16" font="0">be possible by adding additional strictness annotations and by experimenting with</text>
<text top="910" left="173" width="626" height="16" font="0">inlining and unpacked datatypes as in Section 8.3.3. Though we are not currently</text>
<text top="943" left="173" width="626" height="16" font="0">aware of any API issues, a targeted optimization of a particular IPC phase or other</text>
<text top="975" left="173" width="626" height="16" font="0">kernel function might unearth more ineﬃciencies. The experiments that we have</text>
<text top="1008" left="173" width="626" height="16" font="0">presented in this dissertation provide strong evidence that, by pursuing algorith-</text>
<text top="1040" left="173" width="626" height="16" font="0">mic, API, and compiler optimizations, we have the potential to further reduce the</text>
</page>
<page number="310" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">288</text>
<text top="163" left="173" width="594" height="16" font="0">performance gap between our Haskell kernel and typical L4 implementations.</text>
</page>
<page number="311" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">289</text>
<text top="236" left="447" width="77" height="16" font="0">Chapter 9</text>
<text top="287" left="411" width="149" height="16" font="0">RELATED WORK</text>
<text top="379" left="173" width="626" height="16" font="0">In this chapter, we relate the concepts of the H interface design and implementation</text>
<text top="412" left="173" width="626" height="16" font="0">to existing work in the ﬁelds of operating systems and programming languages. We</text>
<text top="444" left="173" width="626" height="16" font="0">focus on the core topic areas of system architecture (Section 9.1), functional op-</text>
<text top="477" left="173" width="626" height="16" font="0">erating systems (Section 9.2), programming language environments (Section 9.3),</text>
<text top="509" left="173" width="626" height="16" font="0">veriﬁed operating systems (Section 9.4), safe operating systems (Section 9.5), and</text>
<text top="542" left="173" width="211" height="16" font="0">virtualization (Section 9.6).</text>
<text top="603" left="173" width="26" height="16" font="0">9.1</text>
<text top="603" left="219" width="258" height="16" font="0">SYSTEM ARCHITECTURE</text>
<text top="654" left="173" width="626" height="16" font="0">Separation between policy and mechanism is a fundamental concept in many mod-</text>
<text top="686" left="173" width="626" height="16" font="0">ern systems, including H. The Hydra system is an important example of this con-</text>
<text top="719" left="173" width="626" height="16" font="0">cept for the operating systems domain [68]. The primary goal of the Hydra design</text>
<text top="751" left="173" width="626" height="16" font="0">is to enable user-processes to control resource allocation policies for the system.</text>
<text top="784" left="173" width="626" height="16" font="0">User-processes cannot be given free reign because of safety and fairness issues, so</text>
<text top="816" left="173" width="626" height="16" font="0">the kernel mechanisms are designed to balance control and safety. For example,</text>
<text top="849" left="173" width="626" height="16" font="0">Hydra implements a parameterized scheduler. Key scheduling parameters, such as</text>
<text top="881" left="173" width="626" height="16" font="0">the amount of time that each process should run before being stopped, are pro-</text>
<text top="914" left="173" width="626" height="16" font="0">vided by per-process user-level schedulers. The mechanisms introduced in Hydra</text>
<text top="946" left="173" width="626" height="16" font="0">were very inﬂuential on future systems, particularly the microkernel community,</text>
<text top="979" left="173" width="626" height="16" font="0">and very similar mechanisms in support of user-level policies appear in kernels like</text>
<text top="1011" left="173" width="164" height="16" font="0">L4 [62] and Mach [2].</text>
<text top="1044" left="199" width="600" height="16" font="0">The H interface aims to strike much the same balance between policy and</text>
</page>
<page number="312" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">290</text>
<text top="163" left="173" width="626" height="16" font="0">mechanism in a setting where the client is itself an operating system. We strive to</text>
<text top="195" left="173" width="626" height="16" font="0">minimize policies in H that are not directly related to safety because any policy</text>
<text top="228" left="173" width="626" height="16" font="0">in H restricts the applicability and ﬂexibility of the abstraction layer. Much of</text>
<text top="260" left="173" width="626" height="16" font="0">our design eﬀort was devoted to the mechanisms that support client control over</text>
<text top="293" left="173" width="626" height="16" font="0">page-map pages and the kernel virtual address-space. Providing these mechanisms</text>
<text top="325" left="173" width="626" height="16" font="0">in a safe way presents a challenge, and guaranteeing that the client policies do not</text>
<text top="358" left="173" width="511" height="16" font="0">introduce safety violations is a major theme of our safety analysis.</text>
<text top="390" left="199" width="600" height="16" font="0">Unlike Hydra, we do not need to manage the complexity of multiple compet-</text>
<text top="423" left="173" width="626" height="16" font="0">ing policies because H is designed for use by a single client at any given time.</text>
<text top="455" left="173" width="626" height="16" font="0">In Hydra, each user-process might set its own policy for resource usage. Hydra</text>
<text top="488" left="173" width="626" height="16" font="0">must be an arbiter between these processes to ensure safety and fairness. In some</text>
<text top="520" left="173" width="626" height="16" font="0">ways, the competition between user-processes is analogous to the competition for</text>
<text top="553" left="173" width="626" height="16" font="0">resources between the environment, the H interface, and the client in our system.</text>
<text top="585" left="173" width="626" height="16" font="0">The diﬀerence in our setting is that the run-time system and H interface resource</text>
<text top="618" left="173" width="626" height="16" font="0">allocation policies are ﬁxed; only the client’s memory usage policy will vary at</text>
<text top="650" left="173" width="71" height="16" font="0">run-time.</text>
<text top="712" left="173" width="26" height="16" font="0">9.2</text>
<text top="712" left="219" width="371" height="16" font="0">FUNCTIONAL OPERATING SYSTEMS</text>
<text top="762" left="173" width="626" height="16" font="0">The idea of applying functional programming languages to the operating systems</text>
<text top="795" left="173" width="626" height="16" font="0">domain has a long history. Many of the early examples represent a very diﬀerent</text>
<text top="827" left="173" width="626" height="16" font="0">era in pure functional programming before monadic I/O was incorporated into</text>
<text top="860" left="173" width="626" height="16" font="0">programming practice. As such, the focus of these works is on mechanisms for</text>
<text top="892" left="173" width="626" height="16" font="0">handling eﬀects, using techniques for stream processing and I/O in a continuation-</text>
<text top="925" left="173" width="626" height="16" font="0">passing style. These challenges are very diﬀerent from those we encounter today.</text>
<text top="957" left="173" width="626" height="16" font="0">Early examples of functional operating systems include Nebula [58] and the Kent</text>
<text top="990" left="173" width="367" height="16" font="0">Applicative Operating System (KAOS) [17, 89].</text>
<text top="1022" left="199" width="600" height="16" font="0">The Hello [26] project implements an operating system in Standard ML and</text>
</page>
<page number="313" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">291</text>
<text top="163" left="173" width="626" height="16" font="0">addresses various language design and eﬃciency issues, such as how to access hard-</text>
<text top="195" left="173" width="626" height="16" font="0">ware devices and how to handle interrupts in a garbage-collected language. It</text>
<text top="228" left="173" width="626" height="16" font="0">builds on the results of the Fox project, where Standard ML was used for systems</text>
<text top="260" left="173" width="626" height="16" font="0">programming. In particular, it includes FoxNet, an eﬃcient implementation of the</text>
<text top="293" left="173" width="626" height="16" font="0">TCP/IP protocol stack [8]. Compared to these projects, a signiﬁcant new feature</text>
<text top="325" left="173" width="626" height="16" font="0">of the H interface is its support for controlling memory management hardware,</text>
<text top="358" left="173" width="474" height="16" font="0">which allows us to run code written in other languages safely.</text>
<text top="390" left="199" width="600" height="16" font="0">Though unpredictable performance results sometimes occur in Haskell due to</text>
<text top="423" left="173" width="626" height="16" font="0">laziness, it is possible to write lazy functional programs that satisfy real-time guar-</text>
<text top="455" left="173" width="626" height="16" font="0">antees. The Embedded Gofer project extended the Haskell language speciﬁcally to</text>
<text top="488" left="173" width="626" height="16" font="0">support programming embedded devices [98, 97]. The language extensions provide</text>
<text top="520" left="173" width="626" height="16" font="0">access to I/O device registers and asynchronous exception support for handling in-</text>
<text top="553" left="173" width="626" height="16" font="0">terrupts, as well as the implementation and adoption of an incremental garbage</text>
<text top="585" left="173" width="626" height="16" font="0">collector to satisfy the guarantees that are necessary in real-time environments.</text>
<text top="618" left="173" width="626" height="16" font="0">The techniques employed in Embedded Gofer are a useful guide if we extend H</text>
<text top="650" left="173" width="626" height="16" font="0">to support real-time guarantees. For performance reasons alone, experiments with</text>
<text top="683" left="173" width="498" height="16" font="0">diﬀerent garbage collector implementations would be interesting.</text>
<text top="745" left="173" width="26" height="16" font="0">9.3</text>
<text top="745" left="219" width="303" height="16" font="0">PROGRAMMING LANGUAGES</text>
<text top="795" left="173" width="626" height="16" font="0">Some people consider the use high-level functional languages to implement operat-</text>
<text top="827" left="173" width="626" height="16" font="0">ing systems to be too much of a departure from traditional systems programming</text>
<text top="860" left="173" width="626" height="16" font="0">techniques. A less radical approach is to add safety to a low-level language. There</text>
<text top="892" left="173" width="626" height="16" font="0">are a number of programming languages that support a greater degree of safety</text>
<text top="925" left="173" width="626" height="16" font="0">than C, while still supporting the low-level and imperative features that are tradi-</text>
<text top="957" left="173" width="626" height="16" font="0">tionally associated with operating systems programming. The nature of the safety</text>
<text top="990" left="173" width="626" height="16" font="0">guarantees and the programming constructs available varies widely with these safe</text>
<text top="1022" left="173" width="144" height="16" font="0">systems languages.</text>
</page>
<page number="314" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">292</text>
<text top="163" left="199" width="600" height="16" font="0">Cyclone was not designed speciﬁcally for systems programming, but as a safe</text>
<text top="195" left="173" width="626" height="16" font="0">replacement for C. Cyclone’s focus is on maintaining the transparency and control</text>
<text top="228" left="173" width="626" height="16" font="0">that programmers enjoy with C, including direct control over resources such as</text>
<text top="260" left="173" width="626" height="16" font="0">memory, while providing strong type- and memory-safety guarantees [36, 35]. Just</text>
<text top="293" left="173" width="626" height="16" font="0">as in Haskell, Cyclone prevents common memory-safety errors like buﬀer overﬂows</text>
<text top="325" left="173" width="626" height="16" font="0">and null pointer dereferences. Certain properties, like bounds checks on arrays,</text>
<text top="358" left="173" width="626" height="16" font="0">must be dynamically checked at run-time. A great feature of Cyclone is that run-</text>
<text top="390" left="173" width="626" height="16" font="0">time checks are eliminated by the compiler whenever possible, for example, when</text>
<text top="423" left="173" width="626" height="16" font="0">an array access can be statically determined to be in-bounds. Cyclone achieves</text>
<text top="455" left="173" width="626" height="16" font="0">safety without using garbage collection by employing a region-based type-system</text>
<text top="488" left="173" width="377" height="16" font="0">that manages the scope and life-span of pointers.</text>
<text top="520" left="199" width="600" height="16" font="0">Cyclone provides the same level of protection against memory-safety errors as</text>
<text top="553" left="173" width="626" height="16" font="0">higher-level languages like Haskell. A Cyclone programmer cannot dereference a</text>
<text top="585" left="173" width="626" height="16" font="0">null pointer or free memory twice, but still maintains a high degree of control</text>
<text top="618" left="173" width="626" height="16" font="0">over resources. Implementing an operating system in Cyclone would not require</text>
<text top="650" left="173" width="626" height="16" font="0">a special interface like H because the language already supports direct control</text>
<text top="683" left="173" width="626" height="16" font="0">over resources in a safe way. However, the existence of the H interface allows us</text>
<text top="715" left="173" width="626" height="16" font="0">to express memory-safety guarantees that are speciﬁc to the operating systems</text>
<text top="748" left="173" width="626" height="16" font="0">domain (as we saw in Chapter 5); these kinds of properties are not captured au-</text>
<text top="780" left="173" width="626" height="16" font="0">tomatically by Cyclone’s language facilities. We could write an H-like abstraction</text>
<text top="813" left="173" width="626" height="16" font="0">layer in Cyclone, but Haskell provides many important features that we utilized in</text>
<text top="845" left="173" width="626" height="16" font="0">the construction of H. The Haskell type system is more expressive than the type</text>
<text top="878" left="173" width="626" height="16" font="0">system of Cyclone; when combined with Haskell’s module system we are able to</text>
<text top="910" left="173" width="626" height="16" font="0">create a strong abstraction barrier between the H internals and the client oper-</text>
<text top="943" left="173" width="626" height="16" font="0">ating system. This abstraction barrier is an essential part of our memory-safety</text>
<text top="975" left="173" width="626" height="16" font="0">argument. Because Cyclone provides the power of C in a memory-safe language,</text>
<text top="1008" left="173" width="626" height="16" font="0">we could greatly increase the assurance argument for H by recoding the low-level</text>
<text top="1040" left="173" width="431" height="16" font="0">portions of our implementation in Cyclone instead of C.</text>
</page>
<page number="315" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">293</text>
<text top="163" left="199" width="600" height="16" font="0">On the other end of the spectrum is Modula-3—a type-safe, object oriented</text>
<text top="195" left="173" width="626" height="16" font="0">language with garbage collection that was designed speciﬁcally for systems pro-</text>
<text top="228" left="173" width="626" height="16" font="0">gramming [74]. Like Haskell, Modula-3 supports isolation between components via</text>
<text top="260" left="173" width="626" height="16" font="0">a powerful module system. Potential safety violations introduced by the user of</text>
<text top="293" left="173" width="626" height="16" font="0">unsafe code, like foreign function calls, are explicitly documented in the program.</text>
<text top="325" left="173" width="626" height="16" font="0">Modula-3 supports the implementation of safe operating systems like Spin [6],</text>
<text top="358" left="173" width="626" height="16" font="0">which we will cover in Section 9.5. Though Modula-3 is a powerful language for</text>
<text top="390" left="173" width="626" height="16" font="0">safe systems programming, its imperative nature and lack of a pure semantics</text>
<text top="423" left="173" width="418" height="16" font="0">makes Modula-3 programs less amenable to reasoning.</text>
<text top="455" left="199" width="600" height="16" font="0">The BitC programming language aims to cover the middle ground by including</text>
<text top="488" left="173" width="626" height="16" font="0">many of the features traditionally associated with high-level languages in a way</text>
<text top="520" left="173" width="626" height="16" font="0">that will be amenable to systems programming [9, 86, 85]. Resource control and</text>
<text top="553" left="173" width="626" height="16" font="0">transparency are central to this philosophy. For example, BitC provides machine-</text>
<text top="585" left="173" width="626" height="16" font="0">level, ﬁxed size representations of types and control over data layout. BitC supports</text>
<text top="618" left="173" width="626" height="16" font="0">garbage collection, but also allows the programmer to write code that does not</text>
<text top="650" left="173" width="626" height="16" font="0">perform dynamic allocation. Another goal of BitC is assurance; the designers</text>
<text top="683" left="173" width="626" height="16" font="0">intend to develop a formal mechanized semantics for the language. Other features</text>
<text top="715" left="173" width="626" height="16" font="0">of BitC include polymorphism, datatypes, pattern matching, and higher order</text>
<text top="748" left="173" width="626" height="16" font="0">procedures. Though BitC is not pure, it is type-safe and supports type classes.</text>
<text top="780" left="173" width="626" height="16" font="0">When BitC matures it will be a viable platform for developing safe operating</text>
<text top="813" left="173" width="416" height="16" font="0">systems (see the discussion of Coyotos in Section 9.5).</text>
<text top="845" left="199" width="600" height="16" font="0">Another interesting line of related work relates to foreign function interface</text>
<text top="878" left="173" width="626" height="16" font="0">design. The construction of safe foreign function interfaces avoids the kinds of</text>
<text top="910" left="173" width="626" height="16" font="0">vulnerabilities that necessitate the use of an abstraction layer to support memory-</text>
<text top="943" left="173" width="626" height="16" font="0">safe low-level programming in high-level languages. One approach is to type check</text>
<text top="975" left="173" width="626" height="16" font="0">unsafe foreign code as if it were code in the safe native language to catch errors</text>
<text top="1008" left="173" width="626" height="16" font="0">that would otherwise be permitted by the foreign type system. This approach has</text>
<text top="1040" left="173" width="626" height="16" font="0">been applied to OCaml’s C foreign function interface and successfully uncovered a</text>
</page>
<page number="316" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">294</text>
<text top="163" left="173" width="626" height="16" font="0">number of bugs in existing foreign code [27]. An interesting challenge arises from</text>
<text top="195" left="173" width="626" height="16" font="0">the fact that C code can observe that there are values of diﬀerent types with the</text>
<text top="228" left="173" width="626" height="16" font="0">same representation. The designers of the OCaml to C system use type inference</text>
<text top="260" left="173" width="626" height="16" font="0">to determine what OCaml type should be assigned to a value based on its usage</text>
<text top="293" left="173" width="626" height="16" font="0">in C. They use dataﬂow analysis to ensure that C code properly registers any</text>
<text top="325" left="173" width="626" height="16" font="0">pointers it has into the OCaml heap and makes the appropriate dynamic checks</text>
<text top="358" left="173" width="626" height="16" font="0">and oﬀset calculations when accessing OCaml datatypes. Such a system would</text>
<text top="390" left="173" width="626" height="16" font="0">greatly improve our ability to assure the behavior of the foreign calls that we use</text>
<text top="423" left="173" width="626" height="16" font="0">in the implementation of the abstraction layer, and might even eliminate the need</text>
<text top="455" left="173" width="626" height="16" font="0">for such an abstraction layer. The major complexity that we foresee relates to</text>
<text top="488" left="173" width="626" height="16" font="0">the fact that our foreign calls can change the system state in ways that are not</text>
<text top="520" left="173" width="605" height="16" font="0">accounted for in the OCaml to C type system, such as modifying a page-table.</text>
<text top="553" left="199" width="600" height="16" font="0">The Scheme community has a long history of trying to incorporate operat-</text>
<text top="585" left="173" width="626" height="16" font="0">ing systems features into the run-time system of the language. This is a diﬀer-</text>
<text top="618" left="173" width="626" height="16" font="0">ent exercise than trying to expose operating systems constructs built on top of a</text>
<text top="650" left="173" width="626" height="16" font="0">(nearly) standard run-time system, but must address many of the same safety and</text>
<text top="683" left="173" width="626" height="16" font="0">protection issues. The DrRacket (formerly DrScheme) programming environment</text>
<text top="715" left="173" width="626" height="16" font="0">supports GUI services, a notion of protection domain speciﬁcally related to GUI</text>
<text top="748" left="173" width="626" height="16" font="0">elements (the integrity of the GUI of the environment itself must be maintained),</text>
<text top="780" left="173" width="626" height="16" font="0">the ability to halt a program, and the ability to reclaim a program’s resources if</text>
<text top="813" left="173" width="626" height="16" font="0">it has gone awry [24]. Wick and Flatt added support for process-based memory</text>
<text top="845" left="173" width="626" height="16" font="0">accounting in a shared heap [99]. These are higher level concerns than we address</text>
<text top="878" left="173" width="626" height="16" font="0">with the H interface because they deal with issues of process management, but it</text>
<text top="910" left="173" width="626" height="16" font="0">is interesting to note that the division between environment structures and client</text>
<text top="943" left="173" width="359" height="16" font="0">structures is a key distinction in both systems.</text>
<text top="975" left="199" width="600" height="16" font="0">A variety of techniques have also been developed in the Java community for</text>
<text top="1008" left="173" width="626" height="16" font="0">adding operating system support to the language in a safe way. Java operating</text>
<text top="1040" left="173" width="626" height="16" font="0">systems can provide the same level of memory-safety as Haskell, and in theory</text>
</page>
<page number="317" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">295</text>
<text top="163" left="173" width="626" height="16" font="0">encounter similar challenges to reconcile control over resources with garbage col-</text>
<text top="195" left="173" width="626" height="16" font="0">lection and other run-time system services. In practice, the mechanisms necessary</text>
<text top="228" left="173" width="626" height="16" font="0">to overcome these challenges are very diﬀerent between Java systems and the H</text>
<text top="260" left="173" width="626" height="16" font="0">interface because the interface that the language run-times present to the program-</text>
<text top="293" left="173" width="154" height="16" font="0">mer are so diﬀerent.</text>
<text top="325" left="199" width="600" height="16" font="0">The KaﬀeOS operating system, like DrScheme, treats the language run-time as</text>
<text top="358" left="173" width="626" height="16" font="0">the operating system kernel [4]. KaﬀeOS extends the normal Java run-time system</text>
<text top="390" left="173" width="626" height="16" font="0">with support for resource management, isolation between software components,</text>
<text top="423" left="173" width="626" height="16" font="0">and shared memory based communication. Essentially, this creates a notion of</text>
<text top="455" left="173" width="626" height="16" font="0">process in Java. KaﬀeOS makes use of the user/kernel CPU modes to protect</text>
<text top="488" left="173" width="626" height="16" font="0">kernel objects from being accessed by user processes. KaﬀeOS has the power to</text>
<text top="520" left="173" width="626" height="16" font="0">manage CPU and memory resources, to terminate a process, and to reclaim a</text>
<text top="553" left="173" width="595" height="16" font="0">process’ memory upon termination, much like a traditional operating system.</text>
<text top="585" left="199" width="600" height="16" font="0">The high level of the interface to DrScheme and KaﬀeOS means that many pol-</text>
<text top="618" left="173" width="626" height="16" font="0">icy decisions (such as when to terminate a thread or how to partition resources) are</text>
<text top="650" left="173" width="626" height="16" font="0">made inside the respective run-time systems. This characteristic restricts the abil-</text>
<text top="683" left="173" width="626" height="16" font="0">ity to write general purpose operating systems in either setting without modifying</text>
<text top="715" left="173" width="626" height="16" font="0">the run-time core itself. By contrast, these policy decisions are implemented in the</text>
<text top="748" left="173" width="626" height="16" font="0">Haskell client of an H-based system. No modiﬁcation of the H implementation or</text>
<text top="780" left="173" width="626" height="16" font="0">the Haskell run-time system is required. The services exposed by H are designed to</text>
<text top="813" left="173" width="626" height="16" font="0">facilitate writing operating systems kernels in a safe language with minimal special</text>
<text top="845" left="173" width="626" height="16" font="0">purpose support from a run-time system. Process separation is supported in the</text>
<text top="878" left="173" width="626" height="16" font="0">traditional way using hardware-based protection techniques. It would be interest-</text>
<text top="910" left="173" width="626" height="16" font="0">ing to combine the techniques for run-time system supported processes with the</text>
<text top="943" left="173" width="626" height="16" font="0">techniques from H for memory-safe operating system construction to obtain the</text>
<text top="975" left="173" width="498" height="16" font="0">beneﬁts of memory- and type-safety at every level of the system.</text>
<text top="1008" left="199" width="600" height="16" font="0">Luna also introduces a notion of separated tasks in Java, but unlike KaﬀeOS,</text>
<text top="1040" left="173" width="626" height="16" font="0">Luna relies fully on the type system to guarantee isolation [45]. The boundaries</text>
</page>
<page number="318" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">296</text>
<text top="163" left="173" width="626" height="16" font="0">between software processes are expressed in the types, making distinctions between</text>
<text top="195" left="173" width="626" height="16" font="0">tasks explicit. A major contribution of Luna is the design and implementation of</text>
<text top="228" left="173" width="626" height="16" font="0">a mechanism for communicating between tasks that supports accurate resource</text>
<text top="260" left="173" width="626" height="16" font="0">accounting and maintains strong isolation boundaries. Inter-task communication</text>
<text top="293" left="173" width="626" height="16" font="0">happens via a special type called a remote pointer; these pointers allow data ob-</text>
<text top="325" left="173" width="626" height="16" font="0">jects to be shared between tasks but can be dynamically revoked at any time.</text>
<text top="358" left="173" width="626" height="16" font="0">Luna is implemented through a combination of source-level and run-time system</text>
<text top="390" left="173" width="626" height="16" font="0">extensions, with most of the support for the new features being provided by the</text>
<text top="423" left="173" width="626" height="16" font="0">RTS. Though Luna addresses a very diﬀerent aspect of systems programming than</text>
<text top="455" left="173" width="626" height="16" font="0">H—inter-process communication rather than virtual-memory management—both</text>
<text top="488" left="173" width="626" height="16" font="0">systems face the challenge of integrating operating systems features into a safe lan-</text>
<text top="520" left="173" width="626" height="16" font="0">guage. The Luna designers heavily emphasize the notion of “types as capabilities”</text>
<text top="553" left="173" width="626" height="16" font="0">that is at the heart of our design for H. Remote pointers provide a mechanism for</text>
<text top="585" left="173" width="626" height="16" font="0">revocation that, if available for data values in Haskell, would eliminate the need</text>
<text top="618" left="173" width="496" height="16" font="0">for many of the dynamic status checks in the H implementation.</text>
<text top="650" left="199" width="600" height="16" font="0">The Sing# language—a type-safe, garbage collected extension of C#—has also</text>
<text top="683" left="173" width="626" height="16" font="0">been used for operating systems development. We delay discussion of this topic un-</text>
<text top="715" left="173" width="626" height="16" font="0">til Section 9.5 where we present the Singularity operating system [22, 48], which is</text>
<text top="748" left="173" width="626" height="16" font="0">implemented in Sing#. The Habit programming language [90], which is a Haskell-</text>
<text top="780" left="173" width="626" height="16" font="0">like language designed speciﬁcally for systems programming, is highly relevant to</text>
<text top="813" left="173" width="626" height="16" font="0">our work on the H interface, but we delay our discussion of it until Chapter 10</text>
<text top="845" left="173" width="626" height="16" font="0">because the the concepts are Habit are tightly integrated with our planned future</text>
<text top="878" left="173" width="42" height="16" font="0">work.</text>
<text top="940" left="173" width="26" height="16" font="0">9.4</text>
<text top="940" left="219" width="333" height="16" font="0">VERIFIED OPERATING SYSTEMS</text>
<text top="990" left="173" width="626" height="16" font="0">The seL4 microkernel [60] is closely related to our work in that both projects share</text>
<text top="1022" left="173" width="626" height="16" font="0">the goal of creating formally veriﬁed operating systems. The diﬀerence between</text>
</page>
<page number="319" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">297</text>
<text top="163" left="173" width="626" height="16" font="0">the two projects lies in the approach. The seL4 team achieved the ultimate goal</text>
<text top="195" left="173" width="626" height="16" font="0">of verifying a complete operating system using a traditional implementation of</text>
<text top="228" left="173" width="626" height="16" font="0">their operating system design in C. That veriﬁcation was a reﬁnement proof of</text>
<text top="260" left="173" width="626" height="16" font="0">an abstract functional speciﬁcation to the high-performance C implementation via</text>
<text top="293" left="173" width="626" height="16" font="0">an executable model written in Haskell. The only problem with this approach</text>
<text top="325" left="173" width="626" height="16" font="0">is the cost, approximately 20 person years of eﬀort, and the lack of potential for</text>
<text top="358" left="173" width="626" height="16" font="0">reuse [60]. Our approach is to demonstrate that we can obtain a subset of the</text>
<text top="390" left="173" width="626" height="16" font="0">memory-safety properties proved by the seL4 team automatically by using a pure</text>
<text top="423" left="173" width="626" height="16" font="0">functional language for operating systems implementation rather than a low-level</text>
<text top="455" left="173" width="294" height="16" font="0">and non-memory-safe language like C.</text>
<text top="488" left="199" width="600" height="16" font="0">We are hopeful that the techniques used by the seL4 team to verify their op-</text>
<text top="520" left="173" width="626" height="16" font="0">erating system could also be used to verify our abstraction layer implementation.</text>
<text top="553" left="173" width="626" height="16" font="0">That would give us a greater degree of assurance in the correctness of our design</text>
<text top="585" left="173" width="626" height="16" font="0">and implementation. Furthermore, unlike the seL4 implementation, the H interface</text>
<text top="618" left="173" width="626" height="16" font="0">could be reused as the basis for many diﬀerent operating system implementations,</text>
<text top="650" left="173" width="626" height="16" font="0">thus allowing us to reap the beneﬁts of the veriﬁcation eﬀort multiple times over.</text>
<text top="683" left="173" width="626" height="16" font="0">Because the potentially unsafe operations of the client operating systems would be</text>
<text top="715" left="173" width="626" height="16" font="0">isolated in H, there would be less need to apply formal veriﬁcation techniques to</text>
<text top="748" left="173" width="117" height="16" font="0">the client code.</text>
<text top="780" left="199" width="600" height="16" font="0">Verve is a type- and memory-safe operating system that is veriﬁed using a very</text>
<text top="813" left="173" width="626" height="16" font="0">diﬀerent approach than seL4, making use of automated veriﬁcation tools rather</text>
<text top="845" left="173" width="626" height="16" font="0">than interactive theorem proving [100]. The architecture of Verve is very similar</text>
<text top="878" left="173" width="626" height="16" font="0">to the architecture of H-based operating systems. The services of a traditional</text>
<text top="910" left="173" width="626" height="16" font="0">operating system kernel are split into two layers: a critical low-level layer that</text>
<text top="943" left="173" width="626" height="16" font="0">provides essential abstractions of the hardware (called the Nucleus) and a higher-</text>
<text top="975" left="173" width="626" height="16" font="0">level kernel written in a type- and memory-safe language (typed assembly language</text>
<text top="1008" left="173" width="626" height="16" font="0">produced via C#). The Nucleus of Verve is a direct analog to H, although the</text>
<text top="1040" left="173" width="626" height="16" font="0">services provided by the two interfaces are very diﬀerent. The Nucleus is lower-level</text>
</page>
<page number="320" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">298</text>
<text top="163" left="173" width="626" height="16" font="0">in some respects, allowing clients to install their own interrupt handlers directly</text>
<text top="195" left="173" width="626" height="16" font="0">into the IDT, for example, but higher-level in others, providing drivers for the</text>
<text top="228" left="173" width="626" height="16" font="0">keyboard and the screen. The most signiﬁcant diﬀerence between the two interfaces</text>
<text top="260" left="173" width="626" height="16" font="0">is the treatment of memory. Verve is designed around the idea of software processes</text>
<text top="293" left="173" width="626" height="16" font="0">where isolation is enforced using the type system. Supporting virtual memory</text>
<text top="325" left="173" width="626" height="16" font="0">management operations introduces new challenges for maintaining language-based</text>
<text top="358" left="173" width="626" height="16" font="0">safety properties. Our work with H demonstrates safety, albeit informally, even</text>
<text top="390" left="173" width="626" height="16" font="0">in the presence of client-controlled hardware processes. Exciting areas of future</text>
<text top="423" left="173" width="626" height="16" font="0">work would include writing H in the BoogiePL language, and experimenting with</text>
<text top="455" left="173" width="626" height="16" font="0">encoding memory-safety for hardware processes using Hoare logic so that the H</text>
<text top="488" left="173" width="626" height="16" font="0">implementation could be automatically veriﬁed using the same tools as the Verve</text>
<text top="520" left="173" width="65" height="16" font="0">Nucleus.</text>
<text top="582" left="173" width="26" height="16" font="0">9.5</text>
<text top="582" left="219" width="285" height="16" font="0">SAFE OPERATING SYSTEMS</text>
<text top="632" left="173" width="626" height="16" font="0">The SPIN operating system is an extensible system that supports the ﬂexible</text>
<text top="665" left="173" width="626" height="16" font="0">construction of safe operating system components using the language-based ab-</text>
<text top="697" left="173" width="626" height="16" font="0">straction barriers of their implementation language, Modula-3 [6]. The designers</text>
<text top="730" left="173" width="626" height="16" font="0">of SPIN wished to avoid implementing application-speciﬁc services at user-level—</text>
<text top="762" left="173" width="626" height="16" font="0">such as custom page fault handlers—because of the high cost of context switching</text>
<text top="795" left="173" width="626" height="16" font="0">between kernel and user mode. Instead, such application-speciﬁc services are im-</text>
<text top="827" left="173" width="626" height="16" font="0">plemented as kernel extensions that run in the same address space as the kernel.</text>
<text top="860" left="173" width="626" height="16" font="0">The SPIN design supports a capability-based interface to the core kernel services</text>
<text top="892" left="173" width="626" height="16" font="0">that a kernel extension might access to ensure protection of the SPIN data struc-</text>
<text top="925" left="173" width="626" height="16" font="0">tures. Protection domains within the kernel address space are simply distinct</text>
<text top="957" left="173" width="626" height="16" font="0">name-spaces that are protected statically by the Modula-3 compiler. Though the</text>
<text top="990" left="173" width="626" height="16" font="0">ultimate system architecture of SPIN is fairly diﬀerent from systems that we might</text>
<text top="1022" left="173" width="626" height="16" font="0">construct using our abstraction layer, their use of capabilities is similar to the way</text>
</page>
<page number="321" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">299</text>
<text top="163" left="173" width="626" height="16" font="0">that datatypes are used as tokens in the H interface API and their use of protected</text>
<text top="195" left="173" width="626" height="16" font="0">name-spaces is similar to the way that we protect the internals of the H interface</text>
<text top="228" left="173" width="626" height="16" font="0">using abstraction barriers in Haskell. An advantage that our approach has over</text>
<text top="260" left="173" width="626" height="16" font="0">SPIN is the use of a pure functional language (Modula-3 is impure and impera-</text>
<text top="293" left="173" width="626" height="16" font="0">tive). Operating systems that are written on top of H can make use of the eﬀect</text>
<text top="325" left="173" width="626" height="16" font="0">tracking facilities of Haskell to reduce the occurrence of bugs and pure functional</text>
<text top="358" left="173" width="626" height="16" font="0">languages are more amenable to formal reasoning than a language like Modula-3.</text>
<text top="390" left="173" width="626" height="16" font="0">Furthermore, we take steps to formally characterize the safety guarantees that our</text>
<text top="423" left="173" width="605" height="16" font="0">abstraction layer supports (see Chapter 5, while in SPIN they are left implicit.</text>
<text top="455" left="199" width="600" height="16" font="0">The KeyKOS, EROS, and Coyotos systems reﬂect a long history of work in the</text>
<text top="488" left="173" width="626" height="16" font="0">realm of secure operating systems. KeyKOS was a successful production kernel</text>
<text top="520" left="173" width="626" height="16" font="0">ﬁrst developed in the 1970s, with much of the attention in the design going to</text>
<text top="553" left="173" width="626" height="16" font="0">robustness, reliability and security [41, 10]. KeyKOS is an operating system that</text>
<text top="585" left="173" width="626" height="16" font="0">uses a capability model to enforce security. The system is divided into a set of</text>
<text top="618" left="173" width="626" height="16" font="0">fundamental objects that are the targets of all operations. The semantics of these</text>
<text top="650" left="173" width="626" height="16" font="0">operations describe the protection model for the system. EROS is an implemen-</text>
<text top="683" left="173" width="626" height="16" font="0">tation of the KeyKOS design focused on the performance and correctness of the</text>
<text top="715" left="173" width="626" height="16" font="0">capability mechanism [87, 88]. The EROS developers veriﬁed that the capability</text>
<text top="748" left="173" width="626" height="16" font="0">mechanism provides conﬁnement, showing essentially that the capabilities protect</text>
<text top="780" left="173" width="626" height="16" font="0">the integrity of system objects from unauthorized modiﬁcation. The techniques</text>
<text top="813" left="173" width="626" height="16" font="0">employed to formalize conﬁnement are similar to those that we employed to de-</text>
<text top="845" left="173" width="626" height="16" font="0">scribe memory-safety for H. Coyotos is a follow-on project to EROS that aims to</text>
<text top="878" left="173" width="626" height="16" font="0">more fully realize the high-assurance potential of the system. The conﬁnement</text>
<text top="910" left="173" width="626" height="16" font="0">proof for EROS was done for a high-level model, not the real system. In Coyotos,</text>
<text top="943" left="173" width="626" height="16" font="0">the developers hope to prove the essential security properties for the actual imple-</text>
<text top="975" left="173" width="626" height="16" font="0">mentation. A key part of this endeavor is the development of a new language that</text>
<text top="1008" left="173" width="626" height="16" font="0">will be amenable to veriﬁcation—the developers will use the BitC programming</text>
<text top="1040" left="173" width="626" height="16" font="0">language for the Coyotos implementation and make use of BitC’s formal semantics</text>
</page>
<page number="322" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">300</text>
<text top="163" left="173" width="626" height="16" font="0">in any security proofs [85]. The security goals of all these systems are very similar</text>
<text top="195" left="173" width="626" height="16" font="0">to the goals of the H interface. It is interesting to note that, even though our</text>
<text top="228" left="173" width="626" height="16" font="0">implementations rely on very diﬀerent techniques to achieve security—capabilities</text>
<text top="260" left="173" width="626" height="16" font="0">versus a language-based abstraction barrier—the formalization techniques and es-</text>
<text top="293" left="173" width="328" height="16" font="0">sential security properties are very similar.</text>
<text top="325" left="199" width="600" height="16" font="0">The Singularity project takes the idea of software-based isolation from SPIN</text>
<text top="358" left="173" width="626" height="16" font="0">even further. In Singularity, all user processes, drivers, and other system com-</text>
<text top="390" left="173" width="626" height="16" font="0">ponents run in the highest privilege address space with the kernel [22, 48]. The</text>
<text top="423" left="173" width="626" height="16" font="0">type-safety of the implementation language, Sing# (a type-safe, garbage collected</text>
<text top="455" left="173" width="626" height="16" font="0">extension of C#), provides software-based isolation between these components,</text>
<text top="488" left="173" width="626" height="16" font="0">despite the shared address space. A novel feature of the Singularity operating</text>
<text top="520" left="173" width="626" height="16" font="0">system is an eﬃcient message-passing mechanism that supports communication</text>
<text top="553" left="173" width="626" height="16" font="0">between components in the system. The communication channels in Singularity</text>
<text top="585" left="173" width="626" height="16" font="0">are strongly typed. Resource ownership is tracked using a linear type system to</text>
<text top="618" left="173" width="626" height="16" font="0">ensure isolation by guaranteeing that blocks of memory are never owned by more</text>
<text top="650" left="173" width="626" height="16" font="0">than one process. Statically veriﬁed channel contracts provide additional assurance</text>
<text top="683" left="173" width="626" height="16" font="0">that components interact correctly. The result is a system with strong isolation</text>
<text top="715" left="173" width="626" height="16" font="0">guarantees that use a combination of modern language techniques, like memory-</text>
<text top="748" left="173" width="337" height="16" font="0">and type-safety, and veriﬁcation techniques.</text>
<text top="780" left="199" width="600" height="16" font="0">The Singularity project relies on some of the same essential features of modern</text>
<text top="813" left="173" width="626" height="16" font="0">programming languages as we do, in particular memory-safety and a strong, static</text>
<text top="845" left="173" width="626" height="16" font="0">type system. In some ways, the type system of Sing# is more expressive than the</text>
<text top="878" left="173" width="626" height="16" font="0">type system of Haskell. Linear types would enable us to avoid much of the dynamic</text>
<text top="910" left="173" width="626" height="16" font="0">checking that needs to be done in the implementation of the abstraction layer.</text>
<text top="943" left="173" width="626" height="16" font="0">The ability to express, and statically verify, resource interactions (like the channel</text>
<text top="975" left="173" width="626" height="16" font="0">contracts in Singularity) could also be useful for establishing memory-safety of the</text>
<text top="1008" left="173" width="626" height="16" font="0">H interface. However, the Sing# type system is less expressive in other ways, for</text>
<text top="1040" left="173" width="626" height="16" font="0">example, the language does not support Haskell’s ability to track eﬀects. Despite</text>
</page>
<page number="323" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">301</text>
<text top="163" left="173" width="626" height="16" font="0">the similar mechanisms for achieving safety, the goal of our work is diﬀerent than</text>
<text top="195" left="173" width="626" height="16" font="0">that of Singularity. We aim to provide a library for writing operating systems</text>
<text top="228" left="173" width="626" height="16" font="0">in Haskell, rather than to construct a single system with a speciﬁc property, like</text>
<text top="260" left="173" width="626" height="16" font="0">isolation. Another diﬀerence is that we provide the ability to run code in any</text>
<text top="293" left="173" width="386" height="16" font="0">language, which Singularity does not support [22].</text>
<text top="355" left="173" width="26" height="16" font="0">9.6</text>
<text top="355" left="219" width="179" height="16" font="0">VIRTUALIZATION</text>
<text top="405" left="173" width="626" height="16" font="0">Virtual machine monitors attempt to multiplex hardware invisibly across multi-</text>
<text top="437" left="173" width="626" height="16" font="0">ple operating systems. This goal diﬀers from that of our abstraction layer, where</text>
<text top="470" left="173" width="626" height="16" font="0">we want to expose the hardware to a single OS. Despite the diﬀerent goals, our</text>
<text top="502" left="173" width="626" height="16" font="0">abstraction layer does share some common features with virtual machine monitor</text>
<text top="535" left="173" width="626" height="16" font="0">designs, in particular with paravirtualization systems like Xen [5]. A paravirtual-</text>
<text top="567" left="173" width="626" height="16" font="0">ized system does not provide binary compatibility for operating systems, rather,</text>
<text top="600" left="173" width="626" height="16" font="0">each guest operating system must be ported to run on the virtual machine moni-</text>
<text top="632" left="173" width="626" height="16" font="0">tor. The VMM exports a low-level, hardware-like interface, so the modiﬁcations to</text>
<text top="665" left="173" width="626" height="16" font="0">the guest are analogous to porting to a new architecture or base library. Though</text>
<text top="697" left="173" width="626" height="16" font="0">an operating system designer that wishes to use our abstraction layer must also</text>
<text top="730" left="173" width="626" height="16" font="0">reimplement their design in a functional programming language, the modiﬁcations</text>
<text top="762" left="173" width="517" height="16" font="0">to the architecture-level primitives will be similar to a port to Xen.</text>
<text top="795" left="199" width="600" height="16" font="0">Much like the H interface, Xen provides an interface of hypervisor calls that</text>
<text top="827" left="173" width="626" height="16" font="0">guest VMs use to request privileged operations. Memory management and CPU</text>
<text top="860" left="173" width="626" height="16" font="0">management are particularly important aspects of the Xen design. When managing</text>
<text top="892" left="173" width="626" height="16" font="0">memory, the guest cannot modify page tables directly. The primary focus is on</text>
<text top="925" left="173" width="626" height="16" font="0">exporting a safe set of API calls that cannot be invoked by a guest OS in a way</text>
<text top="957" left="173" width="626" height="16" font="0">that corrupts the internal structures of Xen or disrupts the execution of another</text>
<text top="990" left="173" width="626" height="16" font="0">guest. Unlike our work, the designers of Xen do not formally characterize the</text>
<text top="1022" left="173" width="626" height="16" font="0">safety guarantees of their API. For limited resources, like memory, Xen uses a</text>
</page>
<page number="324" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">302</text>
<text top="163" left="173" width="626" height="16" font="0">static partitioning among guests. Though the H interface only supports a single</text>
<text top="195" left="173" width="626" height="16" font="0">guest operating system, the facilities for dynamic memory exchange between the</text>
<text top="228" left="173" width="626" height="16" font="0">abstraction layer and the guest might be useful in a system like Xen for enabling</text>
<text top="260" left="173" width="626" height="16" font="0">dynamic system conﬁgurations without sacriﬁcing the strong isolation properties</text>
<text top="293" left="173" width="349" height="16" font="0">that are currently present between Xen VMs.</text>
</page>
<page number="325" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">303</text>
<text top="227" left="443" width="86" height="16" font="0">Chapter 10</text>
<text top="277" left="422" width="129" height="16" font="0">CONCLUSIONS</text>
<text top="370" left="173" width="626" height="16" font="0">In this dissertation, we have demonstrated that it is possible to bridge the gap</text>
<text top="402" left="173" width="626" height="16" font="0">between the requirements of operating system implementations and the features</text>
<text top="435" left="173" width="626" height="16" font="0">of purely functional languages. We accomplished this goal by isolating the poten-</text>
<text top="467" left="173" width="626" height="16" font="0">tially unsafe operations that are required by operating systems in a memory-safe</text>
<text top="500" left="173" width="626" height="16" font="0">abstraction layer called the H interface. The H interface design is integrated with</text>
<text top="532" left="173" width="626" height="16" font="0">the purely functional language Haskell to support the development of memory-</text>
<text top="565" left="173" width="626" height="16" font="0">safe Haskell operating systems that do not make direct use of the foreign function</text>
<text top="597" left="173" width="70" height="16" font="0">interface.</text>
<text top="630" left="199" width="600" height="16" font="0">An essential property of the H interface is memory-safety. The meaning of the</text>
<text top="662" left="173" width="626" height="16" font="0">term memory-safety is a bit murky in the operating systems domain, but we have</text>
<text top="695" left="173" width="626" height="16" font="0">identiﬁed two critical memory-safety issues that are relevant in the context of the H</text>
<text top="727" left="173" width="626" height="16" font="0">interface: no part of the system, including the H operations, should be permitted to</text>
<text top="760" left="173" width="626" height="16" font="0">aﬀect the Haskell run-time system and no user program or client of the H interface</text>
<text top="792" left="173" width="626" height="16" font="0">should have direct access to the memory management hardware. We formalized</text>
<text top="825" left="173" width="626" height="16" font="0">these properties using the Rushby noninterference formalism [82] and connected</text>
<text top="857" left="173" width="626" height="16" font="0">the abstract formalism to our implementation with a relational speciﬁcation of the</text>
<text top="890" left="173" width="285" height="16" font="0">memory management functions in H.</text>
<text top="922" left="199" width="600" height="16" font="0">We demonstrated the expressiveness of the H interface by implementing the L4</text>
<text top="955" left="173" width="626" height="16" font="0">microkernel API using the abstraction layer primitives. No special workarounds or</text>
<text top="987" left="173" width="626" height="16" font="0">uses of the foreign function interface were necessary. L4 supports user-level memory</text>
<text top="1020" left="173" width="626" height="16" font="0">management, so the set of virtual memory management primitives is particularly</text>
<text top="1052" left="173" width="626" height="16" font="0">rich. The experience of developing L4 using H was a positive one. Implementing</text>
</page>
<page number="326" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">304</text>
<text top="163" left="173" width="626" height="16" font="0">L4 in a strongly typed, memory-safe environment made bugs easy to detect when</text>
<text top="195" left="173" width="626" height="16" font="0">they occurred (relative to our experience implementing part of the H library in C)</text>
<text top="228" left="173" width="403" height="16" font="0">and helped us to catch many errors at compile time.</text>
<text top="260" left="199" width="600" height="16" font="0">Performance is another important characteristic of H. Our goal was never to</text>
<text top="293" left="173" width="626" height="16" font="0">produce the best performing L4 implementation ever, but our approach to safety is</text>
<text top="325" left="173" width="626" height="16" font="0">not useful if the techniques are so inherently poorly performing that the resulting</text>
<text top="358" left="173" width="626" height="16" font="0">systems are unusable. We evaluated the performance of our approach using an</text>
<text top="390" left="173" width="626" height="16" font="0">IPC benchmark for L4. The performance of our L4 implementation is signiﬁcantly</text>
<text top="423" left="173" width="626" height="16" font="0">worse than a comparable C kernel, so there is room for improvement. We have</text>
<text top="455" left="173" width="626" height="16" font="0">demonstrated techniques for optimizing Haskell programs in general and H-based</text>
<text top="488" left="173" width="626" height="16" font="0">systems in particular. Though we only applied these optimizations to a narrow</text>
<text top="520" left="173" width="626" height="16" font="0">area of our program, the changes radically improved the performance of IPC. These</text>
<text top="553" left="173" width="626" height="16" font="0">experiments illustrate the potential to optimize performance throughout the L4</text>
<text top="585" left="173" width="184" height="16" font="0">and H implementations.</text>
<text top="618" left="199" width="372" height="16" font="0">The major contributions of this dissertation are:</text>
<text top="664" left="199" width="600" height="17" font="0">• The design and implementation of a memory-safe abstraction layer for imple-</text>
<text top="698" left="217" width="583" height="16" font="0">menting operating systems in a purely functional language. The abstraction</text>
<text top="730" left="217" width="583" height="16" font="0">layer is suﬃciently expressive to support the implementation of real operat-</text>
<text top="763" left="217" width="583" height="16" font="0">ing systems in Haskell. Our implementation of the L4 microkernel provides</text>
<text top="795" left="217" width="360" height="16" font="0">evidence of the abstraction layer’s expressivity.</text>
<text top="842" left="199" width="600" height="17" font="0">• A formalism for describing memory-safety by instantiating an abstract non-</text>
<text top="875" left="217" width="582" height="16" font="0">interference framework. We identify the properties that are necessary and</text>
<text top="908" left="217" width="582" height="16" font="0">meaningful for a Haskell library that controls the memory management hard-</text>
<text top="940" left="217" width="583" height="16" font="0">ware of the underlying machine and demonstrate a unique use of noninter-</text>
<text top="973" left="217" width="58" height="16" font="0">ference.</text>
<text top="1019" left="199" width="600" height="17" font="0">• A performance analysis of a bare metal Haskell program. The bare metal</text>
</page>
<page number="327" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">305</text>
<text top="163" left="217" width="583" height="16" font="0">execution environment for Haskell is not well suited to performance mea-</text>
<text top="195" left="217" width="75" height="16" font="0">surement.</text>
<text top="195" left="308" width="491" height="16" font="0">We introduced facilities for analyzing the performance of our</text>
<text top="228" left="217" width="582" height="16" font="0">Haskell kernel and outlined an optimization path for any H-based system.</text>
<text top="260" left="217" width="583" height="16" font="0">We demonstrated the utility of the proposed optimizations by employing</text>
<text top="293" left="217" width="583" height="16" font="0">them to reduce the cost of transferring 60 words in an L4 IPC message in</text>
<text top="325" left="217" width="583" height="16" font="0">our kernel, producing a ﬁnal version that was more than 6 times faster than</text>
<text top="358" left="217" width="583" height="16" font="0">the original. Our kernel is 60 times slower than the Pistachio implementation</text>
<text top="390" left="217" width="426" height="16" font="0">in C compared to 368 times slower before optimization.</text>
<text top="452" left="173" width="159" height="16" font="0">FUTURE WORK</text>
<text top="502" left="173" width="626" height="16" font="0">Our work opens up many avenues for future exploration. Some of these topics are</text>
<text top="535" left="173" width="626" height="16" font="0">direct extensions of the work presented here, while others represent substantially</text>
<text top="567" left="173" width="216" height="16" font="0">new directions for our work.</text>
<text top="627" left="173" width="494" height="16" font="0">Haskell Device Drivers and Other Systems Applications</text>
<text top="671" left="173" width="626" height="16" font="0">The H interface demonstrates a technique for encapsulating the potentially unsafe</text>
<text top="704" left="173" width="626" height="16" font="0">operations necessary for operating systems in a memory-safe Haskell library. Here,</text>
<text top="736" left="173" width="626" height="16" font="0">memory-safety is speciﬁcally linked to the operating systems domain, as are the</text>
<text top="769" left="173" width="626" height="16" font="0">speciﬁc primitives deﬁned in the abstraction layer. There are many other systems</text>
<text top="801" left="173" width="626" height="16" font="0">programming applications, such as device drivers, that may require access to a</text>
<text top="834" left="173" width="626" height="16" font="0">diﬀerent set of hardware facilities than are supported by H. The implementer of</text>
<text top="866" left="173" width="626" height="16" font="0">a Haskell device driver would encounter the same issues that motivated H when</text>
<text top="899" left="173" width="626" height="16" font="0">working with the foreign function interface directly. However, we can apply the</text>
<text top="931" left="173" width="626" height="16" font="0">same techniques for abstraction, interface design, and safety analysis in these ap-</text>
<text top="964" left="173" width="626" height="16" font="0">plication areas to encapsulate the necessary behaviors for all aspects of systems</text>
<text top="996" left="173" width="107" height="16" font="0">programming.</text>
</page>
<page number="328" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">306</text>
<text top="163" left="173" width="234" height="16" font="0">Performance Optimization</text>
<text top="207" left="173" width="626" height="16" font="0">In this work, we were able to improve upon our initial performance results signif-</text>
<text top="239" left="173" width="626" height="16" font="0">icantly by applying targeted optimizations to the inner loop that performs data</text>
<text top="272" left="173" width="626" height="16" font="0">transfer during an IPC message. Even with these improvements, the performance</text>
<text top="304" left="173" width="626" height="16" font="0">of our Haskell kernel is signiﬁcantly worse than standard C implementations. For-</text>
<text top="337" left="173" width="626" height="16" font="0">tunately, there are many optimization opportunities that remain. Chapter 8 de-</text>
<text top="370" left="173" width="626" height="16" font="0">scribed three essential areas to focus on when optimizing an H-based system: al-</text>
<text top="402" left="173" width="626" height="16" font="0">gorithmic design, better abstractions in the H interface, and improved code gen-</text>
<text top="435" left="173" width="626" height="16" font="0">eration through compiler annotations. There are also opportunities for deeper</text>
<text top="467" left="173" width="626" height="16" font="0">modiﬁcations (and possibly signiﬁcant performance gains) by examining the eﬃ-</text>
<text top="500" left="173" width="626" height="16" font="0">ciency of the data structures used by H, both internally and as they are exposed</text>
<text top="532" left="173" width="98" height="16" font="0">to the client.</text>
<text top="565" left="199" width="600" height="16" font="0">Within the IPC implementation alone, the scheduling, transfer message, and</text>
<text top="597" left="173" width="626" height="16" font="0">thread restart phases take many more cycles than one would expect. These are</text>
<text top="630" left="173" width="626" height="16" font="0">obvious areas to direct our optimization energy next. By applying the techniques</text>
<text top="662" left="173" width="626" height="16" font="0">outlined in this dissertation to these new aspects of the algorithm, we hope to</text>
<text top="695" left="173" width="274" height="16" font="0">further reduce the overhead of IPC.</text>
<text top="754" left="173" width="101" height="16" font="0">Veriﬁcation</text>
<text top="798" left="173" width="626" height="16" font="0">Veriﬁcation is an obvious area to focus on in our future work. A formal proof of</text>
<text top="831" left="173" width="626" height="16" font="0">the unwinding conditions for our Rushby instantiation is our ﬁrst priority. Proving</text>
<text top="863" left="173" width="626" height="16" font="0">the unwinding conditions is suﬃcient to demonstrate memory-safety for our speci-</text>
<text top="896" left="173" width="626" height="16" font="0">ﬁcation and would go a long way towards validating our approach. Completing the</text>
<text top="928" left="173" width="626" height="16" font="0">proof of the unwinding conditions will give us the opportunity to turn our atten-</text>
<text top="961" left="173" width="626" height="16" font="0">tion upward toward higher level properties of Haskell operating systems, such as</text>
<text top="993" left="173" width="626" height="16" font="0">user-program separation, or downward, to a full veriﬁcation of our implementation.</text>
<text top="1026" left="199" width="600" height="16" font="0">To this end, we have begun a joint project to formally verify the unwinding</text>
</page>
<page number="329" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">307</text>
<text top="163" left="173" width="626" height="16" font="0">conditions. The Haskell speciﬁcation and system model have been translated into</text>
<text top="195" left="173" width="626" height="16" font="0">a formal model in HOL Light [43]. Using this model, we have mechanically veriﬁed</text>
<text top="228" left="173" width="626" height="16" font="0">our earlier sketch that the output consistency unwinding condition reduces to weak</text>
<text top="260" left="173" width="626" height="16" font="0">step consistency (see Section 5.4.1). A proof of local respect is currently in progress,</text>
<text top="293" left="173" width="541" height="16" font="0">while the veriﬁcation of weak step consistency remains as future work.</text>
<text top="325" left="199" width="600" height="16" font="0">Completing the proof of the unwinding conditions for the H speciﬁcation will</text>
<text top="358" left="173" width="626" height="16" font="0">allow us to pursue properties of Haskell operating systems that depend on memory-</text>
<text top="390" left="173" width="626" height="16" font="0">safety. Separation properties have been a particular focus of our past work [66,</text>
<text top="423" left="173" width="626" height="16" font="0">67, 39], and are an interesting area to pursue in the context of a Haskell operat-</text>
<text top="455" left="173" width="626" height="16" font="0">ing system. Our experience deﬁning memory-safety in terms of a noninterference</text>
<text top="488" left="173" width="626" height="16" font="0">security policy will provide valuable insight into any future eﬀorts in this domain.</text>
<text top="548" left="173" width="278" height="16" font="0">Operating Systems Exploration</text>
<text top="592" left="173" width="626" height="16" font="0">Through the H interface, we hope to enable a wide range of operating systems</text>
<text top="624" left="173" width="626" height="16" font="0">exploration in Haskell. We demonstrate the feasibility of such exploration through</text>
<text top="657" left="173" width="626" height="16" font="0">our L4 implementation, but this is just one of many possibilities. We are keen</text>
<text top="689" left="173" width="626" height="16" font="0">to see how H generalizes by using the interface to implement other operating</text>
<text top="722" left="173" width="626" height="16" font="0">systems. One obvious candidate is the House operating system that originated</text>
<text top="754" left="173" width="626" height="16" font="0">the idea for H in the ﬁrst place [39]; the API provided by the abstraction layer</text>
<text top="787" left="173" width="626" height="16" font="0">presented in this dissertation is radically diﬀerent from the original version of H,</text>
<text top="819" left="173" width="626" height="16" font="0">and porting House to the new interface would be a valuable learning experience.</text>
<text top="852" left="173" width="626" height="16" font="0">Virtual machine monitors are another interesting domain; H was not speciﬁcally</text>
<text top="884" left="173" width="626" height="16" font="0">designed to support VMMs, so such a project would potentially push the interface</text>
<text top="917" left="173" width="255" height="16" font="0">design in exciting new directions.</text>
<text top="949" left="199" width="600" height="16" font="0">Another dimension of systems exploration is in programming language research</text>
<text top="982" left="173" width="626" height="16" font="0">to better facilitate safe systems programming. Many of the ideas generated by this</text>
<text top="1014" left="173" width="626" height="16" font="0">work, and the challenges that we encountered when using Haskell for operating sys-</text>
<text top="1047" left="173" width="626" height="16" font="0">tems programming, have inﬂuenced the design of a new language being developed</text>
</page>
<page number="330" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">308</text>
<text top="163" left="173" width="626" height="16" font="0">at Portland State University called Habit [90]. Habit aims to provide the level</text>
<text top="195" left="173" width="626" height="16" font="0">of resource control that is necessary for systems programming, including control</text>
<text top="228" left="173" width="626" height="16" font="0">over memory layout and direct access to memory through references [20, 19], in</text>
<text top="260" left="173" width="626" height="16" font="0">a strongly typed functional language. Unlike other languages in this space, Habit</text>
<text top="293" left="173" width="626" height="16" font="0">retains all of the features that made Haskell an attractive candidate for our work—</text>
<text top="325" left="173" width="626" height="16" font="0">purity, monadic eﬀects and type classes—along with many other valuable features</text>
<text top="358" left="173" width="626" height="16" font="0">of safe languages like garbage collection. The addition of a powerful module system</text>
<text top="390" left="173" width="626" height="16" font="0">is planned. From an assurance perspective, Habit greatly improves upon Haskell</text>
<text top="423" left="173" width="626" height="16" font="0">because it will provide a veriﬁed run-time system [73], whereas Haskell’s 50,000</text>
<text top="455" left="173" width="626" height="16" font="0">line C run-time is always the elephant in the room when it comes to assurance</text>
<text top="488" left="173" width="626" height="16" font="0">arguments. There are opportunities for improvements in the performance space as</text>
<text top="520" left="173" width="626" height="16" font="0">well. Besides the fact that Habit allows more direct control over resources, which</text>
<text top="553" left="173" width="626" height="16" font="0">should be an automatic performance win, one of the language’s major departures</text>
<text top="585" left="173" width="626" height="16" font="0">from Haskell is that Habit is strict. Laziness caused unpredictable and severe</text>
<text top="618" left="173" width="626" height="16" font="0">performance problems in our IPC implementation, as mentioned in Section 8.3.3;</text>
<text top="650" left="173" width="626" height="16" font="0">there is hope that a strict language will simplify the optimization process and even</text>
<text top="683" left="173" width="342" height="16" font="0">avoid certain performance problems entirely.</text>
<text top="715" left="199" width="600" height="16" font="0">Extending the connection between Habit and the H interface is also a promising</text>
<text top="748" left="173" width="626" height="16" font="0">topic for future work. Many of the features implemented by H are unnecessary in</text>
<text top="780" left="173" width="626" height="16" font="0">Habit—the language supports safe facilities for systems programming already, in-</text>
<text top="813" left="173" width="626" height="16" font="0">cluding many of the features necessary for writing an operating system. However,</text>
<text top="845" left="173" width="626" height="16" font="0">some aspects of H must be primitive to the language and are not yet part of the</text>
<text top="878" left="173" width="626" height="16" font="0">Habit design, such as the ability to control the memory management hardware.</text>
<text top="910" left="173" width="626" height="16" font="0">Work is underway on the Habit project to support the addition of new primitives</text>
<text top="943" left="173" width="626" height="16" font="0">in a modular way that incorporates the veriﬁcation contract between the primi-</text>
<text top="975" left="173" width="626" height="16" font="0">tive and the rest of the system explicitly. This provides a perfect opportunity to</text>
<text top="1008" left="173" width="626" height="16" font="0">integrate the essential memory management facilities of H fully into Habit. Mov-</text>
<text top="1040" left="173" width="626" height="16" font="0">ing from an H-based platform in Haskell to a fully integrated operating systems</text>
</page>
<page number="331" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">309</text>
<text top="163" left="173" width="626" height="16" font="0">programming environment in Habit will give us all of the safety and engineer-</text>
<text top="195" left="173" width="626" height="16" font="0">ing beneﬁts of Haskell, but with better performance, greater assurance, and more</text>
<text top="228" left="173" width="171" height="16" font="0">control over resources.</text>
<text top="260" left="199" width="600" height="16" font="0">A further beneﬁt of connecting the H primitives to Habit is that the dynamic</text>
<text top="293" left="173" width="626" height="16" font="0">checks necessary for safety could be generated by the compiler when an H primitive</text>
<text top="325" left="173" width="626" height="16" font="0">is used, rather than being an integral part of the H primitive itself. In this way,</text>
<text top="358" left="173" width="626" height="16" font="0">the compiler could insert safety checks in precisely those places where they are</text>
<text top="390" left="173" width="626" height="16" font="0">necessary. In the implementation of H we do not have any information about the</text>
<text top="423" left="173" width="626" height="16" font="0">context in which a primitive is called, so we must always assume the call is unsafe</text>
<text top="455" left="173" width="626" height="16" font="0">and perform run-time checks for each one. We expect that there are many contexts</text>
<text top="488" left="173" width="626" height="16" font="0">that are statically known to be safe. Cyclone illustrates the feasibility of this idea</text>
<text top="520" left="173" width="626" height="16" font="0">for memory-safety checks in a C-style language and we expect the techniques would</text>
<text top="553" left="173" width="626" height="16" font="0">apply equally well to our notion of memory-safety. Though there are many other</text>
<text top="585" left="173" width="626" height="16" font="0">bottlenecks in H, reducing the number of run-time checks would certainly improve</text>
<text top="618" left="173" width="100" height="16" font="0">performance.</text>
</page>
<page number="332" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">310</text>
<text top="233" left="426" width="121" height="16" font="0">REFERENCES</text>
<text top="325" left="190" width="608" height="16" font="0">[1] Toyota recall information website. http://www.toyota.com/recall/abs.html.</text>
<text top="371" left="190" width="609" height="16" font="0">[2] Michael J. Accetta, Robert V. Baron, William J. Bolosky, David B. Golub,</text>
<text top="403" left="218" width="582" height="16" font="0">Richard F. Rashid, Avadis Tevanian, and Michael Young. Mach: A new</text>
<text top="436" left="218" width="582" height="16" font="0">kernel foundation for unix development. In USENIX Summer, pages 93–113,</text>
<text top="468" left="218" width="40" height="16" font="0">1986.</text>
<text top="514" left="190" width="609" height="16" font="0">[3] Video Electronics Standards Association. VESA BIOS EXTENSION (VBE)</text>
<text top="546" left="218" width="582" height="16" font="0">- Core Functions Standard, Version 3, September 1998. http://www.vesa.</text>
<text top="580" left="218" width="33" height="15" font="0">org.</text>
<text top="624" left="190" width="609" height="16" font="0">[4] Godmar Back and Wilson C. Hsieh. The KaﬀeOS Java runtime system. ACM</text>
<text top="656" left="218" width="544" height="16" font="0">Transactions on Programming Language Systems, 27(4):583–630, 2005.</text>
<text top="702" left="190" width="609" height="16" font="0">[5] Paul Barham, Boris Dragovic, Keir Fraser, Steven Hand, Timothy L. Harris,</text>
<text top="734" left="218" width="582" height="16" font="0">Alex Ho, Rolf Neugebauer, Ian Pratt, and Andrew Warﬁeld. Xen and the art</text>
<text top="767" left="218" width="582" height="16" font="0">of virtualization. In Proceedings of the 19th ACM Symposium on Operating</text>
<text top="799" left="218" width="490" height="16" font="0">Systems Principles (SOSP 2003), pages 164–177, October 2003.</text>
<text top="844" left="190" width="609" height="16" font="0">[6] B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fiuczynski, D. Becker,</text>
<text top="877" left="218" width="582" height="16" font="0">S. Eggers, and C. Chambers. Extensibility, safety and performance in the</text>
<text top="909" left="218" width="582" height="16" font="0">SPIN operating system. In Proceedings of the 15th Symposium on Operating</text>
<text top="942" left="218" width="542" height="16" font="0">Systems Principles, pages 267–284, Copper Mountain, Colorado, 1995.</text>
<text top="987" left="190" width="609" height="16" font="0">[7] William R. Bevier and William D. Young. A state-based approach to non-</text>
<text top="1020" left="218" width="582" height="16" font="0">interference. In Proceedings of the Computer Security Foundations Workshop,</text>
<text top="1052" left="218" width="143" height="16" font="0">pages 11–21, 1994.</text>
</page>
<page number="333" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">311</text>
<text top="163" left="190" width="609" height="16" font="0">[8] Edoardo S. Biagioni, Robert Harper, and Peter Lee. A Network Protocol</text>
<text top="195" left="218" width="582" height="16" font="0">Stack in Standard ML. Journal of Higher-Order and Symbolic Computation,</text>
<text top="228" left="218" width="157" height="16" font="0">14(4):309–356, 2001.</text>
<text top="275" left="190" width="439" height="16" font="0">[9] BitC language website. http://www.bitc-lang.org.</text>
<text top="323" left="182" width="618" height="16" font="0">[10] Allen C. Bomberger, William S. Frantz, Ann C. Hardy, Norman Hardy,</text>
<text top="355" left="218" width="582" height="16" font="0">Charles R. Landau, and Jonathan S. Shapiro. The KeyKOS nanokernel</text>
<text top="388" left="218" width="582" height="16" font="0">architecture. In Proceedings of the USENIX Workshop on Microkernels and</text>
<text top="420" left="218" width="369" height="16" font="0">Other Kernel Architectures, pages 95–112, 1992.</text>
<text top="468" left="182" width="618" height="16" font="0">[11] Per Brinch Hansen. The nucleus of a multiprogramming system. Communi-</text>
<text top="500" left="218" width="318" height="16" font="0">cations of the ACM, 13(4):238–241, 1970.</text>
<text top="548" left="182" width="618" height="16" font="0">[12] Manuel M. T. Chakravarty, Sigbjorn Finne, Gergus Henderson, Marcin</text>
<text top="580" left="218" width="582" height="16" font="0">Kowalczyk, Daan Leijen, Simon Marlow, Erik Meijer, Sven Panne, Simon</text>
<text top="613" left="218" width="582" height="16" font="0">Peyton Jones, Alastair Reid, Malcolm Wallace, and Michael Weber. Haskell</text>
<text top="645" left="218" width="582" height="16" font="0">98 Foreign Function Interface (1.0), 2003. http://www.cse.unsw.edu.au/</text>
<text top="683" left="218" width="162" height="15" font="0">~chak/haskell/ffi.</text>
<text top="725" left="182" width="618" height="16" font="0">[13] TIS Committee. Tool Interface Standard (TIS) Executable and Linking For-</text>
<text top="758" left="218" width="375" height="16" font="0">mat (ELF) Speciﬁcation, Version 1.2, May 1995.</text>
<text top="805" left="182" width="104" height="16" font="0">[14] Coverity.</text>
<text top="805" left="309" width="328" height="16" font="0">Coverity Scan open source report 2009.</text>
<text top="805" left="660" width="139" height="16" font="0">Online white pa-</text>
<text top="838" left="218" width="582" height="16" font="0">per, http://scan.coverity.com/report/Coverity_White_Paper-Scan_</text>
<text top="872" left="218" width="300" height="15" font="0">Open_Source_Report_2009.pdf, 2009.</text>
<text top="918" left="182" width="495" height="16" font="0">[15] Coverity. Scan Project. http://scan.coverity.com, 2009.</text>
<text top="965" left="182" width="618" height="16" font="0">[16] John Criswell, Andrew Lenharth, Dinakar Dhurjati, and Vikram S. Adve.</text>
<text top="998" left="218" width="582" height="16" font="0">Secure virtual architecture: a safe execution environment for commodity</text>
<text top="1030" left="218" width="582" height="16" font="0">operating systems. In Andrew Herbert and Kenneth P. Birman, editors,</text>
</page>
<page number="334" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">312</text>
<text top="163" left="218" width="582" height="16" font="0">Proceedings of the 20th ACM Symposium on Operating Systems Principles</text>
<text top="195" left="218" width="392" height="16" font="0">(SOSP 2005), pages 351–366. ACM, October 2005.</text>
<text top="243" left="182" width="618" height="16" font="0">[17] John Cupitt. A brief walk through KAOS. Technical report, Computing</text>
<text top="275" left="218" width="477" height="16" font="0">Laboratory, University of Kent at Canterbury, February 1989.</text>
<text top="323" left="182" width="618" height="16" font="0">[18] Philip Derrin, Kevin Elphinstone, Gerwin Klein, David Cock, and Manuel</text>
<text top="355" left="218" width="582" height="16" font="0">M. T. Chakravarty. Running the manual: An approach to high-assurance</text>
<text top="388" left="218" width="582" height="16" font="0">microkernel development. In Proceedings of the 2006 ACM SIGPLAN Work-</text>
<text top="420" left="218" width="381" height="16" font="0">shop on Haskell, Haskell 2006, pages 60–71, 2006.</text>
<text top="468" left="182" width="618" height="16" font="0">[19] Iavor S. Diatchki and Mark P. Jones. Strongly typed memory areas. In Pro-</text>
<text top="500" left="218" width="582" height="16" font="0">ceedings of ACM SIGPLAN 2006 Haskell Workshop, pages 72–83, Portland,</text>
<text top="533" left="218" width="193" height="16" font="0">Oregon, September 2006.</text>
<text top="580" left="182" width="618" height="16" font="0">[20] Iavor S. Diatchki, Mark P. Jones, and Rebekah Leslie. High-level views on</text>
<text top="613" left="218" width="582" height="16" font="0">low-level representations. In Proceedings of the Tenth ACM SIGPLAN In-</text>
<text top="645" left="218" width="582" height="16" font="0">ternational Conference on Functional Programming, pages 168–179, Tallinn,</text>
<text top="678" left="218" width="195" height="16" font="0">Estonia, September 2005.</text>
<text top="725" left="182" width="321" height="16" font="0">[21] Information Assurance Directorate.</text>
<text top="725" left="531" width="269" height="16" font="0">U.S. government protection pro-</text>
<text top="758" left="218" width="22" height="16" font="0">ﬁle</text>
<text top="758" left="257" width="21" height="16" font="0">for</text>
<text top="758" left="294" width="79" height="16" font="0">separation</text>
<text top="758" left="390" width="53" height="16" font="0">kernels</text>
<text top="758" left="459" width="15" height="16" font="0">in</text>
<text top="758" left="491" width="102" height="16" font="0">environments</text>
<text top="758" left="609" width="69" height="16" font="0">requiring</text>
<text top="758" left="695" width="33" height="16" font="0">high</text>
<text top="758" left="744" width="55" height="16" font="0">robust-</text>
<text top="790" left="218" width="36" height="16" font="0">ness.</text>
<text top="792" left="281" width="518" height="15" font="0">http://niap-ccevs.org/cc-scheme/pp/pp.cfm/id/pp_skpp_hr_</text>
<text top="824" left="218" width="245" height="15" font="0">v1.03, June 2007. Version 1.03.</text>
<text top="870" left="182" width="119" height="16" font="0">[22] Manuel F¨</text>
<text top="870" left="292" width="507" height="16" font="0">ahndrich, Mark Aiken, Chris Hawblitzel, Orion Hodson, Galen C.</text>
<text top="903" left="218" width="582" height="16" font="0">Hunt, James R. Larus, and Steven Levi. Language support for fast and</text>
<text top="935" left="218" width="582" height="16" font="0">reliable message-based communication in Singularity OS. In Yolande Berbers</text>
<text top="968" left="218" width="582" height="16" font="0">and Willy Zwaenepoel, editors, Proceedings of the First EuroSys Conference,</text>
<text top="1000" left="218" width="258" height="16" font="0">pages 177–190. ACM, April 2006.</text>
</page>
<page number="335" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">313</text>
<text top="163" left="182" width="618" height="16" font="0">[23] Norman Feske and Christian Helmuth. A Nitpicker’s guide to a minimal-</text>
<text top="195" left="218" width="582" height="16" font="0">complexity secure GUI. In Proceedings of the 21st Annual Computer Security</text>
<text top="228" left="218" width="338" height="16" font="0">Applications Conference, pages 85–94, 2005.</text>
<text top="275" left="182" width="618" height="16" font="0">[24] Matthew Flatt, Robert Bruce Findler, Shriram Krishnamurthi, and Matthias</text>
<text top="308" left="218" width="582" height="16" font="0">Felleisen. Programming languages as operating systems (or revenge of the</text>
<text top="340" left="218" width="206" height="16" font="0">son of the Lisp machine).</text>
<text top="340" left="440" width="359" height="16" font="0">In Proceedings of the 4th ACM International</text>
<text top="373" left="218" width="581" height="16" font="0">Conference on Functional Programming (ICFP 1999), pages 138–147, 1999.</text>
<text top="420" left="182" width="618" height="16" font="0">[25] Torsten Frenzel. Design and implementation of the L4.sec microkernel for</text>
<text top="453" left="218" width="250" height="16" font="0">shared-memory multiprocessors.</text>
<text top="453" left="486" width="313" height="16" font="0">Diploma Thesis, Dresden University of</text>
<text top="485" left="218" width="197" height="16" font="0">Technology, August 2006.</text>
<text top="533" left="182" width="618" height="16" font="0">[26] Guangrui Fu. Design and Implementation of an Operating System in Stan-</text>
<text top="565" left="218" width="553" height="16" font="0">dard ML. Master’s thesis, University of Hawaii at Manoa, August 1999.</text>
<text top="613" left="182" width="618" height="16" font="0">[27] Michael Furr and Jeﬀrey S. Foster. Checking type safety of foreign func-</text>
<text top="645" left="218" width="582" height="16" font="0">tion calls. In Proceedings of the 2005 ACM SIGPLAN Conference on Pro-</text>
<text top="678" left="218" width="582" height="16" font="0">gramming Language Design and Implementation (PLDI 2005), pages 62–72.</text>
<text top="710" left="218" width="92" height="16" font="0">ACM, 2005.</text>
<text top="758" left="182" width="357" height="16" font="0">[28] Galois website. http://www.galois.com.</text>
<text top="805" left="182" width="618" height="16" font="0">[29] Tal Garﬁnkel, Ben Pfaﬀ, Jim Chow, Mendel Rosenblum, and Dan Boneh.</text>
<text top="838" left="218" width="582" height="16" font="0">Terra: a virtual machine-based platform for trusted computing. In Proceed-</text>
<text top="870" left="218" width="582" height="16" font="0">ings of the 19th ACM Symposium on Operating Systems Principles (SOSP</text>
<text top="903" left="218" width="282" height="16" font="0">2003), pages 193–206, October 2003.</text>
<text top="950" left="182" width="368" height="16" font="0">[30] Genode website. http://www.genode.org.</text>
<text top="998" left="182" width="331" height="16" font="0">[31] GHC website. www.haskell.org/ghc.</text>
</page>
<page number="336" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">314</text>
<text top="163" left="182" width="76" height="16" font="0">[32] GHC</text>
<text top="163" left="277" width="66" height="16" font="0">libraries.</text>
<text top="164" left="393" width="406" height="15" font="0">http://www.haskell.org/ghc/docs/latest/html/</text>
<text top="197" left="218" width="88" height="15" font="0">libraries.</text>
<text top="243" left="182" width="618" height="16" font="0">[33] J. Goguen and J. Meseguer. Unwinding and inference control. In Proceedings</text>
<text top="275" left="218" width="529" height="16" font="0">of the IEEE Symposium on Security and Privacy, pages 75–86, 1984.</text>
<text top="323" left="182" width="618" height="16" font="0">[34] Kenneth Graunke. Extensible scheduling in a Haskell-based operating sys-</text>
<text top="355" left="218" width="413" height="16" font="0">tem. Master’s thesis, Portland State University, 2010.</text>
<text top="403" left="182" width="618" height="16" font="0">[35] Dan Grossman. Quantiﬁed types in an imperative language. ACM Transac-</text>
<text top="435" left="218" width="525" height="16" font="0">tions on Programming Languages and Systems, 28(3):429–475, 2006.</text>
<text top="483" left="182" width="618" height="16" font="0">[36] Dan Grossman, Michael Hicks, Trevor Jim, and Greg Morrisett. Cyclone: a</text>
<text top="515" left="218" width="520" height="16" font="0">type-safe dialect of C. C/C++ Users Journal, 23(1), January 2005.</text>
<text top="563" left="182" width="509" height="16" font="0">[37] GNU GRUB website. http://www.gnu.org/software/grub.</text>
<text top="610" left="182" width="618" height="16" font="0">[38] Andreas Haeberlen and Kevin Elphinstone. User-level management of kernel</text>
<text top="643" left="218" width="582" height="16" font="0">memory. In Proceedings of the Eighth Asia-Paciﬁc Computer Systems Archi-</text>
<text top="675" left="218" width="582" height="16" font="0">tecture Conference (ACSAC’03), Aizu-Wakamatsu City, Japan, September</text>
<text top="708" left="218" width="40" height="16" font="0">2003.</text>
<text top="755" left="182" width="618" height="16" font="0">[39] Thomas Hallgren, Mark P. Jones, Rebekah Leslie, and Andrew Tolmach. A</text>
<text top="788" left="218" width="582" height="16" font="0">principled approach to operating system construction in Haskell. In Olivier</text>
<text top="820" left="218" width="582" height="16" font="0">Danvy and Benjamin C. Pierce, editors, Proceedings of the 10th ACM SIG-</text>
<text top="853" left="218" width="582" height="16" font="0">PLAN International Conference on Functional Programming (ICFP 2005),</text>
<text top="885" left="218" width="299" height="16" font="0">pages 116–128. ACM, September 2005.</text>
<text top="933" left="182" width="370" height="16" font="0">[40] HaLVM website. http://halvm.org/wiki.</text>
<text top="980" left="182" width="618" height="16" font="0">[41] Norm Hardy. The KeyKOS architecture. Operating Systems Review, Septem-</text>
<text top="1012" left="218" width="71" height="16" font="0">ber 1985.</text>
</page>
<page number="337" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">315</text>
<text top="163" left="182" width="618" height="16" font="0">[42] John Harrison. Floating-point veriﬁcation. In John Fitzgerald, Ian J. Hayes,</text>
<text top="195" left="218" width="582" height="16" font="0">and Andrzej Tarlecki, editors, Proceedings of the Formal Methods, Interna-</text>
<text top="228" left="218" width="582" height="16" font="0">tional Symposium of Formal Methods Europe (FM 2005), volume 3582 of</text>
<text top="260" left="218" width="571" height="16" font="0">Lecture Notes in Computer Science, pages 529–532. Springer-Verlag, 2005.</text>
<text top="308" left="182" width="153" height="16" font="0">[43] John Harrison.</text>
<text top="308" left="352" width="209" height="16" font="0">HOL Light: An overview.</text>
<text top="308" left="578" width="221" height="16" font="0">In Stefan Berghofer, Tobias</text>
<text top="340" left="218" width="582" height="16" font="0">Nipkow, Christian Urban, and Makarius Wenzel, editors, Proceedings of the</text>
<text top="373" left="218" width="582" height="16" font="0">22nd International Conference on Theorem Proving in Higher Order Logics,</text>
<text top="405" left="218" width="582" height="16" font="0">TPHOLs 2009, volume 5674 of Lecture Notes in Computer Science, pages</text>
<text top="438" left="218" width="372" height="16" font="0">60–66, Munich, Germany, 2009. Springer-Verlag.</text>
<text top="485" left="182" width="136" height="16" font="0">[44] Hermann H¨</text>
<text top="485" left="308" width="443" height="16" font="0">artig, Michael Hohmuth, Jochen Liedtke, Sebastian Sch¨</text>
<text top="485" left="743" width="57" height="16" font="0">onberg,</text>
<text top="518" left="218" width="582" height="16" font="0">and Jean Wolter. The performance of µkernel-based systems. In Proceedings</text>
<text top="550" left="218" width="582" height="16" font="0">of the Sixteenth ACM Symposium on Operating System Principles (SOSP</text>
<text top="583" left="218" width="196" height="16" font="0">1997), pages 66–77, 1997.</text>
<text top="630" left="182" width="618" height="16" font="0">[45] Chris Hawblitzel and Thorsten von Eicken. Luna: a ﬂexible Java protection</text>
<text top="663" left="218" width="582" height="16" font="0">system. In Proceedings of the 5th Symposium on Operating Systems Design</text>
<text top="695" left="218" width="407" height="16" font="0">and Implementation, OSDI ’02, pages 391–401, 2002.</text>
<text top="743" left="182" width="618" height="16" font="0">[46] Paul Hudak. The Haskell School of Expression: Learning Functional Pro-</text>
<text top="775" left="218" width="550" height="16" font="0">gramming through Multimedia. Cambridge University Press, June 2000.</text>
<text top="823" left="182" width="588" height="16" font="0">[47] Paul Hudak, John Hughes, Simon Peyton Jones, and Philip Wadler.</text>
<text top="823" left="786" width="13" height="16" font="0">A</text>
<text top="855" left="218" width="582" height="16" font="0">history of Haskell: Being lazy with class. In Proceedings of the Third ACM</text>
<text top="888" left="218" width="582" height="16" font="0">SIGPLAN Conference on History of Programming Languages, HOPL III,</text>
<text top="920" left="218" width="186" height="16" font="0">pages 12–1–12–55, 2007.</text>
<text top="968" left="182" width="618" height="16" font="0">[48] Galen C. Hunt and James R. Larus. Singularity: Rethinking the software</text>
<text top="1000" left="218" width="475" height="16" font="0">stack. SIGOPS Operating Systems Review, 41(2):37–49, 2007.</text>
</page>
<page number="338" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">316</text>
<text top="163" left="182" width="618" height="16" font="0">[49] Graham Hutton. Programming in Haskell. Cambridge University Press,</text>
<text top="195" left="218" width="108" height="16" font="0">January 2007.</text>
<text top="240" left="182" width="618" height="16" font="0">[50] Intel Corporation. Statistical analysis of ﬂoating point ﬂaw: Intel white pa-</text>
<text top="273" left="218" width="568" height="16" font="0">per. http://www.intel.com/support/processors/pentium/fdiv, 2004.</text>
<text top="317" left="182" width="180" height="16" font="0">[51] Intel Corporation.</text>
<text top="317" left="383" width="417" height="16" font="0">IA-32 Intel Architecture Software Developer’s Man-</text>
<text top="350" left="218" width="274" height="16" font="0">ual (Volume 3a), January 2006.</text>
<text top="351" left="522" width="277" height="15" font="0">http://www.intel.com/products/</text>
<text top="384" left="218" width="473" height="15" font="0">processor/manuals/index.htm, date viewed: 3 March 2010.</text>
<text top="427" left="182" width="618" height="16" font="0">[52] Intel Corporation. Intel 64 and IA-32 Architectures Software Developer’s</text>
<text top="459" left="218" width="423" height="16" font="0">Manual (Volume 1: Basic Architecture), January 2011.</text>
<text top="504" left="182" width="618" height="16" font="0">[53] Intel Corporation. Intel 64 and IA-32 Architectures Software Developer’s</text>
<text top="536" left="218" width="528" height="16" font="0">Manual (Volume 2B: Instruction Set Reference, N-Z), January 2011.</text>
<text top="581" left="182" width="516" height="16" font="0">[54] Mark P. Jones. A theory of qualiﬁed types. In Bernd Krieg-Br¨</text>
<text top="581" left="689" width="110" height="16" font="0">uckner, editor,</text>
<text top="614" left="218" width="582" height="16" font="0">Proceedings of the 4th European Symposium on Programming (ESOP ’92),</text>
<text top="646" left="218" width="582" height="16" font="0">volume 582 of Lecture Notes in Computer Science, pages 287–306. Springer,</text>
<text top="679" left="218" width="115" height="16" font="0">February 1992.</text>
<text top="723" left="182" width="618" height="16" font="0">[55] Mark P. Jones. A system of constructor classes: Overloading and implicit</text>
<text top="756" left="218" width="582" height="16" font="0">higher-order polymorphism. Journal of Functional Programming, pages 52–</text>
<text top="788" left="218" width="68" height="16" font="0">61, 1995.</text>
<text top="833" left="182" width="618" height="16" font="0">[56] Simon Peyton Jones, Mark Jones, and Erik Meijer. Type classes: An explo-</text>
<text top="865" left="218" width="563" height="16" font="0">ration of the design space. In Proceedings of the Haskell Workshop, 1997.</text>
<text top="910" left="182" width="115" height="16" font="0">[57] Universit¨</text>
<text top="910" left="288" width="184" height="16" font="0">at Karlsruhe. Universit¨</text>
<text top="910" left="462" width="337" height="16" font="0">at Karlsruhe L4 website. http://www.l4ka.</text>
<text top="944" left="218" width="33" height="15" font="0">org.</text>
<text top="987" left="182" width="618" height="16" font="0">[58] Kent Karlsson. Nebula: A functional operating system. Technical report,</text>
<text top="1020" left="218" width="384" height="16" font="0">Programing Methodology Group, University of G¨</text>
<text top="1020" left="592" width="207" height="16" font="0">oteborg and Chalmers Uni-</text>
<text top="1052" left="218" width="212" height="16" font="0">versity of Technology, 1981.</text>
</page>
<page number="339" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">317</text>
<text top="163" left="182" width="169" height="16" font="0">[59] Bernhard Kauer.</text>
<text top="163" left="369" width="430" height="16" font="0">L4.sec implementation - kernel memory management.</text>
<text top="195" left="218" width="478" height="16" font="0">Diploma Thesis, Dresden University of Technology, May 2005.</text>
<text top="242" left="182" width="618" height="16" font="0">[60] Gerwin Klein, Kevin Elphinstone, Gernot Heiser, June Andronick, David</text>
<text top="274" left="218" width="582" height="16" font="0">Cock, Philip Derrin, Dhammika Elkaduwe, Kai Engelhardt, Rafal Kolanski,</text>
<text top="307" left="218" width="582" height="16" font="0">Michael Norrish, Thomas Sewell, Harvey Tuch, and Simon Winwood. seL4:</text>
<text top="339" left="218" width="582" height="16" font="0">Formal veriﬁcation of an OS kernel. In Jeanna Neefe Matthewsand Thomas</text>
<text top="372" left="218" width="582" height="16" font="0">Anderson, editor, Proceedings of the 22nd ACM SIGOPS Symposium on</text>
<text top="404" left="218" width="582" height="16" font="0">Operating Systems Principles (SOSP 2009), pages 207–220, New York, NY,</text>
<text top="437" left="218" width="207" height="16" font="0">USA, October 2009. ACM.</text>
<text top="483" left="182" width="618" height="16" font="0">[61] Greg Kroah-Hartman. Linux Kernel in a Nutshell. O’Reilly &amp; Associates,</text>
<text top="515" left="218" width="495" height="16" font="0">Inc., Cambridge, MA, USA, 2007. http://www.kroah.com/lkn.</text>
<text top="561" left="182" width="581" height="16" font="0">[62] L4ka Team. L4 eXperimental Kernel Reference Manual, January 2005.</text>
<text top="608" left="182" width="158" height="16" font="0">[63] L4Ka::Pistachio</text>
<text top="608" left="356" width="61" height="16" font="0">website.</text>
<text top="609" left="458" width="341" height="15" font="0">http://os.ibds.kit.edu/l4ka/projects/</text>
<text top="642" left="218" width="88" height="15" font="0">pistachio.</text>
<text top="686" left="182" width="618" height="16" font="0">[64] Butler Lampson, Mart´ın Abadi, Michael Burrows, and Edward Wobber. Au-</text>
<text top="719" left="218" width="582" height="16" font="0">thentication in distributed systems: theory and practice. ACM Trans. Com-</text>
<text top="751" left="218" width="240" height="16" font="0">put. Syst., 10(4):265–310, 1992.</text>
<text top="797" left="182" width="618" height="16" font="0">[65] John Launchbury and Simon L Peyton Jones. State in Haskell. Lisp and</text>
<text top="830" left="218" width="390" height="16" font="0">Symbolic Computation, 8:293–341, December 1995.</text>
<text top="876" left="182" width="618" height="16" font="0">[66] Rebekah Leslie. Dynamic intransitive noninterference. In Proceedings of the</text>
<text top="909" left="218" width="582" height="16" font="0">First IEEE International Symposium on Secure Software Engineering, March</text>
<text top="941" left="218" width="40" height="16" font="0">2006.</text>
<text top="987" left="182" width="263" height="16" font="0">[67] Rebekah Leslie, Levent Erk¨</text>
<text top="987" left="436" width="363" height="16" font="0">ok, and Flemming Andersen. Formalizing in-</text>
<text top="1020" left="218" width="582" height="16" font="0">formation ﬂow in a Haskell hypervisor. In Proceedings of the Workshop on</text>
<text top="1052" left="218" width="539" height="16" font="0">Microkernels for Embedded Systems, Sydney, Australia, January 2007.</text>
</page>
<page number="340" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">318</text>
<text top="163" left="182" width="618" height="16" font="0">[68] R. Levin, E. Cohen, W. Corwin, F. Pollack, and W. Wulf. Policy/mechanism</text>
<text top="195" left="218" width="582" height="16" font="0">separation in Hydra. In Proceedings of the Fifth ACM Symposium on Oper-</text>
<text top="228" left="218" width="443" height="16" font="0">ating Systems Principles, SOSP ’75, pages 132–140, 1975.</text>
<text top="275" left="182" width="618" height="16" font="0">[69] Sheng Liang, Paul Hudak, and Mark Jones. Monad transformers and mod-</text>
<text top="308" left="218" width="582" height="16" font="0">ular interpreters. In Proceedings of the 22nd ACM Symposium on Principles</text>
<text top="340" left="218" width="489" height="16" font="0">of Programming Languages (POPL 1995), pages 333–343, 1995.</text>
<text top="388" left="182" width="618" height="16" font="0">[70] Jochen Liedtke. Improving IPC by kernel design. In Proceedings of the</text>
<text top="420" left="218" width="582" height="16" font="0">14th ACM Symposium on Operating System Principles (SOSP 1993), pages</text>
<text top="453" left="218" width="112" height="16" font="0">175–188, 1993.</text>
<text top="500" left="182" width="618" height="16" font="0">[71] Jochen Liedtke. On micro-kernel construction. In Proceedings of the Fifteenth</text>
<text top="533" left="218" width="582" height="16" font="0">ACM Symposium on Operating Systems Principles (SOSP 1995), pages 237–</text>
<text top="565" left="218" width="77" height="16" font="0">250, 1995.</text>
<text top="613" left="182" width="618" height="16" font="0">[72] Jacques-Louis Lions. ARIANE 5, Flight 501 failure, report by the inquiry</text>
<text top="645" left="218" width="95" height="16" font="0">board, 1996.</text>
<text top="693" left="182" width="618" height="16" font="0">[73] Andrew McCreight, Tim Chevalier, and Andrew P. Tolmach. A certiﬁed</text>
<text top="725" left="218" width="582" height="16" font="0">framework for compiling and executing garbage-collected languages. In Paul</text>
<text top="758" left="218" width="582" height="16" font="0">Hudak and Stephanie Weirich, editors, ICFP, pages 273–284. ACM, Septem-</text>
<text top="790" left="218" width="71" height="16" font="0">ber 2010.</text>
<text top="838" left="182" width="618" height="16" font="0">[74] Greg Nelson, editor. Systems Programming with Modula-3. Prentice-Hall,</text>
<text top="870" left="218" width="321" height="16" font="0">Inc., Upper Saddle River, NJ, USA, 1991.</text>
<text top="918" left="182" width="608" height="16" font="0">[75] NICTA. NICTA L4 website. http://ertos.nicta.com.au/research/l4.</text>
<text top="965" left="182" width="618" height="16" font="0">[76] Tobias Nipkow, Lawrence C. Paulson, and Markus Wenzel. Isabelle/HOL—</text>
<text top="998" left="218" width="582" height="16" font="0">A Proof Assistant for Higher-Order Logic, volume 2283 of LNCS. Springer,</text>
<text top="1030" left="218" width="40" height="16" font="0">2002.</text>
</page>
<page number="341" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">319</text>
<text top="163" left="182" width="618" height="16" font="0">[77] Bryan O’Sullivan, John Goerzen, and Don Stewart. Real World Haskell.</text>
<text top="195" left="218" width="298" height="16" font="0">O’Reilly Media, Inc., 1st edition, 2008.</text>
<text top="243" left="182" width="618" height="16" font="0">[78] Simon Peyton Jones, editor. Haskell 98 Language and Libraries, The Revised</text>
<text top="275" left="218" width="328" height="16" font="0">Report. Cambridge University Press, 2003.</text>
<text top="323" left="182" width="618" height="16" font="0">[79] Simon L. Peyton Jones and Philip Wadler. Imperative functional program-</text>
<text top="355" left="218" width="582" height="16" font="0">ming. In Proceedings of the Twentieth Annual ACM SIGPLAN-SIGACT</text>
<text top="388" left="218" width="561" height="16" font="0">Symposium on Principles of Programming Languages, pages 71–84, 1993.</text>
<text top="435" left="182" width="618" height="16" font="0">[80] Sergio Ruocco. User-level ﬁne-grained adaptive real-time scheduling via tem-</text>
<text top="468" left="218" width="582" height="16" font="0">poral reﬂection. In Proceedings of the 27th IEEE Real-Time Systems Sympo-</text>
<text top="500" left="218" width="582" height="16" font="0">sium (RTSS 2006), 5-8 December 2006, Rio de Janeiro, Brazil, pages 246–</text>
<text top="533" left="218" width="159" height="16" font="0">256, December 2006.</text>
<text top="580" left="182" width="618" height="16" font="0">[81] John Rushby. The design and veriﬁcation of secure systems. In Proceedings of</text>
<text top="613" left="218" width="582" height="16" font="0">the Eighth ACM Symposium on Operating System Principles (SOSP 1981),</text>
<text top="645" left="218" width="582" height="16" font="0">pages 12–21, December 1981. (ACM Operating Systems Review , Vol. 15, No.</text>
<text top="678" left="218" width="20" height="16" font="0">5).</text>
<text top="725" left="182" width="618" height="16" font="0">[82] John Rushby. Noninterference, transitivity, and channel-control security poli-</text>
<text top="758" left="218" width="298" height="16" font="0">cies. Technical report, December 1992.</text>
<text top="805" left="182" width="618" height="16" font="0">[83] SANS Institute and MITRE. 2009 CWE/SANS top 25 most dangers pro-</text>
<text top="838" left="218" width="430" height="16" font="0">gramming errors. http://cwe.mitre.org/top25, 2009.</text>
<text top="885" left="182" width="547" height="16" font="0">[84] seL4 website. http://www.ertos.nicta.com.au/research/sel4.</text>
<text top="933" left="182" width="618" height="16" font="0">[85] Jonathan Shapiro, Michael Scott Doerrie, Eric Northup, Swaroop Sridhar,</text>
<text top="965" left="218" width="582" height="16" font="0">and Mark Miller. Towards a veriﬁed, general-purpose operating system ker-</text>
<text top="998" left="218" width="582" height="16" font="0">nel. In Proceedings of the NICTA Workshop on Operating System Veriﬁca-</text>
<text top="1030" left="218" width="242" height="16" font="0">tion, pages 1–19, October 2004.</text>
</page>
<page number="342" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">320</text>
<text top="163" left="182" width="618" height="16" font="0">[86] Jonathan Shapiro, Swaroop Sridhar, and Scott Doerrie. The BitC Language</text>
<text top="195" left="218" width="137" height="16" font="0">Speciﬁction, 2008.</text>
<text top="240" left="182" width="618" height="16" font="0">[87] Jonathan S. Shapiro, Jonathan M. Smith, and David J. Farber. EROS: A fast</text>
<text top="273" left="218" width="582" height="16" font="0">capability system. In Proceedings of the 17th ACM Symposium on Operating</text>
<text top="305" left="218" width="412" height="16" font="0">Systems Principles, SOSP 1999, pages 170–185, 1999.</text>
<text top="350" left="182" width="618" height="16" font="0">[88] Jonathan S. Shapiro and Samuel Weber. Verifying the EROS conﬁnement</text>
<text top="382" left="218" width="582" height="16" font="0">mechanism. In Proceedings of the IEEE Symposium on Security and Privacy,</text>
<text top="415" left="218" width="40" height="16" font="0">2000.</text>
<text top="459" left="182" width="618" height="16" font="0">[89] W. Stoye. Message-based functional operating systems. Science of Computer</text>
<text top="492" left="218" width="278" height="16" font="0">Programming, 6:291–311, May 1986.</text>
<text top="536" left="182" width="618" height="16" font="0">[90] The High Assurance Systems Programming Team. The Habit Programming</text>
<text top="569" left="218" width="465" height="16" font="0">Language: The Revised Preliminary Report, November 2010.</text>
<text top="614" left="182" width="176" height="16" font="0">[91] The GHC Team.</text>
<text top="614" left="382" width="417" height="16" font="0">The Glorious Glasgow Haskell Compilation System</text>
<text top="646" left="218" width="582" height="16" font="0">User’s Guide, Version 7.0.2, 2011. http://www.haskell.org/ghc/docs/</text>
<text top="680" left="218" width="246" height="15" font="0">7.0-latest/users_guide.pdf.</text>
<text top="723" left="182" width="431" height="16" font="0">[92] VirtualBox website. http://www.virtualbox.org.</text>
<text top="768" left="182" width="618" height="16" font="0">[93] David von Oheimb. Information ﬂow control revisited: Noninﬂuence = Non-</text>
<text top="800" left="218" width="582" height="16" font="0">interference + Nonleakage. In Proceedings of the European Symposium on</text>
<text top="833" left="218" width="582" height="16" font="0">Research in Computer Security (ESORICS 2004), volume 3193 of LNCS,</text>
<text top="865" left="218" width="235" height="16" font="0">pages 225–243. Springer, 2004.</text>
<text top="910" left="182" width="618" height="16" font="0">[94] Philip Wadler. Comprehending monads. In Mathematical Structures in Com-</text>
<text top="943" left="218" width="256" height="16" font="0">puter Science, pages 61–78, 1992.</text>
<text top="987" left="182" width="618" height="16" font="0">[95] Philip Wadler. The essence of functional programming. In Ravi Sethi, editor,</text>
<text top="1020" left="218" width="582" height="16" font="0">Proceedings of the 19th ACM SIGPLAN-SIGACT Symposium on Principles</text>
<text top="1052" left="218" width="515" height="16" font="0">of Programming Languages (POPL 1992), pages 1–14. ACM, 1992.</text>
</page>
<page number="343" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="729" width="26" height="16" font="0">321</text>
<text top="163" left="182" width="618" height="16" font="0">[96] Philip Wadler and Stephen Blott. How to make ad-hoc polymorphism less</text>
<text top="195" left="218" width="582" height="16" font="0">ad-hoc. In Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on</text>
<text top="228" left="218" width="555" height="16" font="0">Principles of Programming Languages (POPL 1989), pages 60–76, 1989.</text>
<text top="275" left="182" width="618" height="16" font="0">[97] Malcolm Wallace and Colin Runciman. Extending a functional program-</text>
<text top="308" left="218" width="582" height="16" font="0">ming system for embedded applications. Software Practice and Experiences,</text>
<text top="340" left="218" width="139" height="16" font="0">25(1):73–96, 1995.</text>
<text top="388" left="182" width="618" height="16" font="0">[98] Malcolm Wallace and Colin Runciman. Lambdas in the liftshaft—functional</text>
<text top="420" left="218" width="582" height="16" font="0">programming and an embedded architecture. In Proceedings of the Seventh</text>
<text top="453" left="218" width="582" height="16" font="0">International Conference on Functional Programming Languages and Com-</text>
<text top="485" left="218" width="473" height="16" font="0">puter Architecture (FPCA 1995), pages 249–258. ACM, 1995.</text>
<text top="533" left="182" width="618" height="16" font="0">[99] Adam Wick and Matthew Flatt. Memory accounting without partitions.</text>
<text top="565" left="218" width="582" height="16" font="0">In Proceedings of the 4th International Symposium on Memory Management</text>
<text top="598" left="218" width="328" height="16" font="0">(ISMM 2004), pages 120–130. ACM, 2004.</text>
<text top="645" left="173" width="626" height="16" font="0">[100] Jean Yang and Chris Hawblitzel. Safe to the last instruction: automated ver-</text>
<text top="678" left="218" width="582" height="16" font="0">iﬁcation of a type-safe operating system. In Benjamin G. Zorn and Alexander</text>
<text top="710" left="218" width="582" height="16" font="0">Aiken, editors, Proceedings of the 2010 ACM SIGPLAN Conference on Pro-</text>
<text top="743" left="218" width="582" height="16" font="0">gramming Language Design and Implementation (PLDI 2010), pages 99–110.</text>
<text top="775" left="218" width="134" height="16" font="0">ACM, June 2010.</text>
</page>
</pdf2xml>
