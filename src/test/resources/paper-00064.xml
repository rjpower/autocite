<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="23" family="Times" color="#000000"/>
	<fontspec id="1" size="15" family="Times" color="#000000"/>
	<fontspec id="2" size="12" family="Times" color="#000000"/>
<text top="439" left="215" width="445" height="23" font="0">Lecture Notes on Language-Based Security</text>
<text top="510" left="403" width="69" height="16" font="1">Erik Poll</text>
<text top="531" left="321" width="232" height="16" font="1">Radboud University Nijmegen</text>
<text top="574" left="365" width="145" height="16" font="1">December 20, 2011</text>
<text top="798" left="205" width="465" height="13" font="2">These lecture notes discuss language-based security, which is the term</text>
<text top="816" left="205" width="465" height="13" font="2">loosely used for the collection of features and mechanisms that a pro-</text>
<text top="834" left="205" width="465" height="13" font="2">gramming language can provide to help in building secure applications.</text>
<text top="858" left="205" width="465" height="13" font="2">These features include: memory-safety and typing, as oﬀered by so-</text>
<text top="875" left="205" width="465" height="13" font="2">called safe programming languages; language mechanisms to enforce</text>
<text top="893" left="205" width="465" height="13" font="2">various forms of access control (such as sandboxing), similar to access</text>
<text top="911" left="205" width="465" height="13" font="2">control traditionally oﬀered by operating systems; mechanisms that go</text>
<text top="929" left="205" width="465" height="13" font="2">beyond what typical operating systems do, such as information ﬂow</text>
<text top="947" left="205" width="48" height="13" font="2">control.</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="3" size="35" family="Times" color="#000000"/>
<text top="272" left="167" width="163" height="33" font="3">Contents</text>
<text top="380" left="167" width="9" height="13" font="2">1</text>
<text top="380" left="190" width="95" height="13" font="2">Introduction</text>
<text top="380" left="699" width="9" height="13" font="2">3</text>
<text top="413" left="167" width="9" height="13" font="2">2</text>
<text top="413" left="190" width="246" height="13" font="2">Operating system based security</text>
<text top="413" left="699" width="9" height="13" font="2">6</text>
<text top="431" left="190" width="19" height="13" font="2">2.1</text>
<text top="431" left="224" width="451" height="13" font="2">Operating system abstractions and access control . . . . . . . . . . .</text>
<text top="431" left="700" width="7" height="13" font="2">6</text>
<text top="449" left="190" width="19" height="13" font="2">2.2</text>
<text top="449" left="224" width="451" height="13" font="2">Imperfections in abstractions . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="449" left="700" width="7" height="13" font="2">9</text>
<text top="467" left="190" width="19" height="13" font="2">2.3</text>
<text top="467" left="224" width="451" height="13" font="2">What goes wrong . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="467" left="700" width="7" height="13" font="2">9</text>
<text top="500" left="167" width="9" height="13" font="2">3</text>
<text top="500" left="190" width="216" height="13" font="2">Safe programming languages</text>
<text top="500" left="690" width="17" height="13" font="2">11</text>
<text top="518" left="190" width="19" height="13" font="2">3.1</text>
<text top="518" left="224" width="451" height="13" font="2">Safety &amp; (un)deﬁnedness . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="518" left="692" width="15" height="13" font="2">12</text>
<text top="535" left="224" width="31" height="13" font="2">3.1.1</text>
<text top="535" left="272" width="403" height="13" font="2">Safety and security . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="535" left="692" width="15" height="13" font="2">13</text>
<text top="553" left="190" width="19" height="13" font="2">3.2</text>
<text top="553" left="224" width="451" height="13" font="2">Memory safety . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="553" left="692" width="15" height="13" font="2">13</text>
<text top="571" left="224" width="31" height="13" font="2">3.2.1</text>
<text top="571" left="272" width="403" height="13" font="2">Stronger notions of memory safety . . . . . . . . . . . . . . .</text>
<text top="571" left="692" width="15" height="13" font="2">14</text>
<text top="589" left="190" width="19" height="13" font="2">3.3</text>
<text top="589" left="224" width="451" height="13" font="2">Type safety . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="589" left="692" width="15" height="13" font="2">14</text>
<text top="607" left="224" width="31" height="13" font="2">3.3.1</text>
<text top="607" left="272" width="403" height="13" font="2">Expressivity . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="607" left="692" width="15" height="13" font="2">15</text>
<text top="625" left="224" width="31" height="13" font="2">3.3.2</text>
<text top="625" left="272" width="403" height="13" font="2">Breaking type safety . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="625" left="692" width="15" height="13" font="2">15</text>
<text top="643" left="224" width="31" height="13" font="2">3.3.3</text>
<text top="643" left="272" width="403" height="13" font="2">Ensuring type safety . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="643" left="692" width="15" height="13" font="2">16</text>
<text top="661" left="190" width="19" height="13" font="2">3.4</text>
<text top="661" left="224" width="451" height="13" font="2">Other notions of safety . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="661" left="692" width="15" height="13" font="2">17</text>
<text top="679" left="224" width="31" height="13" font="2">3.4.1</text>
<text top="679" left="272" width="403" height="13" font="2">Safety concerns in low-level languages . . . . . . . . . . . . .</text>
<text top="679" left="692" width="15" height="13" font="2">17</text>
<text top="697" left="224" width="31" height="13" font="2">3.4.2</text>
<text top="697" left="272" width="403" height="13" font="2">Safe arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="697" left="692" width="15" height="13" font="2">17</text>
<text top="715" left="224" width="31" height="13" font="2">3.4.3</text>
<text top="715" left="272" width="403" height="13" font="2">Thread safety . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="715" left="692" width="15" height="13" font="2">18</text>
<text top="733" left="190" width="19" height="13" font="2">3.5</text>
<text top="733" left="224" width="451" height="13" font="2">Other language-level guarantees . . . . . . . . . . . . . . . . . . . . .</text>
<text top="733" left="692" width="15" height="13" font="2">19</text>
<text top="751" left="224" width="31" height="13" font="2">3.5.1</text>
<text top="751" left="272" width="59" height="13" font="2">Visibility</text>
<text top="751" left="345" width="330" height="13" font="2">. . . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="751" left="692" width="15" height="13" font="2">19</text>
<text top="769" left="224" width="31" height="13" font="2">3.5.2</text>
<text top="769" left="272" width="403" height="13" font="2">Constant values and immutable data structures . . . . . . . .</text>
<text top="769" left="692" width="15" height="13" font="2">20</text>
<text top="801" left="167" width="9" height="13" font="2">4</text>
<text top="801" left="190" width="228" height="13" font="2">Language-based access control</text>
<text top="801" left="690" width="17" height="13" font="2">22</text>
<text top="819" left="190" width="19" height="13" font="2">4.1</text>
<text top="819" left="224" width="129" height="13" font="2">Language platforms</text>
<text top="819" left="369" width="306" height="13" font="2">. . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="819" left="692" width="15" height="13" font="2">22</text>
<text top="837" left="190" width="19" height="13" font="2">4.2</text>
<text top="837" left="224" width="451" height="13" font="2">Why to do language-based access control? . . . . . . . . . . . . . . .</text>
<text top="837" left="692" width="15" height="13" font="2">23</text>
<text top="855" left="190" width="19" height="13" font="2">4.3</text>
<text top="855" left="224" width="270" height="13" font="2">Language-based access control and safety</text>
<text top="855" left="508" width="167" height="13" font="2">. . . . . . . . . . . . . . .</text>
<text top="855" left="692" width="15" height="13" font="2">24</text>
<text top="873" left="190" width="19" height="13" font="2">4.4</text>
<text top="873" left="224" width="451" height="13" font="2">How to do language-based access control? . . . . . . . . . . . . . . .</text>
<text top="873" left="692" width="15" height="13" font="2">25</text>
<text top="891" left="224" width="31" height="13" font="2">4.4.1</text>
<text top="891" left="272" width="403" height="13" font="2">Stack walking . . . . . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="891" left="692" width="15" height="13" font="2">26</text>
<text top="924" left="167" width="9" height="13" font="2">5</text>
<text top="924" left="190" width="125" height="13" font="2">Information ﬂow</text>
<text top="924" left="690" width="17" height="13" font="2">32</text>
<text top="942" left="190" width="19" height="13" font="2">5.1</text>
<text top="942" left="224" width="199" height="13" font="2">Principles for information ﬂow</text>
<text top="942" left="438" width="237" height="13" font="2">. . . . . . . . . . . . . . . . . . . . .</text>
<text top="942" left="692" width="15" height="13" font="2">33</text>
<text top="960" left="224" width="31" height="13" font="2">5.1.1</text>
<text top="960" left="272" width="403" height="13" font="2">Implicit and explicit ﬂows . . . . . . . . . . . . . . . . . . . .</text>
<text top="960" left="692" width="15" height="13" font="2">34</text>
<text top="978" left="190" width="19" height="13" font="2">5.2</text>
<text top="978" left="224" width="451" height="13" font="2">Information ﬂow in practice . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="978" left="692" width="15" height="13" font="2">36</text>
<text top="996" left="190" width="19" height="13" font="2">5.3</text>
<text top="996" left="224" width="451" height="13" font="2">Typing for information ﬂow . . . . . . . . . . . . . . . . . . . . . . .</text>
<text top="996" left="692" width="15" height="13" font="2">37</text>
<text top="1163" left="434" width="7" height="13" font="2">2</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="4" size="28" family="Times" color="#000000"/>
<text top="269" left="167" width="154" height="28" font="4">Chapter 1</text>
<text top="339" left="167" width="230" height="33" font="3">Introduction</text>
<text top="432" left="167" width="540" height="13" font="2">Software – or rather defects in software – is at the root of many security problems</text>
<text top="450" left="167" width="540" height="13" font="2">in ICT systems. Indeed, with the possible exception of the human factor, software</text>
<text top="468" left="167" width="540" height="13" font="2">is the most important cause of security problems. The malware (worms, viruses,</text>
<text top="486" left="167" width="540" height="13" font="2">etc.) that plagues our computers often exploits defects or ‘features’ in the software</text>
<text top="504" left="167" width="274" height="13" font="2">that turn out to have nasty consequences.</text>
<text top="522" left="190" width="518" height="13" font="2">Software with security vulnerabilities can be written in any programming lan-</text>
<text top="540" left="167" width="540" height="13" font="2">guage. Still, the programming language can make a diﬀerence here, by the language</text>
<text top="558" left="167" width="540" height="13" font="2">features it provides (or omits), and by the programmer support it oﬀers for these,</text>
<text top="576" left="167" width="540" height="13" font="2">in the form of compilers, type checkers, run-time execution engines (like the Java</text>
<text top="594" left="167" width="540" height="13" font="2">Virtual Machine), etc. All this allows programmers to express certain desired and</text>
<text top="612" left="167" width="540" height="13" font="2">security-relevant properties which are then enforced or guaranteed by the language.</text>
<text top="630" left="167" width="303" height="13" font="2">This is what language-based security is about.</text>
<text top="657" left="190" width="518" height="13" font="2">The prime example of how programming language features can be a major source</text>
<text top="674" left="167" width="540" height="13" font="2">of security vulnerabilities is of course the buﬀer overﬂow: this common security</text>
<text top="692" left="167" width="540" height="13" font="2">vulnerability can only arise in a few programming languages, which unfortunately</text>
<text top="710" left="167" width="540" height="13" font="2">includes some of the most popular ones, namely C and C++. There are many</text>
<text top="728" left="167" width="540" height="13" font="2">other examples of standard security vulnerabilities (see the discussion below) and</text>
<text top="746" left="167" width="540" height="13" font="2">programming languages may be more or less susceptible – or, in the best case,</text>
<text top="764" left="167" width="125" height="13" font="2">immune – to them.</text>
<text top="782" left="190" width="518" height="13" font="2">Type checking is the most familiar and widely accepted form of program anal-</text>
<text top="800" left="167" width="540" height="13" font="2">ysis for typed programming languages whose type system is an integral part of the</text>
<text top="818" left="167" width="540" height="13" font="2">language deﬁnition. Beyond type checking there can be additional forms of pro-</text>
<text top="836" left="167" width="540" height="13" font="2">gram analysis that can detect certain categories of security vulnerabilities, or check</text>
<text top="854" left="167" width="540" height="13" font="2">compliance with some security policies. Such analyses are for instance performed</text>
<text top="872" left="167" width="540" height="13" font="2">by source code analyzers aka static analysis tools. Depending on the programming</text>
<text top="890" left="167" width="540" height="13" font="2">language, but also the kind of application, such tools may try to look for diﬀerent</text>
<text top="908" left="167" width="540" height="13" font="2">types of security problems. Some programming languages will be easier to anal-</text>
<text top="926" left="167" width="540" height="13" font="2">yse than others. A more extreme form of program analysis beyond type checking is</text>
<text top="943" left="167" width="540" height="13" font="2">proof-carrying code, where mathematical proofs are used to guarantee properties</text>
<text top="961" left="167" width="410" height="13" font="2">of program code, which can include very expressive properties.</text>
<text top="979" left="190" width="518" height="13" font="2">Some program analyses do not oﬀer mechanisms to enforce security, but rather</text>
<text top="997" left="167" width="540" height="13" font="2">mechanisms to provide assurance that some security requirements are met, or that</text>
<text top="1015" left="167" width="540" height="13" font="2">certain types of vulnerabilities are not present, where the level of assurance can</text>
<text top="1033" left="167" width="31" height="13" font="2">vary.</text>
<text top="1051" left="190" width="518" height="13" font="2">Programming languages also diﬀer in the features and building blocks for imple-</text>
<text top="1069" left="167" width="540" height="13" font="2">menting security functionality, such as APIs or language features for access control,</text>
<text top="1087" left="167" width="540" height="13" font="2">cryptography, etc. Sandboxing, as used in Java to control the access of untrusted</text>
<text top="1105" left="167" width="540" height="13" font="2">mobile code (e.g., applets in web browsers), is the best-know example of a pro-</text>
<text top="1163" left="434" width="7" height="13" font="2">3</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="5" size="8" family="Times" color="#000000"/>
<text top="168" left="167" width="540" height="13" font="2">gramming language mechanism speciﬁcally included to provide support for security.</text>
<text top="186" left="167" width="540" height="13" font="2">However, don’t make the mistake of thinking that software security is just about</text>
<text top="204" left="167" width="332" height="13" font="2">correctly implementing such security functionality!</text>
<text top="231" left="190" width="518" height="13" font="2">In these lecture notes, we ﬁrst look in chapter 2 at security mechanisms pro-</text>
<text top="249" left="167" width="540" height="13" font="2">vided by the operating system, such as separation of processes and access control.</text>
<text top="266" left="167" width="540" height="13" font="2">In chapter 3 we look at how ’safe’ programming languages can support writing</text>
<text top="284" left="167" width="540" height="13" font="2">secure programs. Safe programming languages provide some guarantees about the</text>
<text top="302" left="167" width="540" height="13" font="2">behaviour of programs, which makes it possible to reason about security and to</text>
<text top="320" left="167" width="540" height="13" font="2">protect against unwanted behaviour that may lead to security vulnerabilities. In</text>
<text top="338" left="167" width="540" height="13" font="2">chapter 4 we study language-based access control, where the language provides a</text>
<text top="356" left="167" width="540" height="13" font="2">sandboxing mechanism to provide more ﬁne-grained access control in which diﬀer-</text>
<text top="374" left="167" width="540" height="13" font="2">ent parts of a program can be subject to diﬀerent security policies. In chapter 5 we</text>
<text top="392" left="167" width="540" height="13" font="2">explore information ﬂow, which allows even more ﬁne-grained access control. In-</text>
<text top="410" left="167" width="540" height="13" font="2">formation ﬂow takes into account where data comes from, what actions are allowed</text>
<text top="428" left="167" width="324" height="13" font="2">with it, and where this data is allowed to ﬂow to.</text>
<text top="482" left="167" width="132" height="13" font="2">Bugs versus ﬂaws</text>
<text top="500" left="167" width="540" height="13" font="2">When discussing security vulnerabilities in software it is common to distinguish</text>
<text top="517" left="167" width="540" height="13" font="2">bugs and ﬂaws. Bugs, also called coding defects, are low-level implementation</text>
<text top="535" left="167" width="540" height="13" font="2">defects in the code – eﬀectively, mistakes introduced by the programmer who wrote</text>
<text top="553" left="167" width="540" height="13" font="2">the code. Flaws are more fundamental problems, that are not due to a defect in</text>
<text top="571" left="167" width="540" height="13" font="2">the code, but which already exist in the design of a system. In practice, it may be</text>
<text top="589" left="167" width="540" height="13" font="2">hard to draw a precise border between these categories. For example, broken access</text>
<text top="607" left="167" width="540" height="13" font="2">control in an implementation may be due to a simple programming bug, resulting</text>
<text top="625" left="167" width="540" height="13" font="2">in an access control check that is incorrect or missing completely. However, the</text>
<text top="643" left="167" width="540" height="13" font="2">way access control is organised in an application – and maybe supported by the</text>
<text top="661" left="167" width="540" height="13" font="2">programming language – can make such bugs more or less likely; e.g., having access</text>
<text top="679" left="167" width="540" height="13" font="2">control decisions scattered throughout the code in an ad-hoc matter makes problems</text>
<text top="697" left="167" width="540" height="13" font="2">much more likely. Finally, access control problems can already be introduced at a</text>
<text top="715" left="167" width="540" height="13" font="2">very high design level, notably by completely overlooking the need for any access</text>
<text top="733" left="167" width="49" height="13" font="2">control.</text>
<text top="803" left="167" width="332" height="13" font="2">Common security vulnerabilities in software</text>
<text top="821" left="167" width="536" height="13" font="2">There are various lists of common security vulnerabilities in software, for example</text>
<text top="850" left="190" width="428" height="14" font="2">• OWASP TOP 10 of most critical web application security risks</text>
<text top="848" left="618" width="6" height="9" font="5">1</text>
<text top="851" left="625" width="4" height="13" font="2">,</text>
<text top="880" left="190" width="413" height="14" font="2">• the book ‘The 24 Deadly Sins of Software Security’ [HLV09],</text>
<text top="910" left="190" width="400" height="14" font="2">• the CWE/SANS TOP 25 Most Dangerous Software Errors</text>
<text top="908" left="590" width="6" height="9" font="5">2</text>
<text top="910" left="596" width="4" height="13" font="2">.</text>
<text top="940" left="167" width="540" height="13" font="2">These lists tend to concentrate on various types of bugs (e.g., buﬀer overﬂows, SQL</text>
<text top="958" left="167" width="540" height="13" font="2">injection, Cross-site scripting), but also include more fundamental ﬂaws (e.g., bro-</text>
<text top="976" left="167" width="540" height="13" font="2">ken access control). Checklists like the ones above are very useful, but don’t ever</text>
<text top="994" left="167" width="540" height="13" font="2">be tempted into thinking that they cover everything that can go wrong. (E.g.,</text>
<text top="1012" left="167" width="514" height="13" font="2">CWE/SANS distinguishes over 700 types of weaknesses in their classiﬁcation.)</text>
<text top="1037" left="167" width="6" height="9" font="5">1</text>
<text top="1040" left="174" width="486" height="12" font="2">https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project</text>
<text top="1055" left="167" width="6" height="9" font="5">2</text>
<text top="1058" left="174" width="533" height="12" font="2">http://www.sans.org/top25-software-errors and http://cwe.mitre.org/</text>
<text top="1076" left="167" width="39" height="12" font="2">top25</text>
<text top="1163" left="434" width="7" height="13" font="2">4</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
<text top="174" left="167" width="368" height="13" font="2">Secure functionality versus security functionality</text>
<text top="192" left="167" width="540" height="13" font="2">Note there is a diﬀerence between secure functionality and security functionality.</text>
<text top="210" left="167" width="540" height="13" font="2">The security functionality of an application concerns security related features such</text>
<text top="228" left="167" width="540" height="13" font="2">as access control, authentication, logging, possibly use of cryptography, etc. But</text>
<text top="245" left="167" width="540" height="13" font="2">any functionality an application provides may contain security vulnerabilities that</text>
<text top="263" left="167" width="540" height="13" font="2">an attacker can exploit: so not only does the security functionality need to be</text>
<text top="281" left="167" width="341" height="13" font="2">correct, but all the functionality needs to be secure.</text>
<text top="299" left="190" width="518" height="13" font="2">In the end, security should be understood as an emergent property of the code</text>
<text top="317" left="167" width="540" height="13" font="2">as a whole, and not as some collection of features. Beware of anyone that claims the</text>
<text top="335" left="167" width="540" height="13" font="2">code is secure ‘because’ it uses encryption, ‘because’ it is written in programming</text>
<text top="353" left="167" width="404" height="13" font="2">language X, or ‘because’ it uses role-based access control, etc.</text>
<text top="1163" left="434" width="7" height="13" font="2">5</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="6" size="19" family="Times" color="#000000"/>
<text top="269" left="167" width="154" height="28" font="4">Chapter 2</text>
<text top="339" left="167" width="440" height="33" font="3">Operating system based</text>
<text top="384" left="167" width="143" height="33" font="3">security</text>
<text top="477" left="167" width="540" height="13" font="2">Before we consider what role the programming language can play in providing se-</text>
<text top="495" left="167" width="540" height="13" font="2">curity, it is useful to take a step back and consider the role an operating system</text>
<text top="513" left="167" width="378" height="13" font="2">(OS) traditionally plays in providing security, and look at</text>
<text top="542" left="190" width="518" height="14" font="2">• the security mechanisms that operating systems traditionally provide, through</text>
<text top="561" left="205" width="304" height="13" font="2">separation and various forms of access control;</text>
<text top="590" left="190" width="275" height="14" font="2">• what the basis for this access control is;</text>
<text top="620" left="190" width="250" height="14" font="2">• the role that abstractions play here.</text>
<text top="666" left="167" width="31" height="19" font="6">2.1</text>
<text top="666" left="223" width="485" height="19" font="6">Operating system abstractions and access con-</text>
<text top="692" left="223" width="38" height="19" font="6">trol</text>
<text top="730" left="167" width="540" height="13" font="2">The operating system provides an interface between the hardware and programs</text>
<text top="748" left="167" width="540" height="13" font="2">executing on this hardware, and also an interface to the human user (see ﬁgure 2.1).</text>
<text top="766" left="167" width="540" height="13" font="2">Here the hardware includes the CPU and the memory, plus a range of other I/O</text>
<text top="784" left="167" width="540" height="13" font="2">devices, typically including a hard disk, a keyboard, a display, and a network con-</text>
<text top="801" left="167" width="51" height="13" font="2">nection.</text>
<text top="819" left="190" width="518" height="13" font="2">The operating system provides useful abstractions to hide a lot of the under-</text>
<text top="837" left="167" width="540" height="13" font="2">lying complexity. For example, the operating system uses segmentation and page</text>
<text top="855" left="167" width="540" height="13" font="2">tables to provide virtual memory, and programs can then use a virtual address</text>
<text top="873" left="167" width="540" height="13" font="2">space for storing data without having to worry about where in memory or where</text>
<text top="891" left="167" width="540" height="13" font="2">on the hard disk the data actually resides (see ﬁgure 2.2). Another example is that</text>
<text top="909" left="167" width="540" height="13" font="2">the operating system provides a ﬁle system to programs and users, which hides the</text>
<text top="927" left="167" width="462" height="13" font="2">details of how the ﬁles are stored over various sectors of the hard disk.</text>
<text top="945" left="190" width="518" height="13" font="2">The central abstraction that the operating system provides is that of a process.</text>
<text top="963" left="167" width="540" height="13" font="2">Each program in execution gives rise to a process, and the operating system tries to</text>
<text top="981" left="167" width="540" height="13" font="2">create the illusion that this process has exclusive access to the CPU (through time</text>
<text top="999" left="167" width="540" height="13" font="2">slicing) and to the computer’s memory, and typically to far more memory than is</text>
<text top="1017" left="167" width="426" height="13" font="2">physically available as RAM (through segmentation and paging).</text>
<text top="1035" left="190" width="518" height="13" font="2">As part of this abstraction, the operating system tries to ensure separation</text>
<text top="1053" left="167" width="540" height="13" font="2">between the diﬀerent processes, so that programs cannot interfere with each other.</text>
<text top="1070" left="167" width="540" height="13" font="2">The prime example here is that processes have their own address space that</text>
<text top="1088" left="167" width="540" height="13" font="2">others cannot touch, which is obviously crucial for security. A process that tries to</text>
<text top="1106" left="167" width="540" height="13" font="2">access memory outside its address space will crash with a so-called segmentation</text>
<text top="1163" left="434" width="7" height="13" font="2">6</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="7" size="11" family="Times" color="#ffffff"/>
	<fontspec id="8" size="8" family="Times" color="#ffffff"/>
	<fontspec id="9" size="11" family="Times" color="#000000"/>
	<fontspec id="10" size="9" family="Times" color="#000000"/>
	<fontspec id="11" size="8" family="Times" color="#000000"/>
	<fontspec id="12" size="7" family="Times" color="#000000"/>
	<fontspec id="13" size="7" family="Times" color="#000000"/>
<text top="459" left="290" width="57" height="15" font="7">Hardware</text>
<text top="461" left="346" width="156" height="12" font="8"> (CPU, memory, I/O peripherals)</text>
<text top="344" left="366" width="51" height="15" font="9">Software</text>
<text top="420" left="342" width="104" height="15" font="9">Operating System</text>
<text top="383" left="355" width="136" height="15" font="9">Programming language</text>
<text top="564" left="242" width="391" height="13" font="2">Figure 2.1: The infrastructure on which programs are built.</text>
<text top="776" left="194" width="123" height="13" font="10">programming language</text>
<text top="849" left="194" width="91" height="13" font="10">operating system</text>
<text top="923" left="194" width="160" height="13" font="10">hardware                                 </text>
<text top="762" left="372" width="157" height="12" font="11"><b>“Hello World”      false</b></text>
<text top="777" left="375" width="150" height="12" font="11"><b>      1.0e-6           </b></text>
<text top="835" left="358" width="189" height="13" font="12"><b>22 48 65 6C 6C ... 22 00            FF</b></text>
<text top="849" left="416" width="73" height="15" font="5">        ...            </text>
<text top="918" left="501" width="35" height="13" font="12"><b>65 6C</b></text>
<text top="955" left="524" width="35" height="13" font="12"><b>22 00</b></text>
<text top="948" left="391" width="36" height="13" font="12"><b>22 48</b></text>
<text top="879" left="320" width="24" height="11" font="13">page </text>
<text top="893" left="322" width="21" height="11" font="13">table</text>
<text top="984" left="376" width="25" height="12" font="11"><b>RAM</b></text>
<text top="987" left="511" width="22" height="12" font="11"><b>disk</b></text>
<text top="1043" left="167" width="540" height="13" font="2">Figure 2.2: The diﬀerent abstraction layers provided by programming language and</text>
<text top="1061" left="167" width="116" height="13" font="2">operating system.</text>
<text top="1163" left="434" width="7" height="13" font="2">7</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="14" size="6" family="Times" color="#000000"/>
<text top="405" left="290" width="57" height="15" font="7">Hardware</text>
<text top="407" left="346" width="156" height="12" font="8"> (CPU, memory, I/O peripherals)</text>
<text top="300" left="286" width="58" height="15" font="9">process A</text>
<text top="372" left="344" width="104" height="15" font="9">Operating System</text>
<text top="298" left="434" width="58" height="15" font="9">process B</text>
<text top="510" left="167" width="540" height="13" font="2">Figure 2.3: Classical operating system security controls: separation between pro-</text>
<text top="527" left="167" width="296" height="13" font="2">cesses and access control of system resources.</text>
<text top="575" left="167" width="540" height="13" font="2">fault. This way the operating system provides some encapsulation of processes.</text>
<text top="593" left="167" width="540" height="13" font="2">Processes can still interfere with each other when competing for the shared resources</text>
<text top="611" left="167" width="540" height="13" font="2">of the computer: e.g., a program that claims a lot of memory or a lot of CPU time</text>
<text top="629" left="167" width="422" height="13" font="2">could interfere with the progress that another process can make.</text>
<text top="647" left="190" width="518" height="13" font="2">The operating system also provides security by enforcing access control for</text>
<text top="665" left="167" width="248" height="13" font="2">many of the abstractions it introduces</text>
<text top="663" left="415" width="6" height="9" font="5">1</text>
<text top="665" left="422" width="285" height="13" font="2">. The prime example here is the ﬁle system,</text>
<text top="683" left="167" width="540" height="13" font="2">where diﬀerent users – and the programs they start – have diﬀerent access rights</text>
<text top="701" left="167" width="540" height="13" font="2">for reading or writing certain ﬁles. Traditionally, access control provided by the</text>
<text top="719" left="167" width="540" height="13" font="2">operating system is organised by user and by process, where processes typically</text>
<text top="737" left="167" width="540" height="13" font="2">inherit the access rights of the user that started them, although modern operating</text>
<text top="755" left="167" width="280" height="13" font="2">systems will oﬀer some ways to tweak this.</text>
<text top="772" left="190" width="411" height="13" font="2">Figure 2.3 illustrates the security mechanisms discussed above.</text>
<text top="790" left="190" width="518" height="13" font="2">The abstractions provided by the operating system play a crucial role in any</text>
<text top="808" left="167" width="540" height="13" font="2">access control for them: if someone gets access to the raw bits on the hard drive,</text>
<text top="826" left="167" width="540" height="13" font="2">any access control provided by the ﬁle system is gone. Access to the data that</text>
<text top="844" left="167" width="540" height="13" font="2">is used to provide these abstractions needs to be tightly controlled: if someone</text>
<text top="862" left="167" width="540" height="13" font="2">can modify page tables, all guarantees about memory separation between processes</text>
<text top="880" left="167" width="540" height="13" font="2">by the operating system can be broken. This means that the code responsible</text>
<text top="898" left="167" width="540" height="13" font="2">for creating and maintaining these abstractions has a special responsibility when</text>
<text top="916" left="167" width="540" height="13" font="2">it comes to security. Such code needs special privileges, to get low-level access</text>
<text top="934" left="167" width="540" height="13" font="2">that other code does not have. Any bugs in this code can lead to serious security</text>
<text top="952" left="167" width="540" height="13" font="2">vulnerabilities; this code has to be trusted, and hopefully it is trustworthy. This has</text>
<text top="970" left="167" width="540" height="13" font="2">led to the distinction between user mode and kernel mode, which most operating</text>
<text top="988" left="167" width="540" height="13" font="2">systems provide. Part of the code that belongs to the operating system is executed in</text>
<text top="1006" left="167" width="540" height="13" font="2">kernel mode, giving it complete and unrestricted access to the underlying hardware.</text>
<text top="1024" left="167" width="540" height="13" font="2">So the access rights of a process do not only depend on the user that started that</text>
<text top="1041" left="167" width="540" height="13" font="2">process, but also on whether the process is executing kernel or user code, which</text>
<text top="1059" left="167" width="116" height="13" font="2">may vary in time.</text>
<text top="1086" left="184" width="5" height="8" font="14">1</text>
<text top="1088" left="190" width="517" height="11" font="10">Of course, the memory separation between processes can also be regarded as a form of access</text>
<text top="1102" left="167" width="42" height="11" font="10">control.</text>
<text top="1163" left="434" width="7" height="13" font="2">8</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1188" width="918">
<text top="163" left="167" width="31" height="19" font="6">2.2</text>
<text top="163" left="223" width="309" height="19" font="6">Imperfections in abstractions</text>
<text top="201" left="167" width="540" height="13" font="2">The abstractions that the operating system provides – and the illusion of each</text>
<text top="219" left="167" width="540" height="13" font="2">process having exclusively access to its own CPU and memory that it tries to provide</text>
<text top="236" left="167" width="482" height="13" font="2">– are not perfect. Such imperfections may lead to security vulnerabilities.</text>
<text top="254" left="190" width="518" height="13" font="2">For example, a process may be able to detect that some of its memory is in fact</text>
<text top="272" left="167" width="540" height="13" font="2">swapped out to disk, based on the response time of certain operations. This property</text>
<text top="290" left="167" width="540" height="13" font="2">was used to break password security of the TENEX, an operating system developed</text>
<text top="308" left="167" width="540" height="13" font="2">in the early 1970s: depending on the response time of some incorrect password</text>
<text top="326" left="167" width="540" height="13" font="2">guess, it was possible to work out if the ﬁrst n characters of the password guess</text>
<text top="344" left="167" width="540" height="13" font="2">were correct, by making sure only these ﬁrst n characters were in main memory,</text>
<text top="362" left="167" width="228" height="13" font="2">and the rest were swapped to disk.</text>
<text top="380" left="190" width="518" height="13" font="2">Another example is that by observing the contents of freshly allocated memory,</text>
<text top="398" left="167" width="540" height="13" font="2">a process can observe the contents of memory that used to belong to other processes.</text>
<text top="416" left="167" width="458" height="13" font="2">This is a classic way of snooping on other users in multi-user systems.</text>
<text top="434" left="190" width="518" height="13" font="2">An example given in [GVW03] shows the unexpected ways in which these im-</text>
<text top="452" left="167" width="540" height="13" font="2">perfections can lead to security problems. In 1993 it was observed that every tar-</text>
<text top="470" left="167" width="24" height="13" font="2">ball</text>
<text top="467" left="191" width="6" height="9" font="5">2</text>
<text top="470" left="205" width="503" height="13" font="2">produced on UNIX Solaris 2.0 contained a fragment of the password ﬁle –</text>
<text top="489" left="167" width="540" height="12" font="2">/etc/passwd on UNIX systems – at the very end. The way that this happened was</text>
<text top="505" left="167" width="67" height="13" font="2">as follows:</text>
<text top="535" left="186" width="522" height="13" font="2">1. To ﬁnd out the owner and group permissions for the tar ﬁle to be created,</text>
<text top="553" left="205" width="503" height="13" font="2">the password ﬁle was consulted. (The password ﬁle tells which group a user</text>
<text top="571" left="205" width="503" height="13" font="2">belongs to.) This meant this ﬁle was read from disk, and stored in RAM. This</text>
<text top="589" left="205" width="159" height="13" font="2">RAM was then released.</text>
<text top="617" left="186" width="522" height="13" font="2">2. Then the tar ﬁle was created. For this RAM memory was allocated. Because</text>
<text top="635" left="205" width="503" height="13" font="2">of the way memory allocation worked, this memory included the memory that</text>
<text top="653" left="205" width="503" height="13" font="2">had just before been used for the password ﬁle. And because memory is not</text>
<text top="671" left="205" width="503" height="13" font="2">wiped on allocation or de-allocation, this memory still contained contents of</text>
<text top="689" left="205" width="114" height="13" font="2">the password ﬁle.</text>
<text top="717" left="186" width="522" height="13" font="2">3. The size of a tar ﬁle is always a multiple of a ﬁxed block size. Unless the</text>
<text top="735" left="205" width="503" height="13" font="2">actual contents size is precisely a multiple of this block size, the block at the</text>
<text top="753" left="205" width="503" height="13" font="2">end will not be completely ﬁlled. The remainder of this block still contained</text>
<text top="771" left="205" width="183" height="13" font="2">data from the password ﬁle.</text>
<text top="800" left="167" width="540" height="13" font="2">As tar ﬁles are typically used to share ﬁles over the internet the security implications</text>
<text top="818" left="167" width="62" height="13" font="2">are clear.</text>
<text top="818" left="243" width="464" height="14" font="2">Fortunately, in Solaris 2.0 the ﬁle /etc/passwd no longer contained</text>
<text top="836" left="167" width="540" height="13" font="2">hashed and salted passwords, these were in a separate ﬁle (the shadow password</text>
<text top="854" left="167" width="29" height="13" font="2">ﬁle).</text>
<text top="872" left="190" width="518" height="14" font="2">A quick ﬁx to the problem is replacing a call to malloc (which allocates memory)</text>
<text top="890" left="167" width="540" height="14" font="2">in the code of tar by a call to calloc (which allocates memory and zeroes it</text>
<text top="908" left="167" width="540" height="13" font="2">out). That only ﬁxes this particular instance of the problem, and people always</text>
<text top="926" left="167" width="540" height="14" font="2">use malloc by default rather than calloc because it is faster. One can think</text>
<text top="944" left="167" width="540" height="13" font="2">about more fundamental solutions to this kind of problem, e.g., always zeroing</text>
<text top="962" left="167" width="540" height="13" font="2">out memory on allocation, or always zeroing out memory upon de-allocation if the</text>
<text top="980" left="167" width="219" height="13" font="2">memory contained sensitive data.</text>
<text top="1024" left="167" width="31" height="19" font="6">2.3</text>
<text top="1024" left="223" width="186" height="19" font="6">What goes wrong</text>
<text top="1061" left="167" width="540" height="13" font="2">The way that security vulnerabilities normally arise in operating systems is more</text>
<text top="1079" left="167" width="457" height="13" font="2">mundane than the tarball example above. It typically happens due to</text>
<text top="1104" left="184" width="5" height="8" font="14">2</text>
<text top="1106" left="190" width="517" height="11" font="10">A tarball is a ﬁle produced by the tar utility for archiving and compressing directories, similar</text>
<text top="1120" left="167" width="38" height="11" font="10">to zip.</text>
<text top="1163" left="434" width="7" height="13" font="2">9</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1188" width="918">
<text top="167" left="190" width="117" height="14" font="2">• software bugs</text>
<text top="192" left="205" width="503" height="13" font="2">Especially buﬀer overﬂow weaknesses in high priority library calls by the op-</text>
<text top="210" left="205" width="365" height="13" font="2">erating system are notorious examples of software bugs.</text>
<text top="234" left="205" width="503" height="13" font="2">Modern operating systems come with very large APIs for user applications to</text>
<text top="252" left="205" width="503" height="13" font="2">use. Many of the system calls in this interface run with very high privileges.</text>
<text top="269" left="205" width="503" height="14" font="2">The standard example is the login function: login is invoked by a user who</text>
<text top="287" left="205" width="503" height="13" font="2">has not been authenticated yet, and who should therefore not be trusted and</text>
<text top="305" left="205" width="503" height="14" font="2">only be given minimal permission; however, the login procedure needs access</text>
<text top="323" left="205" width="503" height="13" font="2">to the password ﬁle to check if the given password guess is correct, so needs</text>
<text top="341" left="205" width="503" height="14" font="2">very high privileges. A buﬀer overﬂow weakness in login can possibly be</text>
<text top="359" left="205" width="424" height="13" font="2">exploited by an attacker to do other things with these privileges.</text>
<text top="388" left="190" width="97" height="14" font="2">• complexity</text>
<text top="413" left="205" width="503" height="13" font="2">Even if the operating system API was implemented without any bugs, the</text>
<text top="431" left="205" width="503" height="13" font="2">sheer complexity of modern operating systems means that users will get things</text>
<text top="449" left="205" width="503" height="13" font="2">wrong or run into unforeseen and unwanted feature interaction, where inter-</text>
<text top="467" left="205" width="377" height="13" font="2">play of various options introduces security vulnerabilities.</text>
<text top="491" left="205" width="503" height="13" font="2">E.g, introductory textbooks on operating systems typically illustrate the idea</text>
<text top="509" left="205" width="503" height="13" font="2">of operating system access control with read, write, and execute permissions,</text>
<text top="527" left="205" width="503" height="13" font="2">with users organised in groups, and one super-user or root who has permis-</text>
<text top="544" left="205" width="503" height="13" font="2">sions to do anything; but real-life modern operating systems oﬀer dozens of</text>
<text top="562" left="205" width="503" height="13" font="2">permissions and all sorts of user groups with diﬀerent privilege levels. The</text>
<text top="580" left="205" width="503" height="13" font="2">advantage is that this enables very ﬁne-grained access control, the disadvan-</text>
<text top="598" left="205" width="503" height="13" font="2">tage is that people get it wrong and grant unwanted access right. See [GA06]</text>
<text top="616" left="205" width="503" height="13" font="2">for an interesting account of how major software vendors got Windows access</text>
<text top="634" left="205" width="94" height="13" font="2">control wrong.</text>
<text top="658" left="205" width="503" height="13" font="2">Note that here there is this a fundamental tension between the Principle</text>
<text top="676" left="205" width="503" height="13" font="2">of Least Privilege, and the more general KISS principle, Keep it Simple,</text>
<text top="694" left="205" width="503" height="13" font="2">Stupid. (Good reading material on these and other design principles for secu-</text>
<text top="712" left="205" width="503" height="14" font="2">rity is available at https://buildsecurityin.us-cert.gov/bsi/articles/</text>
<text top="731" left="205" width="270" height="12" font="2">knowledge/principles/358-BSI.html.)</text>
<text top="730" left="489" width="219" height="13" font="2">The Principle of Least Privilege</text>
<text top="748" left="205" width="503" height="13" font="2">says only the minimal privileges needed should be given; the more ﬁne-grained</text>
<text top="766" left="205" width="503" height="13" font="2">access control is, the better this principle can be followed. But the downside</text>
<text top="784" left="205" width="503" height="13" font="2">is that the more ﬁne-grained access control becomes, the more complex it be-</text>
<text top="801" left="205" width="503" height="13" font="2">comes, and the more likely it becomes that people make mistakes. In line with</text>
<text top="819" left="205" width="503" height="13" font="2">the KISS principle, access control is easier to get right if it involves large-coarse</text>
<text top="837" left="205" width="471" height="13" font="2">chunks of all-or-nothing access, also known as compartmentalisation.</text>
<text top="861" left="205" width="503" height="13" font="2">One can try to combine these design principles by including several layers of</text>
<text top="879" left="205" width="503" height="13" font="2">access control, in line with the design principle of Defense in Depth, where</text>
<text top="897" left="205" width="503" height="13" font="2">diﬀerent layers provide simple and coarse compartments or more ﬁne-grained</text>
<text top="915" left="205" width="278" height="13" font="2">access control within such a compartment.</text>
<text top="1163" left="430" width="15" height="13" font="2">10</text>
</page>
<page number="11" position="absolute" top="0" left="0" height="1188" width="918">
<text top="269" left="167" width="154" height="28" font="4">Chapter 3</text>
<text top="339" left="167" width="525" height="33" font="3">Safe programming languages</text>
<text top="432" left="167" width="540" height="13" font="2">A fundamental way in which a programming language can help in writing secure</text>
<text top="450" left="167" width="540" height="13" font="2">programs is by being ‘safe’. This chapter investigates what safety means here, and</text>
<text top="468" left="167" width="540" height="13" font="2">discusses the various ﬂavours of safety, such as memory safety, type safety, and</text>
<text top="486" left="167" width="88" height="13" font="2">thread safety.</text>
<text top="504" left="190" width="518" height="13" font="2">Precisely pinning down what safety means is tricky, and people have diﬀerent</text>
<text top="522" left="167" width="540" height="13" font="2">opinions on precisely what constitutes a safe programming language. Usually, by</text>
<text top="540" left="167" width="540" height="13" font="2">a safe programming language people mean one that provides memory safety and</text>
<text top="558" left="167" width="540" height="13" font="2">type safety, but there are other forms of safety, as we will see. Safe programming</text>
<text top="576" left="167" width="540" height="13" font="2">languages provide some guarantees about the possible behaviour of programs, which</text>
<text top="594" left="167" width="540" height="13" font="2">can protect against security vulnerabilities due to unwanted behaviour. In essence,</text>
<text top="612" left="167" width="121" height="13" font="2">the central idea is:</text>
<text top="641" left="205" width="465" height="13" font="2">In a safe programming language, you can trust the abstractions pro-</text>
<text top="659" left="205" width="148" height="13" font="2">vided by the language.</text>
<text top="689" left="190" width="420" height="13" font="2">An alternative characterisation, which is a bit more concrete, is:</text>
<text top="718" left="205" width="465" height="13" font="2">In a safe programming language, programs always have a precise and</text>
<text top="736" left="205" width="171" height="13" font="2">well-deﬁned semantics.</text>
<text top="766" left="167" width="540" height="13" font="2">An important goal of safety is that safety makes it possible to reason about programs</text>
<text top="784" left="167" width="540" height="13" font="2">in a modular way: i.e., to make it possible to make guarantees about the behaviour</text>
<text top="802" left="167" width="540" height="13" font="2">of certain ‘parts’ of a program without knowing the rest of it. Here, depending on</text>
<text top="820" left="167" width="540" height="13" font="2">the programming languages, these ‘parts’ can be functions and procedures, objects,</text>
<text top="837" left="167" width="328" height="13" font="2">classes, packages, or some other notion of module.</text>
<text top="867" left="205" width="465" height="13" font="2">In a safe programming language, it is possible to understand the be-</text>
<text top="885" left="205" width="465" height="13" font="2">haviour of a program in a modular way, and to make guarantees about</text>
<text top="903" left="205" width="465" height="13" font="2">part of a program by inspecting only that part and not the entire pro-</text>
<text top="921" left="205" width="37" height="13" font="2">gram.</text>
<text top="950" left="190" width="518" height="13" font="2">The following sections will explain these general ideas in more detail, and give</text>
<text top="968" left="167" width="540" height="13" font="2">more speciﬁc examples. We begin by considering the issue of undeﬁnedness, before</text>
<text top="986" left="167" width="460" height="13" font="2">turning to the more speciﬁc notions of memory safety and type safety.</text>
<text top="1039" left="167" width="186" height="13" font="2">Undeﬁnedness &amp; fuzzing</text>
<text top="1057" left="167" width="540" height="13" font="2">Leaving the meaning of some language constructs undeﬁned under some circum-</text>
<text top="1075" left="167" width="540" height="13" font="2">stances is a potential cause of security problems. More generally, leaving things</text>
<text top="1093" left="167" width="540" height="13" font="2">undeﬁned in the speciﬁcation of any system is a potential cause of trouble. Indeed,</text>
<text top="1111" left="167" width="540" height="13" font="2">a standard technique to ﬁnd security loopholes is to try out how a system behaves</text>
<text top="1163" left="430" width="15" height="13" font="2">11</text>
</page>
<page number="12" position="absolute" top="0" left="0" height="1188" width="918">
<text top="174" left="167" width="540" height="13" font="2">under the circumstances where the speciﬁcation does not say how it should. The</text>
<text top="192" left="167" width="540" height="13" font="2">system might just crash, which might mean you have found a Denial-of-Service</text>
<text top="210" left="167" width="540" height="13" font="2">(DoS) vulnerability (though under some circumstances crashing might be the safe</text>
<text top="228" left="167" width="540" height="13" font="2">thing to do). But you may discover all sorts of surprising – and possible insecure –</text>
<text top="245" left="167" width="69" height="13" font="2">behaviour.</text>
<text top="263" left="190" width="518" height="13" font="2">The test technique of fuzzing is based on this idea. In fuzzing, software is</text>
<text top="281" left="167" width="540" height="13" font="2">tested by sending invalid, unexpected, or simply random inputs to an application</text>
<text top="299" left="167" width="540" height="13" font="2">in the hope of detecting security or robustness problems. Fuzzing with very large</text>
<text top="317" left="167" width="540" height="13" font="2">input strings can be used to hunt for buﬀer overﬂows: if an application crashes</text>
<text top="335" left="167" width="540" height="13" font="2">with a segmentation fault on some very long, but completely random, input string,</text>
<text top="353" left="167" width="540" height="13" font="2">you have found a potential security vulnerability. In protocol fuzzing a lot of</text>
<text top="371" left="167" width="540" height="13" font="2">(semi)random network traﬃc – which might be unusual or slightly malformed – is</text>
<text top="389" left="167" width="540" height="13" font="2">generated to detect security vulnerabilities in a protocol implementation, say an</text>
<text top="407" left="167" width="113" height="13" font="2">SSL/TLS-library.</text>
<text top="459" left="167" width="31" height="19" font="6">3.1</text>
<text top="459" left="223" width="265" height="19" font="6">Safety &amp; (un)deﬁnedness</text>
<text top="497" left="167" width="540" height="13" font="2">Many program statements only make sense under certain circumstances. For ex-</text>
<text top="515" left="167" width="138" height="13" font="2">ample, the statement</text>
<text top="544" left="183" width="133" height="12" font="2">a[i] = (float) x;</text>
<text top="570" left="167" width="540" height="14" font="2">only makes sense if in the current execution state a is an array in which we can</text>
<text top="588" left="167" width="540" height="14" font="2">store ﬂoats, i has an integer value within the array bounds, and x can sensibly be</text>
<text top="606" left="167" width="540" height="13" font="2">converted into a ﬂoat value. If one of these conditions is not met, then it is unclear</text>
<text top="624" left="167" width="313" height="13" font="2">what the semantics of this statement should be.</text>
<text top="642" left="190" width="512" height="13" font="2">There are roughly two approaches that programming languages can take here:</text>
<text top="669" left="186" width="522" height="13" font="2">1. One approach is to accept that a program statement may be executed when</text>
<text top="687" left="205" width="503" height="13" font="2">it does not really make sense. The semantics of the statement is undeﬁned in</text>
<text top="705" left="205" width="303" height="13" font="2">these cases: essentially, anything may happen.</text>
<text top="728" left="205" width="503" height="13" font="2">It is then the obligation of the programmer to ensure that statements are only</text>
<text top="746" left="205" width="333" height="13" font="2">ever executed in situations where they make sense.</text>
<text top="770" left="205" width="503" height="13" font="2">What actually will happen in the undeﬁned cases is down to the compiler and</text>
<text top="788" left="205" width="503" height="13" font="2">the platform responsible for the actual execution. This platform is the raw</text>
<text top="806" left="205" width="503" height="13" font="2">hardware (i.e., the CPU) in the case the compiler produces native code. It</text>
<text top="823" left="205" width="503" height="13" font="2">can also be the (software) execution engine used to execute programs in some</text>
<text top="841" left="205" width="503" height="13" font="2">intermediate language (e.g., a VM executing bytecode) and the hardware on</text>
<text top="859" left="205" width="194" height="13" font="2">top of which this engine runs.</text>
<text top="888" left="186" width="522" height="13" font="2">2. The other approach is that the language ensures that a statement is only ever</text>
<text top="906" left="205" width="503" height="13" font="2">executed when it makes sense, or, when it does not, signals some error in a</text>
<text top="924" left="205" width="422" height="13" font="2">precisely deﬁned manner, for example by throwing an exception.</text>
<text top="947" left="205" width="503" height="13" font="2">It is now the obligation of the language to somehow prevent or detect the</text>
<text top="965" left="205" width="503" height="13" font="2">execution of statements when this does not make sense. This can be through</text>
<text top="983" left="205" width="503" height="13" font="2">measures at compile-time (e.g., type checking), at run-time (by some execution</text>
<text top="1001" left="205" width="503" height="13" font="2">engine that monitors for these conditions, or by the compiler including some</text>
<text top="1019" left="205" width="398" height="13" font="2">checks in the code it produces), or a combination of the two.</text>
<text top="1047" left="167" width="540" height="13" font="2">The ﬁrst approach leads to an unsafe programming language. The second approach</text>
<text top="1065" left="167" width="255" height="13" font="2">leads to a safe programming language.</text>
<text top="1082" left="190" width="518" height="13" font="2">In safe languages, the semantics of a program – or any program fragment – is</text>
<text top="1100" left="167" width="540" height="13" font="2">always precisely deﬁned; even in cases where it does not make sense, it is precisely</text>
<text top="1118" left="167" width="233" height="13" font="2">deﬁned what error will be reported.</text>
<text top="1163" left="430" width="15" height="13" font="2">12</text>
</page>
<page number="13" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="190" width="518" height="13" font="2">C and C++ are the prime examples of unsafe languages. Java and C# are</text>
<text top="186" left="167" width="540" height="13" font="2">meant to be safe, but still have some unsafe features. For instance, the Java Native</text>
<text top="204" left="167" width="540" height="13" font="2">Interface (JNI) allows Java programs to call native machine code. In C# pointer</text>
<text top="222" left="167" width="540" height="14" font="2">arithmetic is allowed in code blocks that are marked as unsafe. So Java and C#</text>
<text top="240" left="167" width="540" height="13" font="2">programs are only safe if these features are not used. Most functional programming</text>
<text top="258" left="167" width="540" height="13" font="2">languages, such as Haskell, ML, or LISP, are safe, as are most logic programming</text>
<text top="275" left="167" width="171" height="13" font="2">languages, such as Prolog.</text>
<text top="302" left="190" width="518" height="13" font="2">The main advantage of the unsafe approach is speed. Execution of a safe language</text>
<text top="320" left="167" width="469" height="13" font="2">typically involves some run-time monitoring that slows execution down.</text>
<text top="338" left="190" width="518" height="13" font="2">An important disadvantage is security. If the programmer is not very careful and</text>
<text top="356" left="167" width="540" height="13" font="2">just one program statement is executed in a state where it does not make sense, we</text>
<text top="374" left="167" width="540" height="13" font="2">have no way of knowing what may happen: it may re-format the hard disk, sent all</text>
<text top="392" left="167" width="540" height="13" font="2">your private email correspondence to wikileaks, etc. This means we can no longer</text>
<text top="410" left="167" width="325" height="13" font="2">make any security guarantees about the program.</text>
<text top="428" left="190" width="518" height="13" font="2">Conﬂicts between security and some practical consideration such as speed (or</text>
<text top="446" left="167" width="540" height="13" font="2">‘convenience’) are common. Almost always people sacriﬁce security in favour of</text>
<text top="464" left="167" width="540" height="13" font="2">the short-term practical advantage, and then live to regret the consequences in the</text>
<text top="482" left="167" width="540" height="13" font="2">long term. Four decades after the introduction of C – and the decision not to do</text>
<text top="500" left="167" width="540" height="13" font="2">bounds checking in C – people are still ﬁxing buﬀer overﬂows in C programs on a</text>
<text top="518" left="167" width="540" height="13" font="2">daily basis, even though ALGOL 60 introduced bounds checking as mechanism to</text>
<text top="535" left="167" width="295" height="13" font="2">prevent this problem over half a century ago.</text>
<text top="575" left="167" width="41" height="16" font="1">3.1.1</text>
<text top="575" left="229" width="169" height="16" font="1">Safety and security</text>
<text top="605" left="167" width="540" height="13" font="2">It is possible to write insecure programs in any programming language. But without</text>
<text top="623" left="167" width="320" height="13" font="2">safety, writing secure programs gets a lot harder.</text>
<text top="641" left="190" width="518" height="14" font="2">Consider a procedure login(uname,passwd) written in some unsafe program-</text>
<text top="659" left="167" width="540" height="13" font="2">ming language. Only if this procedure is very carefully written to check for any</text>
<text top="677" left="167" width="540" height="13" font="2">of the error conditions that would lead to undeﬁned behaviour, we can make some</text>
<text top="695" left="167" width="540" height="13" font="2">guarantees about it (for instance to return true iﬀ it is given a matching username</text>
<text top="712" left="167" width="99" height="13" font="2">and password).</text>
<text top="730" left="190" width="518" height="13" font="2">If not, then we need to know the precise circumstances in which the procedure</text>
<text top="748" left="167" width="540" height="13" font="2">is called in order to make any guarantees. In the best case, this is a lot of work:</text>
<text top="766" left="167" width="540" height="14" font="2">we have to check all the places in the code where login is called, and check that</text>
<text top="784" left="167" width="540" height="13" font="2">these calls cannot trigger any undeﬁned behaviour. When doing this, we should be</text>
<text top="802" left="167" width="540" height="13" font="2">careful not to make any assumptions on user input that the program may receive.</text>
<text top="820" left="167" width="429" height="13" font="2">For non-trivial programs this quickly becomes infeasible to check.</text>
<text top="838" left="190" width="518" height="13" font="2">Note that this reveals a fundamental problem with unsafe languages, apart from</text>
<text top="856" left="167" width="540" height="13" font="2">any security issues: we cannot always understand code in a modular fashion. E.g.,</text>
<text top="874" left="167" width="540" height="14" font="2">we may not be able to know what the procedure login will do without knowing</text>
<text top="892" left="167" width="260" height="13" font="2">the precise context in which it is called.</text>
<text top="910" left="190" width="518" height="13" font="2">Things get worse if the procedure is part of some library that may be called</text>
<text top="928" left="167" width="540" height="14" font="2">from many places, or if login is an operating system call that may be called by any</text>
<text top="946" left="167" width="540" height="13" font="2">application program. In these cases we do not know the speciﬁc circumstances of</text>
<text top="964" left="167" width="540" height="14" font="2">calls to login, so we cannot rely on these to avoid running into undeﬁned behaviour.</text>
<text top="1008" left="167" width="31" height="19" font="6">3.2</text>
<text top="1008" left="223" width="158" height="19" font="6">Memory safety</text>
<text top="1046" left="167" width="551" height="13" font="2">One important form of safety is memory safety. A programming language is memory-</text>
<text top="1064" left="167" width="540" height="13" font="2">safe if programs are guaranteed to only access memory locations that they are</text>
<text top="1082" left="167" width="482" height="13" font="2">permitted to access. Language features that break memory safety include</text>
<text top="1111" left="190" width="138" height="14" font="2">• pointer arithmetic;</text>
<text top="1163" left="430" width="15" height="13" font="2">13</text>
</page>
<page number="14" position="absolute" top="0" left="0" height="1188" width="918">
<text top="167" left="190" width="493" height="14" font="2">• unconstrained casting (e.g., casting a ﬂoating-point number to an array);</text>
<text top="195" left="190" width="199" height="14" font="2">• lack of array bounds checks;</text>
<text top="223" left="190" width="518" height="14" font="2">• programmer-controlled de-allocation (as this allows dangling pointers to mem-</text>
<text top="242" left="205" width="209" height="13" font="2">ory that has been de-allocated).</text>
<text top="269" left="167" width="540" height="13" font="2">Memory safety is a special case of the notion of safety as discussed in section 3.1:</text>
<text top="287" left="167" width="540" height="13" font="2">accessing some random memory location that you shouldn’t will not have a well-</text>
<text top="305" left="167" width="480" height="13" font="2">deﬁned semantics, and can break any abstractions the language provides.</text>
<text top="323" left="190" width="518" height="13" font="2">Memory unsafety makes it hard – if not impossible – to understand programs</text>
<text top="341" left="167" width="540" height="13" font="2">in a modular fashion. Consider a program consisting of two modules, P and Q,</text>
<text top="358" left="167" width="540" height="13" font="2">written in a language that is not memory safe. Code belonging to module Q can</text>
<text top="376" left="167" width="540" height="13" font="2">makes changes anywhere in memory, including data belonging to module P. So code</text>
<text top="394" left="167" width="540" height="13" font="2">belonging to module Q could corrupt data that module P relies on, for instance</text>
<text top="412" left="167" width="540" height="13" font="2">breaking data invariants. This means we cannot make guarantees about P just</text>
<text top="430" left="167" width="540" height="13" font="2">by looking at P, we also have to make sure Q does not interfere with P. Note that</text>
<text top="448" left="167" width="540" height="13" font="2">this means we cannot make guarantees about extensible programs, as any extension</text>
<text top="466" left="167" width="217" height="13" font="2">could corrupt existing behaviour.</text>
<text top="484" left="190" width="518" height="13" font="2">If a language is memory-safe then programs can never crash with a segmentation</text>
<text top="502" left="167" width="540" height="13" font="2">fault. One might even consider it safe to switch oﬀ the checks the operating system</text>
<text top="520" left="167" width="540" height="13" font="2">performs on memory access for these programs. However, the execution of the</text>
<text top="538" left="167" width="540" height="13" font="2">memory-safe program might rely on some interpreter or execution engine that is</text>
<text top="556" left="167" width="540" height="13" font="2">written in an unsafe language, which could still cause out-of-bounds memory access.</text>
<text top="574" left="167" width="540" height="13" font="2">Also, memory safety might rely on the correctness of compilers and type checkers,</text>
<text top="592" left="167" width="540" height="13" font="2">which may contain bugs. So, in line with the security principle of Defence in Depth,</text>
<text top="610" left="167" width="540" height="13" font="2">keeping the memory access control performed by the operating system switched on</text>
<text top="627" left="167" width="185" height="13" font="2">is always a wise thing to do.</text>
<text top="666" left="167" width="41" height="16" font="1">3.2.1</text>
<text top="666" left="229" width="306" height="16" font="1">Stronger notions of memory safety</text>
<text top="696" left="167" width="540" height="13" font="2">A stronger notion of memory safety also guarantees that programs never read unini-</text>
<text top="714" left="167" width="540" height="13" font="2">tialised memory. For the earlier deﬁnition of memory safety – programs are guar-</text>
<text top="732" left="167" width="540" height="13" font="2">anteed to only access memory locations that they are permitted to access – one can</text>
<text top="750" left="167" width="540" height="13" font="2">argue whether accessing uninitialised memory should also count as access that is</text>
<text top="768" left="167" width="103" height="13" font="2">not ‘permitted’.</text>
<text top="786" left="190" width="518" height="13" font="2">One consequence of this is that programs cannot observe the old content of</text>
<text top="804" left="167" width="540" height="13" font="2">physical memory that other processes used previously. So it rules out the possibility</text>
<text top="822" left="167" width="341" height="13" font="2">of spying on other programs discussed in Chapter 2.</text>
<text top="840" left="190" width="518" height="13" font="2">A more interesting consequence is that programs behave more deterministically.</text>
<text top="858" left="167" width="540" height="13" font="2">A program that reads uninitialised memory can behave diﬀerently every time it is</text>
<text top="875" left="167" width="540" height="13" font="2">started. This can for instance make programs hard to debug, as errors might be</text>
<text top="893" left="167" width="155" height="13" font="2">very hard to reproduce.</text>
<text top="938" left="167" width="31" height="19" font="6">3.3</text>
<text top="938" left="223" width="123" height="19" font="6">Type safety</text>
<text top="975" left="167" width="314" height="13" font="2">Another important form of safety is type safety.</text>
<text top="993" left="190" width="518" height="13" font="2">As discussed earlier, safety involves avoiding erroneous conditions under which</text>
<text top="1011" left="167" width="540" height="13" font="2">programs become meaningless. Type systems impose some restrictions on the pro-</text>
<text top="1029" left="167" width="540" height="13" font="2">grammer that avoid meaningless programs. It is therefore not surprising that many</text>
<text top="1047" left="167" width="540" height="13" font="2">safe languages are typed. However, not all safe languages are typed. For example,</text>
<text top="1065" left="167" width="246" height="13" font="2">LISP is a safe, but untyped language.</text>
<text top="1082" left="190" width="518" height="13" font="2">Type soundness, also called type safety or strong typing, is the guarantee</text>
<text top="1100" left="167" width="540" height="13" font="2">that executing well-typed programs can never result in type errors. This means that</text>
<text top="1118" left="167" width="540" height="13" font="2">in a type-safe language we can rely on the abstractions oﬀered by the type system.</text>
<text top="1163" left="430" width="15" height="13" font="2">14</text>
</page>
<page number="15" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="190" width="518" height="13" font="2">C, C++, and Pascal are examples of languages that are typed, but not type-safe.</text>
<text top="186" left="167" width="540" height="13" font="2">Here programs can easily undermine any guarantees of the type system. Java, C#,</text>
<text top="204" left="167" width="317" height="13" font="2">Modula, Scheme, ML, and Haskell are type-safe.</text>
<text top="231" left="190" width="518" height="13" font="2">Type checking is the process of verifying that a program is well typed. This</text>
<text top="249" left="167" width="540" height="13" font="2">can be done at compile-time, in which case we talk of static type checking, or at</text>
<text top="266" left="167" width="380" height="13" font="2">run-time, in which case we talk of dynamic type checking.</text>
<text top="284" left="190" width="518" height="13" font="2">Static type checking has the obvious advantage of catching problems earlier. It</text>
<text top="302" left="167" width="540" height="13" font="2">also oﬀers advantage in speed: if we can rule out some type errors statically, we can</text>
<text top="320" left="167" width="540" height="13" font="2">omit run-time checks, making programs run faster. (Of course, only in a type-safe</text>
<text top="338" left="167" width="195" height="13" font="2">language it is safe to do this.)</text>
<text top="356" left="190" width="518" height="13" font="2">Most type-safe languages rely on a combination of static and dynamic checks.</text>
<text top="374" left="167" width="525" height="13" font="2">Typically, array bounds and certain cast operations will be checked at run-time.</text>
<text top="392" left="190" width="518" height="13" font="2">It is often claimed that “well-typed programs cannot go wrong”, but this is of</text>
<text top="410" left="167" width="540" height="13" font="2">course wildly overstated. At best well-typed programs are less likely to go wrong,</text>
<text top="428" left="167" width="540" height="13" font="2">and only if the type system is sound we can guarantee that certain types of things</text>
<text top="446" left="167" width="113" height="13" font="2">cannot go wrong.</text>
<text top="486" left="167" width="41" height="16" font="1">3.3.1</text>
<text top="486" left="229" width="108" height="16" font="1">Expressivity</text>
<text top="515" left="167" width="540" height="13" font="2">Many programming languages use type systems that have roughly similar expressiv-</text>
<text top="533" left="167" width="540" height="13" font="2">ity, and have a similar division between checks done at compile-time and checks done</text>
<text top="551" left="167" width="540" height="13" font="2">at run-time. However, still important choices can be made here, and we may well</text>
<text top="569" left="167" width="531" height="13" font="2">see languages with diﬀerent, possibly more expressive type systems in the future.</text>
<text top="587" left="190" width="518" height="13" font="2">For example, most imperative programming languages check for nullness of ref-</text>
<text top="605" left="167" width="540" height="13" font="2">erences at run-time. Their types allow null values, and problems with accessing</text>
<text top="623" left="167" width="540" height="13" font="2">null references are only detected at run-time. Using a more expressive type system,</text>
<text top="641" left="167" width="540" height="13" font="2">there is no fundamental reason why some or even all problems with null references</text>
<text top="659" left="167" width="255" height="13" font="2">could not be detected at compile time</text>
<text top="656" left="422" width="6" height="9" font="5">1</text>
<text top="659" left="429" width="279" height="13" font="2">. For this we have to distinguish between</text>
<text top="677" left="167" width="540" height="13" font="2">types that include null reference and those that don’t. E.g., the Spec# dialect of</text>
<text top="695" left="167" width="63" height="13" font="2">C# [BFL</text>
<text top="692" left="230" width="9" height="9" font="5">+</text>
<text top="695" left="240" width="467" height="14" font="2">11] distinguishes between class types A and A?, for all classes A, where</text>
<text top="712" left="167" width="540" height="14" font="2">only values of A? are allowed to be null. Values of type A can be implicitly promoted</text>
<text top="730" left="167" width="540" height="14" font="2">to type A?, but using a value of type A? where a non-value of type A is expected</text>
<text top="748" left="167" width="540" height="13" font="2">requires an explicit cast, which will result in a check for nullness at run-time. Of</text>
<text top="766" left="167" width="540" height="13" font="2">course, this does introduce some extra work for the programmer: he has to specify</text>
<text top="784" left="167" width="540" height="13" font="2">which references are and which are not allowed to be null. But note that a good</text>
<text top="802" left="167" width="540" height="13" font="2">programmer has to think about this anyway, so we are only providing notation to</text>
<text top="820" left="167" width="540" height="13" font="2">document this in the code – notation which is backed up by tool support in the</text>
<text top="838" left="167" width="540" height="14" font="2">compiler or type checker. In casting from A? to A null-pointer exceptions can of</text>
<text top="856" left="167" width="540" height="13" font="2">course still arise, but these can then be limited to speciﬁc – and hopefully few -</text>
<text top="874" left="167" width="153" height="13" font="2">points in the programs.</text>
<text top="914" left="167" width="41" height="16" font="1">3.3.2</text>
<text top="914" left="229" width="183" height="16" font="1">Breaking type safety</text>
<text top="943" left="167" width="540" height="13" font="2">Safe type systems can provide strong guarantees about data, but type safety is a</text>
<text top="961" left="167" width="540" height="13" font="2">very fragile property. A tiny loophole in a type system can be fatal – and usually is,</text>
<text top="979" left="167" width="540" height="13" font="2">undermining the whole type system and destroying all the guarantees that it meant</text>
<text top="997" left="167" width="540" height="13" font="2">to provide. A loophole can be a ﬂaw in the type system, in which case the type</text>
<text top="1015" left="167" width="462" height="13" font="2">system is not safe, or a bug in the implementation of the type checker.</text>
<text top="1033" left="190" width="518" height="13" font="2">To exploit a loophole in a type system, one usually tries to create type con-</text>
<text top="1051" left="167" width="540" height="13" font="2">fusion, where one creates references to the same location in memory which the</text>
<text top="1069" left="167" width="540" height="13" font="2">type system thinks have diﬀerent, and incompatible, types. Here it is important</text>
<text top="1087" left="167" width="540" height="13" font="2">to realise that in the end all values, irrespectively of their types, are just blobs of</text>
<text top="1113" left="184" width="5" height="8" font="14">1</text>
<text top="1115" left="190" width="358" height="11" font="10">Indeed, most functional programming languages already do this.</text>
<text top="1163" left="430" width="15" height="13" font="2">15</text>
</page>
<page number="16" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="167" width="540" height="13" font="2">memory, sequences of bytes or words in RAM or on disk. And any blob of memory</text>
<text top="186" left="167" width="397" height="13" font="2">of the right length can be interpreted as a value of any type.</text>
<text top="204" left="190" width="518" height="14" font="2">For an example, in some object-oriented language, suppose we have types A and</text>
<text top="223" left="167" width="12" height="12" font="2">B,</text>
<text top="253" left="183" width="141" height="12" font="2">class A { int i };</text>
<text top="271" left="183" width="165" height="12" font="2">class B { Object o };</text>
<text top="299" left="167" width="540" height="14" font="2">and suppose we have variables a and b of type A and B, respectively. If through</text>
<text top="317" left="167" width="540" height="14" font="2">some ﬂaw in the type system we can get a and b to point to the same location, then</text>
<text top="335" left="167" width="540" height="14" font="2">by changing the value of a.i we can change the value of b.o; eﬀectively this means</text>
<text top="353" left="167" width="193" height="13" font="2">we can do pointer arithmetic.</text>
<text top="371" left="190" width="363" height="14" font="2">If we can do the same with a reference of type C, where</text>
<text top="402" left="183" width="188" height="12" font="2">class C { final int x };</text>
<text top="431" left="167" width="540" height="14" font="2">then by changing the value of a.i we can change c.x, even though the type C</text>
<text top="449" left="167" width="540" height="14" font="2">indicates that the ﬁeld x is ﬁnal and should therefore be unchangeable. So all</text>
<text top="467" left="167" width="540" height="13" font="2">guarantees that a language provides (e.g., those discussed later in Section 3.5), can</text>
<text top="485" left="167" width="380" height="13" font="2">also be broken by exploiting loopholes in the type system.</text>
<text top="503" left="190" width="518" height="13" font="2">An classic example of a loophole in the implementation of the type checker of</text>
<text top="521" left="167" width="540" height="13" font="2">Navigator 3.0 was discovered by Drew Dean. Here type confusion could be created</text>
<text top="538" left="167" width="540" height="14" font="2">by deﬁning a class with the name A and a class with the name A[]. The latter</text>
<text top="556" left="167" width="540" height="14" font="2">should not be allowed, as [ and ] are illegal characters to use in class names! The</text>
<text top="574" left="167" width="540" height="14" font="2">type checker then did not distinguish between arrays of A and objects of type A[],</text>
<text top="592" left="167" width="540" height="13" font="2">providing an easy loophole to exploit. This attack is discussed in Section 5.7 in</text>
<text top="610" left="167" width="51" height="13" font="2">[MF99].</text>
<text top="628" left="190" width="518" height="13" font="2">In some implementations of Java Card, a dialect of Java for programming smart-</text>
<text top="646" left="167" width="540" height="13" font="2">cards, bugs have also been found where exploiting some strange interactions between</text>
<text top="664" left="167" width="540" height="13" font="2">the normal object allocation mechanism of Java(Card) and smartcard-speciﬁc mech-</text>
<text top="682" left="167" width="513" height="13" font="2">anisms in the Java Card API could lead to type confusion ([MP08, Sect. 3.3]).</text>
<text top="722" left="167" width="41" height="16" font="1">3.3.3</text>
<text top="722" left="229" width="182" height="16" font="1">Ensuring type safety</text>
<text top="751" left="167" width="540" height="13" font="2">To prevent fundamental ﬂaws in a type system one can try to mathematically</text>
<text top="769" left="167" width="540" height="13" font="2">prove the correctness of type systems. This can be done as a pencil-and-paper</text>
<text top="787" left="167" width="540" height="13" font="2">exercise, typically for an interesting subset of the language which captures the</text>
<text top="805" left="167" width="540" height="13" font="2">essential features. It can also be done using a theorem prover, a software program</text>
<text top="823" left="167" width="540" height="13" font="2">that assists in logical reasoning in the same way as Maple or Mathematica assist in</text>
<text top="841" left="167" width="540" height="13" font="2">mathematical analysis. This provides a higher degree of conﬁdence, especially as</text>
<text top="859" left="167" width="540" height="13" font="2">larger subsets of a real programming language are considered. For example, Java</text>
<text top="877" left="167" width="540" height="13" font="2">has 205 bytecode instructions; in a pencil-and-paper proof with 205 cases it is easy</text>
<text top="895" left="167" width="540" height="13" font="2">to overlook a mistake. Safety of various subsets of the Java language has been</text>
<text top="913" left="167" width="411" height="13" font="2">formally veriﬁed using such theorem provers (e.g., see [Ler03]).</text>
<text top="935" left="190" width="518" height="13" font="2">It is not so easy to deﬁne what it means for a type system to be safe, be it infor-</text>
<text top="953" left="167" width="540" height="13" font="2">mally or formally. A formal deﬁnition is needed for any mathematical correctness</text>
<text top="971" left="167" width="38" height="13" font="2">proof.</text>
<text top="989" left="190" width="518" height="13" font="2">One way is to deﬁne an operational semantics of the language in two ways:</text>
<text top="1007" left="167" width="540" height="13" font="2">a ‘typed (defensive) semantics’ where all values are explicitly tagged with type</text>
<text top="1025" left="167" width="540" height="13" font="2">information and where run-time checks are performed for every execution step, and</text>
<text top="1043" left="167" width="540" height="13" font="2">an ‘untyped semantics’ which only performs those type checks which would normally</text>
<text top="1061" left="167" width="540" height="13" font="2">happen at run-time (e.g., for array indices, nullness, or type casts), and then prove</text>
<text top="1079" left="167" width="540" height="13" font="2">that for any program that passes the type checker the two semantics are equivalent.</text>
<text top="1097" left="190" width="518" height="13" font="2">Another way is to prove representation independence. The idea behind this</text>
<text top="1114" left="167" width="540" height="13" font="2">is that a type system is safe if the abstractions it provides cannot be broken. For</text>
<text top="1163" left="430" width="15" height="13" font="2">16</text>
</page>
<page number="17" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="167" width="540" height="13" font="2">example, in a type-safe language it should be impossible to ﬁnd out if the boolean</text>
<text top="186" left="167" width="540" height="14" font="2">value true is represented as 1 (or maybe a 32- or 64-bits word ending with a 1)</text>
<text top="204" left="167" width="540" height="14" font="2">and false as 0, or the other way around. If we deﬁne two semantics of a type-</text>
<text top="222" left="167" width="540" height="14" font="2">safe language, one where true is represented as 1 and false as 0 and one where</text>
<text top="241" left="167" width="540" height="12" font="2">true is represented as 0 and false as 1, we should be able to prove that for any</text>
<text top="258" left="167" width="540" height="13" font="2">well-typed program the semantics are equivalent regardless of which of these two</text>
<text top="275" left="167" width="152" height="13" font="2">representations is used.</text>
<text top="320" left="167" width="31" height="19" font="6">3.4</text>
<text top="320" left="223" width="244" height="19" font="6">Other notions of safety</text>
<text top="358" left="167" width="540" height="13" font="2">When people talk about safe programming languages, they usually mean memory</text>
<text top="376" left="167" width="540" height="13" font="2">safety and type safety as in modern object-oriented languages such as Java. Still,</text>
<text top="393" left="167" width="540" height="13" font="2">there are other notions of safety than the ones discussed so far. There is no black-</text>
<text top="411" left="167" width="540" height="13" font="2">and-white distinction between safe and unsafe. Languages can be more or less safe</text>
<text top="429" left="167" width="296" height="13" font="2">to diﬀerent degrees, and in diﬀerent respects.</text>
<text top="469" left="167" width="41" height="16" font="1">3.4.1</text>
<text top="469" left="229" width="335" height="16" font="1">Safety concerns in low-level languages</text>
<text top="499" left="167" width="540" height="13" font="2">For lower-level language there are the additional safety notions about issues we take</text>
<text top="517" left="167" width="294" height="13" font="2">for granted in higher-level languages, such as</text>
<text top="546" left="190" width="518" height="14" font="2">• Control-ﬂow safety, the guarantee that programs only transfer control to</text>
<text top="565" left="205" width="503" height="13" font="2">correct program points. Programs should not jump to some random location.</text>
<text top="594" left="190" width="518" height="14" font="2">• Stack safety, the guarantee that the run-time stack is preserved across pro-</text>
<text top="612" left="205" width="503" height="13" font="2">cedure calls, i.e., that procedures only make changes at the top frame of the</text>
<text top="630" left="205" width="448" height="13" font="2">stack, and leave lower frames on the stack, of the callers, untouched.</text>
<text top="660" left="167" width="540" height="13" font="2">For high-level languages one typically takes such guarantees for granted. E.g., in a</text>
<text top="678" left="167" width="540" height="13" font="2">high-level language it is usually only possible to jump to entry points of functions</text>
<text top="696" left="167" width="540" height="13" font="2">and procedures, and when these are completed execution will return to the point</text>
<text top="714" left="167" width="540" height="13" font="2">where they were called, providing control-ﬂow safety. Of course, such a guarantee</text>
<text top="732" left="167" width="540" height="13" font="2">is fundamental to being able to understand how programs can behave. Only if the</text>
<text top="750" left="167" width="375" height="13" font="2">compiler is buggy could such safety properties be broken.</text>
<text top="768" left="190" width="518" height="13" font="2">For lower-level languages one might also consider whether procedures (or sub-</text>
<text top="786" left="167" width="540" height="13" font="2">routines) are always called with the right number of arguments. E.g., C is safe in</text>
<text top="804" left="167" width="540" height="13" font="2">the sense that the compiler will complain if we call a procedure with too many or</text>
<text top="822" left="167" width="130" height="13" font="2">too few parameters.</text>
<text top="861" left="167" width="41" height="16" font="1">3.4.2</text>
<text top="861" left="229" width="134" height="16" font="1">Safe arithmetic</text>
<text top="891" left="167" width="540" height="13" font="2">Even for something as basic as arithmetic questions about safety arise. For example,</text>
<text top="909" left="167" width="148" height="13" font="2">consider the statement</text>
<text top="940" left="175" width="63" height="12" font="2">i = i+1;</text>
<text top="969" left="167" width="540" height="14" font="2">This statement makes sense if i is an integer, but what if computing i+1 results in</text>
<text top="987" left="167" width="292" height="13" font="2">an integer overﬂow? Does this make ‘sense’ ?</text>
<text top="1005" left="190" width="518" height="13" font="2">In C, a signed integer overﬂow is undeﬁned behaviour, so C is not safe in this</text>
<text top="1022" left="167" width="46" height="13" font="2">respect</text>
<text top="1020" left="214" width="6" height="9" font="5">2</text>
<text top="1022" left="220" width="487" height="13" font="2">. In Java the semantics is precisely deﬁned: overﬂows behave the way one</text>
<text top="1040" left="167" width="402" height="13" font="2">would expect in two’s complement arithmetic (so adding 1 to 2</text>
<text top="1038" left="570" width="12" height="9" font="5">32</text>
<text top="1040" left="583" width="101" height="14" font="2">−1 becomes −2</text>
<text top="1038" left="685" width="12" height="9" font="5">32</text>
<text top="1040" left="697" width="10" height="13" font="2">),</text>
<text top="1058" left="167" width="540" height="13" font="2">and such overﬂows are silent, meaning that execution continues and no exception</text>
<text top="1085" left="184" width="5" height="8" font="14">2</text>
<text top="1087" left="190" width="517" height="11" font="10">One might think that ‘undeﬁned behaviour’ here just means that i ends up with an unknown</text>
<text top="1101" left="167" width="540" height="11" font="10">value, but the oﬃcial C standard, C99, literally allows any behaviour when integer overﬂow hap-</text>
<text top="1115" left="167" width="266" height="11" font="10">pens, including say reformatting the hard drive.</text>
<text top="1163" left="430" width="15" height="13" font="2">17</text>
</page>
<page number="18" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="167" width="540" height="13" font="2">is thrown. C# goes one step further: a code block or an expression can be marked</text>
<text top="186" left="167" width="509" height="14" font="2">as checked, in which case integer overﬂow will result in a run-time exception.</text>
<text top="204" left="190" width="518" height="13" font="2">In some situations – say, in software for a bank – integer overﬂow can be a</text>
<text top="222" left="167" width="540" height="13" font="2">serious concern. One could consider a language where integer overﬂow results in an</text>
<text top="240" left="167" width="540" height="13" font="2">exception to be safer than a language with silent integer overﬂow, even if both are</text>
<text top="258" left="167" width="364" height="13" font="2">safe in the sense that the semantics is precisely deﬁned.</text>
<text top="275" left="190" width="518" height="13" font="2">By the way, integer overﬂows are a well-known cause of security vulnerabilities,</text>
<text top="293" left="167" width="540" height="13" font="2">usually in combination with buﬀer overﬂows: here the integer overﬂow leads to the</text>
<text top="311" left="167" width="133" height="13" font="2">incorrect buﬀer size.</text>
<text top="329" left="190" width="518" height="13" font="2">One of the more expensive software failures ever was due to a problem with</text>
<text top="347" left="167" width="540" height="13" font="2">arithmetic. The Ariane V rocket was lost due to a software error, where a large nu-</text>
<text top="365" left="167" width="540" height="13" font="2">meric value caused an overﬂow that triggered a (hardware) exception – an exception</text>
<text top="383" left="167" width="540" height="13" font="2">that was not caught and which ﬁrst crashed the program, and next the rocket. In</text>
<text top="401" left="167" width="540" height="13" font="2">this case ignoring the overﬂow would have been better, especially since – ironically</text>
<text top="419" left="167" width="540" height="13" font="2">– the piece of software causing the problem was not doing anything meaningful after</text>
<text top="437" left="167" width="540" height="13" font="2">the launch of the rocket. (The report by the Flight 501 Enquiry Board makes inter-</text>
<text top="455" left="167" width="449" height="13" font="2">esting reading, especially the list of recommendations in Section 4 [L</text>
<text top="452" left="617" width="9" height="9" font="5">+</text>
<text top="455" left="627" width="81" height="13" font="2">96], which is</text>
<text top="473" left="167" width="532" height="13" font="2">a sensible list for security-critical software just as well as safety-critical software.)</text>
<text top="512" left="167" width="41" height="16" font="1">3.4.3</text>
<text top="512" left="229" width="121" height="16" font="1">Thread safety</text>
<text top="542" left="167" width="540" height="13" font="2">Thread safety concerns the execution of multi-threaded or concurrent programs.</text>
<text top="560" left="167" width="540" height="13" font="2">With multi-threading cores and multi-core CPUs becoming more common, thread</text>
<text top="578" left="167" width="540" height="13" font="2">safety will become more of an issue. Indeed, concurrency is widely predicted to</text>
<text top="596" left="167" width="540" height="13" font="2">become a more important source of software problems (for more discussion, read</text>
<text top="614" left="167" width="540" height="13" font="2">[Sut05]), and it will then also become a major source of security ﬂaws. In fact, there</text>
<text top="631" left="167" width="540" height="13" font="2">already is a well-known category of security vulnerabilities when there is concurrent</text>
<text top="649" left="167" width="540" height="13" font="2">access to some resource, namely so-called TOCTOU (Time-of-Check, Time-of-Use)</text>
<text top="667" left="167" width="337" height="13" font="2">errors, also known as ‘Non-Atomic Check and Use’.</text>
<text top="685" left="190" width="518" height="13" font="2">A procedure, function, method – or generally, some piece of code – is called</text>
<text top="703" left="167" width="540" height="13" font="2">thread-safe if it can be safely invoked by multiple threads at the same time. In an</text>
<text top="721" left="167" width="540" height="13" font="2">object-oriented language, a class is called thread-safe if multiple execution threads</text>
<text top="739" left="167" width="461" height="13" font="2">can simultaneously invoke methods on the same instance of that class.</text>
<text top="757" left="190" width="518" height="13" font="2">In line with earlier characterisations of safety, one could deﬁne a programming</text>
<text top="775" left="167" width="540" height="13" font="2">language to be thread-safe if its semantics is well-deﬁned in the presence of multi-</text>
<text top="793" left="167" width="540" height="13" font="2">threading. Even a supposedly safe programming language such as Java is inherently</text>
<text top="811" left="167" width="540" height="13" font="2">unsafe when it comes to concurrency: if a Java program contains data races, it</text>
<text top="829" left="167" width="540" height="13" font="2">may exhibit very strange behaviour, and one cannot make any guarantees about</text>
<text top="847" left="167" width="540" height="13" font="2">the semantics whatsoever. (A program contains a data race if two threads may</text>
<text top="865" left="167" width="522" height="13" font="2">simultaneously access the same variable, where one of these accesses is a write.)</text>
<text top="883" left="190" width="518" height="14" font="2">For example, suppose initially x and y have the value 0 and we execute the</text>
<text top="900" left="167" width="144" height="13" font="2">following two threads:</text>
<text top="930" left="183" width="63" height="12" font="2">Thread 1</text>
<text top="930" left="356" width="63" height="12" font="2">Thread 2</text>
<text top="948" left="191" width="55" height="12" font="2">r1 = x;</text>
<text top="948" left="364" width="55" height="12" font="2">r2 = y;</text>
<text top="966" left="191" width="47" height="12" font="2">y = 1;</text>
<text top="966" left="364" width="47" height="12" font="2">x = 2;</text>
<text top="993" left="167" width="540" height="14" font="2">One would expect either r1 or r2 to have the value 0 at the end of the execution.</text>
<text top="1011" left="167" width="540" height="14" font="2">However, it is possible that in the end r1 == 2 and r2 == 1. The reason for this</text>
<text top="1029" left="167" width="540" height="13" font="2">is that a compiler is allowed to swap the order of two assignments in a thread if,</text>
<text top="1047" left="167" width="540" height="13" font="2">within that single thread, the order of these assignments does not matter. (Such</text>
<text top="1065" left="167" width="540" height="13" font="2">re-orderings can make a program more eﬃcient, if say a value held in a register can</text>
<text top="1082" left="167" width="441" height="13" font="2">be reused.) So a compiler could reorder the statements in thread 1.</text>
<text top="1100" left="190" width="518" height="13" font="2">In fact, things can get a lot weirder still. Some language deﬁnitions do not</text>
<text top="1118" left="167" width="540" height="13" font="2">even exclude the possibility of so-called out-of-thin-air values, where a concurrent</text>
<text top="1163" left="430" width="15" height="13" font="2">18</text>
</page>
<page number="19" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="167" width="540" height="13" font="2">program which only swaps values around between various variables can result in a</text>
<text top="186" left="167" width="540" height="13" font="2">variable receiving some arbitrary value, say 42, even though initially all the variables</text>
<text top="204" left="167" width="115" height="13" font="2">were zero [AB10].</text>
<text top="222" left="190" width="518" height="13" font="2">The natural mental model of how a multi-threading program works, namely</text>
<text top="240" left="167" width="540" height="13" font="2">that all threads simply read and write values in the same shared memory – a so-</text>
<text top="258" left="167" width="540" height="13" font="2">called strong memory model – is fundamentally incorrect. Instead, we can only</text>
<text top="275" left="167" width="540" height="13" font="2">assume a relaxed or weak memory model, which accounts for the fact that individual</text>
<text top="293" left="167" width="540" height="13" font="2">threads keep shadow copies of parts of the shared memory in local caches, and where</text>
<text top="311" left="167" width="540" height="13" font="2">compiler optimisations like the one discussed above are possible. This aﬀects both</text>
<text top="329" left="167" width="540" height="13" font="2">the possible behaviour of programs, and their eﬃciency. (For more on this read</text>
<text top="347" left="167" width="61" height="13" font="2">[Myc07].)</text>
<text top="365" left="190" width="518" height="13" font="2">Of course, declarative programming languages have an easier job in ensuring</text>
<text top="383" left="167" width="497" height="13" font="2">thread safety, as they avoid side-eﬀects – and hence data races – altogether.</text>
<text top="428" left="167" width="31" height="19" font="6">3.5</text>
<text top="428" left="223" width="339" height="19" font="6">Other language-level guarantees</text>
<text top="465" left="167" width="540" height="13" font="2">Apart from typing information, a programming language can allow programmers to</text>
<text top="483" left="167" width="366" height="13" font="2">express other kinds of properties and also enforce these.</text>
<text top="523" left="167" width="41" height="16" font="1">3.5.1</text>
<text top="523" left="229" width="80" height="16" font="1">Visibility</text>
<text top="553" left="167" width="540" height="13" font="2">One such property is visibility. In object-oriented languages the programmer can</text>
<text top="570" left="167" width="540" height="13" font="2">specify if ﬁelds and methods are private or public, or something in between. For</text>
<text top="588" left="167" width="540" height="13" font="2">example C++ has three levels of visibility: public, protected, and private. Java has</text>
<text top="606" left="167" width="540" height="13" font="2">four levels, as it also has a (default) package visibility. This provides some form</text>
<text top="624" left="167" width="540" height="13" font="2">of access control. (We will stick to the term visibility because access control can</text>
<text top="642" left="167" width="247" height="13" font="2">already mean lots of diﬀerent things.)</text>
<text top="660" left="190" width="465" height="13" font="2">Beware that the meaning of protected in Java and C++ is diﬀerent.</text>
<text top="658" left="655" width="6" height="9" font="5">3</text>
<text top="660" left="674" width="34" height="13" font="2">More</text>
<text top="678" left="167" width="540" height="13" font="2">importantly, the guarantees that Java and C++ provide for visibility are very dif-</text>
<text top="696" left="167" width="540" height="13" font="2">ferent. The absence of memory and type safety in C++ means that any visibility</text>
<text top="714" left="167" width="540" height="13" font="2">restrictions in C++ can be broken. In contrast, in safe languages such as Java and</text>
<text top="732" left="167" width="540" height="13" font="2">C# the visibility declarations are rigorously enforced by the programming language:</text>
<text top="750" left="167" width="540" height="13" font="2">e.g., if you deﬁne a ﬁeld as private, you are guaranteed that no-one else can touch</text>
<text top="768" left="167" width="14" height="13" font="2">it.</text>
<text top="786" left="190" width="518" height="13" font="2">The language guarantees provided by visibility are of course also useful from a</text>
<text top="804" left="167" width="540" height="13" font="2">software engineering point of view, as it rigorously enforces well-deﬁned interfaces.</text>
<text top="822" left="167" width="540" height="13" font="2">This is also useful for security. E.g., an interface can provide a small choke point</text>
<text top="839" left="167" width="540" height="13" font="2">for all data to pass through, which can then be the place to perform input validation.</text>
<text top="857" left="167" width="540" height="13" font="2">In a language that is not type-safe one can never guarantee that such an interface</text>
<text top="875" left="167" width="540" height="13" font="2">cannot be by-passed. This becomes especially important in a setting where we have</text>
<text top="893" left="167" width="540" height="13" font="2">some untrusted code, i.e., if we trust some parts of the code more than others,</text>
<text top="911" left="167" width="540" height="13" font="2">typically because part of the code base is mobile code that we downloaded say over</text>
<text top="929" left="167" width="540" height="13" font="2">the internet, as is for instance the case with a Java applet in a web page. As we</text>
<text top="947" left="167" width="540" height="13" font="2">will discuss later, in Chapter 4, visibility is not enough here, and mechanism for</text>
<text top="965" left="167" width="485" height="13" font="2">enforcing more expressive policies than possible with visibility are needed.</text>
<text top="987" left="190" width="518" height="13" font="2">Note that in Java protected is less restrictive in default package visibility: pro-</text>
<text top="1005" left="167" width="540" height="13" font="2">tected ﬁelds are accessible in all subclasses and in the package. This means that,</text>
<text top="1023" left="167" width="540" height="13" font="2">from a security point of view, protected ﬁelds are not really that protected, and</text>
<text top="1041" left="167" width="540" height="13" font="2">neither are package-visible ﬁelds: any code in the same package can access them.</text>
<text top="1059" left="167" width="540" height="13" font="2">In a setting where we have untrusted, possibly malicious code, an attacker can get</text>
<text top="1085" left="184" width="5" height="8" font="14">3</text>
<text top="1088" left="190" width="517" height="11" font="10">In Java, protected methods are accessible in subclasses; in C++, protected methods are also</text>
<text top="1102" left="167" width="279" height="11" font="10">accessible in so-called friend classes and functions.</text>
<text top="1163" left="430" width="15" height="13" font="2">19</text>
</page>
<page number="20" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="167" width="540" height="13" font="2">access to protected ﬁelds simply by declaring his attack code to be in the same</text>
<text top="186" left="167" width="55" height="13" font="2">package.</text>
<text top="204" left="190" width="518" height="13" font="2">To defend against this, sealed packages were introduced in Java 1.4. By declar-</text>
<text top="222" left="167" width="540" height="13" font="2">ing a package as sealed, you eﬀectively close the package, disallowing further exten-</text>
<text top="240" left="167" width="540" height="14" font="2">sions in other ﬁles. The package java.lang has always been a sealed package, since</text>
<text top="258" left="167" width="540" height="13" font="2">the very ﬁrst release of Java, because it contains security-critical functionality that</text>
<text top="275" left="167" width="540" height="13" font="2">attackers should not be able to mess with by getting access to protected ﬁelds or</text>
<text top="293" left="167" width="59" height="13" font="2">methods.</text>
<text top="311" left="190" width="518" height="13" font="2">Even if a class is in a sealed package, an attacker can try to get access to</text>
<text top="329" left="167" width="540" height="13" font="2">protected ﬁelds of some object by creating a new subclass. To prevent this, a class</text>
<text top="347" left="167" width="186" height="14" font="2">has to be declared as final.</text>
<text top="365" left="190" width="518" height="14" font="2">All this means that protected is maybe a bit of a misnomer, as for ﬁelds it</text>
<text top="383" left="167" width="143" height="13" font="2">eﬀectively only means</text>
<text top="417" left="220" width="436" height="12" font="2">protected-but-only-in-a-final-class-in-a-sealed-package.</text>
<text top="456" left="167" width="41" height="16" font="1">3.5.2</text>
<text top="456" left="229" width="420" height="16" font="1">Constant values and immutable data structures</text>
<text top="485" left="167" width="540" height="13" font="2">Another property commonly supported at programming language level is that of</text>
<text top="503" left="167" width="540" height="14" font="2">something being a constant or immutable, by declaring it const in C or C++,</text>
<text top="522" left="167" width="231" height="12" font="2">final in Java, or readonly in C#.</text>
<text top="539" left="190" width="518" height="13" font="2">Although Java is a safe language, ﬁnal ﬁelds are not quite constants: ﬁnal ﬁelds</text>
<text top="557" left="167" width="540" height="13" font="2">are given their values during object initialisation (or during class initialisation, in</text>
<text top="575" left="167" width="540" height="13" font="2">case of static ﬁelds). So there is a (hopefully brief) period of time prior to this, when</text>
<text top="593" left="167" width="540" height="13" font="2">they still have their default initial value. Final instance ﬁelds cannot be read before</text>
<text top="611" left="167" width="540" height="13" font="2">they are initialised, so they really do behave as constants. However, ﬁnal static</text>
<text top="629" left="167" width="540" height="13" font="2">ﬁelds can be read before they are initialised, namely in case there are circularities</text>
<text top="647" left="167" width="164" height="13" font="2">in the class initialisation.</text>
<text top="665" left="190" width="279" height="13" font="2">For example, consider the two Java classes</text>
<text top="696" left="175" width="71" height="12" font="2">class A {</text>
<text top="714" left="191" width="212" height="12" font="2">final static int x = B.y+1;</text>
<text top="732" left="175" width="8" height="12" font="2">}</text>
<text top="768" left="175" width="71" height="12" font="2">class B {</text>
<text top="785" left="191" width="212" height="12" font="2">final static int y = A.x+1;</text>
<text top="803" left="175" width="8" height="12" font="2">}</text>
<text top="832" left="167" width="540" height="14" font="2">Here one of the static ﬁelds, A.x or B.y – will have to be read before it is initialised</text>
<text top="850" left="167" width="540" height="13" font="2">(when it still has its default initial value zero), namely in order to initialise the</text>
<text top="868" left="167" width="540" height="14" font="2">other one. Depending on the order in which these classes are loaded A.x will be</text>
<text top="886" left="167" width="199" height="14" font="2">one and B.y two, or vice versa</text>
<text top="884" left="367" width="6" height="9" font="5">4</text>
<text top="886" left="373" width="4" height="13" font="2">.</text>
<text top="904" left="190" width="518" height="13" font="2">The example above shows that ﬁnal static ﬁelds are not quite compile-time</text>
<text top="922" left="167" width="540" height="13" font="2">constants. In general, apparently simple notions (such as being a constant) can be</text>
<text top="940" left="167" width="540" height="13" font="2">surprisingly tricky if you look closely at the semantics. The precise semantics of</text>
<text top="959" left="167" width="288" height="12" font="2">const in C and C++ can also be confusing.</text>
<text top="984" left="190" width="518" height="13" font="2">Apart from having some constants for primitives types, such as integers, one may</text>
<text top="1002" left="167" width="540" height="13" font="2">also want more complex data structures to be constant or immutable. For example,</text>
<text top="1020" left="167" width="540" height="13" font="2">in an object-oriented language one could want certain objects to be immutable,</text>
<text top="1038" left="167" width="485" height="13" font="2">meaning that their state cannot be modiﬁed after they have been created.</text>
<text top="1065" left="184" width="5" height="8" font="14">4</text>
<text top="1067" left="190" width="517" height="11" font="10">Clearly, such circularities in the initialisation are something you want to avoid! The code</text>
<text top="1081" left="167" width="540" height="11" font="10">analysis tool FindBugs for Java includes a check to detect such circularities. Findbugs is free</text>
<text top="1095" left="167" width="540" height="11" font="10">to download from http://findbugs.sourceforge.net and very easy to get working. If you have</text>
<text top="1109" left="167" width="473" height="11" font="10">never used FindBugs or some other static analysis tool, download it and give it a go!</text>
<text top="1163" left="430" width="15" height="13" font="2">20</text>
</page>
<page number="21" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="190" width="518" height="13" font="2">The classic example of immutable objects are strings in Java. Once an object of</text>
<text top="186" left="167" width="540" height="14" font="2">type String has been created, it cannot be modiﬁed, so we can think of a Java string</text>
<text top="204" left="167" width="540" height="13" font="2">as a constant value. The fact that strings are immutable is in fact crucial for the</text>
<text top="222" left="167" width="540" height="13" font="2">security in Java, as we shall see when we discuss Java sandboxing. More generally,</text>
<text top="240" left="167" width="540" height="13" font="2">any object that you share with untrusted code should better be immutable, if you</text>
<text top="258" left="167" width="540" height="13" font="2">do not want that object to be modiﬁed by that code. One of the classic security</text>
<text top="275" left="167" width="386" height="13" font="2">loopholes in an early release of Java was due to mutability.</text>
<text top="293" left="190" width="518" height="13" font="2">In fact, making objects immutable is a recommended programming practice. As</text>
<text top="311" left="167" width="497" height="13" font="2">Brian Goetz puts it, immutable objects can greatly simplify your life [Goe03]</text>
<text top="309" left="664" width="6" height="9" font="5">5</text>
<text top="311" left="671" width="36" height="13" font="2">. You</text>
<text top="329" left="167" width="540" height="13" font="2">do not have to worry about aliasing or – in a multi-threaded program – data races</text>
<text top="347" left="167" width="266" height="13" font="2">and things become conceptually simpler.</text>
<text top="365" left="190" width="518" height="13" font="2">Immutability of objects is a property that could be expressible and enforced by</text>
<text top="383" left="167" width="540" height="13" font="2">(the type system of) a programming language. The object-oriented language Scala,</text>
<text top="401" left="167" width="540" height="13" font="2">which combines Java with aspects of functional programming languages, does so.</text>
<text top="419" left="167" width="540" height="13" font="2">Scala makes an explicit distinction between mutable and immutable data structures</text>
<text top="437" left="167" width="255" height="13" font="2">(for both primitives types and classes).</text>
<text top="473" left="167" width="313" height="13" font="2">Functionality versus security for visibility</text>
<text top="491" left="167" width="540" height="13" font="2">Visibility provides another illustration of how security and functionality can be at</text>
<text top="509" left="167" width="415" height="13" font="2">odds with each other. Doug Lea’s coding guidelines for Java</text>
<text top="506" left="582" width="6" height="9" font="5">6</text>
<text top="509" left="596" width="112" height="13" font="2">suggest that you</text>
<text top="526" left="167" width="288" height="14" font="2">should use protected rather than private:</text>
<text top="543" left="205" width="252" height="13" font="2">“Generally prefer protected to private.</text>
<text top="561" left="205" width="465" height="13" font="2">Rationale: Unless you have good reason for sealing-in a particular strat-</text>
<text top="579" left="205" width="465" height="13" font="2">egy for using a variable or method, you might as well plan for change</text>
<text top="597" left="205" width="465" height="13" font="2">via subclassing. On the other hand, this almost always entails more</text>
<text top="615" left="205" width="465" height="13" font="2">work. Basing other code in a base class around protected variables and</text>
<text top="633" left="205" width="465" height="13" font="2">methods is harder, since you have to either loosen or check assumptions</text>
<text top="651" left="205" width="465" height="13" font="2">about their properties. (Note that in Java, protected methods are also</text>
<text top="669" left="205" width="465" height="13" font="2">accessible from unrelated classes in the same package. There is hardly</text>
<text top="687" left="205" width="266" height="13" font="2">ever any reason to exploit this though.)”</text>
<text top="704" left="167" width="448" height="13" font="2">But Gary McGraw and Edward Felten’s security guidelines for Java</text>
<text top="702" left="616" width="6" height="9" font="5">7</text>
<text top="704" left="628" width="80" height="13" font="2">suggests the</text>
<text top="722" left="167" width="167" height="13" font="2">opposite, as these include</text>
<text top="739" left="205" width="465" height="13" font="2">“Make all variables private. If you want to allow outside code to access</text>
<text top="757" left="205" width="451" height="13" font="2">variables in an object, this should be done via get and set methods.”</text>
<text top="774" left="167" width="540" height="14" font="2">and warn against using package-level visibility (and hence also protected, as this</text>
<text top="792" left="167" width="117" height="13" font="2">is less restrictive):</text>
<text top="809" left="205" width="267" height="13" font="2">“Rule 4: Don’t depend on package scope</text>
<text top="837" left="205" width="465" height="13" font="2">Classes, methods, and variables that aren’t explicitly labelled as public,</text>
<text top="855" left="205" width="465" height="13" font="2">private, or protected are accessible within the same package. Don’t rely</text>
<text top="873" left="205" width="465" height="13" font="2">on this for security. Java classes aren’t closed [i.e., sealed], so an attacker</text>
<text top="891" left="205" width="465" height="13" font="2">could introduce a new class into your package and use this new class to</text>
<text top="909" left="205" width="331" height="13" font="2">access the things you thought you were hiding. . . .</text>
<text top="937" left="205" width="465" height="13" font="2">Package scope makes a lot of sense from a software engineering stand-</text>
<text top="955" left="205" width="465" height="13" font="2">point, since it prevents innocent, accidental access to things you want</text>
<text top="973" left="205" width="297" height="13" font="2">to hide. But don’t depend on it for security.”</text>
<text top="990" left="167" width="540" height="13" font="2">The ﬁnal sentence here recognises the possible conﬂict between a software engineer-</text>
<text top="1008" left="167" width="540" height="13" font="2">ing standpoint – extensibility is good – and security standpoint – extensibility is</text>
<text top="1026" left="167" width="305" height="13" font="2">evil, or at least a potential source of problems.</text>
<text top="1118" left="184" width="5" height="8" font="14">5</text>
<text top="1121" left="190" width="421" height="10" font="10">http://www-106.ibm.com/developerworks/java/library/j-jtp02183.html</text>
<text top="1163" left="430" width="15" height="13" font="2">21</text>
</page>
<page number="22" position="absolute" top="0" left="0" height="1188" width="918">
<text top="269" left="167" width="154" height="28" font="4">Chapter 4</text>
<text top="339" left="167" width="413" height="33" font="3">Language-based access</text>
<text top="384" left="167" width="127" height="33" font="3">control</text>
<text top="477" left="167" width="540" height="13" font="2">When the operating system performs access control for a program in execution, as</text>
<text top="495" left="167" width="540" height="13" font="2">discussed in Chapter 2, it equally does so for all program code: the operating system</text>
<text top="513" left="167" width="540" height="13" font="2">has one access policy for the program as a whole, so all the code in it executes with</text>
<text top="531" left="167" width="139" height="13" font="2">the same permissions</text>
<text top="529" left="306" width="6" height="9" font="5">1</text>
<text top="531" left="313" width="4" height="13" font="2">.</text>
<text top="549" left="190" width="518" height="13" font="2">By contrast, language-based access control does not treat all parts of the</text>
<text top="567" left="167" width="540" height="13" font="2">program in the same way. Here the language provides a sandboxing mechanism</text>
<text top="585" left="167" width="540" height="13" font="2">to provide more ﬁne-grained access control, where diﬀerent parts of the program –</text>
<text top="603" left="167" width="198" height="13" font="2">which we will call components</text>
<text top="600" left="365" width="6" height="9" font="5">2</text>
<text top="603" left="372" width="241" height="13" font="2">– can be subject to diﬀerent policies.</text>
<text top="648" left="167" width="31" height="19" font="6">4.1</text>
<text top="648" left="223" width="209" height="19" font="6">Language platforms</text>
<text top="685" left="167" width="540" height="13" font="2">Modern programming language platforms (or ‘frameworks’), such as Java or .NET,</text>
<text top="703" left="167" width="48" height="13" font="2">provide</text>
<text top="732" left="190" width="426" height="14" font="2">• an execution engine that is responsible for executing code, and</text>
<text top="762" left="190" width="518" height="14" font="2">• an API that exposes functionality of the platform itself and of the underlying</text>
<text top="781" left="205" width="116" height="13" font="2">operating system.</text>
<text top="810" left="167" width="566" height="14" font="2">The API provides basic building blocks for programs, (for example, java.lang.Object),</text>
<text top="828" left="167" width="540" height="14" font="2">an interface to the underlying operating system (for example System.out.println),</text>
<text top="846" left="167" width="540" height="13" font="2">and provides some components responsible for the security functionality of the plat-</text>
<text top="864" left="167" width="543" height="14" font="2">form (for example the java.lang.ClassLoader and java.lang.SecurityManager).</text>
<text top="882" left="190" width="518" height="13" font="2">The Java platform is oﬃcially called is the Java Runtime Environment, com-</text>
<text top="900" left="167" width="540" height="13" font="2">monly abbreviated to the Java Runtime. It consists of the Java Virtual Machine</text>
<text top="918" left="167" width="540" height="13" font="2">and an implementation of the Java API. The .NET framework also consists of a</text>
<text top="936" left="167" width="540" height="13" font="2">virtual machine, the Common Language Runtime or CLR, and a library, the .NET</text>
<text top="954" left="167" width="159" height="13" font="2">Framework class library.</text>
<text top="972" left="190" width="518" height="13" font="2">The platform also performs access control where it treats diﬀerent parts of the</text>
<text top="990" left="167" width="540" height="13" font="2">code (diﬀerent components) diﬀerently, as illustrated in Figure 4.1. There are then</text>
<text top="1008" left="167" width="540" height="13" font="2">two layers of access control, one by the language platform and one by the operating</text>
<text top="1034" left="184" width="5" height="8" font="14">1</text>
<text top="1036" left="190" width="517" height="11" font="10">One exception here are system calls: when a program invokes an operating system call, this</text>
<text top="1050" left="167" width="540" height="11" font="10">system call is executed with higher privileges, for which the operating system will do a context</text>
<text top="1064" left="167" width="217" height="11" font="10">switch for user mode into kernel mode.</text>
<text top="1077" left="184" width="5" height="8" font="14">2</text>
<text top="1079" left="190" width="517" height="11" font="10">The notion of component was popularised by Szyperski [SGM02], as a term for a reusable</text>
<text top="1093" left="167" width="540" height="11" font="10">piece of software. We use the term rather loosely here, but components in the more precise sense</text>
<text top="1107" left="167" width="379" height="11" font="10">of Szyperski could certainly be used as the components we consider.</text>
<text top="1163" left="430" width="15" height="13" font="2">22</text>
</page>
<page number="23" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="15" size="9" family="Times" color="#ffffff"/>
<text top="243" left="365" width="45" height="13" font="10">program</text>
<text top="389" left="279" width="55" height="13" font="15">Hardware </text>
<text top="390" left="335" width="153" height="12" font="8">(CPU, memory, I/O peripherals)</text>
<text top="210" left="306" width="50" height="13" font="10">Module A</text>
<text top="360" left="332" width="104" height="15" font="9">Operating System</text>
<text top="210" left="419" width="51" height="13" font="10">Module B</text>
<text top="270" left="431" width="51" height="11" font="13">policy for  B</text>
<text top="269" left="313" width="51" height="11" font="13">policy for  A</text>
<text top="291" left="335" width="101" height="13" font="10">Language Platform</text>
<text top="307" left="346" width="80" height="11" font="13">(eg. Java or .NET)</text>
<text top="331" left="361" width="42" height="13" font="10">process</text>
<text top="510" left="167" width="540" height="13" font="2">Figure 4.1: Security controls at programming platform level: separation between</text>
<text top="527" left="167" width="308" height="13" font="2">components and access control per component.</text>
<text top="575" left="167" width="540" height="13" font="2">system, which is a nice example of Defence in Depth. One could in principle get rid</text>
<text top="593" left="167" width="540" height="13" font="2">of the whole operating system, or ‘hide’ it under the language platform, so that the</text>
<text top="611" left="167" width="540" height="13" font="2">language platform is the only interface to the hardware for users and application</text>
<text top="629" left="167" width="453" height="13" font="2">programs. This is for example what is done on JavaCard smartcards.</text>
<text top="674" left="167" width="31" height="19" font="6">4.2</text>
<text top="674" left="223" width="446" height="19" font="6">Why to do language-based access control?</text>
<text top="711" left="167" width="540" height="13" font="2">Why would one want ﬁne-grained access control which enforces diﬀerent policies</text>
<text top="729" left="167" width="540" height="13" font="2">for diﬀerent parts of the code? The reason is that large, modern applications are</text>
<text top="747" left="167" width="540" height="13" font="2">composed of code from diﬀerent sources, not all of them equally trustworthy. Es-</text>
<text top="765" left="167" width="540" height="13" font="2">pecially mobile code – downloaded over the internet to extend an application ‘on</text>
<text top="783" left="167" width="280" height="13" font="2">the ﬂy’ – should be treated with suspicion.</text>
<text top="801" left="190" width="518" height="13" font="2">The prototypical example for this are Java applets in a web browser. A Java</text>
<text top="819" left="167" width="540" height="13" font="2">applet is a Java program downloaded over the web and executed in a web browser;</text>
<text top="837" left="167" width="540" height="13" font="2">clearly you do not want to execute this code with all the access rights of the user,</text>
<text top="855" left="167" width="540" height="13" font="2">of even the access rights of the web browser. For example, your web browser can</text>
<text top="873" left="167" width="540" height="13" font="2">access the hard disk, but you don’t want to give some applet on any web page that</text>
<text top="890" left="167" width="35" height="13" font="2">right.</text>
<text top="908" left="190" width="518" height="13" font="2">Nowadays other examples of mobile code are much more prevalent than Java</text>
<text top="926" left="167" width="257" height="13" font="2">applets: browser extensions, JavaScript</text>
<text top="924" left="424" width="6" height="9" font="5">3</text>
<text top="926" left="436" width="271" height="13" font="2">ActiveX, and mobile phone apps. In fact,</text>
<text top="944" left="167" width="540" height="13" font="2">over the past decade the term ‘mobile code’ has quickly turned into a pleonasm:</text>
<text top="962" left="167" width="540" height="13" font="2">most code is downloaded or regularly updated over the internet, including the op-</text>
<text top="980" left="167" width="540" height="13" font="2">erating system itself. Many of these forms of mobile code are much more dangerous</text>
<text top="998" left="167" width="540" height="13" font="2">than applets, as there are no sandboxing mechanisms in place to constrain them.</text>
<text top="1016" left="167" width="540" height="13" font="2">If you download a browser plugin to your web browser, the code of this plugin can</text>
<text top="1034" left="167" width="419" height="13" font="2">probably be executed with the same rights as the browser itself.</text>
<text top="1060" left="184" width="5" height="8" font="14">3</text>
<text top="1062" left="190" width="276" height="11" font="10">Note that JavaScript has nothing to with Java!</text>
<text top="1062" left="478" width="229" height="11" font="10">Java is an object-oriented programming</text>
<text top="1077" left="167" width="540" height="11" font="10">language, JavaScript a scripting language used in web pages. They have some basic notation in</text>
<text top="1091" left="167" width="540" height="11" font="10">common, both use syntax inspired by C (i.e., lots of curly brackets), and they unfortunately have</text>
<text top="1105" left="167" width="80" height="11" font="10">similar names.</text>
<text top="1163" left="430" width="15" height="13" font="2">23</text>
</page>
<page number="24" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="190" width="518" height="13" font="2">When thinking about mobile code, one should also be aware that the distinction</text>
<text top="186" left="167" width="540" height="13" font="2">between data and program code is often very blurred. Much of what we think of as</text>
<text top="204" left="167" width="540" height="13" font="2">data – e.g., Oﬃce documents and spreadsheets, PDF or postscript ﬁles, etc – can</text>
<text top="222" left="167" width="540" height="13" font="2">in reality contain executable content. So much of the ‘data’ we email around and</text>
<text top="240" left="167" width="211" height="13" font="2">download is in fact mobile code.</text>
<text top="258" left="190" width="518" height="13" font="2">Even for a ‘ﬁxed’ application program that is not extensible using any form of</text>
<text top="275" left="167" width="540" height="13" font="2">mobile code, sandboxing can be useful from a software engineering standpoint, as</text>
<text top="293" left="167" width="540" height="13" font="2">it rigorously enforces modularity, which is also useful for security. For instance, in</text>
<text top="311" left="167" width="540" height="13" font="2">a large program that has potentially dangerous privileges, we can only give these</text>
<text top="329" left="167" width="540" height="13" font="2">privileges to a small part of the code. For a large part of the code bugs and ﬂaws</text>
<text top="347" left="167" width="540" height="13" font="2">become less of a worry, which can be important if some part of the code is taken</text>
<text top="365" left="167" width="540" height="13" font="2">from say some open source project which we think might be buggy. It also means</text>
<text top="383" left="167" width="540" height="13" font="2">that in a security review we may be able to focus attention on a small part of the</text>
<text top="401" left="167" width="347" height="13" font="2">code, which can dramatically reduce costs and eﬀort.</text>
<text top="437" left="167" width="277" height="13" font="2">Trust, trustworthiness, and the TCB</text>
<text top="473" left="167" width="540" height="13" font="2">The notion of trust is important in security. It is also a source of confusion, especially</text>
<text top="491" left="167" width="540" height="13" font="2">if people are sloppy in their terminology, and do not distinguish between trust and</text>
<text top="509" left="167" width="120" height="13" font="2">trustworthiness.</text>
<text top="526" left="190" width="518" height="13" font="2">Depending on your point of view, trust can be something good and desirable,</text>
<text top="544" left="167" width="540" height="13" font="2">or something bad and undesirable. Trust between parties is good in that it enables</text>
<text top="562" left="167" width="540" height="13" font="2">easy interaction and good collaboration between them. However, trust is bad in</text>
<text top="580" left="167" width="540" height="13" font="2">that trust in another party means that party can do damage to you, if it turns out</text>
<text top="598" left="167" width="540" height="13" font="2">not to be trustworthy. For example, if you give someone your bankcard and tell</text>
<text top="616" left="167" width="540" height="13" font="2">them your PIN code, you trust them; this can be useful, for instance if you want</text>
<text top="634" left="167" width="498" height="13" font="2">them to do some shopping for you, but is clearly also potentially dangerous.</text>
<text top="652" left="190" width="518" height="13" font="2">Note that if a party is not trustworthy, then it may be so unintentionally (because</text>
<text top="670" left="167" width="540" height="13" font="2">it is careless or, in the case of software, riddled with security vulnerabilities) or</text>
<text top="688" left="167" width="319" height="13" font="2">intentionally (because it is downright malicious).</text>
<text top="706" left="190" width="518" height="13" font="2">When considering a system that is meant to meet some security objectives, it is</text>
<text top="724" left="167" width="540" height="13" font="2">important to consider which parts of that system are trusted in order to meet that</text>
<text top="742" left="167" width="424" height="13" font="2">objective. This called the Trusted Computing Base or TCB.</text>
<text top="760" left="190" width="518" height="13" font="2">Ideally, the TCB should be as small as possible. The smaller the TCB, the</text>
<text top="777" left="167" width="540" height="13" font="2">less likely that it contains security vulnerabilities. (Still, you should never under-</text>
<text top="795" left="167" width="540" height="13" font="2">estimates people’s stupidity – or an attacker’s creativity – to introduce security</text>
<text top="813" left="167" width="540" height="13" font="2">vulnerabilities in even the smallest piece of software.) Also, the smaller the TCB,</text>
<text top="831" left="167" width="540" height="13" font="2">the less eﬀort it takes to get some conﬁdence that it is trustworthy, for example, in</text>
<text top="849" left="167" width="540" height="13" font="2">the case of software, by doing a code review or by performing some (penetration)</text>
<text top="867" left="167" width="48" height="13" font="2">testing.</text>
<text top="919" left="167" width="31" height="19" font="6">4.3</text>
<text top="919" left="223" width="437" height="19" font="6">Language-based access control and safety</text>
<text top="957" left="167" width="540" height="13" font="2">Obviously, language-based access control is impossible in a programming language</text>
<text top="975" left="167" width="540" height="13" font="2">that is not memory safe. Without memory safety, there is no way to guarantee</text>
<text top="993" left="167" width="419" height="13" font="2">separation of memory used by diﬀerent program components.</text>
<text top="993" left="600" width="107" height="13" font="2">For example, in</text>
<text top="1010" left="167" width="540" height="13" font="2">Fig. 4.1, code in component A should be prevented from accessing data belonging</text>
<text top="1028" left="167" width="540" height="13" font="2">to component B. Stronger still, it should be prevented from accessing data of the</text>
<text top="1046" left="167" width="540" height="13" font="2">underlying language platform since any data used in enforcing the access control by</text>
<text top="1064" left="167" width="277" height="13" font="2">the language platform could be corrupted.</text>
<text top="1082" left="190" width="518" height="13" font="2">It is also hard to envisage how one could achieve language-based access control</text>
<text top="1100" left="167" width="540" height="13" font="2">without type safety. Access control between components inside a program (as sug-</text>
<text top="1118" left="167" width="540" height="13" font="2">gested by the horizontal arrow in Figure 4.1) relies on the visibility declarations to</text>
<text top="1163" left="430" width="15" height="13" font="2">24</text>
</page>
<page number="25" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="167" width="540" height="13" font="2">deﬁne e.g., public versus private interfaces, as discussed in Section 3.5.1. Without</text>
<text top="186" left="167" width="540" height="13" font="2">type safety any restrictions on visibility can be accidentally or deliberately broken.</text>
<text top="204" left="167" width="540" height="13" font="2">Also, without type safety one has to be extremely careful with data passed between</text>
<text top="222" left="167" width="540" height="13" font="2">components as arguments or results of procedures and method calls, as this data</text>
<text top="240" left="167" width="540" height="13" font="2">can be malformed. This also applies to data shared between components via alias-</text>
<text top="258" left="167" width="540" height="13" font="2">ing. Of course, passing data between components quickly leads to aliasing. In a</text>
<text top="275" left="167" width="540" height="13" font="2">concurrent setting a thread in one component could corrupt shared data while an</text>
<text top="293" left="167" width="540" height="13" font="2">thread in another component is using it. (As we will discuss in Section 4.4.1, even</text>
<text top="311" left="167" width="540" height="13" font="2">in a memory- and type-safe language aliasing between components is a notorious</text>
<text top="329" left="167" width="220" height="13" font="2">source of security vulnerabilities.)</text>
<text top="347" left="190" width="518" height="13" font="2">In light of the discussion above, one could even deﬁne a language as being safe</text>
<text top="365" left="167" width="310" height="13" font="2">iﬀ it is possible to securely provide sandboxing.</text>
<text top="409" left="167" width="31" height="19" font="6">4.4</text>
<text top="409" left="223" width="444" height="19" font="6">How to do language-based access control?</text>
<text top="447" left="167" width="540" height="13" font="2">Any kind of access control level, involves policies to specify access rights, a policy</text>
<text top="465" left="167" width="437" height="13" font="2">language to express these in, and a mechanism to enforce them.</text>
<text top="482" left="190" width="518" height="13" font="2">Sandboxing at the language level involves policies that assign permissions to</text>
<text top="500" left="167" width="540" height="13" font="2">program components. The basis for assigning permissions is typically the origin</text>
<text top="518" left="167" width="540" height="13" font="2">of this code, which can be the physical origin of the code (did it come from the</text>
<text top="536" left="167" width="540" height="13" font="2">hard disk – and, if so, from which directory– instead of being downloaded over the</text>
<text top="554" left="167" width="461" height="13" font="2">internet) or digitally signatures on the code that prove its provenance.</text>
<text top="572" left="190" width="518" height="13" font="2">The permissions that are given are rights to perform all kinds of actions, e.g.,</text>
<text top="590" left="167" width="540" height="13" font="2">accessing the ﬁle system, the network, the screen, etc. Some permissions are pro-</text>
<text top="608" left="167" width="540" height="13" font="2">vided by the language platform, and used to control access to functionality that the</text>
<text top="626" left="167" width="394" height="13" font="2">platform provides. In Java the standard permissions include</text>
<text top="652" left="190" width="354" height="15" font="2">• java.io.FilePermission for the ﬁle system access</text>
<text top="680" left="190" width="518" height="15" font="2">• java.net.SocketPermission, java.net.NetPermission for network access,</text>
<text top="699" left="205" width="24" height="13" font="2">and</text>
<text top="726" left="190" width="351" height="15" font="2">• java.awt.AWTPermission for user interface access.</text>
<text top="754" left="167" width="540" height="13" font="2">For speciﬁc platforms there may be other permissions. For example the MIDP</text>
<text top="772" left="167" width="533" height="13" font="2">platform for Java-enabled mobile phones distinguishes permissions for components</text>
<text top="769" left="701" width="6" height="9" font="5">4</text>
<text top="790" left="167" width="329" height="13" font="2">to dial phone numbers or send SMS text messages</text>
<text top="787" left="496" width="6" height="9" font="5">5</text>
<text top="790" left="503" width="4" height="13" font="2">.</text>
<text top="808" left="190" width="189" height="13" font="2">An example policy in Java is</text>
<text top="836" left="183" width="188" height="12" font="2">grant signedBy &#34;Radboud&#34;</text>
<text top="854" left="183" width="94" height="12" font="2">{ permission</text>
<text top="871" left="207" width="361" height="12" font="2">java.io.FilePermission &#34;/home/ds/erik&#34;,&#34;read&#34;;</text>
<text top="889" left="183" width="16" height="12" font="2">};</text>
<text top="907" left="183" width="259" height="12" font="2">grant codebase &#34;file:/home/usr/*&#34;</text>
<text top="925" left="183" width="94" height="12" font="2">{ permission</text>
<text top="943" left="207" width="361" height="12" font="2">java.io.FilePermission &#34;/home/ds/erik&#34;,&#34;read&#34;;</text>
<text top="961" left="183" width="8" height="12" font="2">}</text>
<text top="987" left="167" width="540" height="14" font="2">which grants all code signed by ‘Radboud’ and all code in /home/usr on the ﬁle</text>
<text top="1005" left="167" width="540" height="13" font="2">system read-permission in the speciﬁed directory. Here ‘Radboud’ is an alias for</text>
<text top="1022" left="167" width="453" height="13" font="2">which the corresponding public key has to be deﬁned in the keystore.</text>
<text top="1047" left="184" width="5" height="8" font="14">4</text>
<text top="1049" left="190" width="365" height="11" font="10">The Java components here are called midlets rather than applets.</text>
<text top="1061" left="184" width="5" height="8" font="14">5</text>
<text top="1064" left="190" width="517" height="11" font="10">Here the MIDP access control is very ﬁne-grained. For example, a midlet can be given the</text>
<text top="1078" left="167" width="540" height="11" font="10">right to send text messages or use internet access, but there may then still be a security pop-up</text>
<text top="1092" left="167" width="540" height="11" font="10">where the user is asked for permission. Depending on how far the midlet is trusted, permission</text>
<text top="1106" left="167" width="540" height="11" font="10">may then be granted to the midlet for its entire lifetime, only for the current session, or it may be</text>
<text top="1120" left="167" width="296" height="11" font="10">a one-shot permission, e.g., for sending a single SMS.</text>
<text top="1163" left="430" width="15" height="13" font="2">25</text>
</page>
<page number="26" position="absolute" top="0" left="0" height="1188" width="918">
<text top="166" left="167" width="41" height="16" font="1">4.4.1</text>
<text top="166" left="229" width="122" height="16" font="1">Stack walking</text>
<text top="195" left="167" width="540" height="13" font="2">Program components can invoke each other’s functionality by method calls. This</text>
<text top="213" left="167" width="540" height="13" font="2">complicates the precise meaning of policies: if a component A uses functionality of</text>
<text top="231" left="167" width="540" height="13" font="2">another component B, should it run with its own permissions or that of the other</text>
<text top="249" left="167" width="78" height="13" font="2">component?</text>
<text top="276" left="190" width="518" height="14" font="2">Assume that a method good() is in a component Trusted that has permission</text>
<text top="294" left="167" width="540" height="14" font="2">to reformat the hard disk, and a method evil() is in a less-trusted component</text>
<text top="313" left="167" width="266" height="12" font="2">Evil that does not have this permission.</text>
<text top="330" left="190" width="518" height="14" font="2">If the method good() invokes the method evil(), should evil() have permis-</text>
<text top="348" left="167" width="540" height="14" font="2">sion to reformat the hard disk? After all, it is acting ‘on behalf of’ good(). The</text>
<text top="366" left="167" width="540" height="13" font="2">obvious answer is that it should not: if so, it would be easy for some untrusted code</text>
<text top="384" left="167" width="104" height="13" font="2">to create havoc.</text>
<text top="402" left="190" width="518" height="14" font="2">The opposite situation is more tricky: if evil() invokes good(), should good()</text>
<text top="420" left="167" width="540" height="13" font="2">still use its permission to reformat the hard disk? Clearly there are dangers. But</text>
<text top="438" left="167" width="540" height="13" font="2">it is unavoidable that trusted components have to carry out requests by untrusted</text>
<text top="455" left="167" width="461" height="13" font="2">components. In fact, this is an important role for trusted components.</text>
<text top="482" left="190" width="518" height="13" font="2">For an analogy in the physical world, assume you walk into the branch oﬃce</text>
<text top="500" left="167" width="540" height="13" font="2">of your bank and ask a cashier for some money from your bank account. From</text>
<text top="518" left="167" width="540" height="13" font="2">the perspective of the bank, you are the untrusted party here and the cashier is</text>
<text top="536" left="167" width="417" height="13" font="2">trusted: the cashier has access to the money and you don’t.</text>
<text top="536" left="598" width="109" height="13" font="2">There may even</text>
<text top="554" left="167" width="540" height="13" font="2">be some bullet proof glass between you and the cashier to help enforce this access</text>
<text top="572" left="167" width="540" height="14" font="2">control. The software equivalent would be an untrusted Client component invoking</text>
<text top="590" left="167" width="540" height="14" font="2">the withdraw cash method of some BankEmployee component. When carrying out</text>
<text top="608" left="167" width="540" height="13" font="2">your request, the cashier will be using his privileges to get to the money. Carrying it</text>
<text top="626" left="167" width="540" height="13" font="2">out with only your permissions is clearly impossible. Of course, the cashier should</text>
<text top="644" left="167" width="540" height="13" font="2">be very careful, and e.g., verify your identity and check your bank balance, before</text>
<text top="662" left="167" width="540" height="13" font="2">handing over any cash. Unfortunately (or fortunately, depending on the point of</text>
<text top="680" left="167" width="540" height="13" font="2">view) human cashiers are not susceptible to buﬀer overﬂow attacks, where a client</text>
<text top="698" left="167" width="540" height="13" font="2">giving a carefully chosen and ridiculously long name will be given piles of cash</text>
<text top="715" left="167" width="129" height="13" font="2">without any checks.</text>
<text top="738" left="190" width="518" height="13" font="2">A standard way to handle this is by stack inspection aka stack walking.</text>
<text top="756" left="167" width="540" height="13" font="2">Stack inspection was ﬁrst implemented in Netscape 4.0, then adopted by Internet</text>
<text top="774" left="167" width="173" height="13" font="2">Explorer, Java, and .NET.</text>
<text top="792" left="190" width="175" height="13" font="2">The basic idea here is that</text>
<text top="822" left="205" width="465" height="13" font="2">whenever a thread T tries to access a resource, access is only allowed if</text>
<text top="840" left="205" width="459" height="13" font="2">all components on the call stack have the right to access the resource.</text>
<text top="869" left="167" width="540" height="13" font="2">So the rights of a thread are the intersection of the rights of all outstanding method</text>
<text top="887" left="167" width="540" height="14" font="2">calls. The rationale for this is that if there is a method evil on the call stack that</text>
<text top="905" left="167" width="540" height="13" font="2">does not have some permission, there is the risk that this method is abusing the</text>
<text top="923" left="167" width="540" height="14" font="2">functionality. If the evil method is on top of the stack, it may try to do something</text>
<text top="941" left="167" width="540" height="14" font="2">unwanted itself; if the evil method is not on top of the stack, then it might be</text>
<text top="959" left="167" width="540" height="13" font="2">trying to trick some other code (namely the method higher on the stack that is</text>
<text top="977" left="167" width="295" height="14" font="2">invoked by evil) to do something unwanted.</text>
<text top="995" left="190" width="518" height="13" font="2">As the example of the cashier at the bank suggests, this basic idea is too restric-</text>
<text top="1013" left="167" width="540" height="13" font="2">tive. A component can therefore override this and allow to use some of its privileges</text>
<text top="1031" left="167" width="540" height="13" font="2">that a component lower on the call stack does not have. To do this, that component</text>
<text top="1049" left="167" width="540" height="13" font="2">has to explicitly enable usage of this privilege, to reduce the chance that privileged</text>
<text top="1067" left="167" width="540" height="13" font="2">functionality is exposed accidentally. In Java enabling a privilege is done using the</text>
<text top="1085" left="167" width="540" height="14" font="2">method enablePrivilege. The decision to enable a privilege can also be revoked,</text>
<text top="1103" left="167" width="278" height="14" font="2">by calling the method disablePrivilege.</text>
<text top="1163" left="430" width="15" height="13" font="2">26</text>
</page>
<page number="27" position="absolute" top="0" left="0" height="1188" width="918">
<text top="165" left="183" width="463" height="12" font="2">// Untrusted BankCustomer, without CashWithdrawalPermission</text>
<text top="182" left="183" width="157" height="12" font="2">class BankCustomer {</text>
<text top="200" left="199" width="24" height="12" font="2">...</text>
<text top="218" left="199" width="369" height="12" font="2">public Cash getCash(Bank bank, integer amount){</text>
<text top="236" left="214" width="126" height="12" font="2">walkIntoBank(b);</text>
<text top="254" left="214" width="259" height="12" font="2">Cashier cashier = b.getCashier();</text>
<text top="272" left="214" width="47" height="12" font="2">return</text>
<text top="272" left="277" width="290" height="12" font="2">cashier.cashWithdrawal(this, amount);</text>
<text top="290" left="199" width="8" height="12" font="2">}</text>
<text top="308" left="199" width="24" height="12" font="2">...</text>
<text top="326" left="183" width="8" height="12" font="2">}</text>
<text top="362" left="183" width="384" height="12" font="2">// Trusted Cashier, with CashWithdrawalPermission</text>
<text top="380" left="183" width="118" height="12" font="2">class Cashier {</text>
<text top="398" left="199" width="24" height="12" font="2">...</text>
<text top="416" left="199" width="439" height="12" font="2">public Cash cashWithdrawal (Customer c, integer amount){</text>
<text top="434" left="214" width="212" height="12" font="2">// perform security checks,</text>
<text top="451" left="214" width="377" height="12" font="2">// eg, authenticate customer &amp; check his balance</text>
<text top="469" left="214" width="330" height="12" font="2">enablePrivilege(CashWithdrawalPermission);</text>
<text top="487" left="214" width="243" height="12" font="2">cash = teller.withdraw(amount);</text>
<text top="505" left="214" width="259" height="12" font="2">// update customer’s bank balance</text>
<text top="523" left="214" width="24" height="12" font="2">...</text>
<text top="541" left="214" width="94" height="12" font="2">return cash;</text>
<text top="559" left="199" width="8" height="12" font="2">}</text>
<text top="577" left="199" width="24" height="12" font="2">...</text>
<text top="595" left="167" width="8" height="12" font="2">}</text>
<text top="642" left="167" width="540" height="13" font="2">Figure 4.2: Sample code for the banking example. A more secure implementation of</text>
<text top="661" left="167" width="540" height="12" font="2">cashWithdrawal would disable its CashWithdrawalPermission straight away after</text>
<text top="677" left="167" width="540" height="13" font="2">getting the cash, to avoid the risk of accidentally using this permission in the rest</text>
<text top="695" left="167" width="96" height="13" font="2">of the method.</text>
<text top="738" left="190" width="518" height="13" font="2">Doing access control when some permission is used, now involves inspecting the</text>
<text top="756" left="167" width="540" height="13" font="2">frames on the call stack in a top-down manner – i.e., from the most recent method</text>
<text top="774" left="167" width="540" height="14" font="2">call down to the method call that started execution (e.g., a main method in some</text>
<text top="792" left="167" width="540" height="13" font="2">class). If a stack frame is encountered that does not have a privilege, access will</text>
<text top="809" left="167" width="540" height="13" font="2">be denied. If a stack frame is encountered that does have the permission and has</text>
<text top="827" left="167" width="540" height="13" font="2">it enabled, the walk down the stack is stopped and access is granted. If the stack</text>
<text top="845" left="167" width="540" height="13" font="2">inspection reaches the bottom of the call stack, which can only happen if all frames</text>
<text top="863" left="167" width="540" height="13" font="2">have the permission but none of them have explicitly enabled it, permission will be</text>
<text top="881" left="167" width="54" height="13" font="2">granted.</text>
<text top="899" left="190" width="518" height="13" font="2">For a detailed description of stack inspection in Java, see Chapter 3 of [MF99].</text>
<text top="917" left="167" width="540" height="13" font="2">The code in Figure 4.2 illustrates how code for the cashier example discussed above</text>
<text top="935" left="167" width="102" height="13" font="2">might look like.</text>
<text top="968" left="167" width="147" height="13" font="2">Elevating privileges</text>
<text top="986" left="167" width="540" height="13" font="2">The need for trusted code (or trusted processes) to make available some of its</text>
<text top="1004" left="167" width="461" height="13" font="2">privileges to untrusted code (or untrusted processes) is quite common.</text>
<text top="1022" left="190" width="518" height="13" font="2">As mentioned in the footnote on page 22, one place in which this happens</text>
<text top="1040" left="167" width="540" height="13" font="2">in traditional operating systems is in system calls: when a program invokes an</text>
<text top="1058" left="167" width="476" height="13" font="2">operating system call, this system call is executed with higher privileges.</text>
<text top="1076" left="190" width="518" height="14" font="2">Another way this happens on UNIX systems is through setuid executables.</text>
<text top="1094" left="167" width="540" height="13" font="2">These executables run with the access rights of the owner of the executable rather</text>
<text top="1112" left="167" width="540" height="14" font="2">than the access rights of the user that invokes the program. Often setuid executa-</text>
<text top="1163" left="430" width="15" height="13" font="2">27</text>
</page>
<page number="28" position="absolute" top="0" left="0" height="1188" width="918">
<text top="174" left="167" width="540" height="14" font="2">bles are owned by root, giving them maximal rights. Windows operating systems</text>
<text top="192" left="167" width="439" height="13" font="2">oﬀer so-called Local System Services to do roughly the same thing.</text>
<text top="210" left="190" width="518" height="13" font="2">The classic example to illustrate the inevitable need for such temporary Eleva-</text>
<text top="228" left="167" width="540" height="13" font="2">tion of Privilege is a log-in operation: for an unauthenticated user to log in with a</text>
<text top="245" left="167" width="540" height="13" font="2">username and password, access to the password ﬁle is needed. So a high privilege</text>
<text top="263" left="167" width="540" height="13" font="2">(access to the password ﬁle) is needed by some action executed on behalf of a user</text>
<text top="281" left="167" width="307" height="13" font="2">who is at that point still completely untrusted.</text>
<text top="299" left="190" width="518" height="13" font="2">Mechanisms that oﬀer temporary Elevation of Privilege are notorious sources</text>
<text top="317" left="167" width="540" height="13" font="2">of security vulnerabilities: if they contain security vulnerabilities then the higher</text>
<text top="335" left="167" width="327" height="13" font="2">privileges allow an attacker to do greater damage.</text>
<text top="381" left="167" width="323" height="13" font="2">Loopholes in language-based access control</text>
<text top="409" left="167" width="540" height="13" font="2">Suppose that the TCB for language-based access control is correct (and hence trust-</text>
<text top="427" left="167" width="176" height="13" font="2">worthy), which means that</text>
<text top="456" left="190" width="210" height="14" font="2">• the type system is sound, and</text>
<text top="486" left="190" width="369" height="14" font="2">• the implementation of the type checker is correct, and</text>
<text top="516" left="190" width="518" height="14" font="2">• the language platform (including the virtual machine, the API classes respon-</text>
<text top="535" left="205" width="489" height="13" font="2">sible for the language-based access control) are implemented correctly, and</text>
<text top="564" left="190" width="518" height="14" font="2">• all the API classes that these implementations rely on are implemented cor-</text>
<text top="582" left="205" width="69" height="13" font="2">rectly, and</text>
<text top="611" left="190" width="379" height="14" font="2">• none of the code above includes security vulnerabilities.</text>
<text top="642" left="167" width="540" height="13" font="2">If there are no mistakes in the policy ﬁle, and the keystore does not contain incorrect</text>
<text top="660" left="167" width="540" height="13" font="2">data, then a particular component, say a Java class, may a still be vulnerable to</text>
<text top="678" left="167" width="540" height="13" font="2">attacks by untrusted code. For example, a component could be careless and expose</text>
<text top="696" left="167" width="540" height="13" font="2">public ﬁelds, allowing an attacker to do damage by changing these, or a component</text>
<text top="714" left="167" width="540" height="13" font="2">might allow a class to be sub-classed, allowing an attacker to create a sub-class</text>
<text top="732" left="167" width="277" height="13" font="2">whose instances have malicious behaviour.</text>
<text top="750" left="190" width="518" height="13" font="2">To prevent such vulnerabilities, the programmer has to keep security in mind</text>
<text top="768" left="167" width="540" height="13" font="2">and program defensively. Defensive programming guidelines for Java are discussed</text>
<text top="786" left="167" width="540" height="13" font="2">in Chapter 7.1 of [MF99] or [VMMF00]. Secure coding guidelines for Java are</text>
<text top="803" left="167" width="163" height="13" font="2">also published by CERT</text>
<text top="801" left="330" width="6" height="9" font="5">6</text>
<text top="803" left="343" width="73" height="13" font="2">and Oracle</text>
<text top="801" left="416" width="6" height="9" font="5">7</text>
<text top="803" left="422" width="285" height="13" font="2">. Of course, in implementing the language</text>
<text top="821" left="167" width="480" height="13" font="2">platform itself such defensive programming guidelines should be followed.</text>
<text top="848" left="190" width="518" height="13" font="2">One notorious loophole in enforcing separation between trusted and untrusted</text>
<text top="866" left="167" width="540" height="13" font="2">code is aliasing: if a trusted and untrusted component both have a reference to</text>
<text top="884" left="167" width="540" height="13" font="2">the same object this may be a way for the untrusted code to mess up the behaviour</text>
<text top="902" left="167" width="540" height="13" font="2">of the trusted code. As illustrated in Fig 4.3, aliasing can bypass any access control</text>
<text top="920" left="167" width="540" height="14" font="2">enforced by the language. A classic example of this is with private reference ﬁeld:</text>
<text top="938" left="167" width="540" height="13" font="2">the language prevents access to private ﬁelds by ‘outsiders’, but the object that a</text>
<text top="956" left="167" width="471" height="13" font="2">private ﬁeld points to can be accessed by anyone that has an alias to it.</text>
<text top="974" left="190" width="518" height="13" font="2">Aliasing is harmless if the object in question is immutable. If a trusted and</text>
<text top="992" left="167" width="540" height="14" font="2">untrusted component share a reference to a String object in Java, then, because</text>
<text top="1010" left="167" width="540" height="13" font="2">strings are immutable, there is no way the untrusted component can modify the</text>
<text top="1028" left="167" width="112" height="13" font="2">shared reference.</text>
<text top="1028" left="295" width="412" height="14" font="2">(Note that to ensure that String objects are immutable in</text>
<text top="1046" left="167" width="540" height="13" font="2">the presence of untrusted code, it is crucial, amongst other things, that the class</text>
<text top="1072" left="184" width="5" height="8" font="14">6</text>
<text top="1075" left="190" width="514" height="10" font="10">https://www.securecoding.cert.org/confluence/display/java/The+CERT+Oracle+Secure+</text>
<text top="1089" left="167" width="152" height="10" font="10">Coding+Standard+for+Java</text>
<text top="1100" left="184" width="5" height="8" font="14">7</text>
<text top="1103" left="190" width="401" height="10" font="10">http://www.oracle.com/technetwork/java/seccodeguide-139067.html</text>
<text top="1163" left="430" width="15" height="13" font="2">28</text>
</page>
<page number="29" position="absolute" top="0" left="0" height="1188" width="918">
<text top="169" left="167" width="540" height="12" font="2">java.lang.String is ﬁnal, to rule out malicious subclasses which allow mutable</text>
<text top="186" left="167" width="53" height="13" font="2">strings.)</text>
<text top="208" left="190" width="518" height="13" font="2">The classic example of how aliasing of mutable data can be a security hole is</text>
<text top="226" left="167" width="210" height="13" font="2">the ‘HotJava 1.0 Signature Bug’</text>
<text top="224" left="377" width="6" height="9" font="5">8</text>
<text top="226" left="384" width="324" height="13" font="2">. The problem was caused by the implementation</text>
<text top="244" left="167" width="540" height="14" font="2">of the getSigners method in java.lang.Class, a method which returns an array</text>
<text top="262" left="167" width="540" height="13" font="2">of the signers of a class. The signers associated with a class are an important basis</text>
<text top="280" left="167" width="540" height="13" font="2">of language-based access control, as policies can associate certain permissions with</text>
<text top="298" left="167" width="48" height="13" font="2">signers.</text>
<text top="316" left="190" width="188" height="13" font="2">The code was something like</text>
<text top="347" left="183" width="141" height="12" font="2">package java.lang;</text>
<text top="365" left="183" width="157" height="12" font="2">public class Class {</text>
<text top="383" left="207" width="196" height="12" font="2">private String[] signers;</text>
<text top="419" left="207" width="345" height="12" font="2">/** Obtain list of signers of given class */</text>
<text top="437" left="207" width="235" height="12" font="2">public String[] getSigners() {</text>
<text top="455" left="230" width="118" height="12" font="2">return signers;</text>
<text top="472" left="207" width="8" height="12" font="2">}</text>
<text top="490" left="191" width="24" height="12" font="2">...</text>
<text top="519" left="167" width="540" height="14" font="2">The problem with the code above is that the public method getSigners returns</text>
<text top="537" left="167" width="540" height="14" font="2">an alias to the private array signers. Because arrays in Java are always mutable,</text>
<text top="555" left="167" width="540" height="13" font="2">this allows untrusted code to obtain a reference to this array and then, change the</text>
<text top="573" left="167" width="540" height="13" font="2">content by including a reputable signer such as sun.java.com in the hope of getting</text>
<text top="591" left="167" width="99" height="13" font="2">high privileges.</text>
<text top="609" left="190" width="518" height="14" font="2">The solution to the problem is for getSigners to return a copy of the array</text>
<text top="628" left="167" width="194" height="12" font="2">signers rather than an alias.</text>
<text top="645" left="190" width="518" height="14" font="2">Note that this example illustrates that private ﬁelds are not necessarily that</text>
<text top="663" left="167" width="537" height="13" font="2">private: private ﬁelds that are references may be widely accessible due to aliasing.</text>
<text top="701" left="167" width="101" height="13" font="2">Alias Control</text>
<text top="729" left="167" width="540" height="13" font="2">Unwanted aliasing is a not just a notorious source of security holes, but it is a</text>
<text top="747" left="167" width="540" height="13" font="2">notorious source of bugs in general. There has been a lot of research into type</text>
<text top="765" left="167" width="540" height="13" font="2">systems for programming languages which enforce some alias control to rule out</text>
<text top="783" left="167" width="540" height="13" font="2">unwanted aliasing. Especially in an object-oriented language it is required to make</text>
<text top="801" left="167" width="540" height="13" font="2">some hard guarantees about encapsulation of objects. E.g., one could consider</text>
<text top="819" left="167" width="540" height="14" font="2">adding a modiﬁer private and unaliased to Java to declare reference ﬁelds as</text>
<text top="837" left="167" width="540" height="13" font="2">being ‘really private’, which are then not allowed to be aliased from outside the</text>
<text top="854" left="167" width="34" height="13" font="2">class.</text>
<text top="872" left="190" width="518" height="13" font="2">How to restrict aliasing is still an active topic of research. An example of a</text>
<text top="890" left="167" width="540" height="13" font="2">language platform that enforces restrictions on aliasing is Java Card; on Java Card</text>
<text top="908" left="167" width="540" height="13" font="2">smartcards it is not possible for applications in diﬀerent packages to share references</text>
<text top="926" left="167" width="175" height="13" font="2">across package boundaries.</text>
<text top="944" left="190" width="518" height="13" font="2">Because sharing mutable data is dangerous, one countermeasure is to only share</text>
<text top="962" left="167" width="540" height="13" font="2">immutable data. If this is not possible, an alternative is to make copies of objects –</text>
<text top="980" left="167" width="540" height="13" font="2">by cloning them – when passing them to untrusted code, or after receiving them from</text>
<text top="998" left="167" width="540" height="14" font="2">untrusted code. For example, in the Class example above, the method getSigners</text>
<text top="1016" left="167" width="333" height="14" font="2">should not return signers, but signers.clone().</text>
<text top="1034" left="190" width="518" height="13" font="2">One has to be careful here to make a suﬃciently deep copy of the data. In</text>
<text top="1052" left="167" width="540" height="14" font="2">Java cloning an array returns a shallow copy, so the elements of signers and</text>
<text top="1071" left="167" width="540" height="12" font="2">signers.clone() are aliased. Because the array contains immutable strings, it</text>
<text top="1096" left="184" width="5" height="8" font="14">8</text>
<text top="1099" left="190" width="517" height="11" font="10">For this and more examples of security holes in early versions of Java, see http://sip.cs.</text>
<text top="1114" left="167" width="200" height="10" font="10">princeton.edu/history/index.php.</text>
<text top="1163" left="430" width="15" height="13" font="2">29</text>
</page>
<page number="30" position="absolute" top="0" left="0" height="1188" width="918">
<text top="355" left="323" width="58" height="15" font="9">Language</text>
<text top="357" left="381" width="46" height="12" font="5"> Platform </text>
<text top="372" left="331" width="89" height="12" font="5">(eg. Java or .NET)</text>
<text top="288" left="286" width="50" height="13" font="10">Module A</text>
<text top="286" left="422" width="50" height="13" font="10">Module B</text>
<text top="210" left="286" width="191" height="11" font="13">access via reference, without access control</text>
<text top="320" left="368" width="102" height="11" font="13">visibility access control </text>
<text top="445" left="167" width="540" height="13" font="2">Figure 4.3: Referencing as notorious loophole in language-level access control, by-</text>
<text top="463" left="167" width="242" height="13" font="2">passing language-level access control.</text>
<text top="508" left="167" width="540" height="14" font="2">would be secure in getSigners to return signers.clone(). If strings were mutable,</text>
<text top="526" left="167" width="540" height="14" font="2">this would still not be secure, and a deep clone of the signers array would be</text>
<text top="544" left="167" width="406" height="13" font="2">needed, where all the elements of the array are cloned as well.</text>
<text top="566" left="190" width="518" height="13" font="2">A way a programming language could help here is in oﬀering some heuristics –</text>
<text top="584" left="167" width="540" height="13" font="2">or better still, guarantees – about how deep a clone method is. For example, the</text>
<text top="602" left="167" width="540" height="14" font="2">object-oriented programming language Eiﬀel distinguishes clone and deep clone</text>
<text top="620" left="167" width="540" height="13" font="2">operations, where the former is a shallow clone. In other languages such as Java or</text>
<text top="638" left="167" width="540" height="14" font="2">C# it can be unclear how deep a copy the clone method returns, which may lead</text>
<text top="656" left="167" width="78" height="13" font="2">to mistakes.</text>
<text top="689" left="167" width="356" height="13" font="2">Code-based versus process-based access control</text>
<text top="725" left="167" width="540" height="13" font="2">The nature of access control in language-based access control is diﬀerent from access</text>
<text top="742" left="167" width="540" height="13" font="2">control in standard operating systems: the former is based on origin of the code</text>
<text top="760" left="167" width="540" height="13" font="2">and the associated visibility restrictions, the latter is based on the process identity.</text>
<text top="778" left="167" width="229" height="13" font="2">The examples below illustrate this.</text>
<text top="801" left="190" width="518" height="13" font="2">Suppose on an operating system you start the same program twice. This results</text>
<text top="819" left="167" width="167" height="13" font="2">in two diﬀerent processes</text>
<text top="816" left="335" width="6" height="9" font="5">9</text>
<text top="819" left="341" width="366" height="13" font="2">. Although these processes execute the same code, the</text>
<text top="837" left="167" width="540" height="13" font="2">operating system will enforce separation of the address spaces of these programs.</text>
<text top="855" left="167" width="540" height="13" font="2">That the processes execute the same code does not make any diﬀerence (except</text>
<text top="872" left="167" width="380" height="13" font="2">maybe that the processes might try to use the same ﬁles).</text>
<text top="895" left="190" width="518" height="13" font="2">Now suppose that within a process that executes a Java program you start up</text>
<text top="913" left="167" width="331" height="13" font="2">two threads, for instance by opening two windows.</text>
<text top="931" left="190" width="10" height="13" font="2">If</text>
<text top="931" left="217" width="33" height="13" font="2">these</text>
<text top="931" left="267" width="48" height="13" font="2">threads</text>
<text top="931" left="333" width="49" height="13" font="2">execute</text>
<text top="931" left="399" width="54" height="13" font="2">diﬀerent</text>
<text top="931" left="470" width="34" height="13" font="2">code,</text>
<text top="931" left="524" width="21" height="13" font="2">say</text>
<text top="931" left="562" width="22" height="13" font="2">one</text>
<text top="931" left="601" width="10" height="13" font="2">is</text>
<text top="931" left="629" width="46" height="13" font="2">started</text>
<text top="931" left="692" width="16" height="13" font="2">by</text>
<text top="950" left="167" width="540" height="12" font="2">new.SomeThread().start() and the other by new.AnotherThread().start(),</text>
<text top="967" left="167" width="540" height="13" font="2">then the visibility restrictions of the programming language can prevent the ﬁrst</text>
<text top="985" left="167" width="540" height="13" font="2">thread from accessing some data belonging to the second thread. For example,</text>
<text top="1002" left="167" width="540" height="14" font="2">private ﬁelds in the SomeThread class will not be visible – and hence not accessible</text>
<text top="1020" left="167" width="540" height="14" font="2">– in the AnotherThread class. If the classes are in diﬀerent packages, they will not</text>
<text top="1038" left="167" width="336" height="13" font="2">be able to access each other’s package-visible ﬁelds.</text>
<text top="1056" left="190" width="518" height="13" font="2">But if both threads execute the same code, say they are both started by</text>
<text top="1075" left="167" width="540" height="12" font="2">new.SomeThread().start(), they can access each others private, protected, and</text>
<text top="1092" left="167" width="540" height="13" font="2">package-visible ﬁelds. (Note that in Java a private ﬁeld is not only accessible in the</text>
<text top="1110" left="167" width="346" height="13" font="2">object it belongs to, but by all objects of that class.)</text>
<text top="1163" left="430" width="15" height="13" font="2">30</text>
</page>
<page number="31" position="absolute" top="0" left="0" height="1188" width="918">
<text top="174" left="190" width="518" height="13" font="2">Even if the threads execute diﬀerent code, the visibility restrictions between</text>
<text top="192" left="167" width="540" height="13" font="2">them are rather fragile. We do not have hard and simple encapsulation boundaries</text>
<text top="210" left="167" width="540" height="13" font="2">between these threads like we have between diﬀerent processes on the operating sys-</text>
<text top="228" left="167" width="540" height="14" font="2">tem. For example, suppose one threads executes new.SomeThread().start() and</text>
<text top="245" left="167" width="540" height="14" font="2">the other new.AnotherThread().start(), where SomeThread and AnotherThread</text>
<text top="263" left="167" width="540" height="13" font="2">are in diﬀerent packages. There is then some separation between the processes since</text>
<text top="281" left="167" width="540" height="13" font="2">they only touch each other’s public ﬁelds. However, the two threads might share</text>
<text top="299" left="167" width="540" height="13" font="2">references to some common object, due to aliasing, which might be a way for one</text>
<text top="317" left="167" width="343" height="13" font="2">execution to inﬂuence the other in unintended ways.</text>
<text top="340" left="190" width="518" height="13" font="2">One prominent example where separation between diﬀerent objects of the same</text>
<text top="358" left="167" width="488" height="13" font="2">class would be useful, are the diﬀerent tabs of a window or a web browser.</text>
<text top="376" left="190" width="518" height="13" font="2">For example, suppose you look at diﬀerent web pages simultaneously with your</text>
<text top="393" left="167" width="540" height="13" font="2">web browser, either in diﬀerent windows or in diﬀerent tabs in the same window, and</text>
<text top="411" left="167" width="540" height="13" font="2">in one of these you are logged in to your gmail account. If you visit a website with</text>
<text top="429" left="167" width="540" height="13" font="2">malicious content in another web page, you might be exposed to all sort of security</text>
<text top="447" left="167" width="540" height="13" font="2">vulnerabilities, such as cross-site scripting, session ﬁxation, session hijacking, cross-</text>
<text top="465" left="167" width="540" height="13" font="2">site request forgery, or click jacking. The root cause of all these attacks is the same:</text>
<text top="483" left="167" width="503" height="13" font="2">the other window executes with the same permissions as your gmail window.</text>
<text top="501" left="190" width="518" height="13" font="2">If you would start up new processes instead of starting new windows or tabs</text>
<text top="519" left="167" width="540" height="13" font="2">within the same process to look at diﬀerent web pages, many of these attack vectors</text>
<text top="537" left="167" width="540" height="13" font="2">would disappear. Of course, for this to work cookies should not be stored on disk</text>
<text top="555" left="167" width="540" height="13" font="2">and shared between these processes, but should be in main memory to beneﬁt from</text>
<text top="573" left="167" width="377" height="13" font="2">the memory separation enforced by the operating system.</text>
<text top="1163" left="430" width="15" height="13" font="2">31</text>
</page>
<page number="32" position="absolute" top="0" left="0" height="1188" width="918">
<text top="269" left="167" width="154" height="28" font="4">Chapter 5</text>
<text top="339" left="167" width="304" height="33" font="3">Information ﬂow</text>
<text top="432" left="167" width="540" height="13" font="2">Information ﬂow is about a more expressive category of security properties than</text>
<text top="450" left="167" width="540" height="13" font="2">traditionally used in access control. It is more expressive than access control at the</text>
<text top="468" left="167" width="540" height="13" font="2">level of the operating system discussed in Chapter 2 or at the level of the program-</text>
<text top="486" left="167" width="540" height="13" font="2">ming platform discussed in Chapter 4. This chapter discusses what information</text>
<text top="504" left="167" width="540" height="13" font="2">ﬂow properties mean, both informally and formally, how they can be speciﬁed, and</text>
<text top="522" left="167" width="171" height="13" font="2">how they can be enforced.</text>
<text top="544" left="190" width="518" height="13" font="2">Traditional access control restricts what data you can read (or write), but not</text>
<text top="562" left="167" width="540" height="13" font="2">what you can do with this data after you have read it. Information ﬂow does take</text>
<text top="580" left="167" width="540" height="13" font="2">into account what you are allowed to do with data that you have read, and where</text>
<text top="598" left="167" width="540" height="13" font="2">this information is allowed to ﬂow – hence the name. For write access, it not only</text>
<text top="616" left="167" width="540" height="13" font="2">controls which locations you can write to, but also controls where the value that</text>
<text top="634" left="167" width="216" height="13" font="2">you write might have come from.</text>
<text top="657" left="190" width="518" height="13" font="2">As an example, consider someone using his smart phone to ﬁrst locate the nearest</text>
<text top="674" left="167" width="540" height="13" font="2">hotel by say using Google maps, and then book a room there via the hotel’s website</text>
<text top="692" left="167" width="540" height="13" font="2">with his credit card. Maybe he even called some HotelBooker app on his phone</text>
<text top="710" left="167" width="540" height="13" font="2">that does all these actions for him. The sensitive information involved includes the</text>
<text top="728" left="167" width="540" height="13" font="2">location information and the credit card details. The location data will have to be</text>
<text top="746" left="167" width="540" height="13" font="2">given to Google, to let it ﬁnd the nearest hotel. The credit card information will</text>
<text top="764" left="167" width="540" height="13" font="2">have to be given to the hotel to book a room. So an access control policy for a</text>
<text top="782" left="167" width="540" height="13" font="2">HotelBooker app would have to allow access to both location data and the credit</text>
<text top="800" left="167" width="540" height="13" font="2">card number. There is no need to pass the credit card information to Google, or</text>
<text top="818" left="167" width="540" height="13" font="2">to pass the current location data to the hotel; especially the former would be very</text>
<text top="836" left="167" width="540" height="13" font="2">undesirable. Hence an information ﬂow policy for a HotelBooker app might say</text>
<text top="854" left="167" width="540" height="13" font="2">that location data may only be leaked to Google and the credit card may only be</text>
<text top="872" left="167" width="540" height="13" font="2">leaked to the hotel. Note that such an information ﬂow policy speciﬁes more precise</text>
<text top="890" left="167" width="540" height="13" font="2">restrictions than access control can, and involves the way information ﬂows inside</text>
<text top="908" left="167" width="102" height="13" font="2">the application.</text>
<text top="946" left="167" width="204" height="13" font="2">Integrity vs Conﬁdentiality</text>
<text top="974" left="167" width="540" height="13" font="2">Information ﬂow properties can be about conﬁdentiality, as in the example above,</text>
<text top="992" left="167" width="540" height="13" font="2">or about integrity. For conﬁdentiality we are worried about where some data that</text>
<text top="1010" left="167" width="540" height="13" font="2">has been read might end up. For integrity we are worried about where some data</text>
<text top="1028" left="167" width="540" height="13" font="2">that is written might have come from. The former can violate the conﬁdentiality of</text>
<text top="1046" left="167" width="368" height="13" font="2">the data, the latter can violate the integrity of the data.</text>
<text top="1064" left="190" width="518" height="13" font="2">As an example, suppose an application receives untrusted input over the internet.</text>
<text top="1082" left="167" width="540" height="13" font="2">You might not want this input to be used in sensitive actions, say as the argument</text>
<text top="1100" left="167" width="540" height="14" font="2">of system(), the standard C operation to pass a raw command to the underlying</text>
<text top="1117" left="167" width="116" height="13" font="2">operating system.</text>
<text top="1163" left="430" width="15" height="13" font="2">32</text>
</page>
<page number="33" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="190" width="518" height="13" font="2">Lack of input validation is a major source of security vulnerabilities; these all</text>
<text top="186" left="167" width="540" height="13" font="2">involve unwanted information ﬂows where some untrusted (i.e., low integrity) data</text>
<text top="204" left="167" width="540" height="13" font="2">ends up in a sensitive place (where only high integrity data should be used). Such</text>
<text top="222" left="167" width="540" height="13" font="2">problems can be detected and prevented to some degree by information ﬂow control</text>
<text top="240" left="167" width="177" height="13" font="2">using a policy for integrity.</text>
<text top="258" left="190" width="518" height="13" font="2">Integrity and conﬁdentiality are duals. This means that for every property of</text>
<text top="275" left="167" width="540" height="13" font="2">conﬁdentiality there is a similar but somehow opposite property for integrity. We</text>
<text top="293" left="167" width="540" height="13" font="2">will see some more examples of this duality later: for every way to specify or enforce</text>
<text top="311" left="167" width="540" height="13" font="2">information ﬂow for conﬁdentiality, there is a corresponding – dual – approach for</text>
<text top="329" left="167" width="58" height="13" font="2">integrity.</text>
<text top="374" left="167" width="230" height="13" font="2">Integrity versus conﬁdentiality</text>
<text top="392" left="167" width="540" height="13" font="2">The duality between conﬁdentiality and integrity shows up in many places. E.g.,</text>
<text top="410" left="167" width="540" height="13" font="2">asymmetric cryptography can be used to encrypt data (ensuring conﬁdentiality) or</text>
<text top="428" left="167" width="214" height="13" font="2">to sign data (ensuring integrity).</text>
<text top="446" left="190" width="518" height="13" font="2">When you think about security, often your ﬁrst instinct is to worry about con-</text>
<text top="464" left="167" width="540" height="13" font="2">ﬁdentiality. Indeed, some people think that security is all about secrecy. But in</text>
<text top="482" left="167" width="540" height="13" font="2">many (most?) situations integrity is a far greater worry than conﬁdentiality. After</text>
<text top="500" left="167" width="540" height="13" font="2">all, for data for which conﬁdentiality is important, such as your medical records,</text>
<text top="517" left="167" width="540" height="13" font="2">your criminal record, or information about your ﬁnances, integrity is usually also</text>
<text top="535" left="167" width="540" height="13" font="2">important – and often much more. You may ﬁnd it annoying if other people can</text>
<text top="553" left="167" width="540" height="13" font="2">ﬁnd out how much money you have in your bank account, but if they can change</text>
<text top="571" left="167" width="322" height="13" font="2">this number it is a more serious security concern!</text>
<text top="589" left="190" width="518" height="13" font="2">Moreover, many security problems in software are caused by malicious input</text>
<text top="607" left="167" width="540" height="13" font="2">and insuﬃcient input validation – i.e., insuﬃcient integrity checks. Malware tries</text>
<text top="625" left="167" width="540" height="13" font="2">to destroy the integrity of the systems we use, even if the goal is to then steal</text>
<text top="643" left="167" width="160" height="13" font="2">conﬁdential information.</text>
<text top="692" left="167" width="31" height="19" font="6">5.1</text>
<text top="692" left="223" width="324" height="19" font="6">Principles for information ﬂow</text>
<text top="730" left="167" width="540" height="13" font="2">The work on information ﬂow dates back to the seminal work of Denning &amp; Denning</text>
<text top="748" left="167" width="540" height="13" font="2">[DD77]. Information ﬂow properties, be it for integrity or conﬁdentiality, involve</text>
<text top="765" left="167" width="177" height="13" font="2">a lattice to classify data.</text>
<text top="765" left="358" width="350" height="13" font="2">The simplest possible lattice for conﬁdentiality just</text>
<text top="783" left="167" width="238" height="13" font="2">distinguishes public and secret data:</text>
<text top="818" left="417" width="40" height="13" font="2">Secret</text>
<text top="861" left="417" width="42" height="13" font="2">Public</text>
<text top="898" left="167" width="540" height="13" font="2">Much more complicated lattices are possible, for instance to classify data at diﬀer-</text>
<text top="916" left="167" width="540" height="13" font="2">ent secrecy levels or on diﬀerent topics, as illustrated in Figure 5.1. A lattice for</text>
<text top="934" left="167" width="540" height="13" font="2">integrity nearly always just considers two categories, which distinguishes tainted</text>
<text top="952" left="167" width="317" height="13" font="2">data – typically untrusted input – from the rest:</text>
<text top="987" left="405" width="65" height="13" font="2">Untainted</text>
<text top="1029" left="412" width="50" height="13" font="2">Tainted</text>
<text top="1067" left="167" width="540" height="13" font="2">These lattices provide an ordering on the diﬀerent categories: data has a higher</text>
<text top="1085" left="167" width="540" height="13" font="2">degree of conﬁdentiality or integrity if you go up in the lattice. There is also an</text>
<text top="1103" left="167" width="540" height="13" font="2">implicit ‘inclusion’ in one direction. For example, it is safe to treat some public</text>
<text top="1163" left="430" width="15" height="13" font="2">33</text>
</page>
<page number="34" position="absolute" top="0" left="0" height="1188" width="918">
<text top="202" left="172" width="113" height="12" font="9">Cosmic Top Secret</text>
<text top="246" left="211" width="37" height="12" font="9">Secret</text>
<text top="289" left="192" width="73" height="12" font="9">Conﬁdential</text>
<text top="331" left="198" width="62" height="12" font="9">Restricted</text>
<text top="374" left="193" width="71" height="12" font="9">Unclassiﬁed</text>
<text top="168" left="361" width="90" height="12" font="9">Secret Benelux</text>
<text top="227" left="300" width="91" height="12" font="9">Secret Belgium</text>
<text top="228" left="438" width="114" height="12" font="9">Secret Netherlands</text>
<text top="227" left="585" width="117" height="12" font="9">Secret Luxembourg</text>
<text top="253" left="363" width="86" height="12" font="9">Conf. Benelux</text>
<text top="312" left="303" width="87" height="12" font="9">Conf. Belgium</text>
<text top="313" left="440" width="110" height="12" font="9">Conf. Netherlands</text>
<text top="312" left="586" width="115" height="12" font="9">Conf. Luxembourg</text>
<text top="374" left="371" width="71" height="12" font="9">Unclassiﬁed</text>
<text top="410" left="167" width="540" height="13" font="2">Figure 5.1: Lattices for conﬁdentiality: on the left the oﬃcial NATO classiﬁca-</text>
<text top="428" left="167" width="540" height="13" font="2">tion (which does really include the level ‘Cosmic’ !), on the right some imaginary</text>
<text top="446" left="167" width="434" height="13" font="2">classiﬁcation of sensitive information about the Benelux countries.</text>
<text top="491" left="167" width="540" height="13" font="2">data as if it were secret, but not the other way around. Similarly, it is safe to treat</text>
<text top="509" left="167" width="270" height="13" font="2">some untainted data as if it were tainted.</text>
<text top="527" left="190" width="518" height="13" font="2">Information ﬂow properties involve sources where information come from and</text>
<text top="545" left="167" width="540" height="13" font="2">sinks where information end up in. In the discussion and examples below we will</text>
<text top="563" left="167" width="540" height="13" font="2">often use program variables as both sources and sinks. In addition to this, input</text>
<text top="581" left="167" width="426" height="13" font="2">mechanisms give rise to sources and output mechanisms to sinks.</text>
<text top="621" left="167" width="41" height="16" font="1">5.1.1</text>
<text top="621" left="229" width="230" height="16" font="1">Implicit and explicit ﬂows</text>
<text top="650" left="167" width="401" height="13" font="2">In information ﬂow we distinguish explicit and implicit ﬂows.</text>
<text top="673" left="190" width="518" height="13" font="2">An explicit (or direct) information ﬂow happens when we do an assignment</text>
<text top="691" left="167" width="154" height="13" font="2">of a value to a variable:</text>
<text top="722" left="191" width="47" height="12" font="2">x = y;</text>
<text top="750" left="167" width="198" height="14" font="2">is an explicit ﬂow from y to x.</text>
<text top="768" left="190" width="518" height="14" font="2">If a variable lo holds public data and a variable hi holds secret data, then the</text>
<text top="786" left="167" width="476" height="14" font="2">assignment lo = hi; breaks conﬁdentiality, whereas hi = lo; does not.</text>
<text top="804" left="190" width="518" height="14" font="2">Dually, if a variable lo holds untrusted, tainted data and a variable hi holds</text>
<text top="822" left="167" width="501" height="14" font="2">untainted data, then hi = lo; breaks integrity, whereas lo = hi; does not.</text>
<text top="844" left="190" width="518" height="14" font="2">Implicit (or indirect) ﬂows are trickier. Suppose that program variable lo</text>
<text top="862" left="167" width="440" height="14" font="2">holds public data and variable hi holds secret data. The statement</text>
<text top="894" left="183" width="188" height="12" font="2">if (hi &gt; 0) { lo = 99; }</text>
<text top="922" left="167" width="540" height="14" font="2">does not leak the exact value of hi to lo, but it does leak some information about</text>
<text top="940" left="167" width="540" height="14" font="2">the value of hi to lo. Someone observing lo could tell whether hi is negative or</text>
<text top="958" left="167" width="26" height="13" font="2">not.</text>
<text top="976" left="190" width="518" height="13" font="2">In the worst case, an implicit ﬂow is just as bad as an explicit one. For example,</text>
<text top="994" left="167" width="432" height="14" font="2">for boolean variables b1 and b2, the (implicit) information ﬂow in</text>
<text top="1025" left="183" width="306" height="12" font="2">if (b1) then b2 = true else b2 = false;</text>
<text top="1054" left="167" width="319" height="13" font="2">is equivalent to the (explicit) information ﬂow in</text>
<text top="1085" left="183" width="63" height="12" font="2">b1 = b2;</text>
<text top="1163" left="430" width="15" height="13" font="2">34</text>
</page>
<page number="35" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="190" width="518" height="14" font="2">Implicit ﬂows can become quite tricky. Suppose we have two arrays, priv and</text>
<text top="187" left="167" width="540" height="12" font="2">pub, where priv contains secret data and pub contains public data. The assignments</text>
<text top="204" left="167" width="205" height="13" font="2">below are then not problematic</text>
<text top="235" left="183" width="94" height="12" font="2">pub[3] = lo;</text>
<text top="253" left="183" width="102" height="12" font="2">priv[4] = hi;</text>
<text top="281" left="167" width="255" height="13" font="2">But what about the statements below?</text>
<text top="313" left="183" width="102" height="12" font="2">pub[hi] = 23;</text>
<text top="331" left="183" width="110" height="12" font="2">priv[hi] = 24;</text>
<text top="348" left="183" width="110" height="12" font="2">priv[lo] = 25;</text>
<text top="377" left="167" width="540" height="14" font="2">The assignment pub[hi] = 23; does leak conﬁdential information, because some-</text>
<text top="395" left="167" width="540" height="14" font="2">one observing the content of pub could learn something about the value of hi. More</text>
<text top="413" left="167" width="540" height="14" font="2">subtle is the problem with priv[hi] = 24; this may look harmless, but it may leak</text>
<text top="431" left="167" width="540" height="14" font="2">information: e.g., if hi is negative, the statement will throw an exception because</text>
<text top="449" left="167" width="540" height="14" font="2">of a negative array index; if an attacker can observe this, he can tell that hi was</text>
<text top="467" left="167" width="58" height="13" font="2">negative.</text>
<text top="485" left="190" width="518" height="14" font="2">Finally, priv[lo] = 25 will throw an exception if lo is negative or if lo larger</text>
<text top="503" left="167" width="540" height="14" font="2">than the length of the array priv; if the length of the array priv is considered</text>
<text top="521" left="167" width="500" height="13" font="2">conﬁdential, then in the second case some conﬁdential information is leaked.</text>
<text top="538" left="190" width="518" height="13" font="2">Information can not only be leaked by throwing exceptions, but also by the</text>
<text top="556" left="167" width="540" height="13" font="2">execution time of a program, or by the fact that a program terminates or not. For</text>
<text top="574" left="167" width="307" height="13" font="2">example, consider the program fragment below</text>
<text top="605" left="183" width="235" height="12" font="2">for (i = 0; i &lt; hi; i++) { ...</text>
<text top="605" left="434" width="16" height="12" font="2">};</text>
<text top="634" left="167" width="540" height="13" font="2">If after this for-loop there is some event that an attacker can observe, then the</text>
<text top="652" left="167" width="540" height="14" font="2">timing of this event leaks some information about the value of hi. This is also the</text>
<text top="670" left="167" width="348" height="13" font="2">case if there is some observable event inside the loop.</text>
<text top="688" left="190" width="149" height="13" font="2">The program fragment</text>
<text top="719" left="183" width="259" height="12" font="2">for (i = 0; i &lt; 10; i=i+hi) { ...</text>
<text top="719" left="458" width="16" height="12" font="2">};</text>
<text top="748" left="167" width="540" height="14" font="2">will not terminate if hi is zero, so this program fragment not only leaks information</text>
<text top="766" left="167" width="540" height="13" font="2">by the time it takes to complete, but also by the fact whether it terminates at all.</text>
<text top="784" left="167" width="298" height="13" font="2">This may be easier to observe by an attacker.</text>
<text top="822" left="167" width="124" height="13" font="2">Hidden channels</text>
<text top="850" left="167" width="540" height="13" font="2">In the examples above, the throwing of an exception, the timing, and the termina-</text>
<text top="868" left="167" width="427" height="13" font="2">tion of a program is used as so-called covert or hidden channel.</text>
<text top="886" left="190" width="518" height="13" font="2">Especially when implementing cryptographic algorithms timing is a notorious</text>
<text top="904" left="167" width="540" height="13" font="2">covert channel. For instance, a naive implementation of RSA will leak information</text>
<text top="922" left="167" width="540" height="13" font="2">about the key through time, as the time it takes will increase with the numbers of</text>
<text top="940" left="167" width="540" height="13" font="2">1’s in the secret key. There are all sorts of covert channels that might leak sensitive</text>
<text top="958" left="167" width="540" height="13" font="2">information: such as power usage, memory usage, electromagnetic radiation, etc.</text>
<text top="976" left="167" width="540" height="13" font="2">One of the most powerful attacks on smartcards to retrieve secret cryptographic keys</text>
<text top="993" left="167" width="540" height="13" font="2">nowadays is through power analysis, where the power consumption of a smartcard</text>
<text top="1011" left="167" width="504" height="13" font="2">is closely monitored and statistically analysed to retrieve cryptographic keys.</text>
<text top="1034" left="190" width="518" height="13" font="2">The notion of covert channels is about observing data, rather than inﬂuencing</text>
<text top="1052" left="167" width="540" height="13" font="2">it, so it is an issue for conﬁdentiality, but less so (not at all?) for integrity. So here</text>
<text top="1070" left="167" width="474" height="13" font="2">the duality between conﬁdentiality and integrity appears to break down.</text>
<text top="1163" left="430" width="15" height="13" font="2">35</text>
</page>
<page number="36" position="absolute" top="0" left="0" height="1188" width="918">
<text top="163" left="167" width="31" height="19" font="6">5.2</text>
<text top="163" left="223" width="296" height="19" font="6">Information ﬂow in practice</text>
<text top="201" left="167" width="539" height="13" font="2">There are diﬀerent ways to use the notion of information ﬂow to improve security:</text>
<text top="233" left="190" width="518" height="14" font="2">• One way is through type systems which take levels of conﬁdentiality or</text>
<text top="251" left="205" width="150" height="13" font="2">integrity into account.</text>
<text top="251" left="369" width="339" height="13" font="2">Breaches of information ﬂow policies can then be</text>
<text top="269" left="205" width="503" height="13" font="2">detected at compile-time by means of type checking. Section 5.3 describes</text>
<text top="287" left="205" width="503" height="13" font="2">this possibility in more detail. The most mature realisation of such a type</text>
<text top="305" left="205" width="503" height="13" font="2">system for a real programming language is the Jif extension of Java, which is</text>
<text top="323" left="205" width="162" height="13" font="2">based on JFlow [Mye99].</text>
<text top="352" left="190" width="518" height="14" font="2">• Many source code analysis tools perform some form of information ﬂow</text>
<text top="371" left="205" width="503" height="13" font="2">analysis. Source code analysis tools, also known as code scanning or static</text>
<text top="389" left="205" width="503" height="13" font="2">analysis tools, analyse code at compile time to look for possible security ﬂaws.</text>
<text top="407" left="205" width="503" height="13" font="2">The capabilities of source code analysis tools can vary greatly: the simplest</text>
<text top="425" left="205" width="503" height="14" font="2">versions just do a simple syntactic check (i.e., a CTRL-F or grep) to look</text>
<text top="443" left="205" width="503" height="13" font="2">for dangerous expressions, more advanced versions do a deeper analysis of the</text>
<text top="461" left="205" width="327" height="13" font="2">code, possible including information ﬂow analysis.</text>
<text top="485" left="205" width="503" height="13" font="2">Information ﬂow analyses by code analysis tools focus on integrity rather than</text>
<text top="502" left="205" width="503" height="13" font="2">conﬁdentiality. Some sources of data are considered as tainted (for example,</text>
<text top="520" left="205" width="503" height="13" font="2">arguments of HTTP POST or GET requests in web applications) and the tool</text>
<text top="538" left="205" width="503" height="13" font="2">will try to trace how tainted data is passed through the application and ﬂag a</text>
<text top="556" left="205" width="503" height="13" font="2">warning if tainted data ends up in dangerous places (for example, arguments</text>
<text top="574" left="205" width="463" height="13" font="2">to SQL commands) without passing through input validation routines.</text>
<text top="598" left="205" width="503" height="13" font="2">So the tool has to know (or be told) which routines should be treated as input</text>
<text top="616" left="205" width="503" height="13" font="2">validation routines, i.e., which routines take tainted data as input and produce</text>
<text top="634" left="205" width="503" height="13" font="2">untainted data as output. Also, the tool will have to know which API calls</text>
<text top="652" left="205" width="503" height="14" font="2">give rise to information ﬂows. For example, if a Java string s is tainted, then</text>
<text top="686" left="397" width="118" height="12" font="2">s.toLowerCase()</text>
<text top="718" left="205" width="323" height="13" font="2">probably has to be considered as tainted too, but</text>
<text top="752" left="240" width="432" height="12" font="2">org.apache.commons.lang.StringEscapeUtils.escapeHtml(s)</text>
<text top="783" left="205" width="503" height="13" font="2">can be considered as untainted. (Or maybe the last expression should then</text>
<text top="801" left="205" width="503" height="13" font="2">only be considered as untainted when used as HTML, and still be treated as</text>
<text top="819" left="205" width="285" height="13" font="2">tainted when used in say an SQL query. . . )</text>
<text top="843" left="205" width="503" height="13" font="2">Taken to its extreme, such an information ﬂow analysis would be equivalent to</text>
<text top="861" left="205" width="503" height="13" font="2">having a type system. However, most source code analysis tools take a more</text>
<text top="879" left="205" width="503" height="13" font="2">pragmatic and ad-hoc approach, and cut some corners to keep the analysis</text>
<text top="897" left="205" width="503" height="13" font="2">tractable without too much programmer guidance (in the form of type anno-</text>
<text top="915" left="205" width="503" height="13" font="2">tations), without too much computation (e.g., tools may refrain from doing a</text>
<text top="933" left="205" width="503" height="13" font="2">whole program analysis and only look for unwanted information ﬂow within</text>
<text top="951" left="205" width="503" height="13" font="2">a single procedure), and without generating too many false positives. So in</text>
<text top="969" left="205" width="503" height="13" font="2">the end the analysis will often not be sound (i.e., it will produce some false</text>
<text top="987" left="205" width="423" height="13" font="2">negatives) or complete (i.e., it will produce some false positives).</text>
<text top="1016" left="190" width="518" height="14" font="2">• Instead of the static approaches above, one can also do a dynamic taint</text>
<text top="1034" left="205" width="503" height="13" font="2">propagation. Here tainted data is somehow tagged, and during execution of</text>
<text top="1052" left="205" width="503" height="13" font="2">the program these tags are propagated, and execution is halted if data that is</text>
<text top="1070" left="205" width="503" height="13" font="2">tagged as tainted ends up in dangerous places, such as arguments to security-</text>
<text top="1088" left="205" width="503" height="13" font="2">sensitive API calls. The idea of dynamic taint propagation was popularised</text>
<text top="1106" left="205" width="138" height="13" font="2">by Perl’s taint mode.</text>
<text top="1163" left="430" width="15" height="13" font="2">36</text>
</page>
<page number="37" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="205" width="503" height="13" font="2">Compared to a static analysis (either by a type system or a source code</text>
<text top="186" left="205" width="503" height="13" font="2">analysis tool), such a dynamic approach has the advantage of being simpler</text>
<text top="204" left="205" width="503" height="13" font="2">and being more precise. The obvious disadvantage is that it will only detect</text>
<text top="222" left="205" width="289" height="13" font="2">potential problems at the very last moment.</text>
<text top="251" left="190" width="518" height="14" font="2">• Dynamic taint propagation can also be used to detect certain buﬀer overﬂow</text>
<text top="269" left="205" width="503" height="13" font="2">exploits, and combat the worms that plague operating systems. The basic idea</text>
<text top="287" left="205" width="503" height="13" font="2">is the same: untrusted input is tagged as tainted, these tags are propagated,</text>
<text top="305" left="205" width="503" height="13" font="2">and the system ﬂags a warning if tainted data ends up in the program counter,</text>
<text top="323" left="205" width="503" height="13" font="2">is used as an instruction, or ends up in a critical argument of a security-</text>
<text top="341" left="205" width="169" height="13" font="2">sensitive system call [CCC</text>
<text top="339" left="374" width="9" height="9" font="5">+</text>
<text top="341" left="384" width="323" height="13" font="2">05]. Unlike a traditional signature-based approach</text>
<text top="359" left="205" width="442" height="13" font="2">to detect known exploits, this can even detect zero-day exploits.</text>
<text top="359" left="661" width="46" height="13" font="2">Such a</text>
<text top="377" left="205" width="503" height="13" font="2">dynamic taint propagation could even be pushed down to the hardware level,</text>
<text top="395" left="205" width="503" height="13" font="2">on a 65-bits machine where 1 bit is used to track tainting information, and the</text>
<text top="413" left="205" width="503" height="13" font="2">remaining bits are used for regular 64 bits data values. Unfortunately, there</text>
<text top="431" left="205" width="476" height="13" font="2">are limits to the type of exploits that can be stopped in this way [SB09].</text>
<text top="470" left="167" width="315" height="13" font="2">Run-time monitoring for information ﬂow</text>
<text top="488" left="167" width="540" height="13" font="2">Information ﬂow properties are harder to enforce by run-time monitoring than access</text>
<text top="506" left="167" width="540" height="13" font="2">control properties. Access control for some application can be enforced by run-time</text>
<text top="523" left="167" width="540" height="13" font="2">monitoring of its (input and output) behaviour and then intervening to stop any</text>
<text top="541" left="167" width="540" height="13" font="2">disallowed actions. For information ﬂow this is not possible. For example, consider</text>
<text top="559" left="167" width="540" height="13" font="2">a run-time monitor for the HotelBooker app above, which tries to ensure that my</text>
<text top="577" left="167" width="540" height="13" font="2">credit card number is not leaked to anyone except the hotel. Let’s assume my</text>
<text top="595" left="167" width="540" height="13" font="2">credit card number is 1234 5678 9012 3456. If the monitor sees this number appear,</text>
<text top="613" left="167" width="540" height="14" font="2">say as parameter in an http-request to mafia.org, the monitor could spot it and</text>
<text top="631" left="167" width="540" height="13" font="2">stop the request. But would a monitor also spot and stop such a request with the</text>
<text top="649" left="167" width="540" height="13" font="2">parameter ”6543 2109 8765 4321”? Worse, still, if the monitor spots the number</text>
<text top="667" left="167" width="540" height="13" font="2">1 being communicated over the network, how can it possibly know if this is not</text>
<text top="685" left="167" width="317" height="13" font="2">leaking the ﬁrst digit of my credit card number?</text>
<text top="703" left="190" width="518" height="13" font="2">The only way a run-time monitor could know this is by tracking values passed</text>
<text top="721" left="167" width="540" height="13" font="2">around inside the application, and this is what the dynamic techniques for enforcing</text>
<text top="739" left="167" width="300" height="13" font="2">information ﬂow policies mentioned above do.</text>
<text top="791" left="167" width="31" height="19" font="6">5.3</text>
<text top="791" left="223" width="294" height="19" font="6">Typing for information ﬂow</text>
<text top="828" left="167" width="540" height="13" font="2">This section discusses how information ﬂow policies can be enforced by typing, for</text>
<text top="846" left="167" width="540" height="13" font="2">a toy language, in a sound way – more speciﬁcally, sound with respect to the formal</text>
<text top="864" left="167" width="403" height="13" font="2">characterisation of information ﬂow using non-interference.</text>
<text top="882" left="190" width="518" height="13" font="2">For simplicity, we just consider a lattice with two levels of secrecy: H(igh) and</text>
<text top="900" left="167" width="43" height="13" font="2">L(ow).</text>
<text top="920" left="432" width="11" height="13" font="2">H</text>
<text top="963" left="433" width="9" height="13" font="2">L</text>
<text top="995" left="167" width="540" height="13" font="2">All program variables will have to be assigned a level (type). We will write the</text>
<text top="1013" left="167" width="473" height="14" font="2">level of a program variable as a subscript, so for example we write x</text>
<text top="1018" left="640" width="5" height="9" font="5">t</text>
<text top="1013" left="652" width="55" height="13" font="2">to mean</text>
<text top="1031" left="167" width="540" height="14" font="2">that program variable x has level t. For a real programming language, the levels</text>
<text top="1049" left="167" width="540" height="13" font="2">of program variables would have to be declared, for instance as part of the type</text>
<text top="1066" left="167" width="82" height="13" font="2">declarations.</text>
<text top="1084" left="190" width="518" height="13" font="2">The type system involves typing judgements for expressions and for programs.</text>
<text top="1102" left="167" width="540" height="13" font="2">A typing judgement for an expression is of the form e : t, that expression e has</text>
<text top="1163" left="430" width="15" height="13" font="2">37</text>
</page>
<page number="38" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="167" width="491" height="13" font="2">security level t. For expressions we have the following type derivation rules</text>
<text top="166" left="658" width="6" height="9" font="5">1</text>
<text top="202" left="276" width="63" height="13" font="2">(variable)</text>
<text top="211" left="361" width="9" height="13" font="2">x</text>
<text top="217" left="369" width="5" height="9" font="5">t</text>
<text top="211" left="379" width="14" height="13" font="2">: t</text>
<text top="239" left="212" width="126" height="13" font="2">(binary operations)</text>
<text top="229" left="366" width="25" height="13" font="2">e : t</text>
<text top="229" left="405" width="29" height="13" font="2">e : t</text>
<text top="248" left="373" width="54" height="13" font="2">e ⊕ e : t</text>
<text top="239" left="447" width="216" height="13" font="2">where ⊕ is any binary operation.</text>
<text top="275" left="263" width="76" height="13" font="2">(subtyping)</text>
<text top="266" left="366" width="25" height="13" font="2">e : t</text>
<text top="266" left="405" width="31" height="13" font="2">t &lt; t</text>
<text top="284" left="388" width="25" height="13" font="2">e : t</text>
<text top="310" left="167" width="540" height="13" font="2">In the subtyping rule, &lt; is the ordering on types induces by the lattice. For the</text>
<text top="328" left="167" width="540" height="13" font="2">simple lattice we consider, we just have L &lt; H. This rule allows us to increase the</text>
<text top="346" left="167" width="202" height="13" font="2">secrecy level of any expression.</text>
<text top="363" left="190" width="518" height="13" font="2">To rule out explicit information ﬂows, we clearly want to disallow assignment</text>
<text top="381" left="167" width="540" height="13" font="2">of H-expressions to L-variables. For a typing judgement for programs of the form</text>
<text top="399" left="167" width="540" height="13" font="2">p : ok, meaning that program p does not leak information, the type derivation rule</text>
<text top="417" left="167" width="211" height="13" font="2">for assignment would have to be</text>
<text top="442" left="425" width="25" height="13" font="2">e : t</text>
<text top="461" left="403" width="9" height="13" font="2">x</text>
<text top="466" left="412" width="5" height="9" font="5">t</text>
<text top="461" left="421" width="50" height="13" font="2">= e : ok</text>
<text top="486" left="167" width="540" height="13" font="2">Note that in the combination for the subtyping rule for expressions given above, this</text>
<text top="504" left="167" width="540" height="13" font="2">rules also allows expressions e with a lower classiﬁcation level than t to be assigned</text>
<text top="522" left="167" width="155" height="13" font="2">to a program variable x</text>
<text top="527" left="323" width="5" height="9" font="5">t</text>
<text top="522" left="333" width="61" height="13" font="2">of level t.</text>
<text top="540" left="190" width="518" height="13" font="2">If our programming language would include some output mechanism, say some</text>
<text top="559" left="167" width="335" height="12" font="2">print-statement, the type derivation rule might be</text>
<text top="583" left="423" width="30" height="13" font="2">e : L</text>
<text top="603" left="395" width="85" height="12" font="2">print(e) : ok</text>
<text top="627" left="167" width="540" height="13" font="2">so that only non-conﬁdential information, i.e. information of level L, can be printed.</text>
<text top="648" left="190" width="518" height="13" font="2">However, the type system should also rule out implicit ﬂows, as in a program</text>
<text top="666" left="167" width="58" height="13" font="2">fragment</text>
<text top="685" left="379" width="26" height="12" font="2">if e</text>
<text top="689" left="405" width="6" height="9" font="5">1</text>
<text top="685" left="415" width="43" height="12" font="2">then x</text>
<text top="689" left="458" width="4" height="9" font="5">l</text>
<text top="684" left="467" width="23" height="13" font="2">= e</text>
<text top="689" left="489" width="6" height="9" font="5">2</text>
<text top="707" left="167" width="204" height="13" font="2">where x is a low variable and e</text>
<text top="712" left="371" width="6" height="9" font="5">1</text>
<text top="707" left="382" width="164" height="13" font="2">: H; just requiring that e</text>
<text top="712" left="546" width="6" height="9" font="5">2</text>
<text top="707" left="558" width="149" height="13" font="2">has level L is not good</text>
<text top="725" left="167" width="103" height="13" font="2">enough for this.</text>
<text top="743" left="190" width="518" height="13" font="2">In order to rule out implicit ﬂows, the type system for programs should keep</text>
<text top="761" left="167" width="540" height="13" font="2">track of the levels of the variables that are assigned to in programs: typing judge-</text>
<text top="779" left="167" width="368" height="13" font="2">ments for programs, of the form p : ok t, will means that</text>
<text top="803" left="205" width="465" height="13" font="2">‘p does not leak information and does not assign to variables of levels</text>
<text top="821" left="205" width="90" height="13" font="2">lower than p’.</text>
<text top="845" left="167" width="292" height="13" font="2">The type derivation rules are then as follows</text>
<text top="880" left="301" width="84" height="13" font="2">(assignment)</text>
<text top="870" left="433" width="25" height="13" font="2">e : t</text>
<text top="889" left="407" width="9" height="13" font="2">x</text>
<text top="894" left="415" width="5" height="9" font="5">t</text>
<text top="889" left="425" width="59" height="13" font="2">= e : ok t</text>
<text top="920" left="302" width="83" height="13" font="2">(if-then-else)</text>
<text top="910" left="407" width="25" height="13" font="2">e : t</text>
<text top="910" left="452" width="8" height="13" font="2">p</text>
<text top="916" left="460" width="6" height="9" font="5">1</text>
<text top="910" left="471" width="32" height="13" font="2">: ok t</text>
<text top="910" left="522" width="8" height="13" font="2">p</text>
<text top="916" left="530" width="6" height="9" font="5">2</text>
<text top="910" left="541" width="32" height="13" font="2">: ok t</text>
<text top="930" left="407" width="72" height="12" font="2">if e then p</text>
<text top="934" left="478" width="6" height="9" font="5">1</text>
<text top="930" left="488" width="42" height="12" font="2">else p</text>
<text top="934" left="531" width="6" height="9" font="5">2</text>
<text top="929" left="541" width="32" height="13" font="2">: ok t</text>
<text top="960" left="294" width="90" height="13" font="2">(composition)</text>
<text top="951" left="407" width="8" height="13" font="2">p</text>
<text top="956" left="414" width="6" height="9" font="5">1</text>
<text top="951" left="425" width="32" height="13" font="2">: ok t</text>
<text top="951" left="477" width="8" height="13" font="2">p</text>
<text top="956" left="484" width="6" height="9" font="5">2</text>
<text top="951" left="495" width="32" height="13" font="2">: ok t</text>
<text top="969" left="431" width="8" height="13" font="2">p</text>
<text top="975" left="439" width="6" height="9" font="5">1</text>
<text top="969" left="446" width="14" height="13" font="2">; p</text>
<text top="975" left="460" width="6" height="9" font="5">2</text>
<text top="969" left="471" width="32" height="13" font="2">: ok t</text>
<text top="1000" left="339" width="46" height="13" font="2">(while)</text>
<text top="991" left="422" width="25" height="13" font="2">e : t</text>
<text top="991" left="467" width="43" height="13" font="2">p : ok t</text>
<text top="1011" left="407" width="120" height="12" font="2">while (e){p} : ok t</text>
<text top="1041" left="309" width="76" height="13" font="2">(subtyping)</text>
<text top="1031" left="407" width="43" height="13" font="2">p : ok t</text>
<text top="1031" left="470" width="35" height="13" font="2">t &lt; t</text>
<text top="1050" left="432" width="43" height="13" font="2">p : ok t</text>
<text top="1076" left="184" width="5" height="8" font="14">1</text>
<text top="1078" left="190" width="517" height="11" font="10">These rules are given in the standard format for type derivation rules. In this format premises</text>
<text top="1092" left="167" width="540" height="11" font="10">of a rule are listed above the horizontal line, and the conclusion below it. It can be read as an</text>
<text top="1106" left="167" width="540" height="11" font="10">implication or an if-then statement: if the typing judgements above the line hold then we may</text>
<text top="1120" left="167" width="224" height="11" font="10">conclude the typing judgement below it.</text>
<text top="1163" left="430" width="15" height="13" font="2">38</text>
</page>
<page number="39" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="167" width="540" height="13" font="2">The rule for assignment says that we can only assign values e of level t to variables</text>
<text top="186" left="167" width="9" height="13" font="2">x</text>
<text top="191" left="176" width="5" height="9" font="5">t</text>
<text top="186" left="187" width="520" height="13" font="2">of level t; using the subtyping rule for expressions we can also store values of</text>
<text top="204" left="167" width="268" height="13" font="2">lower levels that t in a variable of level t.</text>
<text top="222" left="190" width="518" height="14" font="2">Note that here the rule for if-then-else ensures that the level of variables</text>
<text top="240" left="167" width="540" height="13" font="2">assigned to in the then- or else-branch is equal or higher than the level of the guard.</text>
<text top="258" left="167" width="540" height="13" font="2">This rules out unwanted implicit ﬂows: assigning to a variable of a lower level than</text>
<text top="275" left="167" width="540" height="13" font="2">the guard would be an unwanted implicit information ﬂow. Similarly, the rule for</text>
<text top="295" left="167" width="511" height="12" font="2">while forbids assignments to variables that have a lower level than the guard.</text>
<text top="311" left="190" width="518" height="13" font="2">Also note that the subtyping rule for programs goes in the opposite direction as</text>
<text top="329" left="167" width="149" height="13" font="2">the one for expressions</text>
<text top="327" left="316" width="6" height="9" font="5">2</text>
<text top="329" left="323" width="4" height="13" font="2">.</text>
<text top="354" left="190" width="496" height="13" font="2">Important questions for the type system above, as for any type system, are:</text>
<text top="380" left="190" width="518" height="14" font="2">• Is the type system sound? In other words: are well-typed programs guaran-</text>
<text top="399" left="205" width="318" height="13" font="2">teed not to contain unwanted information ﬂows?</text>
<text top="426" left="190" width="518" height="14" font="2">• Is the type system complete? In other words: are all programs that do not</text>
<text top="445" left="205" width="409" height="13" font="2">contain unwanted information ﬂows guaranteed to be typable?</text>
<text top="471" left="190" width="518" height="13" font="2">The type system is not complete. Simple examples can show this: for example,</text>
<text top="489" left="167" width="64" height="13" font="2">suppose e</text>
<text top="494" left="232" width="24" height="9" font="5">high</text>
<text top="489" left="263" width="180" height="13" font="2">is a high expression, and x</text>
<text top="494" left="443" width="18" height="9" font="5">low</text>
<text top="489" left="468" width="239" height="13" font="2">is a low variable, then the following</text>
<text top="507" left="167" width="213" height="13" font="2">program lines are not well typed</text>
<text top="534" left="316" width="9" height="13" font="2">x</text>
<text top="539" left="325" width="18" height="9" font="5">low</text>
<text top="534" left="348" width="23" height="13" font="2">= e</text>
<text top="539" left="371" width="24" height="9" font="5">high</text>
<text top="533" left="400" width="22" height="14" font="2">− e</text>
<text top="539" left="422" width="24" height="9" font="5">high</text>
<text top="534" left="447" width="4" height="13" font="2">;</text>
<text top="553" left="316" width="26" height="12" font="2">if e</text>
<text top="557" left="342" width="24" height="9" font="5">high</text>
<text top="553" left="371" width="43" height="12" font="2">then x</text>
<text top="557" left="414" width="18" height="9" font="5">low</text>
<text top="552" left="438" width="70" height="14" font="2">= 7 else x</text>
<text top="557" left="507" width="18" height="9" font="5">low</text>
<text top="552" left="531" width="27" height="13" font="2">= 7;</text>
<text top="580" left="167" width="325" height="13" font="2">even though they clearly do not leak information.</text>
<text top="598" left="190" width="518" height="13" font="2">The type system above is sound. To prove this, we need some formal deﬁnition</text>
<text top="615" left="167" width="540" height="13" font="2">of what it means for a program not to contain unwanted information ﬂows. The</text>
<text top="633" left="167" width="540" height="13" font="2">standard way to do this is by means of non-interference, which deﬁnes interference</text>
<text top="651" left="167" width="540" height="13" font="2">(or dependencies) between values of program values. For this we have to consider</text>
<text top="669" left="167" width="540" height="13" font="2">program states, which are vectors that assign a value to every program value. For</text>
<text top="687" left="167" width="524" height="13" font="2">program states we can consider if they agree on the values for the low variables:</text>
<text top="713" left="167" width="396" height="13" font="2">Deﬁnition 5.3.1 For program states µ and ν, we write µ ≈</text>
<text top="719" left="563" width="18" height="9" font="5">low</text>
<text top="713" left="587" width="120" height="13" font="2">ν iﬀ µ and ν agree</text>
<text top="731" left="167" width="109" height="13" font="2">on low variables.</text>
<text top="760" left="167" width="275" height="13" font="2">The idea behind this deﬁnition is that µ ≈</text>
<text top="765" left="442" width="18" height="9" font="5">low</text>
<text top="760" left="466" width="241" height="13" font="2">ν means that an observer who is only</text>
<text top="778" left="167" width="517" height="13" font="2">allowed to read low variables cannot tell the diﬀerence between states µ and ν.</text>
<text top="796" left="190" width="518" height="13" font="2">Semantically, a program can be seen as a function that takes an initial program</text>
<text top="814" left="167" width="540" height="13" font="2">state as input and produces a ﬁnal program state as output. Given the notion of</text>
<text top="831" left="167" width="12" height="14" font="2">≈</text>
<text top="837" left="179" width="18" height="9" font="5">low</text>
<text top="831" left="203" width="391" height="13" font="2">we can now deﬁne the absence if information ﬂow as follow:</text>
<text top="858" left="167" width="540" height="13" font="2">Deﬁnition 5.3.2 (Non-interference) A program p does not leak information if,</text>
<text top="876" left="167" width="327" height="13" font="2">for all possible start states µ and ν such that µ ≈</text>
<text top="881" left="494" width="18" height="9" font="5">low</text>
<text top="876" left="518" width="189" height="13" font="2">ν, whenever executing p in µ</text>
<text top="894" left="167" width="540" height="13" font="2">terminates and results in µ and executing p in ν terminates and results in ν , then</text>
<text top="912" left="167" width="29" height="13" font="2">µ ≈</text>
<text top="917" left="196" width="18" height="9" font="5">low</text>
<text top="912" left="220" width="17" height="13" font="2">ν .</text>
<text top="940" left="167" width="540" height="13" font="2">The idea is that if in an initial state µ we change the values of one or more of the</text>
<text top="958" left="167" width="540" height="13" font="2">high (secret) variables then, after executing c, we cannot see any diﬀerence in the</text>
<text top="976" left="167" width="540" height="13" font="2">outcome as far as the low (public) variables are concerned. In other words, the</text>
<text top="994" left="167" width="540" height="13" font="2">values of high variables do not interfere with the execution as far as low variables</text>
<text top="1012" left="167" width="540" height="13" font="2">are concerned. This means an observer who is only allowed to observe low variables</text>
<text top="1030" left="167" width="392" height="13" font="2">cannot learn anything about the values of high values. have</text>
<text top="1047" left="190" width="518" height="13" font="2">For this characterisation of (absence of) unwanted information ﬂows we can now</text>
<text top="1065" left="167" width="39" height="13" font="2">prove:</text>
<text top="1090" left="184" width="5" height="8" font="14">2</text>
<text top="1092" left="190" width="517" height="11" font="10">People familiar with the Bell-LaPadula system for mandatory access control with multiple</text>
<text top="1106" left="167" width="540" height="11" font="10">levels of access can recognise the ‘no read up’ and the ‘no write down’ rules in the subtyping rules</text>
<text top="1120" left="167" width="237" height="11" font="10">for expressions and programs, respectively.</text>
<text top="1163" left="430" width="15" height="13" font="2">39</text>
</page>
<page number="40" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="167" width="540" height="13" font="2">Theorem 5.3.1 (Soundness) If p : ok t then p is non-interferent, i.e., does not</text>
<text top="186" left="167" width="290" height="13" font="2">leak information from higher to lower levels.</text>
<text top="246" left="167" width="540" height="13" font="2">Exercise 5.3.1 (Typing for integrity) As an exercise to see if you understand</text>
<text top="264" left="167" width="540" height="13" font="2">the idea of the type system above, deﬁne a type system for integrity instead of</text>
<text top="281" left="167" width="95" height="13" font="2">conﬁdentiality.</text>
<text top="299" left="190" width="518" height="13" font="2">For simplicity, we just consider a lattice with two levels of integrity: U(ntainted)</text>
<text top="317" left="167" width="96" height="13" font="2">and T(ainted).</text>
<text top="338" left="432" width="11" height="13" font="2">U</text>
<text top="380" left="432" width="11" height="13" font="2">T</text>
<text top="412" left="167" width="239" height="13" font="2">Assume that all program variables x</text>
<text top="417" left="406" width="5" height="9" font="5">t</text>
<text top="412" left="417" width="239" height="13" font="2">are labelled with an integrity level t.</text>
<text top="430" left="190" width="518" height="13" font="2">First deﬁne rules for expressions e for judgments of the form e : t, which mean</text>
<text top="448" left="167" width="311" height="13" font="2">that expression e has integrity level t or higher.</text>
<text top="466" left="190" width="518" height="13" font="2">Then deﬁne rules for programs p for judgments of the form p : ok t, which mean</text>
<text top="484" left="167" width="540" height="13" font="2">that program p does not violate integrity (i.e. does not store tainted information in</text>
<text top="502" left="167" width="529" height="13" font="2">a variable of level U ), and only stores information in variables of level t or lower.</text>
<text top="535" left="167" width="540" height="13" font="2">Exercise 5.3.2 (Non-interference for integrity) As an exercise to see if you</text>
<text top="553" left="167" width="540" height="13" font="2">understand the idea of non-interference, deﬁne a notion of non-interference for in-</text>
<text top="571" left="167" width="212" height="13" font="2">tegrity instead of conﬁdentiality.</text>
<text top="588" left="190" width="518" height="13" font="2">As part of this you will have to think about the appropriate notion of equivalence</text>
<text top="606" left="167" width="334" height="14" font="2">≈ on program states that you need to express this.</text>
<text top="646" left="167" width="341" height="16" font="1">Termination-sensitive information ﬂow</text>
<text top="676" left="167" width="540" height="13" font="2">The typing derivation rules above do not take non-termination into account as a hid-</text>
<text top="694" left="167" width="540" height="14" font="2">den channel. For termination-sensitive information ﬂow, the rules for if-then-else</text>
<text top="712" left="167" width="309" height="14" font="2">and while have to be more restrictive, namely:</text>
<text top="753" left="298" width="83" height="13" font="2">(if-then-else)</text>
<text top="744" left="409" width="47" height="13" font="2">e : L p</text>
<text top="749" left="456" width="6" height="9" font="5">1</text>
<text top="744" left="467" width="32" height="13" font="2">: ok t</text>
<text top="744" left="513" width="8" height="13" font="2">p</text>
<text top="749" left="521" width="6" height="9" font="5">2</text>
<text top="744" left="532" width="32" height="13" font="2">: ok t</text>
<text top="763" left="403" width="72" height="12" font="2">if e then p</text>
<text top="767" left="475" width="6" height="9" font="5">1</text>
<text top="763" left="485" width="42" height="12" font="2">else p</text>
<text top="767" left="527" width="6" height="9" font="5">2</text>
<text top="762" left="538" width="32" height="13" font="2">: ok t</text>
<text top="789" left="335" width="46" height="13" font="2">(while)</text>
<text top="780" left="419" width="30" height="13" font="2">e : L</text>
<text top="780" left="463" width="43" height="13" font="2">p : ok t</text>
<text top="800" left="403" width="120" height="12" font="2">while (e){p} : ok t</text>
<text top="832" left="167" width="540" height="14" font="2">The rule for while here excludes the possibility of a high (secret) condition e, as</text>
<text top="850" left="167" width="540" height="14" font="2">this may leak information. For example, the program while(b){ skip } will leak</text>
<text top="867" left="167" width="540" height="14" font="2">the value of b in the termination behaviour. Similarly, the rule for if-then-else</text>
<text top="885" left="167" width="540" height="13" font="2">excludes the possibility of a high (secret) guard, because this may leak information</text>
<text top="903" left="167" width="127" height="13" font="2">– namely in case p</text>
<text top="909" left="295" width="6" height="9" font="5">1</text>
<text top="903" left="308" width="112" height="13" font="2">terminates but p</text>
<text top="909" left="420" width="6" height="9" font="5">2</text>
<text top="903" left="434" width="274" height="13" font="2">does not, or vice versa. Note that these</text>
<text top="921" left="167" width="540" height="13" font="2">rules are very restrictive! It means it is impossible to branch on any conditions that</text>
<text top="939" left="167" width="164" height="13" font="2">involve high information.</text>
<text top="957" left="190" width="518" height="13" font="2">With these rules the type system will again not be complete. To prove soundness,</text>
<text top="975" left="167" width="540" height="13" font="2">we now need a diﬀerent characterisation of what it means for a program not to leak,</text>
<text top="993" left="167" width="410" height="13" font="2">which takes non-termination into account as a hidden channel:</text>
<text top="1023" left="167" width="540" height="13" font="2">Deﬁnition 5.3.3 (Termination-sensitive Non-interference) A program p is</text>
<text top="1041" left="167" width="556" height="13" font="2">termination-sensitive non-interferent (i.e., does not leak information, not even through</text>
<text top="1059" left="167" width="259" height="13" font="2">its termination behaviour) if, for all µ ≈</text>
<text top="1064" left="426" width="18" height="9" font="5">low</text>
<text top="1059" left="450" width="258" height="13" font="2">ν, whenever executing p in µ terminates</text>
<text top="1077" left="167" width="540" height="13" font="2">and results in µ , then executing p in ν also terminates and results in a state ν for</text>
<text top="1095" left="167" width="72" height="13" font="2">which µ ≈</text>
<text top="1100" left="239" width="18" height="9" font="5">low</text>
<text top="1095" left="263" width="17" height="13" font="2">ν .</text>
<text top="1163" left="430" width="15" height="13" font="2">40</text>
</page>
<page number="41" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="190" width="518" height="14" font="2">For the more restrictive rules for if-then-else and while we can now prove</text>
<text top="186" left="167" width="69" height="13" font="2">soundness.</text>
<text top="216" left="167" width="567" height="13" font="2">Theorem 5.3.2 (Soundness) If p : okt then p is termination-sensitive non-interferent,</text>
<text top="234" left="167" width="540" height="13" font="2">i.e., does not leak information from higher to lower levels, even through its termi-</text>
<text top="252" left="167" width="115" height="13" font="2">nation behaviour.</text>
<text top="281" left="190" width="518" height="13" font="2">More complicated notions of non-interference can be given to account for execu-</text>
<text top="299" left="167" width="540" height="13" font="2">tion time as a hidden channel, or to deﬁne what unwanted information ﬂow means</text>
<text top="317" left="167" width="207" height="13" font="2">for non-deterministic programs.</text>
<text top="353" left="167" width="145" height="13" font="2">Growing suspicions</text>
<text top="371" left="167" width="540" height="13" font="2">Looking back at the evolution of computing, we can see a steady increase in com-</text>
<text top="389" left="167" width="540" height="13" font="2">plexity in ever more ﬁne-grained access control, in response to a steady decline in</text>
<text top="407" left="167" width="36" height="13" font="2">trust.</text>
<text top="436" left="190" width="504" height="14" font="2">• Initially, software ran on the bare hardware, free to do anything it wanted.</text>
<text top="466" left="190" width="518" height="14" font="2">• Then operating systems (and hardware) introduced a distinction between ker-</text>
<text top="485" left="205" width="423" height="13" font="2">nel and user mode, and began to enforce access control per user.</text>
<text top="514" left="190" width="518" height="14" font="2">• At ﬁrst all processes started by a user were trusted equally, and trusted as</text>
<text top="532" left="205" width="503" height="13" font="2">much as the user himself, so ran with all the user’s privileges. Gradually</text>
<text top="550" left="205" width="503" height="13" font="2">options appeared to reduce privileges of individual processes, to face the fact</text>
<text top="568" left="205" width="503" height="13" font="2">that some applications should be trusted less than others, even when executed</text>
<text top="586" left="205" width="171" height="13" font="2">by one and the same user.</text>
<text top="615" left="190" width="518" height="14" font="2">• Language-based access control is a next step in the evolution: diﬀerent parts of</text>
<text top="634" left="205" width="503" height="13" font="2">a program are trusted to a diﬀerent degree, and hence executed with diﬀerent</text>
<text top="652" left="205" width="382" height="13" font="2">permissions, as for instance enforced by the Java sandbox.</text>
<text top="681" left="190" width="518" height="14" font="2">• The notion of information ﬂow suggest a possible next step in the evolution:</text>
<text top="700" left="205" width="503" height="13" font="2">our trust in a process running on some computer might not only depend on</text>
<text top="718" left="205" width="503" height="13" font="2">(i) the user who started the process and on (ii) on the origin of the diﬀerent</text>
<text top="736" left="205" width="503" height="13" font="2">parts of the code, but also on the origin of the input that we feed to it: the</text>
<text top="754" left="205" width="503" height="13" font="2">same piece of code, executed by the same user, should be trusted less when</text>
<text top="772" left="205" width="503" height="13" font="2">acting on untrusted input (say input obtained over the web) than when acting</text>
<text top="789" left="205" width="503" height="13" font="2">on trusted input (say input typed on the user’s keyboard). It remains to be</text>
<text top="807" left="205" width="427" height="13" font="2">seen if such forms of access control will ever become mainstream.</text>
<text top="1163" left="430" width="15" height="13" font="2">41</text>
</page>
<page number="42" position="absolute" top="0" left="0" height="1188" width="918">
<text top="272" left="167" width="234" height="33" font="3">Bibliography</text>
<text top="367" left="167" width="45" height="13" font="2">[AB10]</text>
<text top="367" left="246" width="251" height="13" font="2">Sarita V. Adve and Hans-J. Boehm.</text>
<text top="367" left="512" width="195" height="13" font="2">Memory models: A case for</text>
<text top="385" left="246" width="461" height="13" font="2">rethinking parallel languages and hardware. Communications of the</text>
<text top="403" left="246" width="170" height="13" font="2">ACM, 53(8):90–101, 2010.</text>
<text top="433" left="167" width="34" height="13" font="2">[BFL</text>
<text top="431" left="201" width="9" height="9" font="5">+</text>
<text top="433" left="211" width="19" height="13" font="2">11]</text>
<text top="433" left="246" width="170" height="13" font="2">Mike Barnett, Manuel F¨</text>
<text top="433" left="409" width="273" height="13" font="2">ahndrich, K. Rustan M. Leino, Peter M¨</text>
<text top="433" left="674" width="33" height="13" font="2">uller,</text>
<text top="451" left="246" width="461" height="13" font="2">Wolfram Schulte, and Herman Venter. Speciﬁcation and veriﬁcation:</text>
<text top="469" left="246" width="461" height="13" font="2">the Spec# experience. Communications of the ACM, 54(6):81–91, 2011.</text>
<text top="499" left="167" width="37" height="13" font="2">[CCC</text>
<text top="496" left="204" width="9" height="9" font="5">+</text>
<text top="499" left="214" width="19" height="13" font="2">05]</text>
<text top="499" left="246" width="461" height="13" font="2">M. Costa, J. Crowcroft, M. Castro, A. Rowstron, L. Zhou, L. Zhang,</text>
<text top="517" left="246" width="461" height="13" font="2">and P. Barham. Vigilante: end-to-end containment of internet worms.</text>
<text top="534" left="246" width="461" height="13" font="2">In ACM SIGOPS Operating Systems Review, volume 39, pages 133–147.</text>
<text top="552" left="246" width="78" height="13" font="2">ACM, 2005.</text>
<text top="582" left="167" width="46" height="13" font="2">[DD77]</text>
<text top="582" left="246" width="461" height="13" font="2">Dorothy E. Denning and Peter J. Denning. Certiﬁcation of programs for</text>
<text top="600" left="246" width="461" height="13" font="2">secure information ﬂow. Communications of the ACM, 20(7):504–513,</text>
<text top="618" left="246" width="67" height="13" font="2">July 1977.</text>
<text top="648" left="167" width="46" height="13" font="2">[GA06]</text>
<text top="648" left="246" width="461" height="13" font="2">Sudhakar Govindavajhala and Andrew W. Appel. Windows access con-</text>
<text top="666" left="246" width="406" height="13" font="2">trol demystiﬁed. Technical report, Princeton University, 2006.</text>
<text top="696" left="167" width="50" height="13" font="2">[Goe03]</text>
<text top="696" left="246" width="461" height="13" font="2">Brian Goetz. Java theory and practice: To mutate or not to mutate?</text>
<text top="714" left="246" width="356" height="13" font="2">immutable objects can greatly simplify your life, 2003.</text>
<text top="744" left="167" width="62" height="13" font="2">[GVW03]</text>
<text top="744" left="246" width="461" height="13" font="2">M. Graﬀ and K.R. Van Wyk. Secure coding: principles and practices.</text>
<text top="762" left="246" width="142" height="13" font="2">O’Reilly Media, 2003.</text>
<text top="792" left="167" width="53" height="13" font="2">[HLV09]</text>
<text top="792" left="246" width="461" height="13" font="2">Michael Howard, David LeBlanc, and John Viega. The 24 deadly sins</text>
<text top="809" left="246" width="265" height="13" font="2">of software security. McGraw-Hill, 2009.</text>
<text top="839" left="167" width="13" height="13" font="2">[L</text>
<text top="837" left="181" width="9" height="9" font="5">+</text>
<text top="839" left="191" width="19" height="13" font="2">96]</text>
<text top="839" left="246" width="461" height="13" font="2">Jacques-Louis Lions et al. Ariane V Flight 501 failure - Enquiry Board</text>
<text top="857" left="246" width="201" height="13" font="2">report. Technical report, 1996.</text>
<text top="887" left="167" width="45" height="13" font="2">[Ler03]</text>
<text top="887" left="246" width="461" height="13" font="2">Xavier Leroy. Java bytecode veriﬁcation: Algorithms and formaliza-</text>
<text top="905" left="246" width="380" height="13" font="2">tions. Journal of Automated Reasoning, 30:235–269, 2003.</text>
<text top="935" left="167" width="47" height="13" font="2">[MF99]</text>
<text top="935" left="246" width="461" height="13" font="2">Gary McGraw and Ed W. Felten. Securing Java: getting down to busi-</text>
<text top="953" left="246" width="461" height="13" font="2">ness with mobile code. Wiley Computer Pub., 1999. Available online</text>
<text top="971" left="246" width="234" height="14" font="2">at http://www.securingjava.com.</text>
<text top="1001" left="167" width="47" height="13" font="2">[MP08]</text>
<text top="1001" left="246" width="461" height="13" font="2">Wojciech Mostowski and Erik Poll. Malicious code on Java Card smart-</text>
<text top="1019" left="246" width="251" height="13" font="2">cards: Attacks and countermeasures.</text>
<text top="1019" left="512" width="195" height="13" font="2">In CARDIS, volume 5189 of</text>
<text top="1037" left="246" width="227" height="13" font="2">LNCS, pages 1–16. Springer, 2008.</text>
<text top="1067" left="167" width="51" height="13" font="2">[Myc07]</text>
<text top="1067" left="246" width="461" height="13" font="2">Alan Mycroft. Programming language design and analysis motivated</text>
<text top="1084" left="246" width="461" height="13" font="2">by hardware evolution. In SAS’07, number 3634 in LNCS, pages 18–33.</text>
<text top="1102" left="246" width="98" height="13" font="2">Springer, 2007.</text>
<text top="1163" left="430" width="15" height="13" font="2">42</text>
</page>
<page number="43" position="absolute" top="0" left="0" height="1188" width="918">
<text top="168" left="167" width="51" height="13" font="2">[Mye99]</text>
<text top="168" left="246" width="125" height="13" font="2">Andrew C. Myers.</text>
<text top="168" left="385" width="322" height="13" font="2">JFlow: Practical mostly-static information ﬂow</text>
<text top="186" left="246" width="461" height="13" font="2">control. In POPL, pages 228–241. ACM, 1999. Ongoing development</text>
<text top="204" left="246" width="258" height="14" font="2">at http://www.cs.cornell.edu/jif/.</text>
<text top="234" left="167" width="42" height="13" font="2">[SB09]</text>
<text top="234" left="246" width="461" height="13" font="2">Asia Slowinska and Herbert Bos. Pointless tainting? evaluating the</text>
<text top="252" left="246" width="461" height="13" font="2">practicality of pointer tainting. In Proceedings of ACM SIGOPS EU-</text>
<text top="269" left="246" width="328" height="13" font="2">ROSYS, Nuremberg, Germany, March-April 2009.</text>
<text top="299" left="167" width="57" height="13" font="2">[SGM02]</text>
<text top="299" left="246" width="461" height="13" font="2">C. Szyperski, D. Gruntz, and S. Murer. Component software: beyond</text>
<text top="317" left="246" width="426" height="13" font="2">object-oriented programming. Addison-Wesley Professional, 2002.</text>
<text top="347" left="167" width="46" height="13" font="2">[Sut05]</text>
<text top="347" left="246" width="461" height="13" font="2">Herb Sutter. The free lunch is over: A fundamental turn toward con-</text>
<text top="365" left="246" width="407" height="13" font="2">currency in software. Dr. Dobbs Journal, 30(3):202–210, 2005.</text>
<text top="395" left="167" width="540" height="13" font="2">[VMMF00] John Viega, Gary McGraw, Tom Mutdoseh, and Edward W. Fel-</text>
<text top="413" left="246" width="25" height="13" font="2">ten.</text>
<text top="413" left="291" width="206" height="13" font="2">Statically scanning java code:</text>
<text top="413" left="513" width="194" height="13" font="2">Finding security vulnerabili-</text>
<text top="431" left="246" width="27" height="13" font="2">ties.</text>
<text top="431" left="288" width="239" height="13" font="2">Software, IEEE, 17(5):68–77, 2000.</text>
<text top="431" left="542" width="166" height="13" font="2">Almost identical content</text>
<text top="449" left="246" width="461" height="14" font="2">is available at http://www.javaworld.com/javaworld/jw-12-1998/</text>
<text top="468" left="246" width="194" height="12" font="2">jw-12-securityrules.html.</text>
<text top="1163" left="430" width="15" height="13" font="2">43</text>
</page>
</pdf2xml>
