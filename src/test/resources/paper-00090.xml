<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="24" family="Times" color="#231f20"/>
	<fontspec id="1" size="6" family="Times" color="#231f20"/>
	<fontspec id="2" size="15" family="Times" color="#231f20"/>
	<fontspec id="3" size="12" family="Times" color="#231f20"/>
	<fontspec id="4" size="15" family="Times" color="#231f20"/>
	<fontspec id="5" size="11" family="Times" color="#231f20"/>
	<fontspec id="6" size="11" family="Times" color="#231f20"/>
<text top="107" left="92" width="731" height="26" font="0"><b>Auto-Generation and Auto-Tuning of 3D Stencil Codes on</b></text>
<text top="137" left="367" width="173" height="26" font="0"><b>GPU Clusters</b></text>
<text top="147" left="548" width="6" height="7" font="1">∗</text>
<text top="205" left="330" width="254" height="17" font="2">Yongpeng Zhang, Frank Mueller</text>
<text top="223" left="269" width="377" height="14" font="3">North Carolina State University, Raleigh, NC 27695-7534</text>
<text top="238" left="376" width="162" height="17" font="2">muller@cs.ncsu.edu</text>
<text top="312" left="81" width="97" height="16" font="4"><b>ABSTRACT</b></text>
<text top="331" left="81" width="359" height="12" font="5">This paper develops and evaluates search and optimization tech-</text>
<text top="347" left="81" width="359" height="12" font="5">niques for auto-tuning 3D stencil (nearest-neighbor) computations</text>
<text top="363" left="81" width="359" height="12" font="5">on GPUs. Observations indicate that parameter tuning is necessary</text>
<text top="379" left="81" width="359" height="12" font="5">for heterogeneous GPUs to achieve optimal performance with re-</text>
<text top="394" left="81" width="359" height="12" font="5">spect to a search space. Our proposed framework takes a most con-</text>
<text top="410" left="81" width="359" height="12" font="5">cise speciﬁcation of stencil behavior from the user as a single for-</text>
<text top="426" left="81" width="359" height="12" font="5">mula, auto-generates tunable code from it, systematically searches</text>
<text top="441" left="81" width="359" height="12" font="5">for the best conﬁguration and generates the code with optimal pa-</text>
<text top="457" left="81" width="359" height="12" font="5">rameter conﬁgurations for different GPUs. This auto-tuning ap-</text>
<text top="473" left="81" width="359" height="12" font="5">proach guarantees adaptive performance for different generations</text>
<text top="488" left="81" width="359" height="12" font="5">of GPUs while greatly enhancing programmer productivity. Exper-</text>
<text top="504" left="81" width="359" height="12" font="5">imental results show that the delivered ﬂoating point performance</text>
<text top="520" left="81" width="359" height="12" font="5">is very close to previous handcrafted work and outperforms other</text>
<text top="535" left="81" width="231" height="12" font="5">auto-tuned stencil codes by a large margin.</text>
<text top="570" left="81" width="13" height="16" font="4"><b>1.</b></text>
<text top="570" left="112" width="143" height="16" font="4"><b>INTRODUCTION</b></text>
<text top="590" left="81" width="359" height="12" font="5">Main-stream microprocessor design no longer delivers perfor-</text>
<text top="606" left="81" width="359" height="12" font="5">mance boosts by increasing the processor clock frequency due to</text>
<text top="621" left="81" width="359" height="12" font="5">power and thermal constraints. Nonetheless, advances in semicon-</text>
<text top="637" left="81" width="359" height="12" font="5">ductor fabrication still allow the transistor density to increase at the</text>
<text top="653" left="81" width="359" height="12" font="5">rate of Moore’s law. This has resulted in the proliferation of many-</text>
<text top="669" left="81" width="359" height="12" font="5">core parallel architectures and accelerators, among which GPUs</text>
<text top="684" left="81" width="359" height="12" font="5">quickly established themselves as suitable for applications that ex-</text>
<text top="700" left="81" width="186" height="12" font="5">ploit ﬁne-grained data-parallelism.</text>
<text top="731" left="81" width="359" height="12" font="5">Still, software development for parallel architectures turns out to</text>
<text top="747" left="81" width="359" height="12" font="5">be more difﬁcult than that for uni-processors in terms of obtaining</text>
<text top="763" left="81" width="359" height="12" font="5">high performance, even when aided by new programming models</text>
<text top="778" left="81" width="359" height="12" font="5">such as CUDA [1] and OpenCL [9]. Programmers spend substan-</text>
<text top="794" left="81" width="359" height="12" font="5">tial time and effort to understand the underlying architecture to best</text>
<text top="810" left="81" width="359" height="12" font="5">utilize all resources. This can become a daunting task since perfor-</text>
<text top="825" left="81" width="359" height="12" font="5">mance is affected by a multitude of architectural features. Even</text>
<text top="841" left="81" width="359" height="12" font="5">worse, architectural difference between generations of the same</text>
<text top="857" left="81" width="359" height="12" font="5">hardware line may require a diversity of optimization strategies</text>
<text top="873" left="81" width="359" height="12" font="5">with sometimes opposite optimal set-points. Programmers may</text>
<text top="899" left="81" width="6" height="7" font="1">∗</text>
<text top="900" left="87" width="352" height="12" font="5">This work was supported in part by NSF grants 1058779,</text>
<text top="913" left="81" width="318" height="12" font="5">0958311, 0937908, and DOE grant DE-FG02-08ER25837.</text>
<text top="315" left="475" width="359" height="12" font="5">have to explore many (if not all) combinations of optimization op-</text>
<text top="331" left="475" width="359" height="12" font="5">tions and parameter values to determine the best conﬁguration for</text>
<text top="346" left="475" width="359" height="12" font="5">a particular hardware. This poses a great challenge since program-</text>
<text top="362" left="475" width="359" height="12" font="5">mer productivity is adversely affected by lengthy tuning efforts.</text>
<text top="378" left="475" width="359" height="12" font="5">Simply re-proﬁling and re-writing the program each time the hard-</text>
<text top="393" left="475" width="321" height="12" font="5">ware is upgraded is neither desirable nor feasible over time.</text>
<text top="425" left="475" width="359" height="12" font="5">Current compilers for general-purpose languages struggle to bal-</text>
<text top="441" left="475" width="294" height="12" font="5">ance portability, performance and programmability.</text>
<text top="441" left="786" width="48" height="12" font="5">Domain-</text>
<text top="456" left="475" width="359" height="12" font="5">speciﬁc languages (DSLs), in contrast, offer a promising solution</text>
<text top="472" left="475" width="359" height="12" font="5">at the expense of sacriﬁcing language generality [3]. DSLs have re-</text>
<text top="488" left="475" width="359" height="12" font="5">stricted expressiveness aimed at a particular domain. It is precisely</text>
<text top="503" left="475" width="359" height="12" font="5">this domain-speciﬁc knowledge that allows the DSL-compiler to</text>
<text top="519" left="475" width="359" height="12" font="5">attain performance achieve comparable to hand-coded domain im-</text>
<text top="535" left="475" width="359" height="12" font="5">plementations. In contrast, general-purpose languages are inher-</text>
<text top="550" left="475" width="359" height="12" font="5">ently limited in their optimization scope in exchange for assuring</text>
<text top="566" left="475" width="359" height="12" font="5">correctness and good overall (but not best) performance on average</text>
<text top="582" left="475" width="359" height="12" font="5">for a wide range of applications. Examples of well-known DSLs</text>
<text top="597" left="475" width="359" height="12" font="5">are HTML for web pages, Matlab for scientiﬁc computation and</text>
<text top="613" left="475" width="140" height="12" font="5">SQL for database queries.</text>
<text top="645" left="475" width="359" height="12" font="5">This work focuses on providing a portable source-to-source auto-</text>
<text top="660" left="475" width="359" height="12" font="5">generation and auto-tuning framework for iterative 3D Jacobi sten-</text>
<text top="676" left="475" width="359" height="12" font="5">cil computations on different GPUs. We generate stencil code as</text>
<text top="692" left="475" width="359" height="12" font="5">native CUDA code for NVIDIA GPUs, yet the same principles ap-</text>
<text top="707" left="475" width="359" height="12" font="5">ply for GPUs of other vendor and comparable programming mod-</text>
<text top="723" left="475" width="117" height="12" font="5">els, e.g., OpenCL [9].</text>
<text top="754" left="475" width="359" height="12" font="5">Stencil (nearest-neighbor) computations are widely used in scien-</text>
<text top="770" left="475" width="359" height="12" font="5">tiﬁc computing, including structured grids as well as implicit and</text>
<text top="786" left="475" width="359" height="12" font="5">explicit partial differential equation (PDE) solvers in domain rang-</text>
<text top="801" left="475" width="359" height="12" font="5">ing from thermo/ﬂuid dynamics over climate modeling to electro-</text>
<text top="817" left="475" width="359" height="12" font="5">magnetics among others. An iterative explicit stencil computation</text>
<text top="833" left="475" width="359" height="12" font="5">is comprised of computation-intensive kernel. At each discrete</text>
<text top="849" left="475" width="359" height="12" font="5">timestep, all stencil points are updated according to values of their</text>
<text top="864" left="475" width="359" height="12" font="5">spatial neighbors from a previous timestep. On one hand, the uni-</text>
<text top="880" left="475" width="359" height="12" font="5">form and communication-free behavior is well suited for the SIMT</text>
<text top="896" left="475" width="359" height="12" font="5">(single instruction multiple threads) paradigm advocated by state-</text>
<text top="911" left="475" width="359" height="12" font="5">of-the-art GPUs. On the other hand, an efﬁcient GPU implemen-</text>
<text top="927" left="475" width="359" height="12" font="5">tation is sensitive to neighbors accessing patterns across different</text>
<text top="943" left="475" width="359" height="12" font="5">stencils. One key characteristic of most stencil computations is the</text>
<text top="958" left="475" width="359" height="12" font="5">overlap in input values to update multiple neighboring points. Ex-</text>
<text top="974" left="475" width="359" height="12" font="5">ploiting this property is crucial to achieve competitive performance</text>
<text top="990" left="475" width="359" height="12" font="5">on GPUs. One common GPU technique is to use the on-chip <i>shared</i></text>
<text top="1006" left="475" width="43" height="12" font="6"><i>memory</i></text>
<text top="1005" left="521" width="313" height="12" font="5">(shared by a warp/block of threads) as an intermediate stor-</text>
<text top="1021" left="475" width="359" height="12" font="5">age space for overlapped input values. Instead of letting each thread</text>
<text top="1037" left="475" width="359" height="12" font="5">fetching all inputs from off-chip global memory, all inputs are ﬁrst</text>
<text top="1053" left="475" width="359" height="12" font="5">cooperatively loaded to shared memory before they are referenced</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="7" size="11" family="Times" color="#231f20"/>
	<fontspec id="8" size="9" family="Times" color="#231f20"/>
<text top="86" left="81" width="359" height="12" font="5">when computing a new stencil value. This is beneﬁcial even in</text>
<text top="102" left="81" width="359" height="12" font="5">more recent generations of cache-enabled GPUs since this shared</text>
<text top="118" left="81" width="359" height="12" font="5">memory is orders of magnitude faster than global memory. It is</text>
<text top="133" left="81" width="359" height="12" font="5">critical to determine how many threads should be grouped together</text>
<text top="149" left="81" width="359" height="12" font="5">in one block: Increasing the block size increases shared memory</text>
<text top="165" left="81" width="359" height="12" font="5">data reuse but may also deteriorate the GPU’s occupancy rate of</text>
<text top="181" left="81" width="109" height="12" font="5">processing units [1].</text>
<text top="212" left="81" width="359" height="12" font="5">There are many other factors that affect the performance. For ex-</text>
<text top="228" left="81" width="359" height="12" font="5">ample, how many stencil points should a thread work on? The</text>
<text top="243" left="81" width="359" height="12" font="5">larger the number, the more instruction-level optimizations can be</text>
<text top="259" left="81" width="359" height="12" font="5">applied by a compiler. But the less data-parallelism is exposed, the</text>
<text top="275" left="81" width="359" height="12" font="5">higher risk is for not fully utilizing a GPU’s processing units. Also,</text>
<text top="290" left="81" width="359" height="12" font="5">is mapping inputs to texture memory faster? Our experiments show</text>
<text top="306" left="81" width="359" height="12" font="5">that the answer varies from case to case. Overall, there is no uni-</text>
<text top="322" left="81" width="359" height="12" font="5">versal, optimal conﬁguration for all types of stencil computations</text>
<text top="337" left="81" width="359" height="12" font="5">on different GPU models. Therefore, auto-tuning is not only desir-</text>
<text top="353" left="81" width="359" height="12" font="5">able but also necessary to improve performance in this particular</text>
<text top="369" left="81" width="44" height="12" font="5">domain.</text>
<text top="400" left="81" width="359" height="12" font="5">This work falls into the area of implicitly parallel programming</text>
<text top="416" left="81" width="359" height="12" font="5">models [10]. Our model relies on a compiler to generate highly</text>
<text top="432" left="81" width="359" height="12" font="5">efﬁcient parallel code without requiring much interaction with the</text>
<text top="447" left="81" width="69" height="12" font="5">programmer.</text>
<text top="479" left="81" width="205" height="12" font="7"><b>The contributions of this paper are:</b></text>
<text top="509" left="81" width="359" height="13" font="5">• We abstract a wide variety of stencil computations into a set of</text>
<text top="526" left="81" width="359" height="12" font="5">domain-speciﬁc speciﬁcations. This allows the end-user to cus-</text>
<text top="541" left="81" width="359" height="12" font="5">tomize speciﬁc problems without having to consider the underlying</text>
<text top="557" left="81" width="67" height="12" font="5">architecture.</text>
<text top="588" left="81" width="359" height="13" font="5">• We thoroughly summarize optimization techniques for stencil</text>
<text top="604" left="81" width="359" height="12" font="5">problems in previous literature and extract three sets of key parame-</text>
<text top="620" left="81" width="359" height="12" font="5">ters that affect the performance: (1) Block sizes that determine the</text>
<text top="636" left="81" width="359" height="12" font="5">shared-memory usage per block; (2) block dimensions that affect</text>
<text top="651" left="81" width="359" height="12" font="5">the number of registers consumed by each thread and (3) whether</text>
<text top="667" left="81" width="299" height="12" font="5">or not to map a subset of the input into texture memory.</text>
<text top="698" left="81" width="359" height="13" font="5">• We develop an auto-generation and auto-tuning framework,</text>
<text top="714" left="81" width="359" height="12" font="5">i.e., we translate stencil speciﬁcations into executable code that</text>
<text top="730" left="81" width="359" height="12" font="5">is subsequently auto-tuned to the optimal conﬁguration within a</text>
<text top="745" left="81" width="256" height="12" font="5">parametrized search space for each target GPU.</text>
<text top="776" left="81" width="359" height="13" font="5">• Experimental results show competitive performance to manual</text>
<text top="792" left="81" width="359" height="12" font="5">tuning and demonstrate the superiority and necessity for auto-</text>
<text top="808" left="81" width="275" height="12" font="5">tuning to combining performance with correctness.</text>
<text top="840" left="81" width="359" height="12" font="5">The rest of the paper is organized as follows. The related work</text>
<text top="855" left="81" width="359" height="12" font="5">is presented in Section 2. In Section 3, we describe the stencil</text>
<text top="871" left="81" width="359" height="12" font="5">speciﬁcation and the output of the framework. We explain various</text>
<text top="887" left="81" width="359" height="12" font="5">optimization strategies and how they are applied to our framework</text>
<text top="902" left="81" width="359" height="12" font="5">in Section 4. Detailed experimental results are presented in Section</text>
<text top="918" left="81" width="359" height="12" font="5">5, with thorough comparison with previous works. We summarize</text>
<text top="934" left="81" width="120" height="12" font="5">our work in Section 6.</text>
<text top="969" left="81" width="13" height="16" font="4"><b>2.</b></text>
<text top="969" left="112" width="148" height="16" font="4"><b>RELATED WORK</b></text>
<text top="988" left="81" width="359" height="12" font="5">Auto-tuning has long been identiﬁed as an effective approach to</text>
<text top="1004" left="81" width="359" height="12" font="5">offer portability and productivity. For example, ATLAS [2], OSKI</text>
<text top="1020" left="81" width="359" height="12" font="5">[23] and FFTW [6] are well recognized auto-tuning libraries tar-</text>
<text top="1035" left="81" width="359" height="12" font="5">geted at general-purpose processors for dense/sparse linear algebra</text>
<text top="1051" left="81" width="359" height="12" font="5">subroutines and FFT kernels in digital signal processing, respec-</text>
<text top="1067" left="81" width="33" height="12" font="5">tively.</text>
<text top="86" left="475" width="359" height="12" font="5">Recent improvements in programmability of GPUs allow auto-</text>
<text top="102" left="475" width="359" height="12" font="5">tuning to be applied to GPUs as well. Several CUDA implemen-</text>
<text top="118" left="475" width="359" height="12" font="5">tations for linear algebra subroutines and FFTs with auto-tuning</text>
<text top="133" left="475" width="187" height="12" font="5">capability already exist [7, 12, 19].</text>
<text top="165" left="475" width="359" height="12" font="5">Previous implementations of stencil computations on GPUs can be</text>
<text top="181" left="475" width="359" height="12" font="5">grouped into three categories: (1) Hand-coded implementations of</text>
<text top="196" left="475" width="359" height="12" font="5">a particular stencil that strive to achieve the best performance pos-</text>
<text top="212" left="475" width="359" height="12" font="5">sible [17, 18, 20] — but with optimization techniques that may not</text>
<text top="228" left="475" width="359" height="12" font="5">generalize to other types of stencils — (2) Implementations where</text>
<text top="243" left="475" width="359" height="12" font="5">ease of programming is the primary goal rather than performance</text>
<text top="259" left="475" width="359" height="12" font="5">— often with code generators for various stencils [5, 22, 14, 11] —</text>
<text top="275" left="475" width="359" height="12" font="5">and (3) implementations that focus on a particular parameter and</text>
<text top="290" left="475" width="280" height="12" font="5">study how tuning it can affect performance [13, 16].</text>
<text top="322" left="475" width="359" height="12" font="5">We conjecture that performance or programmability are not mu-</text>
<text top="337" left="475" width="359" height="12" font="5">tually exclusive. The merit of our work is to offer both ease of</text>
<text top="353" left="475" width="359" height="12" font="5">programming and performance at the same time. By providing</text>
<text top="369" left="475" width="359" height="12" font="5">a stencil speciﬁcation front-end, we alleviate the end-user’s bur-</text>
<text top="385" left="475" width="359" height="12" font="5">den to master architectural details. Near-optimal performance is</text>
<text top="400" left="475" width="359" height="12" font="5">achieved by extracting necessary parameters and thoroughly auto-</text>
<text top="416" left="475" width="359" height="12" font="5">tuning them. Even though some of the aforementioned work uti-</text>
<text top="432" left="475" width="359" height="12" font="5">lizes certain tuning parameters, such work either relies on ad-hoc</text>
<text top="447" left="475" width="291" height="12" font="5">hand tuning [22] or the tuning space is limited [5, 11].</text>
<text top="486" left="475" width="13" height="16" font="4"><b>3.</b></text>
<text top="486" left="507" width="173" height="16" font="4"><b>DESIGN OVERVIEW</b></text>
<text top="504" left="475" width="359" height="12" font="5">The stencil computation considered in this work allows point-wise</text>
<text top="517" left="475" width="359" height="12" font="5">updates according to a sequence of the following equation over a</text>
<text top="531" left="475" width="128" height="12" font="5">3D rectangular domain:</text>
<text top="565" left="494" width="18" height="11" font="8">out</text>
<text top="564" left="513" width="48" height="12" font="8">([i][j][k])</text>
<text top="564" left="574" width="10" height="12" font="8">=</text>
<text top="580" left="602" width="10" height="9" font="1">m</text>
<text top="565" left="618" width="9" height="11" font="8">w</text>
<text top="568" left="627" width="10" height="9" font="1">m</text>
<text top="565" left="640" width="6" height="8" font="8">∗</text>
<text top="565" left="650" width="12" height="11" font="8">in</text>
<text top="564" left="662" width="29" height="12" font="8">[i ± I</text>
<text top="568" left="690" width="10" height="9" font="1">m</text>
<text top="564" left="701" width="35" height="12" font="8">][j ± J</text>
<text top="568" left="736" width="10" height="9" font="1">m</text>
<text top="564" left="747" width="40" height="12" font="8">][k ± K</text>
<text top="568" left="787" width="10" height="9" font="1">m</text>
<text top="564" left="798" width="4" height="12" font="8">]</text>
<text top="598" left="574" width="10" height="12" font="8">+</text>
<text top="615" left="605" width="4" height="9" font="1">l</text>
<text top="599" left="618" width="9" height="11" font="8">w</text>
<text top="602" left="627" width="4" height="9" font="1">l</text>
<text top="598" left="631" width="91" height="12" font="8">[i][j][k] ∗ in[i ± I</text>
<text top="602" left="723" width="4" height="9" font="1">l</text>
<text top="598" left="727" width="35" height="12" font="8">][j ± J</text>
<text top="602" left="762" width="4" height="9" font="1">l</text>
<text top="598" left="767" width="40" height="12" font="8">][k ± K</text>
<text top="602" left="807" width="4" height="9" font="1">l</text>
<text top="598" left="811" width="4" height="12" font="8">]</text>
<text top="633" left="574" width="10" height="12" font="8">+</text>
<text top="649" left="603" width="7" height="9" font="1">n</text>
<text top="633" left="618" width="9" height="11" font="8">w</text>
<text top="636" left="627" width="7" height="9" font="1">n</text>
<text top="633" left="637" width="6" height="8" font="8">∗</text>
<text top="633" left="647" width="12" height="11" font="8">in</text>
<text top="636" left="659" width="7" height="9" font="1">n</text>
<text top="633" left="820" width="14" height="11" font="8">(1)</text>
<text top="674" left="480" width="353" height="12" font="5">The three dimensional addressing in the parenthesis on the left</text>
<text top="690" left="475" width="301" height="12" font="5">hand side is optional. If absent, we assume the result (</text>
<text top="689" left="776" width="58" height="13" font="5">out in this</text>
<text top="706" left="475" width="359" height="12" font="5">case) is an intermediate result that will be used later in another in-</text>
<text top="722" left="475" width="229" height="12" font="5">struction on the right hand side as an input</text>
<text top="721" left="707" width="13" height="13" font="5">in</text>
<text top="726" left="720" width="7" height="9" font="1">n</text>
<text top="722" left="728" width="106" height="12" font="5">. The ﬁrst two parts</text>
<text top="737" left="475" width="359" height="12" font="5">on the right hand side characterize the stencil behavior. The cen-</text>
<text top="753" left="475" width="341" height="12" font="5">ter point and a number of neighboring points in the input grid (</text>
<text top="752" left="816" width="18" height="13" font="5">in)</text>
<text top="769" left="475" width="224" height="12" font="5">are weighted by either scalar constants (</text>
<text top="768" left="699" width="10" height="13" font="5">w</text>
<text top="773" left="709" width="10" height="9" font="1">m</text>
<text top="769" left="719" width="114" height="12" font="5">) or elements in grid</text>
<text top="784" left="475" width="57" height="12" font="5">variables (</text>
<text top="783" left="532" width="10" height="13" font="5">w</text>
<text top="788" left="542" width="4" height="9" font="1">l</text>
<text top="783" left="547" width="287" height="13" font="5">[i][j][k]) at the same location as the output. Offsets</text>
<text top="800" left="475" width="4" height="12" font="5">(</text>
<text top="799" left="480" width="6" height="13" font="5">I</text>
<text top="804" left="486" width="10" height="9" font="1">m</text>
<text top="799" left="496" width="15" height="13" font="5">/J</text>
<text top="804" left="511" width="10" height="9" font="1">m</text>
<text top="799" left="521" width="19" height="13" font="5">/K</text>
<text top="804" left="540" width="10" height="9" font="1">m</text>
<text top="800" left="555" width="19" height="12" font="5">and</text>
<text top="799" left="579" width="6" height="13" font="5">I</text>
<text top="804" left="585" width="4" height="9" font="1">l</text>
<text top="799" left="589" width="15" height="13" font="5">/J</text>
<text top="804" left="604" width="4" height="9" font="1">l</text>
<text top="799" left="608" width="19" height="13" font="5">/K</text>
<text top="804" left="627" width="4" height="9" font="1">l</text>
<text top="800" left="631" width="203" height="12" font="5">) that constrain how the input grid is</text>
<text top="816" left="475" width="359" height="12" font="5">accessed are all constant. We call their maxima the halo margins of</text>
<text top="831" left="475" width="100" height="12" font="5">three dimensions (</text>
<text top="831" left="575" width="98" height="13" font="5">halo_i = max {I</text>
<text top="836" left="672" width="19" height="9" font="1">m/l</text>
<text top="831" left="692" width="115" height="13" font="5">}, halo_j = max {J</text>
<text top="836" left="807" width="19" height="9" font="1">m/l</text>
<text top="831" left="827" width="7" height="13" font="5">}</text>
<text top="847" left="475" width="19" height="12" font="5">and</text>
<text top="846" left="499" width="111" height="13" font="5">halo_k = max {K</text>
<text top="852" left="610" width="19" height="9" font="1">m/l</text>
<text top="846" left="630" width="204" height="13" font="5">}). To ensure that the access pattern</text>
<text top="863" left="475" width="359" height="12" font="5">is legal (non-negative indexing) for marginal elements in the input</text>
<text top="878" left="475" width="22" height="12" font="5">grid</text>
<text top="878" left="501" width="332" height="13" font="5">in, we assume both input and output grids (in and out) are</text>
<text top="894" left="475" width="354" height="12" font="5">enlarged by twice the halo margins on each associated dimension.</text>
<text top="925" left="475" width="87" height="12" font="5">We differentiate</text>
<text top="925" left="566" width="10" height="13" font="5">w</text>
<text top="930" left="576" width="4" height="9" font="1">l</text>
<text top="925" left="580" width="28" height="12" font="5">s and</text>
<text top="925" left="612" width="222" height="13" font="5">in in (1) and call them <i>array parameters</i></text>
<text top="941" left="475" width="359" height="12" font="5">and <i>array input</i>, respectively. <i>Array parameters </i>are restricted by</text>
<text top="957" left="475" width="359" height="12" font="5">their access pattern: they can only be accessed at the same posi-</text>
<text top="973" left="475" width="359" height="12" font="5">tion as the output element. The <i>array input </i>can be accessed with</text>
<text top="988" left="475" width="137" height="12" font="5">various constant offsets (</text>
<text top="987" left="612" width="222" height="13" font="5">i/j/ks) on each dimension. We assume</text>
<text top="1004" left="475" width="359" height="12" font="5">there is only one array input, but there can be zero or multiple array</text>
<text top="1020" left="475" width="62" height="12" font="5">parameters.</text>
<text top="1051" left="475" width="359" height="12" font="5">Given the stencil speciﬁcation that contains only a list of instruc-</text>
<text top="1067" left="475" width="359" height="12" font="5">tions in the format of Eq. 1, our auto-tuning framework generates</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="9" size="9" family="Times" color="#231f20"/>
<text top="81" left="84" width="74" height="11" font="8">typedef struct {</text>
<text top="94" left="96" width="56" height="11" font="8">int dims[3];</text>
<text top="108" left="96" width="35" height="11" font="8">int iter;</text>
<text top="121" left="96" width="107" height="11" font="8">int haloMargins[2][3];</text>
<text top="135" left="96" width="9" height="11" font="8">...</text>
<text top="148" left="96" width="153" height="11" font="8">int numNodes; // for multi-node</text>
<text top="162" left="96" width="139" height="11" font="8">int curNode;// for multi-node</text>
<text top="175" left="84" width="80" height="11" font="8">} <b>StencilConﬁg</b>;</text>
<text top="212" left="120" width="138" height="12" font="5">(a) Auto-Generated Code</text>
<text top="117" left="298" width="168" height="11" font="9"><b>initStencil</b>(StencilConﬁg *conﬁg);</text>
<text top="130" left="298" width="164" height="11" font="9"><b>stencilIteration</b>(StencilConﬁg *);</text>
<text top="144" left="298" width="190" height="11" font="9"><b>stencilIteration_mpi</b>(StencilConﬁg *);</text>
<text top="157" left="298" width="139" height="11" font="9"><b>exitStencil</b>(StencilConﬁg *);</text>
<text top="207" left="416" width="42" height="12" font="5">(b) API</text>
<text top="81" left="580" width="157" height="11" font="8">int <b>main</b>(int argc, char **argv) {</text>
<text top="94" left="592" width="105" height="11" font="9"><b>StencilConﬁg </b>conﬁg;</text>
<text top="108" left="592" width="71" height="11" font="8">conﬁg.iter = 0;</text>
<text top="121" left="592" width="176" height="11" font="8">conﬁg.dims[0] = 256; ... // more init.</text>
<text top="134" left="592" width="102" height="11" font="9"><b>initStencil</b>(&amp;conﬁg);</text>
<text top="148" left="592" width="214" height="11" font="8">while(conﬁg.iter &lt; 100) // run 100 iterations</text>
<text top="161" left="604" width="128" height="11" font="9"><b>stencilIteration</b>(&amp;conﬁg);</text>
<text top="175" left="592" width="104" height="11" font="9"><b>exitStencil</b>(&amp;conﬁg);</text>
<text top="188" left="580" width="6" height="11" font="8">}</text>
<text top="211" left="648" width="120" height="12" font="5">(c) Sample User Code</text>
<text top="238" left="300" width="314" height="12" font="7"><b>Figure 1: Example of Auto-Generated Code (Excerpts)</b></text>
<text top="408" left="141" width="59" height="12" font="5">(a) 7-Point</text>
<text top="408" left="319" width="67" height="12" font="5">(b) 13-Point</text>
<text top="408" left="502" width="66" height="12" font="5">(c) 19-Point</text>
<text top="408" left="684" width="67" height="12" font="5">(d) 27-Point</text>
<text top="433" left="380" width="155" height="12" font="7"><b>Figure 2: Stencil Examples</b></text>
<text top="478" left="81" width="359" height="12" font="5">a header ﬁle and an implementation ﬁle that can be either included</text>
<text top="494" left="81" width="208" height="12" font="5">in user code or compiled into libraries.</text>
<text top="525" left="81" width="359" height="12" font="5">Excerpts of the generated code are depicted in Figure 1. The two</text>
<text top="541" left="81" width="359" height="12" font="5">major APIs are stencilIteration() and stencilIteration_mpi(). One</text>
<text top="557" left="81" width="359" height="12" font="5">performs single GPU calculations, the other is for multiple-node</text>
<text top="572" left="81" width="359" height="12" font="5">GPUs (GPU clusters) computations with node-to-node MPI mes-</text>
<text top="588" left="81" width="71" height="12" font="5">sage passing.</text>
<text top="619" left="81" width="359" height="12" font="5">We call a stencil calculation an N-point stencil where N is the total</text>
<text top="635" left="81" width="359" height="12" font="5">number of input points used to calculate one output point and an</text>
<text top="651" left="81" width="266" height="12" font="5">order-M stencil where M is the maximum over all</text>
<text top="650" left="350" width="90" height="13" font="5">halo_i/j/ks. In</text>
<text top="666" left="81" width="359" height="12" font="5">this paper, we choose four types of stencil computations as bench-</text>
<text top="682" left="81" width="114" height="12" font="5">marks (see Figure 2).</text>
<text top="713" left="81" width="359" height="13" font="5">• 7-Point Stencil (Figure 2(a)): Each element in the output grid</text>
<text top="729" left="81" width="359" height="12" font="5">is updated by the same position in the input grid and 6 neighbors</text>
<text top="745" left="81" width="359" height="12" font="5">offset by 1 on each direction. The grid point and 6 neighbors are</text>
<text top="761" left="81" width="51" height="12" font="5">scaled by</text>
<text top="760" left="135" width="304" height="13" font="5">α and β, respectively, before they are added to generate</text>
<text top="776" left="81" width="89" height="12" font="5">the output. Both</text>
<text top="775" left="174" width="266" height="13" font="5">α and β are constants. There are 8 ﬂoating-point</text>
<text top="792" left="81" width="275" height="12" font="5">operations for each point (6 adds and 2 multiplies).</text>
<text top="822" left="81" width="359" height="13" font="5">• 13-Point Stencil (Figure 2(b)): The access pattern resembles the</text>
<text top="839" left="81" width="359" height="12" font="5">7-point stencil except that the maximal distance to the neighbors</text>
<text top="855" left="81" width="359" height="12" font="5">extends to 2, making it an order-2 stencil. There are 15 ﬂoating-</text>
<text top="870" left="81" width="306" height="12" font="5">point operations at each point (12 adds and 3 multiplies).</text>
<text top="901" left="81" width="359" height="13" font="5">• 19-Point Stencil (Figure 2(c)): This is also called the Himeno</text>
<text top="917" left="81" width="359" height="12" font="5">benchmark, the behavior of which is detailed elsewhere [20]. We</text>
<text top="933" left="81" width="359" height="12" font="5">use the same speciﬁcation (Table I in [20]), except for ignoring the</text>
<text top="949" left="81" width="359" height="12" font="5">last line of residual calculation. All the weights in this benchmark</text>
<text top="965" left="81" width="359" height="12" font="5">are array parameters, making it a very cache-unfriendly bench-</text>
<text top="980" left="81" width="359" height="12" font="5">mark. The total number of ﬂoating-point operations is 32 and there</text>
<text top="996" left="81" width="185" height="12" font="5">are 14 memory accesses per point.</text>
<text top="1026" left="81" width="359" height="13" font="5">• 27-Point Stencil (Figure 2(d)): Each grid point computation in-</text>
<text top="1043" left="81" width="114" height="12" font="5">volves all points in a</text>
<text top="1042" left="199" width="240" height="13" font="5">3 × 3 × 3 cube surrounding the center grid</text>
<text top="1059" left="81" width="359" height="12" font="5">point. The 4 edge points, 8 corner points and 12 face neighbor</text>
<text top="478" left="475" width="359" height="12" font="5">points are multiplied by different constants. The number of opera-</text>
<text top="494" left="475" width="221" height="12" font="5">tions is 30 with 4 multiplies and 26 adds.</text>
<text top="525" left="475" width="359" height="12" font="5">Table 1 summaries the speciﬁcations and properties of the four</text>
<text top="541" left="475" width="79" height="12" font="5">stencils above.</text>
<text top="572" left="475" width="22" height="16" font="4"><b>3.1</b></text>
<text top="572" left="516" width="291" height="16" font="4"><b>Domain Speciﬁcation and Framework</b></text>
<text top="592" left="475" width="359" height="12" font="5">The formulation of a stencil is trivial in our framework as users pro-</text>
<text top="608" left="475" width="359" height="12" font="5">vides a ﬁle specifying an equation according to the format of Eq. 1</text>
<text top="623" left="475" width="359" height="12" font="5">plus parameters, such as the size of each dimension and data type</text>
<text top="639" left="475" width="359" height="12" font="5">(ﬂoat or double). Table 1 shows that each stencil can be expressed</text>
<text top="655" left="475" width="359" height="12" font="5">by no more than a few lines of code. In contrast to hand-written</text>
<text top="670" left="475" width="359" height="12" font="5">CUDA kernels, which usually are a hundreds of lines of code, this</text>
<text top="686" left="475" width="359" height="12" font="5">is a considerable improvement in terms of productivity. The in-</text>
<text top="702" left="475" width="359" height="12" font="5">ternal work ﬂow of the framework is depicted in Figure 3. The</text>
<text top="717" left="475" width="359" height="12" font="5">parser analyzes the speciﬁcation code in terms of Eq. 1 and ex-</text>
<text top="733" left="475" width="285" height="12" font="5">tracts stencil features. These include halo margins (</text>
<text top="732" left="760" width="73" height="13" font="5">halo_i/j/k),</text>
<text top="749" left="475" width="294" height="12" font="5">input/output array names, scalar or array parameters (</text>
<text top="748" left="770" width="64" height="13" font="5">ws) and the</text>
<text top="765" left="475" width="359" height="12" font="5">number of ﬂoating-point operations per stencil. The parser also</text>
<text top="780" left="475" width="359" height="12" font="5">detects whether the stencil access pattern includes corner element</text>
<text top="796" left="475" width="359" height="12" font="5">accesses or not. 7-point and 13-point stencils are corner access free</text>
<text top="812" left="475" width="359" height="12" font="5">because at most one dimensional offset exists when accessing the</text>
<text top="827" left="475" width="359" height="12" font="5">input array. The code generator takes those feature parameters and</text>
<text top="843" left="475" width="359" height="12" font="5">chooses different template ﬁles according to the corner access pat-</text>
<text top="859" left="475" width="359" height="12" font="5">tern before generating tunable code. The auto-tuning engine mainly</text>
<text top="874" left="475" width="359" height="12" font="5">operates on a single-node level, where optimized parameters are</text>
<text top="890" left="475" width="359" height="12" font="5">determined based on run-time proﬁling. The same optimized pa-</text>
<text top="906" left="475" width="359" height="12" font="5">rameters are used on multiple nodes to generate GPU cluster code</text>
<text top="921" left="475" width="98" height="12" font="5">with MPI support.</text>
<text top="953" left="475" width="22" height="16" font="4"><b>3.2</b></text>
<text top="953" left="516" width="193" height="16" font="4"><b>Domain Kernel Template</b></text>
<text top="973" left="475" width="359" height="12" font="5">The design of the template kernel ﬁle is affected by the strategy</text>
<text top="988" left="475" width="359" height="12" font="5">to break the 3D rectangular space into thread blocks in CUDA. In</text>
<text top="1004" left="475" width="113" height="12" font="5">related work, the 3D</text>
<text top="1003" left="592" width="242" height="13" font="5">X × Y × Z space was divided into smaller</text>
<text top="1020" left="475" width="83" height="12" font="5">cuboids of size</text>
<text top="1019" left="562" width="272" height="13" font="5">x × y × z [5, 15]. Each of them was mapped to</text>
<text top="1035" left="475" width="359" height="12" font="5">a thread block of the same size. Recently, a 2.5D decomposition</text>
<text top="1051" left="475" width="359" height="12" font="5">method was proposed [20, 18]. It decomposes the 3D stencil space</text>
<text top="1067" left="475" width="359" height="12" font="5">over the two most frequently changed dimensions (X and Y). Sten-</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="10" size="8" family="Times" color="#231f20"/>
	<fontspec id="11" size="5" family="Times" color="#231f20"/>
	<fontspec id="12" size="7" family="Times" color="#000000"/>
	<fontspec id="13" size="4" family="Times" color="#000000"/>
	<fontspec id="14" size="5" family="Times" color="#000000"/>
	<fontspec id="15" size="10" family="Times" color="#000000"/>
	<fontspec id="16" size="10" family="Times" color="#000000"/>
	<fontspec id="17" size="5" family="Times" color="#000000"/>
	<fontspec id="18" size="10" family="Times" color="#000000"/>
	<fontspec id="19" size="5" family="Times" color="#000000"/>
	<fontspec id="20" size="3" family="Times" color="#000000"/>
	<fontspec id="21" size="3" family="Times" color="#000000"/>
<text top="88" left="114" width="28" height="9" font="10">Kernel</text>
<text top="88" left="360" width="55" height="9" font="10">Speciﬁcation</text>
<text top="81" left="628" width="29" height="9" font="10"># array</text>
<text top="93" left="628" width="30" height="9" font="10">params</text>
<text top="81" left="681" width="23" height="9" font="10">Flops</text>
<text top="93" left="681" width="43" height="9" font="10">per stencil</text>
<text top="81" left="746" width="42" height="9" font="10">mem. refs</text>
<text top="93" left="746" width="43" height="9" font="10">per stencil</text>
<text top="105" left="113" width="30" height="9" font="10">7-point</text>
<text top="105" left="153" width="21" height="9" font="10">tmp</text>
<text top="104" left="178" width="24" height="10" font="10">= (u</text>
<text top="108" left="202" width="34" height="7" font="11">i+1,j,k</text>
<text top="104" left="239" width="19" height="10" font="10">+ u</text>
<text top="108" left="258" width="34" height="8" font="11">i−1,j,k</text>
<text top="104" left="296" width="19" height="10" font="10">+ u</text>
<text top="108" left="315" width="34" height="7" font="11">i,j+1,k</text>
<text top="104" left="353" width="19" height="10" font="10">+ u</text>
<text top="108" left="372" width="35" height="8" font="11">i,j−1,k</text>
<text top="104" left="410" width="19" height="10" font="10">+ u</text>
<text top="108" left="429" width="34" height="7" font="11">i,j,k+1</text>
<text top="104" left="466" width="19" height="10" font="10">+ u</text>
<text top="108" left="485" width="34" height="8" font="11">i,j,k−1</text>
<text top="104" left="520" width="42" height="12" font="10">) ∗ beta;</text>
<text top="105" left="649" width="5" height="9" font="10">0</text>
<text top="105" left="708" width="5" height="9" font="10">8</text>
<text top="105" left="773" width="5" height="9" font="10">8</text>
<text top="117" left="113" width="31" height="9" font="10">order-1</text>
<text top="116" left="153" width="7" height="9" font="10">u</text>
<text top="116" left="160" width="6" height="10" font="10">1</text>
<text top="120" left="166" width="21" height="7" font="11">i,j,k</text>
<text top="116" left="191" width="97" height="12" font="10">= tmp + alpha ∗ u</text>
<text top="120" left="288" width="21" height="7" font="11">i,j,k</text>
<text top="116" left="310" width="3" height="10" font="10">;</text>
<text top="129" left="110" width="64" height="9" font="10">13-point tmp</text>
<text top="129" left="178" width="66" height="12" font="10">= coef 1 ∗ (u</text>
<text top="133" left="244" width="34" height="7" font="11">i+1,j,k</text>
<text top="129" left="281" width="19" height="10" font="10">+ u</text>
<text top="133" left="300" width="34" height="8" font="11">i−1,j,k</text>
<text top="129" left="337" width="19" height="10" font="10">+ u</text>
<text top="133" left="356" width="34" height="7" font="11">i,j+1,k</text>
<text top="129" left="394" width="19" height="10" font="10">+ u</text>
<text top="133" left="413" width="35" height="8" font="11">i,j−1,k</text>
<text top="129" left="451" width="19" height="10" font="10">+ u</text>
<text top="133" left="470" width="34" height="7" font="11">i,j,k+1</text>
<text top="129" left="507" width="19" height="10" font="10">+ u</text>
<text top="133" left="526" width="34" height="8" font="11">i,j,k−1</text>
<text top="129" left="561" width="8" height="10" font="10">);</text>
<text top="141" left="113" width="31" height="9" font="10">order-2</text>
<text top="141" left="153" width="21" height="9" font="10">tmp</text>
<text top="141" left="174" width="78" height="12" font="10">+ = coef 2 ∗ (u</text>
<text top="145" left="253" width="34" height="7" font="11">i+2,j,k</text>
<text top="141" left="290" width="19" height="10" font="10">+ u</text>
<text top="145" left="309" width="34" height="8" font="11">i−2,j,k</text>
<text top="141" left="347" width="19" height="10" font="10">+ u</text>
<text top="145" left="365" width="34" height="7" font="11">i,j+2,k</text>
<text top="141" left="403" width="19" height="10" font="10">+ u</text>
<text top="145" left="422" width="35" height="8" font="11">i,j−2,k</text>
<text top="141" left="460" width="19" height="10" font="10">+ u</text>
<text top="145" left="479" width="34" height="7" font="11">i,j,k+2</text>
<text top="141" left="516" width="19" height="10" font="10">+ u</text>
<text top="145" left="535" width="34" height="8" font="11">i,j,k−2</text>
<text top="141" left="570" width="8" height="10" font="10">);</text>
<text top="141" left="649" width="5" height="9" font="10">0</text>
<text top="141" left="705" width="10" height="9" font="10">15</text>
<text top="141" left="771" width="10" height="9" font="10">14</text>
<text top="153" left="153" width="7" height="9" font="10">u</text>
<text top="153" left="160" width="6" height="10" font="10">1</text>
<text top="157" left="166" width="21" height="7" font="11">i,j,k</text>
<text top="153" left="191" width="97" height="12" font="10">= tmp + coef 0 ∗ u</text>
<text top="157" left="288" width="21" height="7" font="11">i,j,k</text>
<text top="153" left="310" width="3" height="10" font="10">;</text>
<text top="166" left="153" width="6" height="9" font="10">s</text>
<text top="165" left="159" width="49" height="10" font="10">0 = wrk1</text>
<text top="170" left="208" width="21" height="7" font="11">i,j,k</text>
<text top="165" left="233" width="31" height="10" font="10">+ a0d</text>
<text top="170" left="263" width="21" height="7" font="11">i,j,k</text>
<text top="168" left="288" width="15" height="9" font="10">∗ p</text>
<text top="170" left="303" width="34" height="7" font="11">i,j,k+1</text>
<text top="165" left="340" width="31" height="10" font="10">+ a1d</text>
<text top="170" left="370" width="21" height="7" font="11">i,j,k</text>
<text top="168" left="395" width="15" height="9" font="10">∗ p</text>
<text top="170" left="410" width="47" height="7" font="11">i,j+1,k+1</text>
<text top="165" left="457" width="3" height="10" font="10">;</text>
<text top="178" left="153" width="6" height="9" font="10">s</text>
<text top="177" left="159" width="49" height="10" font="10">0+ = b0d</text>
<text top="181" left="207" width="21" height="7" font="11">i,j,k</text>
<text top="180" left="232" width="20" height="9" font="10">∗ (p</text>
<text top="181" left="251" width="47" height="7" font="11">i,j+1,k+1</text>
<text top="180" left="302" width="18" height="9" font="10">− p</text>
<text top="181" left="320" width="47" height="8" font="11">i,j−1,k+1</text>
<text top="180" left="371" width="18" height="9" font="10">− p</text>
<text top="181" left="389" width="47" height="8" font="11">i,j+1,k−1</text>
<text top="177" left="440" width="18" height="10" font="10">+ p</text>
<text top="181" left="458" width="48" height="8" font="11">i,j−1,k−1</text>
<text top="177" left="507" width="38" height="10" font="10">) + a2d</text>
<text top="181" left="545" width="21" height="7" font="11">i,j,k</text>
<text top="180" left="569" width="15" height="9" font="10">∗ p</text>
<text top="181" left="584" width="34" height="7" font="11">i+1,j,k</text>
<text top="177" left="619" width="3" height="10" font="10">;</text>
<text top="190" left="110" width="49" height="9" font="10">19-point s</text>
<text top="189" left="159" width="49" height="10" font="10">0+ = b1d</text>
<text top="193" left="207" width="21" height="7" font="11">i,j,k</text>
<text top="192" left="232" width="20" height="9" font="10">∗ (p</text>
<text top="193" left="251" width="47" height="7" font="11">i+1,j+1,k</text>
<text top="192" left="302" width="18" height="9" font="10">− p</text>
<text top="193" left="320" width="47" height="8" font="11">i−1,j+1,k</text>
<text top="192" left="371" width="18" height="9" font="10">− p</text>
<text top="193" left="389" width="47" height="8" font="11">i+1,j−1,k</text>
<text top="189" left="440" width="18" height="10" font="10">+ p</text>
<text top="193" left="458" width="48" height="8" font="11">i−1,j−1,k</text>
<text top="189" left="507" width="8" height="10" font="10">);</text>
<text top="202" left="113" width="31" height="9" font="10">order-1</text>
<text top="202" left="153" width="6" height="9" font="10">s</text>
<text top="201" left="159" width="49" height="10" font="10">0+ = b2d</text>
<text top="205" left="207" width="21" height="7" font="11">i,j,k</text>
<text top="204" left="232" width="20" height="9" font="10">∗ (p</text>
<text top="205" left="251" width="46" height="7" font="11">i+1,j,k+1</text>
<text top="204" left="301" width="18" height="9" font="10">− p</text>
<text top="205" left="320" width="47" height="8" font="11">i−1,j,k+1</text>
<text top="204" left="370" width="18" height="9" font="10">− p</text>
<text top="205" left="388" width="47" height="8" font="11">i+1,j,k−1</text>
<text top="201" left="439" width="18" height="10" font="10">+ p</text>
<text top="205" left="457" width="47" height="8" font="11">i−1,j,k−1</text>
<text top="201" left="505" width="37" height="10" font="10">) + c0d</text>
<text top="205" left="541" width="21" height="7" font="11">i,j,k</text>
<text top="204" left="566" width="15" height="9" font="10">∗ p</text>
<text top="205" left="581" width="34" height="8" font="11">i,j,k−1</text>
<text top="201" left="616" width="3" height="10" font="10">;</text>
<text top="202" left="646" width="10" height="9" font="10">12</text>
<text top="202" left="705" width="10" height="9" font="10">32</text>
<text top="202" left="771" width="10" height="9" font="10">32</text>
<text top="214" left="109" width="50" height="9" font="10">(himeno) s</text>
<text top="213" left="159" width="49" height="10" font="10">0+ = c1d</text>
<text top="217" left="207" width="21" height="7" font="11">i,j,k</text>
<text top="216" left="232" width="15" height="9" font="10">∗ p</text>
<text top="217" left="247" width="35" height="8" font="11">i,j−1,k</text>
<text top="213" left="285" width="29" height="10" font="10">+ c2d</text>
<text top="217" left="314" width="21" height="7" font="11">i,j,k</text>
<text top="216" left="339" width="15" height="9" font="10">∗ p</text>
<text top="217" left="354" width="34" height="8" font="11">i−1,j,k</text>
<text top="213" left="389" width="3" height="10" font="10">;</text>
<text top="226" left="153" width="11" height="9" font="10">ss</text>
<text top="225" left="168" width="59" height="12" font="10">= (s0 ∗ a3d</text>
<text top="229" left="227" width="21" height="7" font="11">i,j,k</text>
<text top="228" left="251" width="18" height="9" font="10">− p</text>
<text top="229" left="270" width="21" height="7" font="11">i,j,k</text>
<text top="225" left="291" width="35" height="12" font="10">) ∗ bnd</text>
<text top="229" left="326" width="21" height="7" font="11">i,j,k</text>
<text top="225" left="348" width="3" height="10" font="10">;</text>
<text top="238" left="153" width="21" height="9" font="10">wrk</text>
<text top="237" left="175" width="6" height="10" font="10">2</text>
<text top="241" left="181" width="21" height="7" font="11">i,j,k</text>
<text top="237" left="206" width="19" height="10" font="10">= p</text>
<text top="241" left="224" width="21" height="7" font="11">i,j,k</text>
<text top="237" left="249" width="73" height="12" font="10">+ omega ∗ ss;</text>
<text top="250" left="153" width="5" height="9" font="10">b</text>
<text top="254" left="158" width="21" height="7" font="11">i,j,k</text>
<text top="250" left="184" width="72" height="12" font="10">= param0 ∗ a</text>
<text top="254" left="256" width="21" height="7" font="11">i,j,k</text>
<text top="262" left="153" width="73" height="12" font="10">+param1 ∗ (a</text>
<text top="266" left="227" width="34" height="8" font="11">i−1,j,k</text>
<text top="262" left="264" width="18" height="10" font="10">+ a</text>
<text top="266" left="283" width="34" height="7" font="11">i+1,j,k</text>
<text top="262" left="320" width="18" height="10" font="10">+ a</text>
<text top="266" left="338" width="35" height="8" font="11">i,j−1,k</text>
<text top="262" left="376" width="18" height="10" font="10">+ a</text>
<text top="266" left="395" width="34" height="7" font="11">i,j+1,k</text>
<text top="262" left="432" width="18" height="10" font="10">+ a</text>
<text top="266" left="451" width="34" height="8" font="11">i,j,k−1</text>
<text top="262" left="488" width="18" height="10" font="10">+ a</text>
<text top="266" left="507" width="34" height="7" font="11">i,j,k+1</text>
<text top="262" left="541" width="5" height="10" font="10">)</text>
<text top="274" left="110" width="35" height="9" font="10">27-point</text>
<text top="274" left="153" width="73" height="12" font="10">+param2 ∗ (a</text>
<text top="278" left="227" width="48" height="8" font="11">i−1,j−1,k</text>
<text top="274" left="278" width="18" height="10" font="10">+ a</text>
<text top="278" left="296" width="47" height="8" font="11">i−1,j+1,k</text>
<text top="274" left="347" width="18" height="10" font="10">+ a</text>
<text top="278" left="366" width="47" height="8" font="11">i+1,j−1,k</text>
<text top="274" left="416" width="18" height="10" font="10">+ a</text>
<text top="278" left="435" width="47" height="7" font="11">i+1,j+1,k</text>
<text top="274" left="485" width="18" height="10" font="10">+ a</text>
<text top="278" left="504" width="47" height="8" font="11">i−1,j,k−1</text>
<text top="274" left="554" width="18" height="10" font="10">+ a</text>
<text top="278" left="573" width="47" height="8" font="11">i−1,j,k+1</text>
<text top="274" left="649" width="5" height="9" font="10">0</text>
<text top="274" left="705" width="10" height="9" font="10">30</text>
<text top="274" left="771" width="10" height="9" font="10">28</text>
<text top="286" left="113" width="31" height="9" font="10">order-1</text>
<text top="286" left="153" width="16" height="10" font="10">+a</text>
<text top="290" left="169" width="47" height="8" font="11">i+1,j,k−1</text>
<text top="286" left="219" width="18" height="10" font="10">+ a</text>
<text top="290" left="238" width="46" height="7" font="11">i+1,j,k+1</text>
<text top="286" left="288" width="18" height="10" font="10">+ a</text>
<text top="290" left="306" width="48" height="8" font="11">i,j−1,k−1</text>
<text top="286" left="357" width="18" height="10" font="10">+ a</text>
<text top="290" left="376" width="47" height="8" font="11">i,j−1,k+1</text>
<text top="286" left="426" width="18" height="10" font="10">+ a</text>
<text top="290" left="445" width="47" height="8" font="11">i,j+1,k−1</text>
<text top="286" left="496" width="18" height="10" font="10">+ a</text>
<text top="290" left="514" width="47" height="7" font="11">i,j+1,k+1</text>
<text top="286" left="562" width="5" height="10" font="10">)</text>
<text top="298" left="153" width="73" height="12" font="10">+param3 ∗ (a</text>
<text top="302" left="227" width="61" height="8" font="11">i−1,j−1,k−1</text>
<text top="298" left="291" width="18" height="10" font="10">+ a</text>
<text top="302" left="310" width="61" height="8" font="11">i−1,j−1,k+1</text>
<text top="298" left="374" width="18" height="10" font="10">+ a</text>
<text top="302" left="392" width="61" height="8" font="11">i−1,j+1,k−1</text>
<text top="298" left="456" width="18" height="10" font="10">+ a</text>
<text top="302" left="474" width="60" height="8" font="11">i−1,j+1,k+1</text>
<text top="310" left="153" width="16" height="10" font="10">+a</text>
<text top="314" left="169" width="61" height="8" font="11">i+1,j−1,k−1</text>
<text top="310" left="233" width="18" height="10" font="10">+ a</text>
<text top="314" left="251" width="60" height="8" font="11">i+1,j−1,k+1</text>
<text top="310" left="315" width="18" height="10" font="10">+ a</text>
<text top="314" left="333" width="60" height="8" font="11">i+1,j+1,k−1</text>
<text top="310" left="397" width="18" height="10" font="10">+ a</text>
<text top="314" left="415" width="60" height="7" font="11">i+1,j+1,k+1</text>
<text top="310" left="476" width="8" height="10" font="10">);</text>
<text top="339" left="201" width="513" height="12" font="7"><b>Table 1: Speciﬁcations of Four Stencil Benchmarks. Indices are subscripted to save space.</b></text>
<text top="399" left="321" width="23" height="9" font="12">Code</text>
<text top="400" left="230" width="28" height="9" font="12">Parser</text>
<text top="393" left="471" width="38" height="9" font="12">Parameter</text>
<text top="414" left="471" width="27" height="9" font="12">Engine</text>
<text top="397" left="390" width="31" height="9" font="12">Tunable</text>
<text top="407" left="397" width="20" height="9" font="12">Code</text>
<text top="404" left="720" width="47" height="9" font="12">Multi−Node</text>
<text top="411" left="315" width="38" height="9" font="12">Generator</text>
<text top="411" left="628" width="60" height="9" font="12">Code Generator</text>
<text top="415" left="720" width="20" height="9" font="12">Code</text>
<text top="489" left="727" width="47" height="9" font="12">Multi−Node</text>
<text top="500" left="727" width="42" height="9" font="12">Stencil Lib</text>
<text top="404" left="542" width="47" height="9" font="12">Single Node</text>
<text top="415" left="553" width="20" height="9" font="12">Code</text>
<text top="393" left="546" width="40" height="9" font="12">Optimized</text>
<text top="400" left="635" width="47" height="9" font="12">Multi−Node</text>
<text top="393" left="720" width="40" height="9" font="12">Optimized</text>
<text top="489" left="542" width="47" height="9" font="12">Single Node</text>
<text top="500" left="546" width="42" height="9" font="12">Stencil Lib</text>
<text top="397" left="144" width="26" height="9" font="12">Stencil</text>
<text top="407" left="137" width="38" height="9" font="12">Reference</text>
<text top="475" left="379" width="39" height="9" font="12">Templates</text>
<text top="404" left="471" width="27" height="9" font="12">Tuning</text>
<text top="548" left="81" width="753" height="12" font="7"><b>Figure 3: System work ﬂow: A user-deﬁned speciﬁcation is parsed to generate tunable code based on a template. The code is passed</b></text>
<text top="563" left="81" width="665" height="12" font="7"><b>to an auto-tuning system to ﬁnd the best parameter conﬁguration for a single GPU (also for GPU clusters with MPI)</b></text>
<text top="608" left="81" width="57" height="12" font="5">cils of size</text>
<text top="607" left="140" width="299" height="13" font="5">x×y ×Z are assigned to a thread block, which contains</text>
<text top="624" left="81" width="79" height="12" font="5">only a plane of</text>
<text top="623" left="163" width="276" height="13" font="5">x × y threads. Inside the kernel, threads sweep over</text>
<text top="640" left="81" width="304" height="12" font="5">the Z axis and cooperatively process one plane at a time.</text>
<text top="671" left="81" width="359" height="12" font="5">The beneﬁts of the second method are three-fold: (1) It reduces</text>
<text top="687" left="81" width="359" height="12" font="5">the pressure on shared memory usage. In 3D decomposition, each</text>
<text top="702" left="81" width="198" height="12" font="5">block maintains a small block of size</text>
<text top="702" left="282" width="157" height="13" font="5">(x + 2 × halo_i) × (y + 2 ×</text>
<text top="717" left="81" width="359" height="13" font="5">halo_j) × (z + 2 × halo_k) in shared memory. The 2.5D method</text>
<text top="734" left="81" width="143" height="12" font="5">only needs a blocks size of</text>
<text top="733" left="227" width="213" height="13" font="5">(x + 2 × halo_i) × (y + 2 × halo_j) ×</text>
<text top="749" left="81" width="359" height="13" font="5">(1 + 2 × halo_k). While sweeping through the z-axis, the planes</text>
<text top="765" left="81" width="359" height="12" font="5">can be shifted and reused as the work on z-axis is progressed. If</text>
<text top="781" left="81" width="359" height="12" font="5">the stencil does not have corner accesses, such as 7-point and 13-</text>
<text top="797" left="81" width="359" height="12" font="5">point stencils, we can further reduce the shared-memory usage to</text>
<text top="811" left="81" width="359" height="13" font="5">(x + 2 × halo_i) × (y + 2 × halo_j) while keeping the other</text>
<text top="828" left="81" width="359" height="12" font="5">parameters in registers. (2) The 3D decomposition method con-</text>
<text top="844" left="81" width="359" height="12" font="5">sumes more memory bandwidth on the Z axis because halo regions</text>
<text top="859" left="81" width="359" height="12" font="5">on Z are loaded twice on different blocks along the Z axis. (3) The</text>
<text top="875" left="81" width="359" height="12" font="5">2.5D decomposition method tends to allocate more stencil points</text>
<text top="891" left="81" width="359" height="12" font="5">per thread (Z points per thread instead of z points). This is an opti-</text>
<text top="906" left="81" width="359" height="12" font="5">mization technique also known as thread fusion. For a large enough</text>
<text top="922" left="81" width="103" height="12" font="5">problem size, <i>i.e.</i>, (</text>
<text top="921" left="184" width="255" height="13" font="5">X × Y ) generates enough threads, this helps to</text>
<text top="938" left="81" width="351" height="12" font="5">amortize other overheads, such as initial setup code in the kernel.</text>
<text top="969" left="81" width="359" height="12" font="5">In our design, we adopt the block partition strategy in the 2.5D</text>
<text top="985" left="81" width="359" height="12" font="5">blocking method, <i>i.e.</i>, stencil space is partitioned into columns</text>
<text top="1000" left="81" width="77" height="12" font="5">(Figure 4(a)).</text>
<text top="1000" left="174" width="265" height="12" font="5">The cross section of each column is of size</text>
<text top="1016" left="81" width="4" height="12" font="5">(</text>
<text top="1015" left="85" width="279" height="13" font="5">BlockSize.x × BlockSize.y), see Figure 4(b).</text>
<text top="1016" left="378" width="61" height="12" font="5">We further</text>
<text top="1032" left="81" width="267" height="12" font="5">unroll over both X and Y dimensions to use (</text>
<text top="1031" left="347" width="92" height="13" font="5">BlockDim.x ×</text>
<text top="1047" left="81" width="359" height="13" font="5">BlockDim.y) threads per kernel block (see Figure 4(c)). Previous</text>
<text top="1063" left="81" width="359" height="12" font="5">work only exploits the unrolling factor at most over the Y dimen-</text>
<text top="608" left="475" width="359" height="12" font="5">sion. Our experiments illustrate that unrolling over both dimen-</text>
<text top="624" left="475" width="208" height="12" font="5">sions can be beneﬁcial (see Section 5).</text>
<text top="676" left="737" width="20" height="6" font="13">threads</text>
<text top="679" left="539" width="3" height="6" font="13">y</text>
<text top="683" left="528" width="3" height="6" font="13">x</text>
<text top="672" left="547" width="3" height="6" font="13">1</text>
<text top="753" left="574" width="6" height="7" font="14">X</text>
<text top="718" left="505" width="6" height="7" font="14">Y</text>
<text top="659" left="477" width="5" height="7" font="14">Z</text>
<text top="718" left="757" width="0" height="12" font="15">...</text>
<text top="726" left="792" width="-6" height="12" font="16">...</text>
<text top="780" left="501" width="42" height="7" font="14">Into Columns</text>
<text top="780" left="753" width="37" height="7" font="14">Dimensions</text>
<text top="768" left="493" width="68" height="7" font="14">(a) Decompose Space</text>
<text top="768" left="730" width="86" height="7" font="14">(c) Unroll on Both X and Y</text>
<text top="768" left="621" width="60" height="7" font="14">(b) Column Size is </text>
<text top="780" left="609" width="93" height="7" font="14">(BlockSize.x, BlockSize.y, Z)</text>
<text top="729" left="629" width="38" height="7" font="14">BlockSize.x</text>
<text top="725" left="683" width="19" height="7" font="17">BlockSize.y</text>
<text top="695" left="780" width="10" height="12" font="18">...</text>
<text top="729" left="830" width="0" height="7" font="19">BlockSize.y</text>
<text top="753" left="757" width="38" height="7" font="14">BlockSize.x</text>
<text top="712" left="776" width="0" height="5" font="20">BlockDim.y</text>
<text top="719" left="741" width="25" height="5" font="21">BlockDim.x</text>
<text top="824" left="475" width="359" height="12" font="7"><b>Figure 4: Stencil space decomposed over X &amp; Y; process one</b></text>
<text top="839" left="475" width="284" height="12" font="7"><b>column per thread block; thread code is unrolled.</b></text>
<text top="878" left="475" width="359" height="12" font="5">Our code generator is based on two kernel templates, depending</text>
<text top="894" left="475" width="359" height="12" font="5">on whether the stencil has corner accesses (Fig. 5(a)) or not (Fig.</text>
<text top="910" left="475" width="67" height="12" font="5">5(b)), where</text>
<text top="909" left="547" width="287" height="13" font="5">halo_k = 1 is assumed in these ﬁgures. Their most</text>
<text top="925" left="475" width="359" height="12" font="5">distinct difference is how the shared memory is used. For sten-</text>
<text top="941" left="475" width="359" height="12" font="5">cils with corner accesses, all input stencils are ﬁrst stored in shared</text>
<text top="957" left="475" width="359" height="12" font="5">memory to calculate the output stencils. The corner-free stencils</text>
<text top="973" left="475" width="359" height="12" font="5">can be treated as a special case where a plane of stencils does not</text>
<text top="988" left="475" width="359" height="12" font="5">share inputs other than the points on the same plane. Therefore,</text>
<text top="1004" left="475" width="359" height="12" font="5">only the middle plane is stored in shared memory in this case —</text>
<text top="1020" left="475" width="359" height="12" font="5">all other inputs along the Z axis are stored in register ﬁles. This ap-</text>
<text top="1035" left="475" width="359" height="12" font="5">proach, tailored to corner-free stencils, not only reduces the shared</text>
<text top="1051" left="475" width="359" height="12" font="5">memory pressure but also speeds up the stencil calculation due to</text>
<text top="1067" left="475" width="357" height="12" font="5">the performance advantage of using registers over shared memory.</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="22" size="5" family="Times" color="#231f20"/>
	<fontspec id="23" size="5" family="Times" color="#231f20"/>
<text top="88" left="84" width="143" height="8" font="22"><b># d e f i n e </b>s i z e y (BLOCK_Y+ h a l o _ j ∗2)</text>
<text top="97" left="84" width="143" height="8" font="22"><b># d e f i n e </b>s i z e x (BLOCK_X+ h a l o _ i ∗2)</text>
<text top="115" left="85" width="80" height="7" font="22"><b>t e m p l a t e </b>&lt; <b>c l a s s </b>T&gt;</text>
<text top="124" left="85" width="43" height="7" font="11">_ _ k e r n e l _ _</text>
<text top="124" left="135" width="95" height="7" font="11">s t e n c i l _ i t e r a t i o n ( . . . )</text>
<text top="133" left="85" width="4" height="7" font="11">{</text>
<text top="142" left="95" width="6" height="7" font="23"><i>/ /</i></text>
<text top="142" left="108" width="60" height="7" font="23"><i>I n i t i a l i z a t i o n</i></text>
<text top="142" left="175" width="51" height="7" font="23"><i>I n s t r u c t i o n s</i></text>
<text top="151" left="94" width="46" height="7" font="11">g _ t x = . . . ;</text>
<text top="151" left="152" width="46" height="7" font="11">g _ t y = . . . ;</text>
<text top="160" left="95" width="10" height="7" font="11">. . .</text>
<text top="169" left="94" width="159" height="7" font="22"><b>_ _ s h a r e d _ _ </b>T s h A r r [ 3 ] [ s i z e y ] [ s i z e x ] ;</text>
<text top="178" left="95" width="96" height="7" font="11">f i r s t = 0 ; s e c o n d = 1 ;</text>
<text top="178" left="198" width="42" height="7" font="11">t h i r d = 2 ;</text>
<text top="187" left="95" width="29" height="7" font="23"><i>/ / Load</i></text>
<text top="187" left="131" width="60" height="7" font="23"><i>f i r s t 2 p l a n e s</i></text>
<text top="196" left="94" width="70" height="7" font="11">s h A r r [ 0 ] [ ] [ ] = ;</text>
<text top="205" left="94" width="70" height="7" font="11">s h A r r [ 1 ] [ ] [ ] = ;</text>
<text top="214" left="94" width="138" height="7" font="22"><b>f o r </b>( k= h a l o _ k ; k&lt;= z S i z e ; k ++) {</text>
<text top="223" left="104" width="55" height="7" font="23"><i>/ / Load t h i r d</i></text>
<text top="223" left="166" width="83" height="7" font="23"><i>p l a n e t o _ _ s h a r e d _ _</i></text>
<text top="232" left="103" width="70" height="7" font="11">s h A r r [ 2 ] [ ] [ ] = ;</text>
<text top="241" left="103" width="70" height="7" font="22"><b>_ _ s y n c t h r e a d s </b>( ) ;</text>
<text top="250" left="103" width="6" height="7" font="22"><b>i f</b></text>
<text top="250" left="116" width="43" height="7" font="11">( i n s i d e ) {</text>
<text top="259" left="108" width="6" height="7" font="23"><i>/ /</i></text>
<text top="259" left="121" width="28" height="7" font="23"><i>s t e n c i l</i></text>
<text top="259" left="157" width="47" height="7" font="23"><i>c a l c u l a t i o n</i></text>
<text top="268" left="108" width="10" height="7" font="11">. . .</text>
<text top="277" left="102" width="4" height="7" font="11">}</text>
<text top="286" left="103" width="70" height="7" font="22"><b>_ _ s y n c t h r e a d s </b>( ) ;</text>
<text top="295" left="104" width="6" height="7" font="23"><i>/ /</i></text>
<text top="295" left="117" width="20" height="7" font="23"><i>S h i f t</i></text>
<text top="295" left="143" width="25" height="7" font="23"><i>p l a n e s</i></text>
<text top="304" left="104" width="88" height="7" font="11">f i r s t = ( f i r s t + 1 ) %3;</text>
<text top="313" left="103" width="97" height="7" font="11">s e c o n d = ( s e c o n d + 1 ) %3;</text>
<text top="322" left="103" width="88" height="7" font="11">t h i r d = ( t h i r d + 1 ) %3;</text>
<text top="330" left="85" width="13" height="7" font="11">} }</text>
<text top="345" left="100" width="139" height="12" font="5">(a) With Corner Accesses</text>
<text top="88" left="264" width="143" height="8" font="22"><b># d e f i n e </b>s i z e y (BLOCK_Y+ h a l o _ j ∗2)</text>
<text top="97" left="264" width="143" height="8" font="22"><b># d e f i n e </b>s i z e x (BLOCK_X+ h a l o _ i ∗2)</text>
<text top="115" left="264" width="80" height="7" font="22"><b>t e m p l a t e </b>&lt; <b>c l a s s </b>T&gt;</text>
<text top="124" left="264" width="145" height="7" font="11">_ _ k e r n e l _ _ s t e n c i l _ n o _ c o r n e r ( . . . )</text>
<text top="133" left="264" width="4" height="7" font="11">{</text>
<text top="142" left="274" width="6" height="7" font="23"><i>/ /</i></text>
<text top="142" left="287" width="60" height="7" font="23"><i>I n i t i a l i z a t i o n</i></text>
<text top="142" left="354" width="51" height="7" font="23"><i>I n s t r u c t i o n s</i></text>
<text top="151" left="273" width="46" height="7" font="11">g _ t x = . . . ;</text>
<text top="151" left="331" width="46" height="7" font="11">g _ t y = . . . ;</text>
<text top="160" left="274" width="10" height="7" font="11">. . .</text>
<text top="169" left="273" width="146" height="7" font="22"><b>_ _ s h a r e d _ _ </b>T s h A r r [ s i z e y ] [ s i z e x ] ;</text>
<text top="187" left="274" width="29" height="7" font="23"><i>/ / Load</i></text>
<text top="187" left="310" width="73" height="7" font="23"><i>f i r s t 2 p l a n e s t o</i></text>
<text top="187" left="390" width="38" height="7" font="23"><i>r e g i s t e r s</i></text>
<text top="196" left="272" width="65" height="7" font="11">T m i d d l e = . . . ;</text>
<text top="196" left="348" width="61" height="7" font="11">T b e l o w = . . . ;</text>
<text top="205" left="273" width="160" height="8" font="22"><b>f o r </b>( k= h a l o _ k ; k&lt;= z S i z e−h a l o _ k ; k ++)</text>
<text top="214" left="302" width="4" height="7" font="11">{</text>
<text top="223" left="283" width="6" height="7" font="23"><i>/ /</i></text>
<text top="223" left="296" width="20" height="7" font="23"><i>S h i f t</i></text>
<text top="223" left="323" width="38" height="7" font="23"><i>r e g i s t e r s</i></text>
<text top="232" left="282" width="56" height="7" font="11">t o p = m i d d l e ;</text>
<text top="241" left="282" width="65" height="7" font="11">m i d d l e = b e l o w ;</text>
<text top="250" left="283" width="6" height="7" font="23"><i>/ /</i></text>
<text top="250" left="295" width="16" height="7" font="23"><i>l o a d</i></text>
<text top="250" left="318" width="20" height="7" font="23"><i>t h i r d</i></text>
<text top="250" left="345" width="34" height="7" font="23"><i>p l a n e t o</i></text>
<text top="250" left="386" width="38" height="7" font="23"><i>r e g i s t e r s</i></text>
<text top="259" left="281" width="61" height="7" font="11">T b e l o w = . . . ;</text>
<text top="268" left="282" width="70" height="7" font="22"><b>_ _ s y n c t h r e a d s </b>( ) ;</text>
<text top="277" left="283" width="6" height="7" font="23"><i>/ /</i></text>
<text top="277" left="295" width="137" height="7" font="23"><i>l o a d m i d d l e p l a n e t o _ _ s h a r e d _ _</i></text>
<text top="286" left="283" width="10" height="7" font="11">. . .</text>
<text top="295" left="282" width="70" height="7" font="22"><b>_ _ s y n c t h r e a d s </b>( ) ;</text>
<text top="304" left="283" width="6" height="7" font="22"><b>i f</b></text>
<text top="304" left="296" width="43" height="7" font="11">( i n s i d e ) {</text>
<text top="313" left="292" width="6" height="7" font="23"><i>/ /</i></text>
<text top="313" left="305" width="28" height="7" font="23"><i>s t e n c i l</i></text>
<text top="313" left="341" width="47" height="7" font="23"><i>c a l c u l a t i o n</i></text>
<text top="322" left="292" width="10" height="7" font="11">. . .</text>
<text top="330" left="264" width="22" height="7" font="11">} } }</text>
<text top="345" left="274" width="157" height="12" font="5">(b) Without Corner Accesses</text>
<text top="370" left="160" width="200" height="12" font="7"><b>Figure 5: Stencil Kernel Templates</b></text>
<text top="413" left="81" width="13" height="16" font="4"><b>4.</b></text>
<text top="413" left="112" width="260" height="16" font="4"><b>GPU-SPECIFIC AUTO-TUNING</b></text>
<text top="432" left="81" width="359" height="12" font="5">We next describe in detail various optimization techniques used by</text>
<text top="448" left="81" width="359" height="12" font="5">our implementation. We reason about their effects on performance</text>
<text top="464" left="81" width="359" height="12" font="5">and consider if they need to be made elastic by promoting them as</text>
<text top="479" left="81" width="147" height="12" font="5">parameters for auto-tuning.</text>
<text top="513" left="81" width="22" height="16" font="4"><b>4.1</b></text>
<text top="513" left="121" width="204" height="16" font="4"><b>Single Node Optimizations</b></text>
<text top="533" left="81" width="359" height="12" font="7"><b>Coalescing Memory Accesses</b>: For NVIDIA GPUs, the latency of</text>
<text top="549" left="81" width="359" height="12" font="5">global memory references is deeply affected by whether the mem-</text>
<text top="565" left="81" width="359" height="12" font="5">ory is accessed in coalesced way or not. More recent GPUs sup-</text>
<text top="580" left="81" width="359" height="12" font="5">port coalesced memory access when memory accesses conducted</text>
<text top="596" left="81" width="359" height="12" font="5">by threads in one warp can be combined into as few memory trans-</text>
<text top="612" left="81" width="359" height="12" font="5">actions as possible [1], where a warp is the basic thread instruction</text>
<text top="627" left="81" width="359" height="12" font="5">scheduling unit in NVIDIA GPUs. We reinforce the following rules</text>
<text top="643" left="81" width="224" height="12" font="5">to coalesce most of the memory accesses:</text>
<text top="674" left="81" width="359" height="13" font="5">• The size of the most frequently changing dimension (X dimen-</text>
<text top="690" left="81" width="359" height="12" font="5">sion) for input/output arrays is padded to multiples of 32 stencil</text>
<text top="706" left="81" width="51" height="12" font="5">elements.</text>
<text top="736" left="81" width="359" height="13" font="5">• The origin of the input/output arrays are shifted right by 32 −</text>
<text top="752" left="81" width="359" height="13" font="5">HALO_I stencil elements relative to the memory pointer obtained</text>
<text top="769" left="81" width="359" height="12" font="5">from the CUDA malloc function. This guarantees 128-bit align-</text>
<text top="784" left="81" width="359" height="12" font="5">ment. The internal origins of the input/output array thus become</text>
<text top="800" left="81" width="359" height="12" font="5">128-bit aligned ensuring coalesced memory accesses for output ar-</text>
<text top="816" left="81" width="359" height="12" font="5">rays as long as every thread loads the same row at the same time</text>
<text top="831" left="81" width="230" height="12" font="5">when operating on a half-warp granularity.</text>
<text top="862" left="81" width="359" height="13" font="5">• Parameter arrays are allocated to be the same size as the in-</text>
<text top="878" left="81" width="359" height="12" font="5">put/output array, even though only the internal elements are used</text>
<text top="894" left="81" width="359" height="12" font="5">throughout the stencil calculation. This way, the indices of param-</text>
<text top="910" left="81" width="359" height="12" font="5">eter arrays and parameter input become identical saving registers</text>
<text top="925" left="81" width="359" height="12" font="5">and extra cycles for address calculations. Similar to the input/out-</text>
<text top="941" left="81" width="359" height="12" font="5">put arrays, their origins are also shifted to the right. Reading from</text>
<text top="957" left="81" width="255" height="12" font="5">the parameter arrays become coalesced as well.</text>
<text top="988" left="81" width="359" height="12" font="7"><b>Tuning the Block Size</b>: Choosing the right block size is one of</text>
<text top="1004" left="81" width="359" height="12" font="5">the most important factors to balance the utilization of registers</text>
<text top="1020" left="81" width="359" height="12" font="5">and shared memory. Since we use Z-axis sweeps, our blocks have</text>
<text top="1035" left="81" width="126" height="12" font="5">two dimensions of size</text>
<text top="1035" left="211" width="228" height="13" font="5">BlockSize.x × BlockSize.y. The opti-</text>
<text top="1051" left="81" width="359" height="12" font="5">mal blocking size is determined by several seemingly conﬂicting</text>
<text top="1067" left="81" width="40" height="12" font="5">factors:</text>
<text top="86" left="475" width="359" height="13" font="5">• Since accesses to part of the halo margins are non-coalesced</text>
<text top="102" left="475" width="359" height="12" font="5">memory accesses, we want to limit these as much as possible. This</text>
<text top="118" left="475" width="157" height="12" font="5">gives us incentive to increase</text>
<text top="117" left="635" width="188" height="13" font="5">BlockSize.x as much as possible.</text>
<text top="148" left="475" width="359" height="13" font="5">• To reduce the redundant loading of halo margins between differ-</text>
<text top="165" left="475" width="332" height="12" font="5">ent blocks, we need to keep the block close to a square shape.</text>
<text top="195" left="475" width="359" height="13" font="5">• The shared-memory usage is proportional to BlockSize.x ×</text>
<text top="211" left="475" width="359" height="13" font="5">BlockSize.y. It must not surpass the shared-memory size on-chip.</text>
<text top="243" left="475" width="359" height="12" font="5">Our experiments show that the optimal blocking size can be differ-</text>
<text top="259" left="475" width="359" height="12" font="5">ent under different scenarios: On one hand, different GPU models</text>
<text top="275" left="475" width="359" height="12" font="5">require different sizes for the same stencil problem. On the other</text>
<text top="290" left="475" width="359" height="12" font="5">hand, the same GPU model requires different blocking sizes for</text>
<text top="306" left="475" width="359" height="12" font="5">different stencil problems. To obtain the coalesced memory ac-</text>
<text top="322" left="475" width="280" height="12" font="5">cess effects for an input array, our search space for</text>
<text top="321" left="759" width="75" height="13" font="5">BlockSize.x</text>
<text top="337" left="475" width="255" height="12" font="5">is a multiple of the half-warp (16, 32, 48, 64).</text>
<text top="337" left="737" width="96" height="13" font="5">BlockSize.y has</text>
<text top="353" left="475" width="359" height="12" font="5">no such constraints. So we sweep its value continuously from 2</text>
<text top="369" left="475" width="283" height="12" font="5">to 16. The search space for the CUDA block size (</text>
<text top="368" left="758" width="76" height="13" font="5">BlockDim.x</text>
<text top="385" left="475" width="19" height="12" font="5">and</text>
<text top="384" left="501" width="333" height="13" font="5">BlockDim.y) is a subset of the block size search space,</text>
<text top="400" left="475" width="133" height="12" font="5">with the constraint that</text>
<text top="399" left="614" width="220" height="13" font="5">BlockSize.x/y is integer divisible by</text>
<text top="415" left="475" width="359" height="13" font="5">BlockDim.x/y. The motivation behind this ratio is that a smaller</text>
<text top="432" left="475" width="359" height="12" font="5">set of threads has a higher efﬁciency in using registers. This thor-</text>
<text top="447" left="475" width="359" height="12" font="5">ough search lets us balance register utilization and shared memory</text>
<text top="463" left="475" width="359" height="12" font="5">space, two key resources for stencil implementations on GPUs that</text>
<text top="479" left="475" width="57" height="12" font="5">are scarce.</text>
<text top="510" left="475" width="359" height="12" font="7"><b>Loading the Input Array Efﬁciently</b>: An important step in the</text>
<text top="526" left="475" width="359" height="12" font="5">stencil kernel is to efﬁciently access the input array. A straight-</text>
<text top="541" left="475" width="359" height="12" font="5">forward but naive implementation is to load it directly from the</text>
<text top="557" left="475" width="359" height="12" font="5">off-chip global memory while calculating the output point. The</text>
<text top="573" left="475" width="359" height="12" font="5">obvious drawback is that this does not exploit the data sharing be-</text>
<text top="588" left="475" width="359" height="12" font="5">tween neighboring threads. The on-chip shared memory serves</text>
<text top="604" left="475" width="323" height="12" font="5">as an ideal user-controlled scratch pad in this scenario.</text>
<text top="604" left="813" width="21" height="12" font="5">The</text>
<text top="620" left="475" width="359" height="12" font="5">problem narrows down to how to efﬁciently load a larger block</text>
<text top="636" left="475" width="51" height="12" font="5">of data (</text>
<text top="635" left="527" width="307" height="13" font="5">(BlockSize.x + 2 ∗ HALO_I) × (BlockSize.y +</text>
<text top="650" left="475" width="359" height="13" font="5">2 ∗ HALO_J)) using a smaller set of computation threads</text>
<text top="667" left="475" width="4" height="12" font="5">(</text>
<text top="666" left="480" width="354" height="13" font="5">BlockDim.x × BlockDim.y). We ﬁrst load the internal re-</text>
<text top="683" left="475" width="33" height="12" font="5">gion (</text>
<text top="682" left="509" width="325" height="13" font="5">BlockSize.x × BlockSize.y). Because BlockDim.x/y</text>
<text top="698" left="475" width="85" height="12" font="5">are divisible by</text>
<text top="698" left="565" width="269" height="13" font="5">BlockSize.x/y, this can be done easily without</text>
<text top="714" left="475" width="359" height="12" font="5">branches. For marginal regions, we rely on the code generator</text>
<text top="730" left="475" width="359" height="12" font="5">to map computational threads to elements on the margin region,</text>
<text top="745" left="475" width="264" height="12" font="5">as shown in Figure 6. In the graph, we assume</text>
<text top="745" left="744" width="90" height="13" font="5">BlockDim.x/y</text>
<text top="761" left="475" width="49" height="12" font="5">equals to</text>
<text top="760" left="527" width="306" height="13" font="5">BlockSize.x/y, respectively. Each computing thread is</text>
<text top="777" left="475" width="359" height="12" font="5">sequentially assigned to a point in the margin area. The x and y in-</text>
<text top="792" left="475" width="359" height="12" font="5">dices are auto generated as a constant array. The number of points</text>
<text top="808" left="475" width="359" height="12" font="5">in the margin area is not necessarily divisible by the number of</text>
<text top="824" left="475" width="359" height="12" font="5">computing threads. In those cases, threads will be responsible for</text>
<text top="840" left="475" width="359" height="12" font="5">loading more than one marginal points or there will be idle threads</text>
<text top="855" left="475" width="359" height="12" font="5">that load the upper-left corner point (see the Figure 6(a)) to avoid</text>
<text top="871" left="475" width="359" height="12" font="5">diverging branches. Comparing with other approaches, e.g., [20],</text>
<text top="887" left="475" width="359" height="12" font="5">this method neither requires branches nor issues any unnecessary</text>
<text top="902" left="475" width="359" height="12" font="5">loads. The only non-coalesced memory loads are issued for the</text>
<text top="918" left="475" width="209" height="12" font="5">columns on each side of the sub-plane.</text>
<text top="949" left="475" width="359" height="12" font="7"><b>Using Texture Memory</b>: Mapping the read-only input array into</text>
<text top="965" left="475" width="359" height="12" font="5">the GPU’s texture memory has been shown to improve performance</text>
<text top="981" left="475" width="359" height="12" font="5">in [20], especially for bandwidth-limited benchmarks. There is no</text>
<text top="996" left="475" width="359" height="12" font="5">texture support for the double precision data type, but we can use</text>
<text top="1012" left="475" width="215" height="12" font="5">the texture fetch for the int2 type and <i>__</i></text>
<text top="1011" left="690" width="144" height="13" font="5">hiloint2double to convert</text>
<text top="1028" left="475" width="359" height="12" font="5">it to double. Whether or not to use texture memory for the input</text>
<text top="1044" left="475" width="273" height="12" font="5">array is determined by a boolean tuning parameter.</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="24" size="6" family="Times" color="#000000"/>
	<fontspec id="25" size="8" family="Times" color="#000000"/>
<text top="202" left="363" width="35" height="7" font="24">idle thread</text>
<text top="208" left="153" width="12" height="9" font="25">(1)</text>
<text top="211" left="344" width="12" height="9" font="25">(2)</text>
<text top="85" left="302" width="76" height="7" font="24">non−coalesced loading</text>
<text top="228" left="210" width="106" height="12" font="5">(a) No Corner Case</text>
<text top="82" left="677" width="65" height="6" font="14">non−coalesced loading</text>
<text top="211" left="528" width="12" height="9" font="25">(1)</text>
<text top="211" left="723" width="12" height="9" font="25">(2)</text>
<text top="228" left="574" width="117" height="12" font="5">(b) With Corner Case</text>
<text top="253" left="81" width="753" height="12" font="7"><b>Figure 6: Load input sub-plane to shared memory. Internal regions are loaded in Step (1). There is a one-to-one mapping between</b></text>
<text top="269" left="81" width="753" height="12" font="7"><b>computing threads and internal regions. In Step (2), the mapping is auto-generated by the parameter tuning engine. (A circle denotes</b></text>
<text top="285" left="81" width="419" height="12" font="7"><b>a thread. A triangle denotes an array element loaded at the current step.)</b></text>
<text top="326" left="81" width="22" height="16" font="4"><b>4.2</b></text>
<text top="326" left="121" width="190" height="16" font="4"><b>Multi-Node Auto-Tuning</b></text>
<text top="346" left="81" width="359" height="12" font="5">For GPU clusters, we divide the stencil space along the Cartesian</text>
<text top="361" left="81" width="359" height="12" font="5">space. Each node is responsible for updating a smaller rectangular</text>
<text top="377" left="81" width="359" height="12" font="5">3D space. The tuning parameters determined for a single node are</text>
<text top="393" left="81" width="359" height="12" font="5">re-used directly for multi-node scenarios. However, the code gen-</text>
<text top="409" left="81" width="359" height="12" font="5">erator needs to break the single kernel into several smaller ones,</text>
<text top="424" left="81" width="359" height="12" font="5">each of which only processes a portion of the data set. The objec-</text>
<text top="440" left="81" width="359" height="12" font="5">tive is to separate the six plane boundaries from the internal region.</text>
<text top="456" left="81" width="359" height="12" font="5">While the boundaries need to be exchanged between neighboring</text>
<text top="471" left="81" width="359" height="12" font="5">nodes, the internal regions can be calculated completely in parallel</text>
<text top="487" left="81" width="114" height="12" font="5">with communication.</text>
<text top="518" left="81" width="359" height="12" font="5">Our framework generates MPI calls for inter-node communication.</text>
<text top="534" left="81" width="259" height="12" font="5">Nodes perform the following steps per iteration:</text>
<text top="565" left="81" width="359" height="12" font="5">(1) Kernels copy non-continuous boundaries residing in GPU mem-</text>
<text top="581" left="81" width="359" height="12" font="5">ory into continuous GPU memory buffers. For stencils with corner</text>
<text top="597" left="81" width="359" height="12" font="5">accesses, eight corners and 12 edges are also copied into separate</text>
<text top="612" left="81" width="359" height="12" font="5">buffers. Then, continuous boundaries are transferred from GPU</text>
<text top="628" left="81" width="231" height="12" font="5">memory to host memory via cudaMemcpy.</text>
<text top="660" left="81" width="285" height="12" font="5">(2) An asynchronous kernel updates internal regions.</text>
<text top="691" left="81" width="359" height="12" font="5">(3) MPI sends and receives are issued to exchange boundaries.</text>
<text top="707" left="81" width="359" height="12" font="5">Once boundaries are received, boundaries are copied from host</text>
<text top="722" left="81" width="359" height="12" font="5">memory to GPU memory. This step can be overlapped with the</text>
<text top="738" left="81" width="44" height="12" font="5">step (2).</text>
<text top="769" left="81" width="226" height="12" font="5">(4) Kernels update stencils on boundaries.</text>
<text top="801" left="81" width="205" height="12" font="5">These steps are illustrated in Figure 7.</text>
<text top="836" left="81" width="13" height="16" font="4"><b>5.</b></text>
<text top="836" left="112" width="229" height="16" font="4"><b>EXPERIMENTAL RESULTS</b></text>
<text top="859" left="81" width="22" height="16" font="4"><b>5.1</b></text>
<text top="859" left="121" width="153" height="16" font="4"><b>Experimental Setup</b></text>
<text top="878" left="81" width="359" height="12" font="5">We conducted experiments on single nodes with four NVIDIA</text>
<text top="894" left="81" width="359" height="12" font="5">GPU models: Geforce GTX 280, Tesla C1060, Tesla C2050 and</text>
<text top="910" left="81" width="359" height="12" font="5">Geforce GTX 480, spanning two generations of NVIDIA GPUs</text>
<text top="925" left="81" width="359" height="12" font="5">ranging from consumer-end graphics card to high performance</text>
<text top="941" left="81" width="359" height="12" font="5">computing GPUs. Their major speciﬁcations are listed in Table 2.</text>
<text top="957" left="81" width="359" height="12" font="5">All kernels are compiled under CUDA 3.2 at O3 optimization level.</text>
<text top="973" left="81" width="359" height="12" font="5">Experiments with Tesla C2050 are conducted with ECC turned off.</text>
<text top="988" left="81" width="359" height="12" font="5">For Fermi GPUs (Tesla C2050 and GTX 480), we prefer shared</text>
<text top="1004" left="81" width="359" height="12" font="5">memory over L1 cache since the shared memory size is 48 KB (in</text>
<text top="1020" left="81" width="190" height="12" font="5">contrast to 16 KB in earlier GPUs).</text>
<text top="1051" left="81" width="359" height="12" font="5">We also conducted multi-node experiments on two set of GPU clus-</text>
<text top="1067" left="81" width="359" height="12" font="5">ters connected by QDR Inﬁniband (36 Gbps) with fat-tree topology.</text>
<text top="469" left="688" width="98" height="9" font="25">(4) Compute boundaries</text>
<text top="405" left="559" width="58" height="9" font="25">own boundary</text>
<text top="405" left="559" width="58" height="9" font="25">own boundary</text>
<text top="367" left="556" width="77" height="9" font="25">neighbor boundary</text>
<text top="439" left="480" width="20" height="9" font="25">GPU</text>
<text top="450" left="476" width="35" height="9" font="25">Memory</text>
<text top="394" left="480" width="20" height="9" font="25">CPU</text>
<text top="405" left="476" width="35" height="9" font="25">Memory</text>
<text top="507" left="563" width="26" height="9" font="25">region</text>
<text top="496" left="559" width="33" height="9" font="25">internal </text>
<text top="500" left="650" width="113" height="9" font="25">(2) Compute internal region</text>
<text top="450" left="688" width="133" height="9" font="25">(1) Copy own boundaries to host</text>
<text top="405" left="718" width="31" height="9" font="25">to GPU</text>
<text top="325" left="669" width="66" height="9" font="25">(3.a) MPI IRecv</text>
<text top="359" left="692" width="66" height="9" font="25">(3.b) MPI ISend</text>
<text top="394" left="688" width="122" height="9" font="25">(3.c) Copy neighbor boundary</text>
<text top="567" left="475" width="52" height="12" font="7"><b>Figure 7:</b></text>
<text top="568" left="531" width="303" height="11" font="9"><b>Steps in multi-node scenario. For clarity, only one boundary</b></text>
<text top="584" left="475" width="77" height="11" font="9"><b>plane is shown.</b></text>
<text top="631" left="475" width="359" height="12" font="5">One cluster was comprised of 32 nodes, each with one Tesla C2050,</text>
<text top="646" left="475" width="241" height="12" font="5">other had 48 nodes, each with one GTX 480.</text>
<text top="686" left="475" width="22" height="16" font="4"><b>5.2</b></text>
<text top="686" left="516" width="151" height="16" font="4"><b>Single Node Results</b></text>
<text top="706" left="475" width="359" height="12" font="5">Our single-node auto-tuning engine ﬁnds the optimal parame-</text>
<text top="722" left="475" width="359" height="12" font="5">ters for all stencil types on each GPU model within the given</text>
<text top="737" left="475" width="74" height="12" font="5">search space.</text>
<text top="737" left="563" width="231" height="12" font="5">These parameters are shown in Table 3.</text>
<text top="737" left="807" width="27" height="12" font="5">Each</text>
<text top="753" left="475" width="359" height="12" font="5">GPU model has different optimal settings for all stencil types,</text>
<text top="769" left="475" width="221" height="12" font="5">even within the same GPU generation.</text>
<text top="769" left="709" width="125" height="12" font="5">Almost all models fa-</text>
<text top="784" left="475" width="49" height="12" font="5">vor large</text>
<text top="783" left="529" width="305" height="13" font="5">BlockSize.x except for some cases with early genera-</text>
<text top="800" left="475" width="359" height="12" font="5">tion GPUs. These older GPUs have tighter restrictions on shared</text>
<text top="816" left="475" width="359" height="12" font="5">memory size, especially for double precision (DP) stencils. Thus,</text>
<text top="831" left="475" width="159" height="12" font="5">they can only afford smaller</text>
<text top="831" left="640" width="194" height="13" font="5">BlockSize.x sizes. BlockSize.y</text>
<text top="847" left="475" width="104" height="12" font="5">is usually less than</text>
<text top="846" left="584" width="250" height="13" font="5">BlockSize.x, except for 7/13-point DP sten-</text>
<text top="863" left="475" width="359" height="12" font="5">cils on a GTX 280 and the 13-point DP stencil on a Tesla C1060</text>
<text top="878" left="475" width="118" height="12" font="5">because their smaller</text>
<text top="878" left="599" width="235" height="13" font="5">BlockSize.x (16) allows them to have a</text>
<text top="894" left="475" width="31" height="12" font="5">larger</text>
<text top="893" left="511" width="323" height="13" font="5">BlockSize.y. Thus, reducing the non-coalesced memory</text>
<text top="910" left="475" width="98" height="12" font="5">access (increasing</text>
<text top="909" left="578" width="256" height="13" font="5">BlockSize.x) is favored over reducing redun-</text>
<text top="925" left="475" width="118" height="12" font="5">dant loads (increasing</text>
<text top="925" left="597" width="82" height="13" font="5">BlockSize.y).</text>
<text top="957" left="475" width="359" height="12" font="5">An illustration of each tuning parameter’s contribution to perfor-</text>
<text top="973" left="475" width="359" height="12" font="5">mance is given in Figure 8. Here, auto-tuning is comprised of three</text>
<text top="988" left="475" width="51" height="12" font="5">steps: (1)</text>
<text top="987" left="530" width="304" height="13" font="5">BlockSize.x/y are set to be equal to BlockDim.x/y;</text>
<text top="1004" left="475" width="16" height="12" font="5">(2)</text>
<text top="1003" left="495" width="339" height="13" font="5">BlockSizes.x/y are tuned for better performance; (3) texture</text>
<text top="1020" left="475" width="359" height="12" font="5">mapping is enabled/disabled. The necessity to unroll is conﬁrmed</text>
<text top="1035" left="475" width="82" height="12" font="5">by the fact that</text>
<text top="1035" left="562" width="272" height="13" font="5">BlockDim.x/y sizes are almost always different</text>
<text top="1051" left="475" width="23" height="12" font="5">than</text>
<text top="1050" left="503" width="331" height="13" font="5">BlockSize.x/y. The only exception is given by a 19-point</text>
<text top="1067" left="475" width="218" height="12" font="5">DP stencil for Fermi GPUs. In this cases,</text>
<text top="1066" left="696" width="138" height="13" font="5">BlockSize.y is too small</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1188" width="918">
<text top="83" left="166" width="31" height="11" font="8">Model</text>
<text top="83" left="231" width="545" height="11" font="8">SM Count Core Count L1 Cache Bandwidth(GB/s) Register File Size Shared Memory SP GFlops DP GFlops</text>
<text top="100" left="138" width="87" height="11" font="8">Geforce GTX 280</text>
<text top="100" left="250" width="12" height="11" font="8">30</text>
<text top="100" left="305" width="18" height="11" font="8">240</text>
<text top="100" left="367" width="9" height="11" font="8">N</text>
<text top="100" left="429" width="27" height="11" font="8">141.7</text>
<text top="100" left="518" width="32" height="11" font="8">16 KB</text>
<text top="100" left="606" width="29" height="11" font="8">16KB</text>
<text top="100" left="682" width="18" height="11" font="8">933</text>
<text top="100" left="744" width="12" height="11" font="8">78</text>
<text top="114" left="152" width="60" height="11" font="8">Tesla C1060</text>
<text top="114" left="250" width="12" height="11" font="8">30</text>
<text top="114" left="305" width="18" height="11" font="8">240</text>
<text top="114" left="367" width="9" height="11" font="8">N</text>
<text top="114" left="429" width="27" height="11" font="8">102.4</text>
<text top="114" left="518" width="32" height="11" font="8">16 KB</text>
<text top="114" left="606" width="29" height="11" font="8">16KB</text>
<text top="114" left="682" width="18" height="11" font="8">933</text>
<text top="114" left="744" width="12" height="11" font="8">78</text>
<text top="128" left="152" width="60" height="11" font="8">Tesla C2050</text>
<text top="128" left="250" width="12" height="11" font="8">14</text>
<text top="128" left="305" width="18" height="11" font="8">448</text>
<text top="128" left="367" width="9" height="11" font="8">Y</text>
<text top="128" left="434" width="18" height="11" font="8">144</text>
<text top="128" left="518" width="32" height="11" font="8">32 KB</text>
<text top="128" left="591" width="59" height="11" font="8">16 or 48 KB</text>
<text top="128" left="679" width="24" height="11" font="8">1288</text>
<text top="128" left="741" width="18" height="11" font="8">515</text>
<text top="142" left="138" width="87" height="11" font="8">Geforce GTX 480</text>
<text top="142" left="250" width="12" height="11" font="8">15</text>
<text top="142" left="305" width="18" height="11" font="8">480</text>
<text top="142" left="367" width="9" height="11" font="8">Y</text>
<text top="142" left="429" width="27" height="11" font="8">177.4</text>
<text top="142" left="518" width="32" height="11" font="8">32 KB</text>
<text top="142" left="591" width="59" height="11" font="8">16 or 48 KB</text>
<text top="142" left="679" width="24" height="11" font="8">1345</text>
<text top="142" left="741" width="18" height="11" font="8">168</text>
<text top="186" left="332" width="250" height="12" font="7"><b>Table 2: Single Node Experiment Platforms</b></text>
<text top="216" left="229" width="31" height="11" font="8">Model</text>
<text top="216" left="294" width="298" height="11" font="8">BlockSize.x BlockSize.y BlockDim.x BlockDim.y Texture</text>
<text top="216" left="631" width="54" height="11" font="9"><b>SP GFlops</b></text>
<text top="233" left="201" width="151" height="11" font="8">Geforce GTX 280 64/32/64/16</text>
<text top="233" left="370" width="34" height="11" font="8">8/8/3/6</text>
<text top="233" left="423" width="58" height="11" font="8">32/32/64/16</text>
<text top="233" left="499" width="34" height="11" font="8">8/2/3/2</text>
<text top="233" left="552" width="44" height="11" font="8">Y/Y/N/N</text>
<text top="233" left="608" width="100" height="11" font="8">76.0/117.0/57.6/94.2</text>
<text top="248" left="214" width="60" height="11" font="8">Tesla C1060</text>
<text top="248" left="294" width="58" height="11" font="8">64/64/64/32</text>
<text top="248" left="370" width="34" height="11" font="8">8/6/6/8</text>
<text top="248" left="423" width="58" height="11" font="8">32/64/64/32</text>
<text top="248" left="499" width="34" height="11" font="8">8/2/3/2</text>
<text top="248" left="552" width="44" height="11" font="8">Y/N/Y/N</text>
<text top="248" left="611" width="94" height="11" font="8">57.5/91.8/44.8/95.5</text>
<text top="262" left="214" width="60" height="11" font="8">Tesla C2050</text>
<text top="262" left="294" width="58" height="11" font="8">64/64/64/64</text>
<text top="262" left="370" width="34" height="11" font="8">8/6/3/4</text>
<text top="262" left="423" width="58" height="11" font="8">32/64/32/32</text>
<text top="262" left="499" width="34" height="11" font="8">8/3/3/4</text>
<text top="262" left="552" width="159" height="11" font="8">Y/Y/N/Y 87.3/133.8/64.6/157.6</text>
<text top="276" left="201" width="151" height="11" font="8">Geforce GTX 480 64/64/64/64</text>
<text top="276" left="370" width="34" height="11" font="8">3/3/3/8</text>
<text top="276" left="423" width="58" height="11" font="8">32/32/32/32</text>
<text top="276" left="499" width="34" height="11" font="8">3/3/3/4</text>
<text top="276" left="552" width="162" height="11" font="8">Y/Y/N/Y 108.2/167.8/77.4/203.7</text>
<text top="293" left="229" width="31" height="11" font="8">Model</text>
<text top="293" left="294" width="298" height="11" font="8">BlockSize.x BlockSize.y BlockDim.x BlockDim.y Texture</text>
<text top="293" left="630" width="56" height="11" font="9"><b>DP GFlops</b></text>
<text top="310" left="201" width="151" height="11" font="8">Geforce GTX 280 16/16/16/16</text>
<text top="310" left="364" width="46" height="11" font="8">16/16/6/6</text>
<text top="310" left="423" width="58" height="11" font="8">16/16/16/16</text>
<text top="310" left="499" width="34" height="11" font="8">4/8/3/3</text>
<text top="310" left="552" width="44" height="11" font="8">N/N/Y/N</text>
<text top="310" left="611" width="94" height="11" font="8">32.5/35.4/24.0/29.0</text>
<text top="324" left="214" width="60" height="11" font="8">Tesla C1060</text>
<text top="324" left="294" width="58" height="11" font="8">32/16/32/16</text>
<text top="324" left="367" width="40" height="11" font="8">6/16/4/6</text>
<text top="324" left="423" width="58" height="11" font="8">32/16/32/16</text>
<text top="324" left="499" width="34" height="11" font="8">2/8/2/3</text>
<text top="324" left="552" width="44" height="11" font="8">N/N/Y/N</text>
<text top="324" left="611" width="94" height="11" font="8">28.8/35.3/22.8/29.3</text>
<text top="338" left="214" width="60" height="11" font="8">Tesla C2050</text>
<text top="338" left="294" width="58" height="11" font="8">64/32/64/32</text>
<text top="338" left="370" width="34" height="11" font="8">8/6/3/6</text>
<text top="338" left="423" width="58" height="11" font="8">32/32/64/32</text>
<text top="338" left="499" width="34" height="11" font="8">4/2/3/2</text>
<text top="338" left="552" width="44" height="11" font="8">Y/Y/N/Y</text>
<text top="338" left="611" width="94" height="11" font="8">45.9/66.8/31.8/97.7</text>
<text top="352" left="201" width="151" height="11" font="8">Geforce GTX 480 64/32/64/32</text>
<text top="352" left="370" width="34" height="11" font="8">6/6/3/4</text>
<text top="352" left="423" width="58" height="11" font="8">32/32/64/16</text>
<text top="352" left="499" width="34" height="11" font="8">3/2/3/4</text>
<text top="352" left="552" width="44" height="11" font="8">Y/Y/N/Y</text>
<text top="352" left="611" width="94" height="11" font="8">55.2/77.2/38.7/86.0</text>
<text top="396" left="146" width="623" height="12" font="7"><b>Table 3: 7/13/19/27-Point Stencil Optimal Tuning Results on Single GPU for Single/Double Precision (SP/DP)</b></text>
<text top="441" left="81" width="359" height="12" font="5">to unroll. In addition, Fermi GPUs provide enough registers to sup-</text>
<text top="456" left="81" width="31" height="12" font="5">port a</text>
<text top="456" left="115" width="262" height="13" font="5">BlockDim.x of the same size as BlockSize.x.</text>
<text top="488" left="81" width="359" height="12" font="5">Another interesting observation is that mapping the input array to</text>
<text top="504" left="81" width="359" height="12" font="5">texture memory does not necessarily result in better performance.</text>
<text top="519" left="81" width="359" height="12" font="5">This is in part because some stencils are not bandwidth-limited on</text>
<text top="535" left="81" width="359" height="12" font="5">certain GPUs. For GPUs that have high GFlops capabilities, using</text>
<text top="551" left="81" width="359" height="12" font="5">texture memory usually helps because memory references are on</text>
<text top="566" left="81" width="359" height="12" font="5">the critical path (7/13/27-point DP stencils for C2050 and GTX</text>
<text top="582" left="81" width="359" height="12" font="5">480). Using texture memory has one overhead though: Texture</text>
<text top="598" left="81" width="359" height="12" font="5">mapping requires the device memory to start from 128-bit aligned</text>
<text top="613" left="81" width="359" height="12" font="5">address. But our input/output array base addresses are shifted to</text>
<text top="629" left="81" width="316" height="12" font="5">non-aligned addresses so that the addresses with offset at</text>
<text top="628" left="402" width="38" height="13" font="5">halo_i</text>
<text top="645" left="81" width="359" height="12" font="5">(base address for internal region) are 128-bit aligned. Therefore,</text>
<text top="660" left="81" width="359" height="12" font="5">there is an extra offset adjustment calculation if we want to enable</text>
<text top="676" left="81" width="359" height="12" font="5">texture mapping. This extra arithmetic for address computation can</text>
<text top="692" left="81" width="359" height="12" font="5">negate the beneﬁt of lower latencies for texture memory accesses</text>
<text top="708" left="81" width="83" height="12" font="5">for some cases.</text>
<text top="739" left="81" width="359" height="12" font="5">To demonstrate the effectiveness of the auto-tuning engine, we se-</text>
<text top="755" left="81" width="359" height="12" font="5">lect two cases and represent performance in GFlops as a surface in</text>
<text top="770" left="81" width="359" height="12" font="5">a 3D histogram. Figure 9 depicts the single-precision (SP) 7-point</text>
<text top="786" left="81" width="359" height="12" font="5">stencil on a GTX 280. Figure 10 depicts the DP 27-point stencil</text>
<text top="802" left="81" width="359" height="12" font="5">on a Tesla C2050. The left diagrams in the ﬁgures illustrate how</text>
<text top="817" left="81" width="218" height="12" font="5">the performance changes while varying</text>
<text top="817" left="304" width="136" height="13" font="5">BlockSize.x/y, assum-</text>
<text top="833" left="81" width="64" height="12" font="5">ing the best</text>
<text top="832" left="148" width="291" height="13" font="5">BlockDim.x/y has been found. The right diagrams</text>
<text top="849" left="81" width="359" height="12" font="5">in the ﬁgures depicts how the performance changes when varying</text>
<text top="864" left="81" width="359" height="13" font="5">BlockDim.x/y for a ﬁxed BlockSize.x/y overall. The ﬁgures</text>
<text top="880" left="81" width="359" height="12" font="5">demonstrate that each tuning parameter plays an important role in</text>
<text top="896" left="81" width="359" height="12" font="5">the ﬁnal performance, neither one of which can be explored inde-</text>
<text top="912" left="81" width="359" height="12" font="5">pendently of the other. Hence, an auto-tuner needs to exhaustively</text>
<text top="927" left="81" width="112" height="12" font="5">test all permutations.</text>
<text top="959" left="81" width="359" height="12" font="5">Our auto-tuning engine does exactly that: an exhaustive search over</text>
<text top="974" left="81" width="359" height="12" font="5">all possible permutations is performed. This guarantees a global</text>
<text top="990" left="81" width="359" height="12" font="5">optimum with respect to the parameter search space. Adaptive</text>
<text top="1006" left="81" width="359" height="12" font="5">search methods could be adopted to prune the search space. How-</text>
<text top="1021" left="81" width="359" height="12" font="5">ever, care must be taken because local optima exist, as seen in the</text>
<text top="1037" left="81" width="359" height="12" font="5">ﬁgures. For example, in Figure 9(b), (64,4) is another locally op-</text>
<text top="1053" left="81" width="28" height="12" font="5">timal</text>
<text top="1052" left="113" width="327" height="13" font="5">BlockDim.x/y pair. Considering the search space is rela-</text>
<text top="441" left="475" width="359" height="12" font="5">tively small (less than 200 combinations in the worst case), exhaus-</text>
<text top="456" left="475" width="285" height="12" font="5">tive search is feasible as individual runs can be short.</text>
<text top="491" left="475" width="22" height="16" font="4"><b>5.3</b></text>
<text top="491" left="516" width="149" height="16" font="4"><b>Multi-Node Results</b></text>
<text top="511" left="475" width="359" height="12" font="5">We study the weak scaling property [8] of our framework in the</text>
<text top="526" left="475" width="359" height="12" font="5">two GPU clusters. We keep the problem size per GPU constant and</text>
<text top="542" left="475" width="359" height="12" font="5">increase the stencil size over all three dimensions at roughly the</text>
<text top="558" left="475" width="359" height="12" font="5">same rate as the increase in number of GPUs. Therefore, the sten-</text>
<text top="573" left="475" width="359" height="12" font="5">cil space is kept as close to a cube as possible. The Y axis of Figure</text>
<text top="589" left="475" width="359" height="12" font="5">11 depicts the normalized performance (measured in GFlops) of a</text>
<text top="605" left="475" width="359" height="12" font="5">single GPU. For the C2050 GPU cluster, all three order-1 stencils</text>
<text top="620" left="475" width="359" height="12" font="5">(7/19/27-point) show better efﬁciency (77% to 80%) than order-2</text>
<text top="636" left="475" width="359" height="12" font="5">stencil (50% for 13-point). Because the GTX 480 has higher single-</text>
<text top="652" left="475" width="359" height="12" font="5">node DP GFlops for 7/13/19-point stencils, the weak scaling efﬁ-</text>
<text top="667" left="475" width="359" height="12" font="5">ciency is worse than that on the C2050 cluster. But for 27-point</text>
<text top="683" left="475" width="359" height="12" font="5">stencils, GTX 480’s single-node DP GFlops is less than C2050’s</text>
<text top="699" left="475" width="359" height="12" font="5">DP GFlops. Therefore, the efﬁciency is better (about 90%). This</text>
<text top="715" left="475" width="359" height="12" font="5">can be explained by the difference in inter-node message sizes re-</text>
<text top="730" left="475" width="359" height="12" font="5">quired by different stencils types. The message size is roughly pro-</text>
<text top="746" left="475" width="359" height="12" font="5">portional to the degree of the stencil order. Therefore, our 13-point</text>
<text top="762" left="475" width="359" height="12" font="5">stencil is communication-bound in our current cluster conﬁgura-</text>
<text top="777" left="475" width="24" height="12" font="5">tion.</text>
<text top="809" left="475" width="359" height="12" font="5">Some of the curves do not show a noticeable improvement from 24</text>
<text top="824" left="475" width="359" height="12" font="5">to 27 GPUs (nodes). The 19-point stencil curve even shows a slight</text>
<text top="840" left="475" width="283" height="12" font="5">drop. This is because the stencil space is divided into</text>
<text top="839" left="762" width="72" height="13" font="5">2 × 3 × 4 and</text>
<text top="855" left="475" width="359" height="13" font="5">3 × 3 × 3 partitions in these two cases, respectively. The latter case</text>
<text top="871" left="475" width="359" height="12" font="5">contains a center node that needs to communicate with all other 26</text>
<text top="887" left="475" width="359" height="12" font="5">nodes. This node becomes a hot-spot and reduces the performance.</text>
<text top="903" left="475" width="359" height="12" font="5">But as we increase the number of GPUs, the curve recovers to the</text>
<text top="919" left="475" width="175" height="12" font="5">expected slope for weak scaling.</text>
<text top="953" left="475" width="22" height="16" font="4"><b>5.4</b></text>
<text top="953" left="516" width="252" height="16" font="4"><b>Comparison with Previous Work</b></text>
<text top="973" left="475" width="359" height="12" font="5">We report our results on a wide range of GPUs and stencil types,</text>
<text top="988" left="475" width="359" height="12" font="5">which allows us to compare our performance directly with a wide</text>
<text top="1004" left="475" width="359" height="12" font="5">range of prior work, both for handwritten and auto-generated codes.</text>
<text top="1035" left="475" width="359" height="12" font="5">Datta <i>et al.</i>’s work on optimizing stencil codes in multi-core archi-</text>
<text top="1051" left="475" width="359" height="12" font="5">tectures including GPUs is one of the early contributions in this</text>
<text top="1067" left="475" width="359" height="12" font="5">area [5]. They showed an unprecedented 36 GFlops for 7-point</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="26" size="6" family="Times" color="#000000"/>
	<fontspec id="27" size="6" family="Times" color="#000000"/>
<text top="293" left="116" width="7" height="8" font="24"> 0</text>
<text top="248" left="111" width="11" height="8" font="24"> 50</text>
<text top="203" left="107" width="16" height="8" font="24"> 100</text>
<text top="158" left="107" width="16" height="8" font="24"> 150</text>
<text top="113" left="107" width="16" height="8" font="24"> 200</text>
<text top="298" left="141" width="24" height="8" font="26">GTX 280</text>
<text top="298" left="156" width="84" height="8" font="26">C1060C2050GTX 480 GTX 280</text>
<text top="298" left="230" width="84" height="8" font="26">C1060C2050GTX 480 GTX 280</text>
<text top="298" left="305" width="84" height="8" font="26">C1060C2050GTX 480 GTX 280</text>
<text top="298" left="380" width="54" height="8" font="26">C1060C2050GTX 480</text>
<text top="215" left="94" width="0" height="8" font="27">Gflops/sec</text>
<text top="91" left="204" width="146" height="8" font="24">Contributions of Each Tuning Parameter</text>
<text top="185" left="135" width="54" height="8" font="24">7-Point Stencil</text>
<text top="158" left="197" width="58" height="8" font="24">13-Point Stencil</text>
<text top="203" left="285" width="58" height="8" font="24">19-Point Stencil</text>
<text top="131" left="344" width="58" height="8" font="24">27-Point Stencil</text>
<text top="130" left="185" width="43" height="8" font="24">Block Dims</text>
<text top="121" left="185" width="43" height="8" font="24">Block Sizes</text>
<text top="112" left="200" width="28" height="8" font="24">Texture</text>
<text top="338" left="173" width="181" height="12" font="5">(a) Single Precision (SP) Stencils</text>
<text top="293" left="485" width="7" height="8" font="24"> 0</text>
<text top="259" left="480" width="11" height="8" font="24"> 20</text>
<text top="224" left="480" width="11" height="8" font="24"> 40</text>
<text top="190" left="480" width="11" height="8" font="24"> 60</text>
<text top="156" left="480" width="11" height="8" font="24"> 80</text>
<text top="122" left="476" width="16" height="8" font="24"> 100</text>
<text top="298" left="510" width="24" height="8" font="26">GTX 280</text>
<text top="298" left="524" width="84" height="8" font="26">C1060C2050GTX 480 GTX 280</text>
<text top="298" left="599" width="84" height="8" font="26">C1060C2050GTX 480 GTX 280</text>
<text top="298" left="674" width="84" height="8" font="26">C1060C2050GTX 480 GTX 280</text>
<text top="298" left="748" width="54" height="8" font="26">C1060C2050GTX 480</text>
<text top="215" left="463" width="0" height="8" font="27">Gflops/sec</text>
<text top="91" left="573" width="146" height="8" font="24">Contributions of Each Tuning Parameter</text>
<text top="190" left="504" width="54" height="8" font="24">7-Point Stencil</text>
<text top="147" left="583" width="58" height="8" font="24">13-Point Stencil</text>
<text top="214" left="655" width="58" height="8" font="24">19-Point Stencil</text>
<text top="113" left="728" width="58" height="8" font="24">27-Point Stencil</text>
<text top="130" left="554" width="43" height="8" font="24">Block Dims</text>
<text top="121" left="554" width="43" height="8" font="24">Block Sizes</text>
<text top="112" left="569" width="28" height="8" font="24">Texture</text>
<text top="338" left="538" width="189" height="12" font="5">(b) Double Precision (DP) Stencils</text>
<text top="364" left="339" width="236" height="12" font="7"><b>Figure 8: Stencil Tuning Effect Breakups</b></text>
<text top="525" left="217" width="11" height="8" font="24"> 16</text>
<text top="534" left="263" width="11" height="8" font="24"> 32</text>
<text top="542" left="309" width="11" height="8" font="24"> 64</text>
<text top="540" left="350" width="4" height="8" font="24">2</text>
<text top="533" left="363" width="4" height="8" font="24">3</text>
<text top="526" left="376" width="4" height="8" font="24">4</text>
<text top="518" left="390" width="4" height="8" font="24">6</text>
<text top="511" left="403" width="4" height="8" font="24">8</text>
<text top="504" left="414" width="8" height="8" font="24">16</text>
<text top="488" left="187" width="11" height="8" font="24"> 30</text>
<text top="482" left="187" width="11" height="8" font="24"> 35</text>
<text top="476" left="187" width="11" height="8" font="24"> 40</text>
<text top="470" left="187" width="11" height="8" font="24"> 45</text>
<text top="464" left="187" width="11" height="8" font="24"> 50</text>
<text top="458" left="187" width="11" height="8" font="24"> 55</text>
<text top="452" left="187" width="11" height="8" font="24"> 60</text>
<text top="446" left="187" width="11" height="8" font="24"> 65</text>
<text top="440" left="187" width="11" height="8" font="24"> 70</text>
<text top="434" left="187" width="11" height="8" font="24"> 75</text>
<text top="429" left="187" width="11" height="8" font="24"> 80</text>
<text top="467" left="171" width="0" height="8" font="27">Gflops/sec</text>
<text top="403" left="345" width="82" height="8" font="24">max at block size (64 8)</text>
<text top="541" left="229" width="45" height="8" font="24">Block Size X</text>
<text top="527" left="393" width="45" height="8" font="24">Block Size Y</text>
<text top="467" left="171" width="0" height="8" font="27">Gflops/sec</text>
<text top="479" left="441" width="11" height="8" font="24"> 30</text>
<text top="472" left="441" width="11" height="8" font="24"> 35</text>
<text top="465" left="441" width="11" height="8" font="24"> 40</text>
<text top="459" left="441" width="11" height="8" font="24"> 45</text>
<text top="452" left="441" width="11" height="8" font="24"> 50</text>
<text top="446" left="441" width="11" height="8" font="24"> 55</text>
<text top="439" left="441" width="11" height="8" font="24"> 60</text>
<text top="432" left="441" width="11" height="8" font="24"> 65</text>
<text top="426" left="441" width="11" height="8" font="24"> 70</text>
<text top="419" left="441" width="11" height="8" font="24"> 75</text>
<text top="413" left="441" width="11" height="8" font="24"> 80</text>
<text top="558" left="229" width="159" height="12" font="5">(a) Find Optimal Block Sizes</text>
<text top="525" left="514" width="11" height="8" font="24"> 16</text>
<text top="534" left="560" width="11" height="8" font="24"> 32</text>
<text top="542" left="606" width="11" height="8" font="24"> 64</text>
<text top="539" left="650" width="4" height="8" font="24">2</text>
<text top="528" left="670" width="4" height="8" font="24">3</text>
<text top="516" left="690" width="4" height="8" font="24">4</text>
<text top="505" left="710" width="4" height="8" font="24">8</text>
<text top="488" left="488" width="6" height="8" font="24"> 0</text>
<text top="480" left="484" width="11" height="8" font="24"> 10</text>
<text top="473" left="484" width="11" height="8" font="24"> 20</text>
<text top="465" left="484" width="11" height="8" font="24"> 30</text>
<text top="458" left="484" width="11" height="8" font="24"> 40</text>
<text top="451" left="484" width="11" height="8" font="24"> 50</text>
<text top="443" left="484" width="11" height="8" font="24"> 60</text>
<text top="436" left="484" width="11" height="8" font="24"> 70</text>
<text top="429" left="484" width="11" height="8" font="24"> 80</text>
<text top="467" left="468" width="0" height="8" font="27">Gflops/sec</text>
<text top="393" left="657" width="87" height="8" font="24">max at block dims=(32 8)</text>
<text top="541" left="526" width="46" height="8" font="24">Block Dim X</text>
<text top="527" left="689" width="46" height="8" font="24">Block Dim Y</text>
<text top="467" left="468" width="0" height="8" font="27">Gflops/sec</text>
<text top="479" left="738" width="6" height="8" font="24"> 0</text>
<text top="470" left="738" width="11" height="8" font="24"> 10</text>
<text top="462" left="738" width="11" height="8" font="24"> 20</text>
<text top="454" left="738" width="11" height="8" font="24"> 30</text>
<text top="446" left="738" width="11" height="8" font="24"> 40</text>
<text top="437" left="738" width="11" height="8" font="24"> 50</text>
<text top="429" left="738" width="11" height="8" font="24"> 60</text>
<text top="421" left="738" width="11" height="8" font="24"> 70</text>
<text top="413" left="738" width="11" height="8" font="24"> 80</text>
<text top="558" left="459" width="294" height="12" font="5">(b) Find Optimal Block Dims, Fixed Block Size at (64,</text>
<text top="571" left="459" width="11" height="12" font="5">8)</text>
<text top="610" left="345" width="224" height="12" font="7"><b>Figure 9: GTX 280 7-Point Stencil (SP)</b></text>
<text top="655" left="81" width="359" height="12" font="5">stencil on a GTX 280 with their highly optimized code. Theirs is</text>
<text top="671" left="81" width="359" height="12" font="5">10% faster than our performance (32.5 GFlops). This is mainly due</text>
<text top="686" left="81" width="359" height="12" font="5">to the difference between the instruction orders in our template ﬁle</text>
<text top="702" left="81" width="359" height="12" font="5">and their hand-tuned kernel code, as we discovered by inspecting</text>
<text top="718" left="81" width="359" height="12" font="5">their and our codes side-by-side. But interestingly, their best per-</text>
<text top="734" left="81" width="206" height="12" font="5">formance is achieved at a block size of</text>
<text top="733" left="290" width="149" height="13" font="5">16 × 16 and unroll factor of</text>
<text top="749" left="81" width="359" height="12" font="5">4 over the dimension Y, which is consistent to our ﬁndings in our</text>
<text top="765" left="81" width="359" height="12" font="5">auto-tuning engine. However, this conﬁguration is <i>only </i>optimal for</text>
<text top="781" left="81" width="359" height="12" font="5">a DP 7-point stencil on the GTX 280s. For everything else, the</text>
<text top="795" left="81" width="359" height="13" font="5">16 × 16 block sizes are no longer optimal, as indicated by Table 3.</text>
<text top="828" left="81" width="359" height="12" font="5">An efﬁcient and handwritten CUDA implementation on the Hi-</text>
<text top="843" left="81" width="359" height="12" font="5">meno benchmark is reported by Philips <i>et al. </i>[20]. Their imple-</text>
<text top="859" left="81" width="359" height="12" font="5">mentation, with an extra two Flops per stencil for residual calcula-</text>
<text top="875" left="81" width="359" height="12" font="5">tion, achieved 50 GFlops SP on a Tesla C1060. Our auto-generated</text>
<text top="890" left="81" width="337" height="12" font="5">code achieves 44.8 GFlops on the same platform and is within</text>
<text top="890" left="421" width="18" height="13" font="5">5%</text>
<text top="906" left="81" width="184" height="12" font="5">to theirs if Flops are normalized (</text>
<text top="905" left="264" width="39" height="13" font="5">44.8 ×</text>
<text top="904" left="309" width="11" height="6" font="1">34</text>
<text top="914" left="309" width="11" height="6" font="1">32</text>
<text top="905" left="326" width="113" height="13" font="5">= 47.6 ). Their best</text>
<text top="922" left="81" width="78" height="12" font="5">block sizes are</text>
<text top="921" left="162" width="277" height="13" font="5">64 × 2 for Tesla C1060, while ours is 64 × 6 with an</text>
<text top="937" left="81" width="359" height="12" font="5">unrolling factor of 2 over the Y axis. This is because they load the</text>
<text top="953" left="81" width="359" height="12" font="5">input arrays into shared memory by issuing four branch-free loads</text>
<text top="969" left="81" width="181" height="12" font="5">aligned at four corners. Choosing</text>
<text top="968" left="265" width="174" height="13" font="5">BlockSize.y as 2, in their case,</text>
<text top="985" left="81" width="359" height="12" font="5">minimizes redundant memory loads, which is beneﬁcial because</text>
<text top="1000" left="81" width="359" height="12" font="5">SP Himeno is bandwidth limited on the C1060. They also reported</text>
<text top="1016" left="81" width="359" height="12" font="5">near-perfect weak scaling efﬁciency on up to 16 GPUs. But their</text>
<text top="1032" left="81" width="359" height="12" font="5">system conﬁguration is different from ours: (1) Each node has two</text>
<text top="1047" left="81" width="359" height="12" font="5">GPUs instead of one in our case. Therefore, half of the network</text>
<text top="1063" left="81" width="359" height="12" font="5">messages become memory copies on the same host. (2) The stencil</text>
<text top="655" left="475" width="359" height="12" font="5">space only grows along the Z axis, eliminating the need to perform</text>
<text top="671" left="475" width="359" height="12" font="5">Cartesian partitioning. This reduces the multi-node code complex-</text>
<text top="686" left="475" width="87" height="12" font="5">ity signiﬁcantly.</text>
<text top="718" left="475" width="359" height="12" font="5">Kamil <i>et al. </i>proposed an auto-tuning framework for multi-core ar-</text>
<text top="734" left="475" width="359" height="12" font="5">chitectures [11]. However, they reported only 14 GFlops DP on a</text>
<text top="749" left="475" width="359" height="12" font="5">7-point stencil for a GTX 280. This is mainly because their code</text>
<text top="765" left="475" width="359" height="12" font="5">generator does not take advantage of the fast on-chip shared mem-</text>
<text top="781" left="475" width="359" height="12" font="5">ory, which is an ideal intermediate storage level to reduce memory</text>
<text top="796" left="475" width="184" height="12" font="5">load for stencil-like computations.</text>
<text top="828" left="475" width="359" height="12" font="5">Nguyen <i>et al. </i>have reported by far the fastest implementation of</text>
<text top="843" left="475" width="359" height="12" font="5">any SP stencil code on single GPU [18]. Their manually-written</text>
<text top="859" left="475" width="359" height="12" font="5">code for a 7-point stencil achieves 136 GFlops on GTX 285 (a simi-</text>
<text top="875" left="475" width="359" height="12" font="5">lar platform as GTX 280), a large gain over our reported 76 GFlops.</text>
<text top="890" left="475" width="359" height="12" font="5">However, their extra speedup comes from saving a large amount of</text>
<text top="906" left="475" width="359" height="12" font="5">global memory accesses by exploiting data locality on the time do-</text>
<text top="922" left="475" width="359" height="12" font="5">main. This is equivalent to executing several iterations per kernel,</text>
<text top="937" left="475" width="359" height="12" font="5">a technique also known as increasing the ghost region. Increasing</text>
<text top="953" left="475" width="359" height="12" font="5">the ghost region leads to less frequent message exchanges but does</text>
<text top="969" left="475" width="359" height="12" font="5">not reduce the total amount of data transferred in the network be-</text>
<text top="985" left="475" width="359" height="12" font="5">cause the payload for each message increases as well. It has been</text>
<text top="1000" left="475" width="359" height="12" font="5">shown to be insigniﬁcant in multi-node scenarios due to the slower</text>
<text top="1016" left="475" width="359" height="12" font="5">inter-node communication [21]. Therefore, we decided not to in-</text>
<text top="1032" left="475" width="359" height="12" font="5">clude ghost region sizes/update frequencies as a tuning parameter</text>
<text top="1047" left="475" width="359" height="12" font="5">in our code generator and auto-tuning schemes. For DP stencils,</text>
<text top="1063" left="475" width="359" height="12" font="5">their performance is no better than [5] due to limitations in shared</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1188" width="918">
<text top="225" left="217" width="11" height="8" font="24"> 16</text>
<text top="233" left="263" width="11" height="8" font="24"> 32</text>
<text top="242" left="309" width="11" height="8" font="24"> 64</text>
<text top="240" left="350" width="4" height="8" font="24">2</text>
<text top="233" left="363" width="4" height="8" font="24">3</text>
<text top="225" left="376" width="4" height="8" font="24">4</text>
<text top="218" left="390" width="4" height="8" font="24">6</text>
<text top="211" left="403" width="4" height="8" font="24">8</text>
<text top="203" left="414" width="8" height="8" font="24">16</text>
<text top="187" left="191" width="6" height="8" font="24"> 0</text>
<text top="180" left="187" width="11" height="8" font="24"> 10</text>
<text top="173" left="187" width="11" height="8" font="24"> 20</text>
<text top="165" left="187" width="11" height="8" font="24"> 30</text>
<text top="158" left="187" width="11" height="8" font="24"> 40</text>
<text top="150" left="187" width="11" height="8" font="24"> 50</text>
<text top="143" left="187" width="11" height="8" font="24"> 60</text>
<text top="136" left="187" width="11" height="8" font="24"> 70</text>
<text top="128" left="187" width="11" height="8" font="24"> 80</text>
<text top="167" left="171" width="0" height="8" font="27">Gflops/sec</text>
<text top="96" left="355" width="82" height="8" font="24">max at block size (64 4)</text>
<text top="241" left="229" width="45" height="8" font="24">Block Size X</text>
<text top="227" left="393" width="45" height="8" font="24">Block Size Y</text>
<text top="167" left="171" width="0" height="8" font="27">Gflops/sec</text>
<text top="178" left="441" width="6" height="8" font="24"> 0</text>
<text top="170" left="441" width="11" height="8" font="24"> 10</text>
<text top="162" left="441" width="11" height="8" font="24"> 20</text>
<text top="154" left="441" width="11" height="8" font="24"> 30</text>
<text top="145" left="441" width="11" height="8" font="24"> 40</text>
<text top="137" left="441" width="11" height="8" font="24"> 50</text>
<text top="129" left="441" width="11" height="8" font="24"> 60</text>
<text top="121" left="441" width="11" height="8" font="24"> 70</text>
<text top="112" left="441" width="11" height="8" font="24"> 80</text>
<text top="257" left="229" width="159" height="12" font="5">(a) Find Optimal Block Sizes</text>
<text top="225" left="514" width="11" height="8" font="24"> 16</text>
<text top="233" left="560" width="11" height="8" font="24"> 32</text>
<text top="242" left="606" width="11" height="8" font="24"> 64</text>
<text top="236" left="653" width="4" height="8" font="24">2</text>
<text top="222" left="680" width="4" height="8" font="24">3</text>
<text top="207" left="707" width="4" height="8" font="24">4</text>
<text top="187" left="488" width="6" height="8" font="24"> 0</text>
<text top="180" left="484" width="11" height="8" font="24"> 10</text>
<text top="173" left="484" width="11" height="8" font="24"> 20</text>
<text top="165" left="484" width="11" height="8" font="24"> 30</text>
<text top="158" left="484" width="11" height="8" font="24"> 40</text>
<text top="150" left="484" width="11" height="8" font="24"> 50</text>
<text top="143" left="484" width="11" height="8" font="24"> 60</text>
<text top="136" left="484" width="11" height="8" font="24"> 70</text>
<text top="128" left="484" width="11" height="8" font="24"> 80</text>
<text top="167" left="468" width="0" height="8" font="27">Gflops/sec</text>
<text top="81" left="635" width="87" height="8" font="24">max at block dims=(16 4)</text>
<text top="241" left="526" width="46" height="8" font="24">Block Dim X</text>
<text top="227" left="689" width="46" height="8" font="24">Block Dim Y</text>
<text top="167" left="468" width="0" height="8" font="27">Gflops/sec</text>
<text top="178" left="738" width="6" height="8" font="24"> 0</text>
<text top="170" left="738" width="11" height="8" font="24"> 10</text>
<text top="162" left="738" width="11" height="8" font="24"> 20</text>
<text top="154" left="738" width="11" height="8" font="24"> 30</text>
<text top="145" left="738" width="11" height="8" font="24"> 40</text>
<text top="137" left="738" width="11" height="8" font="24"> 50</text>
<text top="129" left="738" width="11" height="8" font="24"> 60</text>
<text top="121" left="738" width="11" height="8" font="24"> 70</text>
<text top="112" left="738" width="11" height="8" font="24"> 80</text>
<text top="257" left="459" width="294" height="12" font="5">(b) Find Optimal Block Dims, Fixed Block Size at (64,</text>
<text top="271" left="459" width="11" height="12" font="5">4)</text>
<text top="296" left="345" width="224" height="12" font="7"><b>Figure 10: C2050 27-Point Stencil (DP)</b></text>
<text top="558" left="111" width="7" height="8" font="24"> 0</text>
<text top="523" left="111" width="7" height="8" font="24"> 5</text>
<text top="487" left="106" width="11" height="8" font="24"> 10</text>
<text top="452" left="106" width="11" height="8" font="24"> 15</text>
<text top="417" left="106" width="11" height="8" font="24"> 20</text>
<text top="382" left="106" width="11" height="8" font="24"> 25</text>
<text top="346" left="106" width="11" height="8" font="24"> 30</text>
<text top="567" left="114" width="7" height="8" font="24"> 0</text>
<text top="567" left="152" width="7" height="8" font="24"> 5</text>
<text top="567" left="188" width="11" height="8" font="24"> 10</text>
<text top="567" left="226" width="11" height="8" font="24"> 15</text>
<text top="567" left="264" width="11" height="8" font="24"> 20</text>
<text top="567" left="302" width="11" height="8" font="24"> 25</text>
<text top="567" left="340" width="11" height="8" font="24"> 30</text>
<text top="567" left="378" width="11" height="8" font="24"> 35</text>
<text top="567" left="416" width="11" height="8" font="24"> 40</text>
<text top="494" left="94" width="0" height="8" font="27">Normalized Performance</text>
<text top="580" left="240" width="70" height="9" font="12">Number of GPUs</text>
<text top="354" left="168" width="73" height="8" font="24">7-Point Stencil (DP)</text>
<text top="363" left="163" width="78" height="8" font="24">13-Point Stencil (DP)</text>
<text top="372" left="163" width="78" height="8" font="24">19-Point Stencil (DP)</text>
<text top="381" left="163" width="78" height="8" font="24">27-Point Stencil (DP)</text>
<text top="596" left="216" width="95" height="12" font="5">(a) C2050 cluster</text>
<text top="558" left="479" width="7" height="8" font="24"> 0</text>
<text top="534" left="479" width="7" height="8" font="24"> 5</text>
<text top="511" left="475" width="11" height="8" font="24"> 10</text>
<text top="487" left="475" width="11" height="8" font="24"> 15</text>
<text top="464" left="475" width="11" height="8" font="24"> 20</text>
<text top="440" left="475" width="11" height="8" font="24"> 25</text>
<text top="417" left="475" width="11" height="8" font="24"> 30</text>
<text top="393" left="475" width="11" height="8" font="24"> 35</text>
<text top="370" left="475" width="11" height="8" font="24"> 40</text>
<text top="346" left="475" width="11" height="8" font="24"> 45</text>
<text top="567" left="483" width="7" height="8" font="24"> 0</text>
<text top="567" left="513" width="7" height="8" font="24"> 5</text>
<text top="567" left="541" width="11" height="8" font="24"> 10</text>
<text top="567" left="572" width="11" height="8" font="24"> 15</text>
<text top="567" left="602" width="11" height="8" font="24"> 20</text>
<text top="567" left="632" width="11" height="8" font="24"> 25</text>
<text top="567" left="663" width="11" height="8" font="24"> 30</text>
<text top="567" left="693" width="11" height="8" font="24"> 35</text>
<text top="567" left="724" width="11" height="8" font="24"> 40</text>
<text top="567" left="754" width="11" height="8" font="24"> 45</text>
<text top="567" left="784" width="11" height="8" font="24"> 50</text>
<text top="494" left="463" width="0" height="8" font="27">Normalized Performance</text>
<text top="580" left="608" width="70" height="9" font="12">Number of GPUs</text>
<text top="354" left="536" width="73" height="8" font="24">7-Point Stencil (DP)</text>
<text top="363" left="532" width="78" height="8" font="24">13-Point Stencil (DP)</text>
<text top="372" left="532" width="78" height="8" font="24">19-Point Stencil (DP)</text>
<text top="381" left="532" width="78" height="8" font="24">27-Point Stencil (DP)</text>
<text top="596" left="577" width="111" height="12" font="5">(b) GTX 480 cluster</text>
<text top="622" left="295" width="325" height="12" font="7"><b>Figure 11: Weak Scaling of DP Stencils on GPU Clusters</b></text>
<text top="666" left="81" width="161" height="12" font="5">memory size of the GTX 285.</text>
<text top="698" left="81" width="359" height="12" font="5">Unat <i>et al. </i>proposed a compiler framework called Mint using anno-</text>
<text top="713" left="81" width="359" height="12" font="5">tated C as the front-end. It converts stencil computation into C code</text>
<text top="729" left="81" width="359" height="12" font="5">using pragmas with several levels of optimized CUDA code [22].</text>
<text top="745" left="81" width="359" height="12" font="5">Our DP performance of a 7-point stencil on the C1060 achieves</text>
<text top="761" left="81" width="359" height="12" font="5">the same GFlops as their hand-written code (28 GFlops). In con-</text>
<text top="776" left="81" width="359" height="12" font="5">trast, auto-generated Mint code with the highest level optimization</text>
<text top="792" left="81" width="136" height="12" font="5">achieves only 22 GFlops.</text>
<text top="823" left="81" width="359" height="12" font="5">Christen <i>et al. </i>[4] and Maruyama <i>et al. </i>[14] proposed two DSLs:</text>
<text top="839" left="81" width="359" height="12" font="5">Patus and Physis. Patus purely depends on the cache on the Fermi</text>
<text top="855" left="81" width="359" height="12" font="5">architecture without using any shared memory. Therefore, its auto-</text>
<text top="870" left="81" width="359" height="12" font="5">tuning capability is severely limited. Physis currently lacks any</text>
<text top="886" left="81" width="359" height="12" font="5">auto-tuning scheme, one has to choose block sizes manually. Both</text>
<text top="902" left="81" width="209" height="12" font="5">report SP performance inferior to ours.</text>
<text top="937" left="81" width="13" height="16" font="4"><b>6.</b></text>
<text top="937" left="112" width="122" height="16" font="4"><b>CONCLUSION</b></text>
<text top="957" left="81" width="359" height="12" font="5">This paper shows that GPU programmability and performance are</text>
<text top="973" left="81" width="359" height="12" font="5">not mutually exclusive under DSLs. With a DSL speciﬁcation fed</text>
<text top="988" left="81" width="359" height="12" font="5">to the front-end, problem descriptions can become very concise and</text>
<text top="1004" left="81" width="359" height="12" font="5">intuitive. Using auto-tuning with run-time proﬁle feedback, opti-</text>
<text top="1020" left="81" width="359" height="12" font="5">mal tuning points within the parameter search space can be iden-</text>
<text top="1035" left="81" width="359" height="12" font="5">tiﬁed. Our framework combines auto-generation and auto-tuning</text>
<text top="1051" left="81" width="359" height="12" font="5">of 3D stencil codes on heterogeneous GPU clusters. We extract</text>
<text top="1067" left="81" width="359" height="12" font="5">a small, selective number of key performance-sensitive parameters</text>
<text top="666" left="475" width="359" height="12" font="5">and auto-tune them to achieve the best possible performance over a</text>
<text top="682" left="475" width="359" height="12" font="5">variety of GPUs. Compared to previous work, we manage to keep</text>
<text top="698" left="475" width="359" height="12" font="5">the programmer’s effort to even a lower overhead without signiﬁ-</text>
<text top="713" left="475" width="159" height="12" font="5">cant sacriﬁce in performance.</text>
<text top="759" left="475" width="13" height="16" font="4"><b>7.</b></text>
<text top="759" left="507" width="121" height="16" font="4"><b>REFERENCES</b></text>
<text top="778" left="482" width="301" height="12" font="5">[1] NVIDIA Cooperation, CUDA Programming Guide.</text>
<text top="795" left="482" width="328" height="12" font="5">[2] C. W. Antoine, A. Petitet, and J. J. Dongarra. Automated</text>
<text top="811" left="504" width="326" height="12" font="5">Empirical Optimization of Software and the ATLAS Project.</text>
<text top="827" left="504" width="106" height="12" font="6"><i>Parallel Computing</i></text>
<text top="827" left="610" width="88" height="12" font="5">, 27:2001, 2000.</text>
<text top="844" left="482" width="330" height="12" font="5">[3] B. Catanzaro, A. Fox, K. Keutzer, D. Patterson, B.-Y. Su,</text>
<text top="860" left="504" width="328" height="12" font="5">M. Snir, K. Olukotun, P. Hanrahan, and H. Chaﬁ. Ubiquitous</text>
<text top="875" left="504" width="309" height="12" font="5">Parallel Computing from Berkeley, Illinois, and Stanford.</text>
<text top="891" left="504" width="65" height="12" font="6"><i>IEEE Micro</i></text>
<text top="891" left="569" width="139" height="12" font="5">, 30(2):41–55, Mar. 2010.</text>
<text top="908" left="482" width="338" height="12" font="5">[4] M. Christen, O. Schenk, and H. Burkhart. PATUS: A Code</text>
<text top="924" left="504" width="326" height="12" font="5">Generation and Autotuning Framework For Parallel Iterative</text>
<text top="940" left="504" width="302" height="12" font="5">Stencil Computations on Modern Microarchitectures. <i>In</i></text>
<text top="955" left="504" width="312" height="12" font="6"><i>IEEE Intl Parallel and Distributed Processing Symposium</i></text>
<text top="971" left="504" width="46" height="12" font="6"><i>(IPDPS)</i></text>
<text top="971" left="551" width="65" height="12" font="5">, May 2011.</text>
<text top="988" left="482" width="319" height="12" font="5">[5] K. Datta, M. Murphy, V. Volkov, S. Williams, J. Carter,</text>
<text top="1004" left="504" width="293" height="12" font="5">L. Oliker, D. Patterson, J. Shalf, and K. Yelick. Stencil</text>
<text top="1020" left="504" width="253" height="12" font="5">Computation Optimization and Auto-tuning on</text>
<text top="1035" left="504" width="316" height="12" font="5">State-of-the-art Multicore Architectures. In <i>Proceedings of</i></text>
<text top="1051" left="504" width="281" height="12" font="6"><i>the 2008 ACM/IEEE conference on Supercomputing</i></text>
<text top="1051" left="785" width="48" height="12" font="5">, SC ’08,</text>
<text top="1067" left="504" width="308" height="12" font="5">pages 4:1–4:12, Piscataway, NJ, USA, 2008. IEEE Press.</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1188" width="918">
<text top="86" left="87" width="329" height="12" font="5">[6] M. Frigo. A Fast Fourier Transform Compiler. <i>SIGPLAN</i></text>
<text top="102" left="110" width="23" height="12" font="6"><i>Not.</i></text>
<text top="102" left="133" width="140" height="12" font="5">, 39:642–655, April 2004.</text>
<text top="119" left="87" width="330" height="12" font="5">[7] P. Guo and L. Wang. Auto-Tuning CUDA Parameters for</text>
<text top="135" left="110" width="251" height="12" font="5">Sparse Matrix-Vector Multiplication on GPUs.</text>
<text top="151" left="110" width="299" height="12" font="6"><i>Computational and Information Sciences, International</i></text>
<text top="166" left="110" width="78" height="12" font="6"><i>Conference on</i></text>
<text top="166" left="188" width="115" height="12" font="5">, 0:1154–1157, 2010.</text>
<text top="184" left="87" width="352" height="12" font="5">[8] J. L. Gustafson. Reevaluating Amdahl’s law. <i>Commun. ACM</i>,</text>
<text top="199" left="110" width="129" height="12" font="5">31:532–533, May 1988.</text>
<text top="216" left="87" width="247" height="12" font="5">[9] http://www.khronos.org/opencl. OpenCL.</text>
<text top="234" left="81" width="359" height="12" font="5">[10] W.-m. Hwu, S. Ryoo, S.-z. Ueng, J. H. Kelm, I. Gelado, S. S.</text>
<text top="249" left="110" width="309" height="12" font="5">Stone, R. E. Kidd, S. S. Baghsorkhi, A. A. Mahesri, S. C.</text>
<text top="265" left="110" width="326" height="12" font="5">Tsao, N. Navarro, S. S. Lumetta, M. I. Frank, and S. J. Patel.</text>
<text top="281" left="110" width="321" height="12" font="5">Implicitly Parallel Programming Models for Thousand-core</text>
<text top="296" left="110" width="321" height="12" font="5">Microprocessors. In <i>Proceedings of the 44th annual Design</i></text>
<text top="312" left="110" width="127" height="12" font="6"><i>Automation Conference</i></text>
<text top="312" left="237" width="177" height="12" font="5">, pages 754–759, New York, NY,</text>
<text top="328" left="110" width="101" height="12" font="5">USA, 2007. ACM.</text>
<text top="345" left="81" width="346" height="12" font="5">[11] S. Kamil, C. Chan, L. Oliker, J. Shalf, and S. Williams. An</text>
<text top="361" left="110" width="295" height="12" font="5">Auto-Tuning Framework for Parallel Multicore Stencil</text>
<text top="376" left="110" width="297" height="12" font="5">Computations. In <i>In IEEE Intl Parallel and Distributed</i></text>
<text top="392" left="110" width="173" height="12" font="6"><i>Processing Symposium (IPDPS)</i></text>
<text top="392" left="283" width="37" height="12" font="5">, 2010.</text>
<text top="409" left="81" width="337" height="12" font="5">[12] Y. Li, J. Dongarra, and S. Tomov. A Note on Auto-tuning</text>
<text top="425" left="110" width="313" height="12" font="5">GEMM for GPUs. In <i>Proceedings of the 9th International</i></text>
<text top="441" left="110" width="246" height="12" font="6"><i>Conference on Computational Science: Part I</i></text>
<text top="441" left="356" width="61" height="12" font="5">, ICCS ’09,</text>
<text top="456" left="110" width="317" height="12" font="5">pages 884–892, Berlin, Heidelberg, 2009. Springer-Verlag.</text>
<text top="473" left="81" width="327" height="12" font="5">[13] Z. Li and Y. Song. Automatic Tiling of Iterative Stencil</text>
<text top="489" left="110" width="303" height="12" font="5">Loops. <i>ACM Trans. Program. Lang. Syst.</i>, 26:975–1028,</text>
<text top="505" left="110" width="90" height="12" font="5">November 2004.</text>
<text top="522" left="81" width="358" height="12" font="5">[14] N. Maruyama, T. Nomura, K. Sato, and S. Matsuoka. Physis:</text>
<text top="538" left="110" width="293" height="12" font="5">An Implicitly Parallel Programming Model for Stencil</text>
<text top="553" left="110" width="259" height="12" font="5">Computations on Large-Scale GPU-Accelerated</text>
<text top="569" left="110" width="124" height="12" font="5">Supercomputers. 2011.</text>
<text top="586" left="81" width="331" height="12" font="5">[15] S. Matsuoka, T. Aoki, T. Endo, A. Nukada, T. Kato, and</text>
<text top="602" left="110" width="312" height="12" font="5">A. Hasegawa. GPU Accelerated Computing from Hype to</text>
<text top="618" left="110" width="325" height="12" font="5">Mainstream, the Rebirth of Vector Computing. In <i>Journal of</i></text>
<text top="633" left="110" width="171" height="12" font="6"><i>Physics: Conference Series 180</i></text>
<text top="633" left="281" width="37" height="12" font="5">, 2009.</text>
<text top="86" left="475" width="314" height="12" font="5">[16] J. Meng and K. Skadron. Performance Modeling and</text>
<text top="102" left="504" width="305" height="12" font="5">Automatic Ghost Zone Optimization for Iterative Stencil</text>
<text top="118" left="504" width="309" height="12" font="5">Loops on GPUs. In <i>Proceedings of the 23rd international</i></text>
<text top="134" left="504" width="166" height="12" font="6"><i>conference on Supercomputing</i></text>
<text top="133" left="671" width="140" height="12" font="5">, ICS ’09, pages 256–265,</text>
<text top="149" left="504" width="186" height="12" font="5">New York, NY, USA, 2009. ACM.</text>
<text top="166" left="475" width="356" height="12" font="5">[17] P. Micikevicius. 3D Finite Difference Computation on GPUs</text>
<text top="182" left="504" width="316" height="12" font="5">using CUDA. In <i>Proceedings of 2nd Workshop on General</i></text>
<text top="198" left="504" width="272" height="12" font="6"><i>Purpose Processing on Graphics Processing Units</i></text>
<text top="198" left="777" width="3" height="12" font="5">,</text>
<text top="213" left="504" width="323" height="12" font="5">GPGPU-2, pages 79–84, New York, NY, USA, 2009. ACM.</text>
<text top="231" left="475" width="342" height="12" font="5">[18] A. Nguyen, N. Satish, J. Chhugani, C. Kim, and P. Dubey.</text>
<text top="246" left="504" width="313" height="12" font="5">3.5-D Blocking Optimization for Stencil Computations on</text>
<text top="262" left="504" width="287" height="12" font="5">Modern CPUs and GPUs. In <i>Proceedings of the 2010</i></text>
<text top="278" left="504" width="322" height="12" font="6"><i>ACM/IEEE International Conference for High Performance</i></text>
<text top="293" left="504" width="250" height="12" font="6"><i>Computing, Networking, Storage and Analysis</i></text>
<text top="293" left="754" width="48" height="12" font="5">, SC ’10,</text>
<text top="309" left="504" width="317" height="12" font="5">pages 1–13, Washington, DC, USA, 2010. IEEE Computer</text>
<text top="325" left="504" width="43" height="12" font="5">Society.</text>
<text top="342" left="475" width="343" height="12" font="5">[19] A. Nukada and S. Matsuoka. Auto-tuning 3-D FFT library</text>
<text top="358" left="504" width="326" height="12" font="5">for CUDA GPUs. In <i>Proceedings of the Conference on High</i></text>
<text top="373" left="504" width="319" height="12" font="6"><i>Performance Computing Networking, Storage and Analysis</i></text>
<text top="373" left="823" width="3" height="12" font="5">,</text>
<text top="389" left="504" width="296" height="12" font="5">SC ’09, pages 30:1–30:10, New York, NY, USA, 2009.</text>
<text top="405" left="504" width="33" height="12" font="5">ACM.</text>
<text top="422" left="475" width="311" height="12" font="5">[20] E. Phillips and M. Fatica. Implementing the Himeno</text>
<text top="438" left="504" width="312" height="12" font="5">benchmark with CUDA on GPU clusters. In <i>International</i></text>
<text top="453" left="504" width="304" height="12" font="6"><i>Parallel and Distributed Processing Symposium(IPDPS)</i></text>
<text top="453" left="809" width="3" height="12" font="5">,</text>
<text top="469" left="504" width="55" height="12" font="5">Apr 2010.</text>
<text top="486" left="475" width="355" height="12" font="5">[21] M. Ripeanu, A. Iamnitchi, and I. Foster. Cactus Application:</text>
<text top="502" left="504" width="285" height="12" font="5">Performance Predictions in Grid Environments. In <i>In</i></text>
<text top="517" left="504" width="326" height="12" font="6"><i>proceedings of European Conference on Parallel Computing</i></text>
<text top="533" left="504" width="85" height="12" font="6"><i>(EuroPar) 2001</i></text>
<text top="533" left="589" width="37" height="12" font="5">, 2001.</text>
<text top="550" left="475" width="325" height="12" font="5">[22] D. Unat, X. Cai, and S. Baden. Mint: Realizing CUDA</text>
<text top="566" left="504" width="310" height="12" font="5">Performance in 3D Stencil Methods with Annotated C. In</text>
<text top="582" left="504" width="284" height="12" font="6"><i>Proceedings of the 25th International Conference on</i></text>
<text top="597" left="504" width="138" height="12" font="6"><i>Supercomputing (ICS’11)</i></text>
<text top="597" left="642" width="37" height="12" font="5">, 2011.</text>
<text top="615" left="475" width="354" height="12" font="5">[23] R. Vuduc, J. W. Demmel, and K. A. Yelick. OSKI: A library</text>
<text top="630" left="504" width="318" height="12" font="5">of Automatically Tuned Sparse Matrix Kernels. In <i>Institute</i></text>
<text top="646" left="504" width="117" height="12" font="6"><i>of Physics Publishing</i></text>
<text top="646" left="621" width="37" height="12" font="5">, 2005.</text>
</page>
</pdf2xml>
