<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="19" family="Times" color="#000000"/>
	<fontspec id="1" size="14" family="Times" color="#000000"/>
	<fontspec id="2" size="15" family="Times" color="#000000"/>
<text top="99" left="176" width="566" height="19" font="0">Automated Compilation of ISPC Programs to FPGA</text>
<text top="123" left="336" width="246" height="15" font="1">15-869 Fall 2011 Final Report</text>
<text top="143" left="339" width="240" height="15" font="1">Gabriel Weisz <a href="mailto:gweisz@cs.cmu.edu">gweisz@cs.cmu.edu</a></text>
<text top="180" left="54" width="10" height="16" font="2">1</text>
<text top="180" left="84" width="111" height="16" font="2">Introduction</text>
<text top="217" left="79" width="372" height="15" font="1">Field Programmable Gate Arrays (FPGAs) are hard-</text>
<text top="238" left="54" width="398" height="15" font="1">ware devices that contain circuits that can be conﬁg-</text>
<text top="258" left="54" width="398" height="15" font="1">ured to implement the desired functionality. While they</text>
<text top="278" left="54" width="398" height="15" font="1">have traditionally been used for prototyping, there has</text>
<text top="299" left="54" width="398" height="15" font="1">been an increased interest in using these devices for com-</text>
<text top="319" left="54" width="398" height="15" font="1">putation. Part of the reason for this is that the com-</text>
<text top="339" left="54" width="398" height="15" font="1">puter architecture community is coming up against se-</text>
<text top="360" left="54" width="398" height="15" font="1">vere power restrictions - while Moore’s Law continues</text>
<text top="380" left="54" width="398" height="15" font="1">to hold and the density of transistors keeps increasing,</text>
<text top="400" left="54" width="398" height="15" font="1">hardware designers are ﬁnding it increasingly diﬃcult</text>
<text top="420" left="54" width="398" height="15" font="1">to deliver power to these transistors and to dissipate</text>
<text top="441" left="54" width="398" height="15" font="1">the heat that they pro<a href="pdfxml.html#11">duce[5]. </a>Recent work has shown</text>
<text top="461" left="54" width="398" height="15" font="1">that FPGAs can provide high performance computation</text>
<text top="481" left="54" width="398" height="15" font="1">with good power <a href="pdfxml.html#11">eﬃciency[4], </a>which might allow these</text>
<text top="502" left="54" width="398" height="15" font="1">devices to be used to help available computational capa-</text>
<text top="522" left="54" width="398" height="15" font="1">bility increase in the face of limited power budges. An</text>
<text top="542" left="54" width="398" height="15" font="1">indication that the mainstream processor community is</text>
<text top="563" left="54" width="398" height="15" font="1">beginning to embrace FPGAs is Intel’s recently released</text>
<text top="583" left="54" width="398" height="15" font="1"><a href="pdfxml.html#12">Stellarton[9] </a>platform, which combines an Atom proces-</text>
<text top="603" left="54" width="398" height="15" font="1">sor and a reconﬁgurable FPGA fabric (which is based</text>
<text top="624" left="54" width="379" height="15" font="1">upon an Altera product) within a processor package.</text>
<text top="644" left="79" width="372" height="15" font="1">While the capability of FPGAs to eﬀectively per-</text>
<text top="664" left="54" width="398" height="15" font="1">form computation has been demonstrated, actually us-</text>
<text top="685" left="54" width="398" height="15" font="1">ing these devices in such a fashion remains a challenge.</text>
<text top="705" left="54" width="398" height="15" font="1">Languages that are typically used to create FPGA appli-</text>
<text top="725" left="54" width="398" height="15" font="1">cations such as Verilog and VHDL present a very diﬀer-</text>
<text top="746" left="54" width="398" height="15" font="1">ent programming model from that which software devel-</text>
<text top="766" left="54" width="398" height="15" font="1">opers generally use, and the learning curve for these lan-</text>
<text top="786" left="54" width="398" height="15" font="1">guages is steep. In addition to overcoming the language</text>
<text top="807" left="54" width="398" height="15" font="1">hurdle, creating any signiﬁcant application requires the</text>
<text top="827" left="54" width="398" height="15" font="1">ability to communicate between the chip and the outside</text>
<text top="847" left="54" width="398" height="15" font="1">world and use more memory than is available locally.</text>
<text top="868" left="54" width="398" height="15" font="1">Manufacturers of FPGAs do provide such communica-</text>
<text top="888" left="54" width="398" height="15" font="1">tion interfaces, but not only do these interfaces need</text>
<text top="908" left="54" width="398" height="15" font="1">to be manually instantiated for each application, but</text>
<text top="929" left="54" width="398" height="15" font="1">the mechanisms used to interact with these interfaces</text>
<text top="949" left="54" width="398" height="15" font="1">varies between device manufacturers, and can even vary</text>
<text top="969" left="54" width="398" height="15" font="1">between diﬀerent devices from the same manufacturer.</text>
<text top="990" left="54" width="398" height="15" font="1">After instantiating these interfaces, the application de-</text>
<text top="1010" left="54" width="398" height="15" font="1">signer must also instantiate a data path that allows data</text>
<text top="1030" left="54" width="398" height="15" font="1">transport to occur, and control logic to ensure that data</text>
<text top="1051" left="54" width="157" height="15" font="1">is sequenced properly.</text>
<text top="1071" left="79" width="372" height="15" font="1">One answer to these issues has emerged in the form</text>
<text top="1091" left="54" width="398" height="15" font="1">of <a href="pdfxml.html#11">CoRAM[3], </a>a proposed design for a standard memory</text>
<text top="181" left="466" width="398" height="15" font="1">architecture for FPGAs. CoRAM provides a standard</text>
<text top="201" left="466" width="398" height="15" font="1">memory interface across device manufacturers, and an</text>
<text top="221" left="466" width="398" height="15" font="1">integrated network on chip for data delivery within the</text>
<text top="242" left="466" width="398" height="15" font="1">reconﬁgurable fabric. Sequencing is performed via con-</text>
<text top="262" left="466" width="398" height="15" font="1">trol threads that the developer can writes using a C-like</text>
<text top="282" left="466" width="398" height="15" font="1">language, which can include overlapping asynchronous</text>
<text top="303" left="466" width="398" height="15" font="1">I/O operations and control ﬂow. CoRAM can be imple-</text>
<text top="323" left="466" width="398" height="15" font="1">mented in hardware within future FPGAs, but can also</text>
<text top="343" left="466" width="398" height="15" font="1">be instantiated as a soft design in current generation</text>
<text top="364" left="466" width="398" height="15" font="1">devices. A paper (to be presented in the 2012 Internal</text>
<text top="384" left="466" width="398" height="15" font="1">Symposium on FPGAs) shows that CoRAM does allow</text>
<text top="404" left="466" width="398" height="15" font="1">the full capabilities of the FPGA to be exploited when</text>
<text top="425" left="466" width="398" height="15" font="1">implemented intrinsically within the device, and that the</text>
<text top="445" left="466" width="398" height="15" font="1">soft version is eﬀective for some workloads, particularly</text>
<text top="465" left="466" width="398" height="15" font="1">for workloads that are not bandwidth or latency lim-</text>
<text top="486" left="466" width="398" height="15" font="1">ited. A question remains as to whether or not CoRAM</text>
<text top="506" left="466" width="398" height="15" font="1">is amenable to full system compilation, and this work is</text>
<text top="526" left="466" width="368" height="15" font="1">intended as a step towards answering this question.</text>
<text top="547" left="492" width="372" height="15" font="1">ISPC is the Intel SPMD Program <a href="pdfxml.html#12">Compiler[10]. </a>Like</text>
<text top="567" left="466" width="398" height="15" font="1">Op<a href="pdfxml.html#12">enCL[11] </a>and CUD<a href="pdfxml.html#12">A[12], </a>it allows users to write loop</text>
<text top="587" left="466" width="398" height="15" font="1">based programs to indicate that loop nests should be</text>
<text top="608" left="466" width="398" height="15" font="1">parallelized in a Single Program Multiple Data (SPMD)</text>
<text top="628" left="466" width="398" height="15" font="1">system. The diﬀerence between ISPC and CUDA and</text>
<text top="648" left="466" width="398" height="15" font="1">OpenCL is that ISPC is intended to be compiled directly</text>
<text top="668" left="466" width="398" height="15" font="1">to Single Instruction Multiple Data (SIMD) processor</text>
<text top="689" left="466" width="398" height="15" font="1">instructions such as Intel’s SSE or AVX. The diﬀerence</text>
<text top="709" left="466" width="398" height="15" font="1">between SPMD and SIMD is that SPMD allows parallel</text>
<text top="729" left="466" width="398" height="15" font="1">instruction lanes to be individually enabled or disabled,</text>
<text top="750" left="466" width="398" height="15" font="1">so some control ﬂow divergence can occur. ISPC is some-</text>
<text top="770" left="466" width="398" height="15" font="1">what simpler than OpenCL or CUDA in that ISPC does</text>
<text top="790" left="466" width="398" height="15" font="1">not contain various levels of local memory like the other</text>
<text top="811" left="466" width="398" height="15" font="1">languages do, and does not contain a concept analogous</text>
<text top="831" left="466" width="398" height="15" font="1">to thread blocks. ISPC is distributed as open source</text>
<text top="851" left="466" width="398" height="15" font="1">LLVM based compiler, which made it attractive as a</text>
<text top="872" left="466" width="214" height="15" font="1">base technology for this work.</text>
<text top="916" left="466" width="10" height="16" font="2">2</text>
<text top="916" left="497" width="123" height="16" font="2">Related Work</text>
<text top="953" left="492" width="372" height="15" font="1">High Level Synthesis is the general name for tech-</text>
<text top="974" left="466" width="398" height="15" font="1">niques to produce a hardware design (for use on an</text>
<text top="994" left="466" width="398" height="15" font="1">FPGA or an ASIC) from a high level description such</text>
<text top="1014" left="466" width="398" height="15" font="1">as a software <a href="pdfxml.html#12">program[7]. </a>A number of systems that at-</text>
<text top="1035" left="466" width="398" height="15" font="1">tempt to provide High Level Synthesis capabilities exist,</text>
<text top="1055" left="466" width="334" height="15" font="1">but all existing systems have some limitations.</text>
<text top="1075" left="492" width="386" height="15" font="1"><a href="pdfxml.html#12">AutoESL[13] </a>is a commercial system that is distributed</text>
<text top="1096" left="466" width="398" height="15" font="1">by Xilinx, which also produces FPGA devices. It con-</text>
<text top="1140" left="455" width="8" height="15" font="1">1</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
<text top="86" left="54" width="398" height="15" font="1">verts C code to a state machine that is either compiled to</text>
<text top="106" left="54" width="398" height="15" font="1">a ﬁnite state machine or run on an embedded micropro-</text>
<text top="127" left="54" width="398" height="15" font="1">cessor. This tool does require some manual restructuring</text>
<text top="147" left="54" width="398" height="15" font="1">of the code, particularly if oﬀ chip memory is to be used,</text>
<text top="167" left="54" width="398" height="15" font="1">and does not attempt to automatically generate parallel</text>
<text top="188" left="54" width="398" height="15" font="1">implementations of the provided software, although it</text>
<text top="208" left="54" width="398" height="15" font="1">does allow the user to annotate the code to allow it to</text>
<text top="228" left="54" width="117" height="15" font="1">be pip<a href="pdfxml.html#12">elined[14].</a></text>
<text top="249" left="79" width="372" height="15" font="1">Altera’s C2H workﬂo<a href="pdfxml.html#12">w[15] </a>also enables compilation</text>
<text top="269" left="54" width="398" height="15" font="1">of some parts of a C program to Altera’s FPGA parts.</text>
<text top="289" left="54" width="398" height="15" font="1">It is not intended for whole program parallelism, and</text>
<text top="310" left="54" width="398" height="15" font="1">while it can schedule parts of the code that it compiles</text>
<text top="330" left="54" width="398" height="15" font="1">to run in parallel, enabling parallel computation is not</text>
<text top="350" left="54" width="175" height="15" font="1">the goal of the compiler.</text>
<text top="371" left="79" width="372" height="15" font="1">LegUp <a href="pdfxml.html#11">[2] </a>is a recently developed system for whole</text>
<text top="391" left="54" width="398" height="15" font="1">program compilation to FPGA. It is designed to be ﬂex-</text>
<text top="411" left="54" width="398" height="15" font="1">ible and support a large subset of the C language, but</text>
<text top="432" left="54" width="398" height="15" font="1">does not produce highly pipelined or parallel programs,</text>
<text top="452" left="54" width="324" height="15" font="1">nor does it support ﬂoating point operations.</text>
<text top="472" left="79" width="372" height="15" font="1">ROCCC <a href="pdfxml.html#12">[16] </a>is an open source product that can pro-</text>
<text top="493" left="54" width="398" height="15" font="1">duce highly pipelined compute kernels from C source,</text>
<text top="513" left="54" width="398" height="15" font="1">and does include support for ﬂoating point operations,</text>
<text top="533" left="54" width="398" height="15" font="1">but includes very limited support for control ﬂow, and</text>
<text top="554" left="54" width="398" height="15" font="1">does not support accessing memory, although it can cre-</text>
<text top="574" left="54" width="232" height="15" font="1">ate address generation hardware</text>
<text top="594" left="79" width="372" height="15" font="1">BlueSpec <a href="pdfxml.html#12">[17] </a>is a Haskell-derived language that com-</text>
<text top="615" left="54" width="398" height="15" font="1">piles to Verilog code. This code is typically not a com-</text>
<text top="635" left="54" width="402" height="15" font="1">plete system, but consists of modules that are used within</text>
<text top="655" left="54" width="398" height="15" font="1">a larger design. While BlueSpec is easier to write than</text>
<text top="675" left="54" width="398" height="15" font="1">typical hardware design languages, it is a functional lan-</text>
<text top="696" left="54" width="297" height="15" font="1">guage that can be daunting to new users.</text>
<text top="716" left="79" width="372" height="15" font="1">FCUD<a href="pdfxml.html#12">A[8] </a>is system to allow programs written in</text>
<text top="736" left="54" width="398" height="15" font="1">CUDA to be compiled to an FPGA. While it does pro-</text>
<text top="757" left="54" width="398" height="15" font="1">duce a functional system, it does require that application</text>
<text top="777" left="54" width="398" height="15" font="1">developers annotate their code to indicate exactly how</text>
<text top="797" left="54" width="290" height="15" font="1">it should be implemented on the FPGA.</text>
<text top="818" left="79" width="372" height="15" font="1">OpenMP is a framework for parallel programming</text>
<text top="838" left="54" width="398" height="15" font="1">that allows loops to be annotated to indicate how paral-</text>
<text top="858" left="54" width="398" height="15" font="1">lelism occurs. A project from the Barcelona Supercom-</text>
<text top="879" left="54" width="398" height="15" font="1">puter Cen<a href="pdfxml.html#11">ter[1] </a>did seek to target FPGAs from OpenMP</text>
<text top="899" left="54" width="398" height="15" font="1">programs, but like FCUDA required the programmer to</text>
<text top="919" left="54" width="398" height="15" font="1">be extremely explicit in how the kernels are described</text>
<text top="940" left="54" width="398" height="15" font="1">and how data is transferred. A project from the Na-</text>
<text top="960" left="54" width="398" height="15" font="1">tional University of Singap<a href="pdfxml.html#12">ore[6] </a>had similar goals, but</text>
<text top="980" left="54" width="398" height="15" font="1">did not appear do anything to handle data marshaling</text>
<text top="1001" left="54" width="398" height="15" font="1">between the FPGA and oﬀ chip memory - it appeared</text>
<text top="1021" left="54" width="348" height="15" font="1">to focus solely on programs that generated data.</text>
<text top="1041" left="79" width="372" height="15" font="1">It appears that Altera is working on mechanisms to</text>
<text top="1062" left="54" width="398" height="15" font="1">compile OpenCL code to the <a href="pdfxml.html#12">FPGA[18]</a>, but no oﬃcial</text>
<text top="1082" left="54" width="318" height="15" font="1">information has been published at this time.</text>
<text top="325" left="506" width="318" height="15" font="1">Figure 1: Compilation Workﬂow Illustration</text>
<text top="373" left="466" width="10" height="16" font="2">3</text>
<text top="373" left="497" width="199" height="16" font="2">Flow and Architecture</text>
<text top="411" left="492" width="372" height="15" font="1">The general approach taken during the implementa-</text>
<text top="431" left="466" width="398" height="15" font="1">tion of this work was to leverage the CoRAM framework</text>
<text top="451" left="466" width="398" height="15" font="1">and an existing research project that seeks to compile a</text>
<text top="472" left="466" width="398" height="15" font="1">subset of programs that can be converted to LLVM byte</text>
<text top="492" left="466" width="398" height="15" font="1">code to FPGA systems. The hope was that the con-</text>
<text top="512" left="466" width="398" height="15" font="1">structs provided by the ISPC language would make it</text>
<text top="533" left="466" width="398" height="15" font="1">easier to produce parallel systems, since ISPC program</text>
<text top="553" left="466" width="398" height="15" font="1">are somewhat more limited than C programs, and par-</text>
<text top="573" left="466" width="398" height="15" font="1">allelism is explicitly annotated by the application devel-</text>
<text top="593" left="466" width="398" height="15" font="1">oper. The intent is to target the current soft implemen-</text>
<text top="614" left="466" width="398" height="15" font="1">tation of CoRAM, which can implement complete sys-</text>
<text top="634" left="466" width="398" height="15" font="1">tems on current generation FPGA devices. An overview</text>
<text top="654" left="466" width="398" height="15" font="1">of the compilation workﬂow is illustrated in ﬁgure <a href="pdfxml.html#2">1.</a></text>
<text top="675" left="466" width="320" height="15" font="1">The steps performed during compilation are:</text>
<text top="709" left="486" width="209" height="15" font="1">1. Compile the ISPC module</text>
<text top="742" left="486" width="301" height="15" font="1">2. Post-process the ISPC compiler output</text>
<text top="776" left="486" width="378" height="15" font="1">3. Partition the program into control threads and ker-</text>
<text top="796" left="507" width="101" height="15" font="1">nel operations</text>
<text top="830" left="486" width="212" height="15" font="1">4. Generate hardware kernels</text>
<text top="864" left="486" width="223" height="15" font="1">5. Generate a top level module</text>
<text top="898" left="486" width="240" height="15" font="1">6. Generate the hardware system</text>
<text top="942" left="466" width="10" height="16" font="2">4</text>
<text top="942" left="497" width="139" height="16" font="2">Implementation</text>
<text top="980" left="492" width="372" height="15" font="1">A detailed description of each step and how it is im-</text>
<text top="1000" left="466" width="131" height="15" font="1">plemented follows.</text>
<text top="1043" left="466" width="26" height="16" font="2">4.1</text>
<text top="1043" left="512" width="246" height="16" font="2">ISPC Program Compilation</text>
<text top="1075" left="492" width="372" height="15" font="1">The ﬁrst step in the process is to compile the ISPC</text>
<text top="1095" left="466" width="398" height="15" font="1">module. Full ISPC programs consist of two parts: an</text>
<text top="1140" left="455" width="8" height="15" font="1">2</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
<text top="86" left="54" width="398" height="15" font="1">ISPC module and a C module. The ISPC module con-</text>
<text top="106" left="54" width="398" height="15" font="1">tains all of the ISPC code to be executed, which are</text>
<text top="127" left="54" width="398" height="15" font="1">exported to the rest of the system by generating an ob-</text>
<text top="147" left="54" width="398" height="15" font="1">ject ﬁle and a C style header ﬁle. The object ﬁle follows</text>
<text top="167" left="54" width="398" height="15" font="1">the standard calling conventions of the operating system</text>
<text top="188" left="54" width="398" height="15" font="1">being used, allowing the the code to be linked like any</text>
<text top="208" left="54" width="288" height="15" font="1">other object ﬁle using a standard linker.</text>
<text top="228" left="79" width="372" height="15" font="1">As ISPC was intended to produce SIMD code, an</text>
<text top="249" left="54" width="398" height="15" font="1">intrinsic part of the code generator within it handles</text>
<text top="269" left="54" width="398" height="15" font="1">tracking lane masks to allow execution of SPMD pro-</text>
<text top="289" left="54" width="398" height="15" font="1">grams. ISPC natively supports Intel’s SSE2, SSE4, and</text>
<text top="310" left="54" width="398" height="15" font="1">AVX extensions to the x86 instruction set. The origi-</text>
<text top="330" left="54" width="398" height="15" font="1">nal plan was to use the stock ISPC compiler, possibly</text>
<text top="350" left="54" width="398" height="15" font="1">hooking into its parsing mechanisms to determine how</text>
<text top="371" left="54" width="398" height="15" font="1">the program was annotated for parallelism, and use its</text>
<text top="391" left="54" width="398" height="15" font="1">LLVM byte code output with the CoRAMify partition-</text>
<text top="411" left="54" width="398" height="15" font="1">ing pass and CoRAM Compiler system generation pass.</text>
<text top="432" left="79" width="372" height="15" font="1">This tasks turned out to be more diﬃcult than antic-</text>
<text top="452" left="54" width="398" height="15" font="1">ipated. The ﬁrst diﬃculty was that the current release of</text>
<text top="472" left="54" width="398" height="15" font="1">ISPC is designed for LLVM 2.9, while the CoRAM passes</text>
<text top="493" left="54" width="398" height="15" font="1">use LLVM 2.8. LLVM 2.9 is the current version of the</text>
<text top="513" left="54" width="398" height="15" font="1">LLVM compiler, although version 3.0 is scheduled to be</text>
<text top="533" left="54" width="398" height="15" font="1">released shortly. Version 2.9 LLVM byte code cannot be</text>
<text top="554" left="54" width="398" height="15" font="1">read by version 2.8 passes due to format diﬀerences in</text>
<text top="574" left="54" width="398" height="15" font="1">both the binary and assembly ﬁle formats. An attempt</text>
<text top="594" left="54" width="398" height="15" font="1">was made to port the two CoRAM passes to version 2.9,</text>
<text top="615" left="54" width="398" height="15" font="1">but diﬃculties in this conversion made it more feasible</text>
<text top="635" left="54" width="398" height="15" font="1">to back port ISPC to version 2.8. The ISPC documen-</text>
<text top="655" left="54" width="398" height="15" font="1">tation did mention that LLVM 2.8 had diﬃculties with</text>
<text top="675" left="54" width="398" height="15" font="1">the vector instructions that it produced, but since the</text>
<text top="696" left="54" width="398" height="15" font="1">ultimate intent was not to use vector instructions these</text>
<text top="716" left="54" width="281" height="15" font="1">diﬃculties were deemed not important.</text>
<text top="736" left="79" width="372" height="15" font="1">The next issue encountered was with the output tar-</text>
<text top="757" left="54" width="398" height="15" font="1">gets supported by ISPC. The intent was to have ISPC</text>
<text top="777" left="54" width="398" height="15" font="1">produce scalar ﬁles and retain the annotations that indi-</text>
<text top="797" left="54" width="398" height="15" font="1">cated parallelism. This was required because the hard-</text>
<text top="818" left="54" width="398" height="15" font="1">ware kernels are generated using the R<a href="pdfxml.html#12">OCCC[16] </a>com-</text>
<text top="838" left="54" width="398" height="15" font="1">piler, which requires using LLVM’s C back end to pro-</text>
<text top="858" left="54" width="398" height="15" font="1">duce code to use with it. The C back end does not sup-</text>
<text top="879" left="54" width="398" height="15" font="1">port vector operations. Unfortunately, ISPC only sup-</text>
<text top="899" left="54" width="398" height="15" font="1">ports vector output. One diﬃculty in making ISPC sup-</text>
<text top="919" left="54" width="398" height="15" font="1">port scalar output is that the idea of tracking and using</text>
<text top="940" left="54" width="398" height="15" font="1">lane enable masks is pervasive to the ISPC code genera-</text>
<text top="960" left="54" width="398" height="15" font="1">tor, and it appeared that removing the lane mask would</text>
<text top="980" left="54" width="398" height="15" font="1">require largely rewriting the several thousand lines of</text>
<text top="1001" left="54" width="398" height="15" font="1">ISPC’s code generator. Since code generation can be</text>
<text top="1021" left="54" width="398" height="15" font="1">complicated, and ISPC code generation was based upon</text>
<text top="1041" left="54" width="398" height="15" font="1">an abstract syntax tree that was not thoroughly docu-</text>
<text top="1062" left="54" width="398" height="15" font="1">mented, a new ISPC target was created to enable gen-</text>
<text top="1082" left="54" width="398" height="15" font="1">erating scalar code. As previously mentioned, it was in-</text>
<text top="86" left="466" width="398" height="15" font="1">feasible to directly generate scalar code, so the approach</text>
<text top="106" left="466" width="398" height="15" font="1">taken was to generate 1-wide vector code instead, and</text>
<text top="127" left="466" width="398" height="15" font="1">convert this code to scalar code downstream in the work-</text>
<text top="147" left="466" width="33" height="15" font="1">ﬂow.</text>
<text top="167" left="492" width="395" height="15" font="1">Creating the 1-wide vector target was relatively straight-</text>
<text top="188" left="466" width="398" height="15" font="1">forward, although it was necessary to implement ISPC’s</text>
<text top="208" left="466" width="398" height="15" font="1">standard library for 1-wide vectors. This library consists</text>
<text top="228" left="466" width="398" height="15" font="1">of LLVM assembly code that implements load, store,</text>
<text top="249" left="466" width="398" height="15" font="1">permutation, and mathematical operations. The math-</text>
<text top="269" left="466" width="398" height="15" font="1">ematical operations were required because the goal was</text>
<text top="289" left="466" width="398" height="15" font="1">to support programs that include ﬂoating point compu-</text>
<text top="310" left="466" width="398" height="15" font="1">tations, and ISPC programs cannot link to the standard</text>
<text top="330" left="466" width="398" height="15" font="1">math library. LLVM does support ﬂoating point intrin-</text>
<text top="350" left="466" width="398" height="15" font="1">sics, so it was possible to implement the ﬂoating point</text>
<text top="371" left="466" width="265" height="15" font="1">operations by calling these intrinsics.</text>
<text top="391" left="492" width="372" height="15" font="1">One other minor complication is that by default,</text>
<text top="411" left="466" width="398" height="15" font="1">ISPC generates both an exportable version of the main</text>
<text top="432" left="466" width="398" height="15" font="1">function to be called and an internal version, which takes</text>
<text top="452" left="466" width="398" height="15" font="1">a lane mask as a parameter, and contains mangled func-</text>
<text top="472" left="466" width="398" height="15" font="1">tion and variable names. ISPC was modiﬁed to suppress</text>
<text top="493" left="466" width="398" height="15" font="1">generation of the internal version of the exported func-</text>
<text top="513" left="466" width="33" height="15" font="1">tion.</text>
<text top="556" left="466" width="26" height="16" font="2">4.2</text>
<text top="556" left="512" width="193" height="16" font="2">ISPC Post Processing</text>
<text top="588" left="492" width="372" height="15" font="1">The second step in the process is post processing the</text>
<text top="608" left="466" width="398" height="15" font="1">byte code produced by ISPC. Standard LLVM passes</text>
<text top="628" left="466" width="398" height="15" font="1">are used to convert the byte code to Single Static As-</text>
<text top="649" left="466" width="398" height="15" font="1">signment (SSA) form, to remove dead code, to move</text>
<text top="669" left="466" width="398" height="15" font="1">loop invariant code out of the loop that contains it, and</text>
<text top="689" left="466" width="398" height="15" font="1">to perform other optimizations. It was hoped that the</text>
<text top="709" left="466" width="398" height="15" font="1">standard LLVM passes would be able to completely re-</text>
<text top="730" left="466" width="398" height="15" font="1">move the lane masks which do not do anything on 1-wide</text>
<text top="750" left="466" width="398" height="15" font="1">vectors, but this turned out not to be the case. In most</text>
<text top="770" left="466" width="398" height="15" font="1">cases, this is not an issue, but it did turn out to be a</text>
<text top="791" left="466" width="271" height="15" font="1">problem for one attempted work ﬂow.</text>
<text top="811" left="492" width="378" height="15" font="1">After using LLVM standard passes, two custom passes</text>
<text top="831" left="466" width="398" height="15" font="1">are used prior to the CoRAMify partitioning pass. The</text>
<text top="852" left="466" width="398" height="15" font="1">ﬁrst pass is a devectorization pass. The previous section</text>
<text top="872" left="466" width="398" height="15" font="1">described how it was necessary to generate 1-wide vec-</text>
<text top="892" left="466" width="398" height="15" font="1">tor code rather than scalar code. The devectorization</text>
<text top="913" left="466" width="398" height="15" font="1">pass converts the 1-wide vector code into scalar code. It</text>
<text top="933" left="466" width="398" height="15" font="1">traces through every instruction, tracking which instruc-</text>
<text top="953" left="466" width="398" height="15" font="1">tions are vector instructions. Vector loads are replaced</text>
<text top="974" left="466" width="398" height="15" font="1">by scalar loads of the same data, and every subsequent</text>
<text top="994" left="466" width="398" height="15" font="1">instruction that uses vectors is replaced by an iden-</text>
<text top="1014" left="466" width="398" height="15" font="1">tical scalar instruction using the corresponding scalar</text>
<text top="1035" left="466" width="402" height="15" font="1">operands. LLVM provides user instructions, which makes</text>
<text top="1055" left="466" width="398" height="15" font="1">it easy to trace through instructions as they are devec-</text>
<text top="1075" left="466" width="398" height="15" font="1">torized up until data is stored back to memory. The one</text>
<text top="1096" left="466" width="398" height="15" font="1">complicated instructions are Phi nodes, since they in-</text>
<text top="1140" left="455" width="8" height="15" font="1">3</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
<text top="86" left="54" width="398" height="15" font="1">troduce circular use patterns, and these are resolved by</text>
<text top="106" left="54" width="398" height="15" font="1">creating fake instructions when Phi nodes are ﬁrst en-</text>
<text top="127" left="54" width="398" height="15" font="1">countered and cleaning them up after all other instruc-</text>
<text top="147" left="54" width="189" height="15" font="1">tions have been processed.</text>
<text top="167" left="79" width="372" height="15" font="1">The second custom post processing pass is a de-</text>
<text top="188" left="54" width="398" height="15" font="1">casting pass. Since ISPC uses a standard library to pro-</text>
<text top="208" left="54" width="398" height="15" font="1">cess various instruction types, there are many instances</text>
<text top="228" left="54" width="398" height="15" font="1">in which pointers are cast from their native types to</text>
<text top="249" left="54" width="398" height="15" font="1">generic void pointers to integer pointers, and then the</text>
<text top="269" left="54" width="398" height="15" font="1">data is cast back to the original type. These casts don’t</text>
<text top="289" left="54" width="398" height="15" font="1">incur a run-time overhead as they don’t actually do any-</text>
<text top="310" left="54" width="398" height="15" font="1">thing, but can potentially confuse later analysis passes.</text>
<text top="330" left="54" width="398" height="15" font="1">The de-casting pass traces through all cast instructions,</text>
<text top="350" left="54" width="376" height="15" font="1">and removes any cast-recast operations that it ﬁnds.</text>
<text top="393" left="54" width="26" height="16" font="2">4.3</text>
<text top="393" left="100" width="142" height="16" font="2">CoRAMify Pass</text>
<text top="425" left="79" width="372" height="15" font="1">The CoRAMify pass is responsible for analyzing the</text>
<text top="445" left="54" width="398" height="15" font="1">program and partitioning it into kernel operations, which</text>
<text top="466" left="54" width="398" height="15" font="1">as previously mentioned are converted to hardware us-</text>
<text top="486" left="54" width="398" height="15" font="1">ing a package called ROCCC, and all other operations,</text>
<text top="506" left="54" width="410" height="15" font="1">which are converted into multiple CoRAM control threads.</text>
<text top="527" left="54" width="207" height="15" font="1">The pass operates as follows:</text>
<text top="560" left="74" width="378" height="15" font="1">1. Instructions are traced to determine if they are</text>
<text top="581" left="95" width="364" height="15" font="1">data instructions, control ﬂow instructions, or mem-</text>
<text top="601" left="95" width="357" height="15" font="1">ory instructions. Memory instructions are used as</text>
<text top="621" left="95" width="357" height="15" font="1">addresses, control ﬂow instructions are branch in-</text>
<text top="642" left="95" width="357" height="15" font="1">structions or instructions that inﬂuence branch in-</text>
<text top="662" left="95" width="357" height="15" font="1">structions (such as comparison instructions), and</text>
<text top="682" left="95" width="357" height="15" font="1">data instructions are instructions whose results are</text>
<text top="703" left="95" width="209" height="15" font="1">ultimately stored to memory.</text>
<text top="736" left="74" width="378" height="15" font="1">2. Memory instructions are relocated - load instruc-</text>
<text top="757" left="95" width="357" height="15" font="1">tions are moved as early as possible and store in-</text>
<text top="777" left="95" width="357" height="15" font="1">structions are moved as late as possible. Instruc-</text>
<text top="797" left="95" width="357" height="15" font="1">tions that calculate memory addresses are grouped</text>
<text top="818" left="95" width="323" height="15" font="1">with the memory instructions that use them.</text>
<text top="852" left="74" width="378" height="15" font="1">3. The data instructions are moved into a new func-</text>
<text top="872" left="95" width="357" height="15" font="1">tion, which is later converted to C for use with</text>
<text top="892" left="95" width="64" height="15" font="1">ROCCC.</text>
<text top="926" left="74" width="401" height="15" font="1">4. Constants such as memory addresses and loop bounds,</text>
<text top="946" left="95" width="357" height="15" font="1">which are passed to the CoRAMify pass, replace</text>
<text top="967" left="95" width="357" height="15" font="1">parameters to the function that is being converted</text>
<text top="987" left="95" width="280" height="15" font="1">and global values used by the function.</text>
<text top="1021" left="74" width="378" height="15" font="1">5. Each input or output to the new function is con-</text>
<text top="1041" left="95" width="357" height="15" font="1">verted into its own stream. The original function</text>
<text top="1061" left="95" width="357" height="15" font="1">is then broken up into multiple functions, one for</text>
<text top="1082" left="95" width="357" height="15" font="1">each stream. This makes it easier to reorder loops</text>
<text top="86" left="507" width="357" height="15" font="1">and perform other operations on the code without</text>
<text top="106" left="507" width="282" height="15" font="1">worrying about unintended side eﬀects.</text>
<text top="140" left="486" width="378" height="15" font="1">6. The loop nests for each function are analyzed to</text>
<text top="161" left="507" width="357" height="15" font="1">determine how the memory accesses in each stream</text>
<text top="181" left="507" width="357" height="15" font="1">at that loop nest. At this point, accumulations,</text>
<text top="201" left="507" width="357" height="15" font="1">where a variable is both read and written, are in-</text>
<text top="221" left="507" width="357" height="15" font="1">ferred. LLVM’s Scalar Evolution Analysis frame-</text>
<text top="242" left="507" width="357" height="15" font="1">work is used to perform this analysis, although</text>
<text top="262" left="507" width="357" height="15" font="1">much work went into supplementing the informa-</text>
<text top="282" left="507" width="149" height="15" font="1">tion that it provides.</text>
<text top="316" left="486" width="378" height="15" font="1">7. If there is an accumulation, and that accumulation</text>
<text top="337" left="507" width="357" height="15" font="1">happens in an inner loop nest which would pre-</text>
<text top="357" left="507" width="357" height="15" font="1">vent the application from exploiting parallelism,</text>
<text top="377" left="507" width="357" height="15" font="1">then the loops are re-ordered, and stream accesses</text>
<text top="398" left="507" width="364" height="15" font="1">rewritten, for all functions. It is necessary to rewrite</text>
<text top="418" left="507" width="357" height="15" font="1">all of the functions at this time to ensure that the</text>
<text top="438" left="507" width="351" height="15" font="1">correct data is delivered to the hardware kernels.</text>
<text top="472" left="486" width="378" height="15" font="1">8. Each stream is processed to determine what mem-</text>
<text top="492" left="507" width="357" height="15" font="1">ory access patterns it exhibits in order to group</text>
<text top="513" left="507" width="366" height="15" font="1">memory accesses into larger blocks and reduce mem-</text>
<text top="533" left="507" width="212" height="15" font="1">ory bandwidth requirements.</text>
<text top="533" left="735" width="129" height="15" font="1">In particular, the</text>
<text top="553" left="507" width="357" height="15" font="1">CoRAMify pass looks for sequential accesses, re-</text>
<text top="574" left="507" width="357" height="15" font="1">peated accesses, and places where arrays may need</text>
<text top="594" left="507" width="129" height="15" font="1">to be transposed.</text>
<text top="594" left="653" width="211" height="15" font="1">Sequential accesses are com-</text>
<text top="614" left="507" width="235" height="15" font="1">bined into a single, larger access.</text>
<text top="648" left="486" width="378" height="15" font="1">9. The system detects how many compute kernels to</text>
<text top="668" left="507" width="357" height="15" font="1">instantiate. The number of kernels that is instan-</text>
<text top="689" left="507" width="357" height="15" font="1">tiated depends on the amount of parallelism found</text>
<text top="709" left="507" width="357" height="15" font="1">and a maximum number of kernels that is speciﬁed</text>
<text top="729" left="507" width="214" height="15" font="1">as a parameter to the system.</text>
<text top="763" left="478" width="386" height="15" font="1">10. The system instantiates CoRAM streams, and con-</text>
<text top="783" left="507" width="357" height="15" font="1">verts all memory reads and writes in the control</text>
<text top="804" left="507" width="206" height="15" font="1">threads to stream operations</text>
<text top="837" left="478" width="386" height="15" font="1">11. The descriptor ﬁle containing information about</text>
<text top="858" left="507" width="357" height="15" font="1">the CoRAM streams is created, which is used to</text>
<text top="878" left="507" width="217" height="15" font="1">generate the top level module.</text>
<text top="935" left="466" width="39" height="15" font="1">4.3.1</text>
<text top="935" left="524" width="177" height="15" font="1">Partitioning Example</text>
<text top="966" left="492" width="372" height="15" font="1">As a concrete illustration of how the partitioning</text>
<text top="986" left="466" width="398" height="15" font="1">pass works, Listing <a href="pdfxml.html#5">1 </a>contains the complete source code</text>
<text top="1006" left="466" width="398" height="15" font="1">for an ISPC implementation of a blocked matrix matrix</text>
<text top="1027" left="466" width="398" height="15" font="1">multiply, and is in fact the exact ISPC source code used</text>
<text top="1047" left="466" width="398" height="15" font="1">by the matrix-matrix multiply test case. The function</text>
<text top="1067" left="466" width="398" height="15" font="1">is decorated with the ”export” keyword, indicating that</text>
<text top="1088" left="466" width="398" height="15" font="1">this function is meant to be called by the main program,</text>
<text top="1140" left="455" width="8" height="15" font="1">4</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="3" size="11" family="Times" color="#000000"/>
<text top="87" left="67" width="245" height="12" font="3">1 e x p o r t v o i d mmm ispc ( u n i f o r m</text>
<text top="87" left="324" width="78" height="12" font="3">f l o a t A [ ] ,</text>
<text top="104" left="112" width="55" height="12" font="3">u n i f o r m</text>
<text top="104" left="180" width="78" height="12" font="3">f l o a t B [ ] ,</text>
<text top="104" left="270" width="55" height="12" font="3">u n i f o r m</text>
<text top="104" left="337" width="78" height="12" font="3">f l o a t C [ ] ,</text>
<text top="120" left="112" width="88" height="12" font="3">u n i f o r m i n t</text>
<text top="120" left="212" width="129" height="12" font="3">s i z e , u n i f o r m i n t</text>
<text top="120" left="354" width="97" height="12" font="3">b l o c k s i z e ) {</text>
<text top="137" left="67" width="7" height="12" font="3">2</text>
<text top="137" left="100" width="120" height="12" font="3">f o r ( u n i f o r m i n t</text>
<text top="137" left="232" width="212" height="12" font="3">i 0 =0; i 0 &lt;s i z e ; i 0+=b l o c k s i z e</text>
<text top="153" left="129" width="23" height="12" font="3">) {</text>
<text top="170" left="67" width="7" height="12" font="3">3</text>
<text top="170" left="116" width="120" height="12" font="3">f o r ( u n i f o r m i n t</text>
<text top="170" left="249" width="141" height="12" font="3">j 0 =0; j 0 &lt;s i z e ; j 0+=</text>
<text top="186" left="146" width="97" height="12" font="3">b l o c k s i z e ) {</text>
<text top="202" left="67" width="7" height="12" font="3">4</text>
<text top="202" left="133" width="273" height="12" font="3">f o r ( u n i f o r m i n t k0 =0; k0&lt;s i z e ; k0+=</text>
<text top="219" left="163" width="97" height="12" font="3">b l o c k s i z e ) {</text>
<text top="235" left="67" width="7" height="12" font="3">5</text>
<text top="235" left="149" width="129" height="12" font="3">f o r ( u n i f o r m i n t</text>
<text top="235" left="290" width="145" height="12" font="3">i 1 =0; i 1 &lt;b l o c k s i z e ;</text>
<text top="252" left="179" width="55" height="12" font="3">i 1 ++) {</text>
<text top="268" left="67" width="7" height="12" font="3">6</text>
<text top="268" left="165" width="88" height="12" font="3">u n i f o r m i n t</text>
<text top="268" left="266" width="62" height="12" font="3">i=i 0+i 1 ;</text>
<text top="285" left="67" width="7" height="12" font="3">7</text>
<text top="285" left="166" width="120" height="12" font="3">f o r ( u n i f o r m i n t</text>
<text top="285" left="299" width="145" height="12" font="3">j c =0; j c &lt;b l o c k s i z e ;</text>
<text top="301" left="196" width="155" height="12" font="3">j c+=programCount ) {</text>
<text top="317" left="67" width="7" height="12" font="3">8</text>
<text top="317" left="183" width="21" height="12" font="3">i n t</text>
<text top="317" left="216" width="170" height="12" font="3">j=j 0+j c+programIndex ;</text>
<text top="334" left="67" width="7" height="12" font="3">9</text>
<text top="334" left="183" width="198" height="12" font="3">f o r ( u n i f o r m i n t k1 =0; k1&lt;</text>
<text top="350" left="213" width="138" height="12" font="3">b l o c k s i z e ; k1++) {</text>
<text top="367" left="60" width="14" height="12" font="3">10</text>
<text top="367" left="198" width="162" height="12" font="3">u n i f o r m i n t k=k0+k1 ;</text>
<text top="383" left="60" width="14" height="12" font="3">11</text>
<text top="383" left="196" width="241" height="12" font="3">C [ i ∗ s i z e+j ]+=A [ i ∗ s i z e+k ] ∗ B [ k∗</text>
<text top="400" left="229" width="61" height="12" font="3">s i z e+j ] ;</text>
<text top="416" left="60" width="14" height="12" font="3">12</text>
<text top="415" left="190" width="7" height="13" font="3">}</text>
<text top="433" left="60" width="14" height="12" font="3">13</text>
<text top="432" left="165" width="7" height="13" font="3">}</text>
<text top="449" left="60" width="14" height="12" font="3">14</text>
<text top="448" left="148" width="7" height="13" font="3">}</text>
<text top="465" left="60" width="14" height="12" font="3">15</text>
<text top="465" left="131" width="7" height="13" font="3">}</text>
<text top="482" left="60" width="14" height="12" font="3">16</text>
<text top="481" left="115" width="7" height="13" font="3">}</text>
<text top="498" left="60" width="14" height="12" font="3">17</text>
<text top="498" left="98" width="7" height="13" font="3">}</text>
<text top="515" left="60" width="29" height="12" font="3">18 }</text>
<text top="542" left="54" width="398" height="15" font="1">Listing 1: ISPC source code for a blocked matrix matrix</text>
<text top="563" left="54" width="60" height="15" font="1">multiply</text>
<text top="624" left="54" width="398" height="15" font="1">which will cause ISPC to include its declaration in the</text>
<text top="645" left="54" width="398" height="15" font="1">header ﬁle that it creates. The function takes parame-</text>
<text top="665" left="54" width="398" height="15" font="1">ters for the a and b input arrays, and the c output array.</text>
<text top="685" left="54" width="398" height="15" font="1">The output array is assumed to be zero-initialized in this</text>
<text top="706" left="54" width="398" height="15" font="1">implementation. Parameters also indicate the size of the</text>
<text top="726" left="54" width="398" height="15" font="1">arrays an the desired block size - so a diﬀerent block size</text>
<text top="746" left="54" width="398" height="15" font="1">can be implemented by simply changing this parameter.</text>
<text top="767" left="79" width="372" height="15" font="1">This implementation is almost exactly the same as</text>
<text top="787" left="54" width="398" height="15" font="1">a canonical implementation of a blocked matrix-matrix</text>
<text top="807" left="54" width="350" height="15" font="1">multiply in C. There are a few minor diﬀerences:</text>
<text top="839" left="74" width="378" height="15" font="1">1. The parameters to the function, and all loop iter-</text>
<text top="859" left="95" width="357" height="15" font="1">ation variables except for the loop on line 7, are</text>
<text top="880" left="95" width="357" height="15" font="1">decorated with the ”uniform” keyword. This indi-</text>
<text top="900" left="95" width="357" height="15" font="1">cates that these variables take the same value in</text>
<text top="920" left="95" width="136" height="15" font="1">all execution lanes.</text>
<text top="953" left="74" width="378" height="15" font="1">2. The loop starting on line 7 is incremented by ”pro-</text>
<text top="974" left="95" width="357" height="15" font="1">gramCount” rather than 1, and the actual variable</text>
<text top="994" left="95" width="357" height="15" font="1">used for computation is the sum of that variable</text>
<text top="1014" left="95" width="357" height="15" font="1">and ”programIndex”. These indicate that these</text>
<text top="1035" left="95" width="357" height="15" font="1">variables will be used by diﬀerent execution lanes,</text>
<text top="1055" left="95" width="357" height="15" font="1">and in particular each execution lane has a unique</text>
<text top="1075" left="95" width="357" height="15" font="1">”programIndex” variable, which is a number be-</text>
<text top="1096" left="95" width="263" height="15" font="1">tween 0 and the number of lanes - 1.</text>
<text top="86" left="486" width="378" height="15" font="1">3. This particular implementation assumes that both</text>
<text top="106" left="507" width="357" height="15" font="1">the matrices themselves and the blocks are square,</text>
<text top="127" left="507" width="334" height="15" font="1">although nothing in the compiler requires this.</text>
<text top="160" left="466" width="303" height="15" font="1">The analysis of the code occurs as follows:</text>
<text top="193" left="486" width="378" height="15" font="1">1. The code in line 11 is identiﬁed as the kernel code.</text>
<text top="213" left="507" width="357" height="15" font="1">Line 11 actually consists of a number of operations</text>
<text top="233" left="507" width="357" height="15" font="1">- four address calculations, three loads, one store,</text>
<text top="254" left="507" width="357" height="15" font="1">and one ﬂoating point multiply and one ﬂoating</text>
<text top="274" left="507" width="74" height="15" font="1">point add.</text>
<text top="307" left="486" width="378" height="15" font="1">2. The loads and associated address operations are</text>
<text top="328" left="507" width="357" height="15" font="1">moved to the top of the basic block containing the</text>
<text top="348" left="507" width="357" height="15" font="1">loop body, and the store and its address operations</text>
<text top="368" left="507" width="273" height="15" font="1">are moved to the bottom of this block</text>
<text top="402" left="486" width="378" height="15" font="1">3. The ﬂoating point multiply and add are moved</text>
<text top="422" left="507" width="357" height="15" font="1">into a separate function. This function is actually</text>
<text top="442" left="507" width="357" height="15" font="1">implemented in such a way that addresses for the</text>
<text top="463" left="507" width="312" height="15" font="1">input and output variables are passed to it.</text>
<text top="496" left="486" width="378" height="15" font="1">4. The main function mmm ispc is replaced by a ver-</text>
<text top="517" left="507" width="357" height="15" font="1">sion that takes no parameters, and expects A, B,</text>
<text top="537" left="507" width="357" height="15" font="1">C, size, and block size to be global variables. These</text>
<text top="557" left="507" width="357" height="15" font="1">global variables are then placed with the values</text>
<text top="578" left="507" width="357" height="15" font="1">provided to the compiler. It is important to note</text>
<text top="598" left="507" width="357" height="15" font="1">that the user is required to provide values for these</text>
<text top="618" left="507" width="357" height="15" font="1">variables at compile time in order for the compiler</text>
<text top="638" left="507" width="126" height="15" font="1">to work correctly.</text>
<text top="672" left="486" width="378" height="15" font="1">5. The main function is replaced by four versions -</text>
<text top="692" left="507" width="357" height="15" font="1">one that reads A, one that reads B, one that reads</text>
<text top="713" left="507" width="357" height="15" font="1">C, and one that writes C. The fact that c is both</text>
<text top="733" left="507" width="305" height="15" font="1">read and written to is stored at this point.</text>
<text top="766" left="486" width="322" height="15" font="1">6. The analysis of each variable is as follows:</text>
<text top="799" left="527" width="337" height="15" font="1">• a is read sequentially in the loop on line 9. A</text>
<text top="820" left="543" width="321" height="15" font="1">is invariant in the loop on line 7 (since j does</text>
<text top="840" left="543" width="321" height="15" font="1">not appear in the expression for A), and is</text>
<text top="861" left="543" width="321" height="15" font="1">read in a non sequential form in the loop on</text>
<text top="881" left="543" width="321" height="15" font="1">line 5. Similarly, it is sequential in the loop</text>
<text top="901" left="543" width="321" height="15" font="1">on line 4, invariant in the loop on line 3, and</text>
<text top="922" left="543" width="258" height="15" font="1">non sequential in the loop on line 2.</text>
<text top="947" left="527" width="337" height="15" font="1">• B is read non sequentially in the loop on line</text>
<text top="968" left="543" width="321" height="15" font="1">9, sequentially in the loop on line 7, and in-</text>
<text top="988" left="543" width="321" height="15" font="1">variant in the loop on line 5. Similarly, it is</text>
<text top="1009" left="543" width="321" height="15" font="1">non sequential in the loop on line 4, sequen-</text>
<text top="1029" left="543" width="321" height="15" font="1">tial in the loop on line 3, and invariant in the</text>
<text top="1049" left="543" width="102" height="15" font="1">loop on line 2.</text>
<text top="1074" left="527" width="337" height="15" font="1">• The memory access pattern for C is the same</text>
<text top="1096" left="543" width="321" height="15" font="1">for both the read and write accesses, and the</text>
<text top="1140" left="455" width="8" height="15" font="1">5</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1188" width="918">
<text top="86" left="131" width="329" height="15" font="1">compiler has determined this fact by this point.</text>
<text top="106" left="131" width="321" height="15" font="1">It is invariant in the loop on line 9, sequential</text>
<text top="127" left="131" width="321" height="15" font="1">in the loop on line 7, and non sequential in</text>
<text top="147" left="131" width="321" height="15" font="1">the loop on line 5. It is invariant in the loop</text>
<text top="167" left="131" width="321" height="15" font="1">on line 4, sequential in the loop on line 3, and</text>
<text top="188" left="131" width="218" height="15" font="1">invariant in the loop on line 2.</text>
<text top="221" left="74" width="378" height="15" font="1">7. During this step, the compiler has determines that</text>
<text top="242" left="95" width="357" height="15" font="1">the accumulation over c occurs at the innermost</text>
<text top="262" left="95" width="357" height="15" font="1">loop nest, which would prevent parallel operation.</text>
<text top="282" left="95" width="357" height="15" font="1">The loop is moved outwards two steps, right before</text>
<text top="303" left="95" width="357" height="15" font="1">the accumulation at line 4. It stops at this point</text>
<text top="323" left="95" width="357" height="15" font="1">because it has determined that a suﬃcient amount</text>
<text top="343" left="95" width="357" height="15" font="1">of parallelism is now available. The progression of</text>
<text top="364" left="95" width="357" height="15" font="1">all variables are re-written to match the new loop</text>
<text top="384" left="95" width="42" height="15" font="1">order.</text>
<text top="418" left="74" width="378" height="15" font="1">8. At this point the compiler attempts to roll up vari-</text>
<text top="438" left="95" width="241" height="15" font="1">able accesses as much as possible.</text>
<text top="471" left="115" width="337" height="15" font="1">• A is now invariant at the loop on line 9, non</text>
<text top="492" left="131" width="321" height="15" font="1">sequential at the loop on line 7, and sequen-</text>
<text top="513" left="131" width="321" height="15" font="1">tial in the loop on line 5. The loops on line</text>
<text top="533" left="131" width="321" height="15" font="1">9 and 5 are modiﬁed so that their iteration</text>
<text top="553" left="131" width="321" height="15" font="1">count is 1 (since the invariance is handled by</text>
<text top="574" left="131" width="321" height="15" font="1">repeating the number of items seen up to that</text>
<text top="594" left="131" width="321" height="15" font="1">point - 1 in this case - and the sequential ac-</text>
<text top="614" left="131" width="321" height="15" font="1">cesses are converted into one access with a</text>
<text top="635" left="131" width="321" height="15" font="1">for a larger number of items). Since there is</text>
<text top="655" left="131" width="321" height="15" font="1">a non-sequential access inside the sequential</text>
<text top="675" left="131" width="287" height="15" font="1">access, the need to transpose a is noted.</text>
<text top="701" left="115" width="337" height="15" font="1">• B is now sequential in the loop at line 9, in-</text>
<text top="722" left="131" width="321" height="15" font="1">variant at the loop at line 7, and non sequen-</text>
<text top="742" left="131" width="321" height="15" font="1">tial in the loop at line 5. The innermost loop</text>
<text top="762" left="131" width="321" height="15" font="1">is converted to a access. The invariant loop</text>
<text top="783" left="131" width="321" height="15" font="1">is handled by noting that one long access of</text>
<text top="803" left="131" width="321" height="15" font="1">items needs to be repeated. The outer loop</text>
<text top="823" left="131" width="284" height="15" font="1">is left alone because it is non sequential</text>
<text top="849" left="115" width="337" height="15" font="1">• C is now sequential in the loop at line 9, non</text>
<text top="870" left="131" width="321" height="15" font="1">sequential in the loop at line 7, and invariant</text>
<text top="890" left="131" width="321" height="15" font="1">at the loop at line 5. The sequential access is</text>
<text top="911" left="131" width="321" height="15" font="1">converted into a larger access. The invariant</text>
<text top="931" left="131" width="321" height="15" font="1">access at line 5 is converted to a single loop</text>
<text top="951" left="131" width="321" height="15" font="1">iteration, and since the next outer access -</text>
<text top="972" left="131" width="321" height="15" font="1">at line 4 - is also invariant, it is also rolled</text>
<text top="992" left="131" width="321" height="15" font="1">into the accumulation. The accumulation will</text>
<text top="1012" left="131" width="321" height="15" font="1">accumulate everything inside it, or all items</text>
<text top="1033" left="131" width="289" height="15" font="1">transferred in the loops at lines 7 and 9.</text>
<text top="1066" left="95" width="357" height="15" font="1">One thing to note is that if the block size is equal</text>
<text top="1087" left="95" width="357" height="15" font="1">to the matrix size - if there is only 1 block - then</text>
<text top="87" left="479" width="120" height="12" font="3">1 NumKernels : 6 4</text>
<text top="104" left="479" width="112" height="12" font="3">2 F o r c e S i z e : 6 4</text>
<text top="120" left="479" width="138" height="12" font="3">3 Thread : mmm ispc</text>
<text top="137" left="479" width="7" height="12" font="3">4</text>
<text top="137" left="561" width="146" height="12" font="3">T r a n s p o s e W r i t e F i f o</text>
<text top="153" left="591" width="162" height="12" font="3">: 0 , 6 4 , 1 , 6 4 , 6 4 , 2 6 2 1 4 4</text>
<text top="170" left="479" width="7" height="12" font="3">5</text>
<text top="186" left="479" width="155" height="12" font="3">6 Thread : mmm ispc 0</text>
<text top="202" left="479" width="7" height="12" font="3">7</text>
<text top="202" left="561" width="163" height="12" font="3">L o o p W r i t e F i f o : 1 , 6 3 , 1</text>
<text top="219" left="479" width="7" height="12" font="3">8</text>
<text top="235" left="479" width="163" height="12" font="3">9 Thread : mmm ispc wr</text>
<text top="252" left="472" width="14" height="12" font="3">10</text>
<text top="252" left="561" width="105" height="12" font="3">R e a d F i f o : 3 , 6 4</text>
<text top="268" left="472" width="14" height="12" font="3">11</text>
<text top="285" left="472" width="162" height="12" font="3">12 Thread : mmm ispc 1</text>
<text top="301" left="472" width="14" height="12" font="3">13</text>
<text top="301" left="561" width="113" height="12" font="3">W r i t e F i f o : 2 , 6 4</text>
<text top="317" left="472" width="14" height="12" font="3">14</text>
<text top="334" left="472" width="243" height="12" font="3">15 A c c u m u l a t o r P a i r : 2 , 3 , 8 1 2 8 , 6 4</text>
<text top="362" left="466" width="71" height="15" font="1">Listing 2:</text>
<text top="362" left="553" width="311" height="15" font="1">System Descriptor ﬁle for Matrix Matrix</text>
<text top="382" left="466" width="196" height="15" font="1">Multiply with 64x64 blocks</text>
<text top="445" left="507" width="357" height="15" font="1">the compiler can determine that the non sequential</text>
<text top="465" left="507" width="357" height="15" font="1">accesses are actually sequential accesses of larger</text>
<text top="486" left="507" width="360" height="15" font="1">blocks (once the sequential accesses have been mod-</text>
<text top="506" left="507" width="357" height="15" font="1">iﬁed) - in this case there is only one access for each</text>
<text top="526" left="507" width="357" height="15" font="1">variable after transformation, and the entire ma-</text>
<text top="547" left="507" width="220" height="15" font="1">trix is sent in a single transfer.</text>
<text top="580" left="486" width="378" height="15" font="1">9. At this point the compiler sees that there are as</text>
<text top="601" left="507" width="357" height="15" font="1">many operations as items in the block that can</text>
<text top="621" left="507" width="357" height="15" font="1">be executed at once. It will instantiate up to this</text>
<text top="641" left="507" width="357" height="15" font="1">many kernels, and also up to the maximum number</text>
<text top="662" left="507" width="251" height="15" font="1">of kernels passed to the compiler.</text>
<text top="662" left="773" width="91" height="15" font="1">The optimal</text>
<text top="682" left="507" width="357" height="15" font="1">number of kernels is actually the number of items</text>
<text top="702" left="507" width="357" height="15" font="1">in the block / 20, since the compute kernel has a</text>
<text top="723" left="507" width="357" height="15" font="1">latency of 20 cycles. In practice, the experiments</text>
<text top="743" left="507" width="357" height="15" font="1">used a number of kernels equal to the number of</text>
<text top="763" left="507" width="150" height="15" font="1">items in a block row.</text>
<text top="797" left="478" width="386" height="15" font="1">10. Stream instantiation is a simple transformation</text>
<text top="817" left="507" width="357" height="15" font="1">that converts the loads into a transfer of the num-</text>
<text top="838" left="507" width="218" height="15" font="1">ber of items inferred in step 6.</text>
<text top="871" left="478" width="386" height="15" font="1">11. The descriptor ﬁle contains the id of each stream,</text>
<text top="892" left="507" width="357" height="15" font="1">the type of stream it is (regular stream, repeat,</text>
<text top="912" left="507" width="357" height="15" font="1">transpose, or accumulation), the number of ker-</text>
<text top="932" left="507" width="357" height="15" font="1">nels, and the desired external data path width. An</text>
<text top="953" left="507" width="357" height="15" font="1">example of the system descriptor ﬁle is in Listing</text>
<text top="973" left="507" width="357" height="15" font="1"><a href="pdfxml.html#6">2. </a>This ﬁle was generated 128x128 matrices, 64x64</text>
<text top="993" left="507" width="357" height="15" font="1">blocks, a maximum of 64 compute kernels, and a</text>
<text top="1014" left="507" width="357" height="15" font="1">maximum external data path width of 64 bytes.</text>
<text top="1034" left="507" width="357" height="15" font="1">The system that is instantiated is displayed in Fig-</text>
<text top="1054" left="507" width="357" height="15" font="1">ure <a href="pdfxml.html#7">2. </a>This diagram shows only the components</text>
<text top="1075" left="507" width="357" height="15" font="1">generated by the CoRAMify compiler, the Kernel</text>
<text top="1095" left="507" width="357" height="15" font="1">Generation Step, and the Top Level Module gen-</text>
<text top="1140" left="455" width="8" height="15" font="1">6</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1188" width="918">
<text top="283" left="55" width="396" height="15" font="1">Figure 2: Top level module for Matrix Matrix Multiply</text>
<text top="332" left="95" width="357" height="15" font="1">eration step. The ﬁgure illustrates the three input</text>
<text top="353" left="95" width="357" height="15" font="1">streams for A,B, and C, and the output stream for</text>
<text top="373" left="95" width="357" height="15" font="1">C. A is transferred into a transpose buﬀer, B into a</text>
<text top="393" left="95" width="357" height="15" font="1">repeat buﬀer, and C goes through an accumulation</text>
<text top="414" left="95" width="357" height="15" font="1">buﬀer. The ﬁgure illustrates for compute kernels</text>
<text top="434" left="95" width="357" height="15" font="1">that are pipelined. The internal data paths can</text>
<text top="454" left="95" width="357" height="15" font="1">be wider than the external data path - they must</text>
<text top="475" left="95" width="357" height="15" font="1">be wide enough to deliver one input to each com-</text>
<text top="495" left="95" width="357" height="15" font="1">pute kernel. The reason for making the external</text>
<text top="515" left="95" width="357" height="15" font="1">data paths narrower than the internal data path is</text>
<text top="536" left="95" width="357" height="15" font="1">that the external data bandwidth will be limited</text>
<text top="556" left="95" width="357" height="15" font="1">by the system’s memory interface, so there is no</text>
<text top="576" left="95" width="357" height="15" font="1">reason to make a data path wider than the mem-</text>
<text top="597" left="95" width="357" height="15" font="1">ory interface can support. Data is converted to the</text>
<text top="617" left="95" width="357" height="15" font="1">internal path width as it enters the buﬀers - nar-</text>
<text top="637" left="95" width="357" height="15" font="1">row data path items are accumulated over several</text>
<text top="658" left="95" width="357" height="15" font="1">clock cycles when they are brought in, and sent</text>
<text top="678" left="95" width="357" height="15" font="1">out over multiple clock cycles when they are sent</text>
<text top="698" left="95" width="28" height="15" font="1">out.</text>
<text top="741" left="54" width="26" height="16" font="2">4.4</text>
<text top="741" left="100" width="164" height="16" font="2">Kernel Generation</text>
<text top="773" left="79" width="372" height="15" font="1">The kernels are generated by using LLVM’s C back-</text>
<text top="793" left="54" width="398" height="15" font="1">end to generate C from the byte code representing the</text>
<text top="814" left="54" width="398" height="15" font="1">kernel computation and passing it through the ROCCC</text>
<text top="834" left="54" width="398" height="15" font="1">kernel generator after a minimal amount of text pro-</text>
<text top="854" left="54" width="398" height="15" font="1">cessing to clean it up. ROCCC generates fully pipelined</text>
<text top="875" left="54" width="398" height="15" font="1">VHDL compute kernels that support ﬂoating point op-</text>
<text top="895" left="54" width="398" height="15" font="1">erations that use FPGA vendor provided compute cores.</text>
<text top="915" left="54" width="398" height="15" font="1">ROCCC is conﬁgured with the latency information for</text>
<text top="935" left="54" width="398" height="15" font="1">each ﬂoating point operation, and generates registers to</text>
<text top="956" left="54" width="398" height="15" font="1">ensure that the number of cycles needed for the opera-</text>
<text top="976" left="54" width="398" height="15" font="1">tions is maintained. ROCCC handles control ﬂow within</text>
<text top="996" left="54" width="398" height="15" font="1">the cores via predication, and creates modules with in-</text>
<text top="1017" left="54" width="398" height="15" font="1">puts and outputs speciﬁed by the data streams created</text>
<text top="1037" left="54" width="398" height="15" font="1">by the CoRAMify pass. The compute kernels have no</text>
<text top="1057" left="54" width="398" height="15" font="1">information about data access patterns and are stateless</text>
<text top="1078" left="54" width="398" height="15" font="1">except for data moving through their pipelines, initiat-</text>
<text top="86" left="466" width="398" height="15" font="1">ing computation whenever all of their inputs are ready</text>
<text top="106" left="466" width="340" height="15" font="1">and able to produce 1 calculate per clock cycle.</text>
<text top="149" left="466" width="26" height="16" font="2">4.5</text>
<text top="149" left="512" width="265" height="16" font="2">Top Level Module Generation</text>
<text top="181" left="492" width="372" height="15" font="1">The top level module is generated from a descrip-</text>
<text top="201" left="466" width="398" height="15" font="1">tor ﬁle that is generated by the CoRAMify pass con-</text>
<text top="222" left="466" width="398" height="15" font="1">taining information about the various queues in the sys-</text>
<text top="242" left="466" width="398" height="15" font="1">tem along with the source code of for the compute ker-</text>
<text top="262" left="466" width="398" height="15" font="1">nel, which is used to determine the names and sizes of</text>
<text top="283" left="466" width="398" height="15" font="1">each input and output. The top level module generation</text>
<text top="303" left="466" width="398" height="15" font="1">script creates a BlueSpec module that instantiates the</text>
<text top="323" left="466" width="398" height="15" font="1">CoRAM ﬁfos used by the input and output queues, the</text>
<text top="344" left="466" width="398" height="15" font="1">specialized buﬀer structures and state machines that im-</text>
<text top="364" left="466" width="398" height="15" font="1">plement each of the queues according to the detected ac-</text>
<text top="384" left="466" width="398" height="15" font="1">cess pattern, the appropriate number of instances of the</text>
<text top="405" left="466" width="398" height="15" font="1">compute kernel as determined by the CoRAMify pass,</text>
<text top="425" left="466" width="398" height="15" font="1">and the logic necessary to steer the data between the</text>
<text top="445" left="466" width="398" height="15" font="1">queues and the compute kernels. This top level module</text>
<text top="466" left="466" width="398" height="15" font="1">is fairly simple - it initiates computation whenever the</text>
<text top="486" left="466" width="398" height="15" font="1">input structures it contains indicate that all inputs are</text>
<text top="506" left="466" width="398" height="15" font="1">ready, and retires computations whenever computations</text>
<text top="527" left="466" width="398" height="15" font="1">are complete. The module generation script makes sure</text>
<text top="547" left="466" width="398" height="15" font="1">that there is enough buﬀer space available for all kernel</text>
<text top="567" left="466" width="59" height="15" font="1">outputs.</text>
<text top="588" left="492" width="372" height="15" font="1">After the module generation script is complete, the</text>
<text top="608" left="466" width="398" height="15" font="1">top level module is run through the BlueSpec compiler,</text>
<text top="628" left="466" width="398" height="15" font="1">along with any library modules that it uses (such as</text>
<text top="649" left="466" width="398" height="15" font="1">queue handling buﬀer modules), to produce verilog code</text>
<text top="669" left="466" width="221" height="15" font="1">for the system generation step.</text>
<text top="712" left="466" width="26" height="16" font="2">4.6</text>
<text top="712" left="512" width="169" height="16" font="2">System Generation</text>
<text top="744" left="492" width="372" height="15" font="1">The system generation step takes the verilog mod-</text>
<text top="764" left="466" width="398" height="15" font="1">ules generated by the top level module generation step</text>
<text top="784" left="466" width="398" height="15" font="1">and the LLVM byte code for the control threads gen-</text>
<text top="805" left="466" width="398" height="15" font="1">erated by the CoRAMify step, and builds a complete</text>
<text top="825" left="466" width="398" height="15" font="1">system using the soft CoRAM platform. This step is im-</text>
<text top="845" left="466" width="398" height="15" font="1">plemented as a LLVM pass that can parse through the</text>
<text top="866" left="466" width="398" height="15" font="1">enough of the verilog modules to infer modules, commu-</text>
<text top="886" left="466" width="398" height="15" font="1">nication ports, embedded memories (BRAMs for the Xil-</text>
<text top="906" left="466" width="398" height="15" font="1">inx platform), and the connections between them. This</text>
<text top="927" left="466" width="398" height="15" font="1">LLVM pass produces a state machine implemented in</text>
<text top="947" left="466" width="398" height="15" font="1">Verilog for each control thread. It also instantiates the</text>
<text top="967" left="466" width="398" height="15" font="1">DRAM interface, the network on chip (with enough in-</text>
<text top="987" left="466" width="398" height="15" font="1">put ports from DRAM to use all of the available memory</text>
<text top="1008" left="466" width="398" height="15" font="1">bandwidth), and an instance of the top level module in-</text>
<text top="1028" left="466" width="398" height="15" font="1">stantiated in the previous step. All of these modules,</text>
<text top="1048" left="466" width="398" height="15" font="1">along with the VHDL modules produced by the Kernel</text>
<text top="1069" left="466" width="398" height="15" font="1">Generation pass and the hardware cores that it uses for</text>
<text top="1089" left="466" width="398" height="15" font="1">ﬂoating point computation, comprise a complete system</text>
<text top="1140" left="455" width="8" height="15" font="1">7</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="4" size="9" family="Times" color="#000000"/>
<text top="86" left="54" width="398" height="15" font="1">that can be compiled into a bit ﬁle for an FPGA or</text>
<text top="106" left="54" width="252" height="15" font="1">simulated using an HDL simulator.</text>
<text top="151" left="54" width="10" height="16" font="2">5</text>
<text top="151" left="84" width="111" height="16" font="2">Experiments</text>
<text top="189" left="79" width="372" height="15" font="1">The experiments below in simulation modeling an</text>
<text top="209" left="54" width="401" height="15" font="1">FPGA system similar to that provided by Xilinx’s ML605</text>
<text top="229" left="54" width="398" height="15" font="1">prototype board. This board is readily available and</text>
<text top="249" left="54" width="398" height="15" font="1">contains a relatively recent generation FPGA chip (A</text>
<text top="270" left="54" width="398" height="15" font="1">Virtex-6, which was the current generation of Xilinx’s</text>
<text top="290" left="54" width="398" height="15" font="1">products until very recently - the Virtex-7 line of chips</text>
<text top="310" left="54" width="398" height="15" font="1">has been released, but are not yet readily available). It</text>
<text top="331" left="54" width="398" height="15" font="1">also contains a single DDR-2 memory interface. The</text>
<text top="351" left="54" width="398" height="15" font="1">simulator used was Xilinx’s iSim version 13.3, which is</text>
<text top="371" left="54" width="398" height="15" font="1">the latest version available of this cycle accurate HDL</text>
<text top="392" left="54" width="71" height="15" font="1">simulator.</text>
<text top="434" left="54" width="26" height="16" font="2">5.1</text>
<text top="434" left="100" width="213" height="16" font="2">Matrix-Matrix Multiply</text>
<text top="466" left="79" width="372" height="15" font="1">The ﬁrst experiments performed were with a matrix-</text>
<text top="487" left="54" width="398" height="15" font="1">matrix multiply, using the ISPC code documented in</text>
<text top="507" left="54" width="70" height="15" font="1">Listing <a href="pdfxml.html#5">1.</a></text>
<text top="507" left="139" width="312" height="15" font="1">The goal of this experiment was to see if</text>
<text top="527" left="54" width="398" height="15" font="1">a fully automated compilation workﬂow could saturate</text>
<text top="548" left="54" width="398" height="15" font="1">the computational ability of the FPGA. This is a follow</text>
<text top="568" left="54" width="398" height="15" font="1">up on an earlier experiment that determined that a hand</text>
<text top="588" left="54" width="398" height="15" font="1">tuned version of a matrix-matrix multiply could saturate</text>
<text top="609" left="54" width="398" height="15" font="1">an FPGA using CoRAM (with 1024x1024 matrices and</text>
<text top="629" left="54" width="398" height="15" font="1">128 processing elements, although a very diﬀerent paral-</text>
<text top="649" left="54" width="398" height="15" font="1">lelization pattern), demonstrating the feasibility of the</text>
<text top="670" left="54" width="398" height="15" font="1">platform itself. The tests varied the number of compute</text>
<text top="690" left="54" width="398" height="15" font="1">kernels between 64 and 128 and the size of the matrices</text>
<text top="710" left="54" width="398" height="15" font="1">between 128x128 and 512x512, and set the block size</text>
<text top="731" left="54" width="398" height="15" font="1">equal to the square of the number of compute kernels</text>
<text top="751" left="54" width="398" height="15" font="1">(for example, for 64 compute kernels, 64x64 blocks were</text>
<text top="771" left="54" width="54" height="15" font="1">tested).</text>
<text top="792" left="79" width="378" height="15" font="1">Figure <a href="pdfxml.html#8">3 </a>shows the raw results achieved by the matrix-</text>
<text top="812" left="54" width="398" height="15" font="1">matrix multiply. The number of items along each di-</text>
<text top="832" left="54" width="398" height="15" font="1">mension of the matrix is doubling with each step in the</text>
<text top="853" left="54" width="390" height="15" font="1">graph. Because the algorithm used here is the simple n</text>
<text top="850" left="444" width="6" height="11" font="4">3</text>
<text top="873" left="54" width="398" height="15" font="1">algorithm for multiplying two matrices, the total number</text>
<text top="893" left="54" width="398" height="15" font="1">of computations to be performed increases by a factor</text>
<text top="914" left="54" width="398" height="15" font="1">of 8 as the matrices get larger. However, the number</text>
<text top="934" left="54" width="398" height="15" font="1">of cycles taken as the size of the matrices get larger in-</text>
<text top="954" left="54" width="398" height="15" font="1">creases by a much smaller factor. This indicates that the</text>
<text top="975" left="54" width="398" height="15" font="1">overhead of the data transfers is being amortized by the</text>
<text top="995" left="54" width="398" height="15" font="1">block structure - the application is able to successfully</text>
<text top="1015" left="54" width="398" height="15" font="1">overlap computation with data transfers, and keep the</text>
<text top="1036" left="54" width="398" height="15" font="1">highly pipelined compute kernels busy. Figure <a href="pdfxml.html#9">4 </a>shows</text>
<text top="1056" left="54" width="398" height="15" font="1">the throughput that was achieved, assuming a 200 MHz</text>
<text top="1076" left="54" width="398" height="15" font="1">system clock, which is a reasonable speed for the board</text>
<text top="360" left="466" width="398" height="15" font="1">Figure 3: Total Cycles taken by Matrix-Matrix Multiply</text>
<text top="410" left="466" width="398" height="15" font="1">being tested. Each kernel can reach a theoretical maxi-</text>
<text top="430" left="466" width="398" height="15" font="1">mum of 2 ﬂops/cycle, since it performs a ﬂoating point</text>
<text top="451" left="466" width="398" height="15" font="1">multiply and a ﬂoating point add. Thus the theoreti-</text>
<text top="471" left="466" width="398" height="15" font="1">cal maximum throughput for 64 kernels at 200 MHz is</text>
<text top="491" left="466" width="398" height="15" font="1">25.6 GFlops/s, and maximum possible throughput for</text>
<text top="512" left="466" width="398" height="15" font="1">128 kernels is 51.2 GFlops/s. As the size of the matrices</text>
<text top="532" left="466" width="398" height="15" font="1">increases, it is evident that the achieved throughput is</text>
<text top="552" left="466" width="277" height="15" font="1">approaching the theoretical maximum.</text>
<text top="572" left="492" width="372" height="15" font="1">Figure <a href="pdfxml.html#9">5 </a>shows the eﬃciency achieved by the com-</text>
<text top="593" left="466" width="198" height="15" font="1">putation. This is deﬁned as</text>
<text top="588" left="678" width="125" height="11" font="4">Achieved T hroughput</text>
<text top="602" left="671" width="139" height="11" font="4">T heoretical T hroughput</text>
<text top="618" left="492" width="13" height="15" font="1">=</text>
<text top="614" left="515" width="200" height="11" font="4">M inimum cycles f or computation</text>
<text top="627" left="524" width="182" height="11" font="4">Actual Cycles f or computation</text>
<text top="618" left="717" width="5" height="15" font="1">.</text>
<text top="618" left="737" width="127" height="15" font="1">The graph shows</text>
<text top="638" left="466" width="398" height="15" font="1">that the application approaches 100% of the peak pos-</text>
<text top="659" left="466" width="398" height="15" font="1">sible throughput as the matrix size increases, and in</text>
<text top="679" left="466" width="398" height="15" font="1">fact shows that 95% of peak eﬃciency can be reached</text>
<text top="699" left="466" width="398" height="15" font="1">when there are at least 4x4 blocks (64x64 blocks with</text>
<text top="720" left="466" width="398" height="15" font="1">128x128 matrices or 128x128 blocks with 512x512 ma-</text>
<text top="740" left="466" width="398" height="15" font="1">trices). Above this point, the eﬃciency continues to in-</text>
<text top="760" left="466" width="398" height="15" font="1">crease with the increase in matrix size, but much more</text>
<text top="781" left="466" width="47" height="15" font="1">slowly.</text>
<text top="823" left="466" width="26" height="16" font="2">5.2</text>
<text top="823" left="512" width="292" height="16" font="2">Vector Addition with Indirection</text>
<text top="855" left="492" width="372" height="15" font="1">The second experiment tried was a simple vector-</text>
<text top="876" left="466" width="398" height="15" font="1">vector addition with an indirection. The source code</text>
<text top="896" left="466" width="398" height="15" font="1">for this application is included in Listing <a href="pdfxml.html#9">3. </a>The output</text>
<text top="916" left="466" width="398" height="15" font="1">vector is the sum of two input vectors, with the a level</text>
<text top="937" left="466" width="398" height="15" font="1">of indirection used to index one of the input vectors.</text>
<text top="957" left="466" width="398" height="15" font="1">The goal of this experiment was to demonstrated that</text>
<text top="977" left="466" width="398" height="15" font="1">the compiler could support indirection, and to determine</text>
<text top="998" left="466" width="128" height="15" font="1">how it performed.</text>
<text top="1018" left="492" width="372" height="15" font="1">This experiment was tried with 8 compute kernels,</text>
<text top="1038" left="466" width="398" height="15" font="1">with vector sizes varying between 64 and 512 items. Fig-</text>
<text top="1059" left="466" width="398" height="15" font="1">ure <a href="pdfxml.html#9">3 </a>shows the number of cycles taken by the applica-</text>
<text top="1079" left="466" width="398" height="15" font="1">tion as it ran. In this case, the work to be performed</text>
<text top="1140" left="455" width="8" height="15" font="1">8</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1188" width="918">
<text top="370" left="54" width="398" height="15" font="1">Figure 4: Gigaﬂops/s achieved by Matrix-Matrix Multi-</text>
<text top="390" left="54" width="285" height="15" font="1">ply (assuming a 200 MHz system clock)</text>
<text top="712" left="54" width="398" height="15" font="1">Figure 5: % of Peak Throughput Achieved by Matrix-</text>
<text top="733" left="54" width="116" height="15" font="1">Matrix Multiply</text>
<text top="772" left="67" width="229" height="12" font="3">1 e x p o r t v o i d vecmem ( u n i f o r m</text>
<text top="772" left="307" width="78" height="12" font="3">f l o a t a [ ] ,</text>
<text top="788" left="112" width="55" height="12" font="3">u n i f o r m</text>
<text top="788" left="180" width="78" height="12" font="3">f l o a t b [ ] ,</text>
<text top="788" left="270" width="162" height="12" font="3">u n i f o r m i n t b I n d s [ ] ,</text>
<text top="805" left="112" width="55" height="12" font="3">u n i f o r m</text>
<text top="805" left="180" width="78" height="12" font="3">f l o a t c [ ] ,</text>
<text top="805" left="270" width="88" height="12" font="3">u n i f o r m i n t</text>
<text top="805" left="370" width="55" height="12" font="3">s i z e ) {</text>
<text top="821" left="67" width="7" height="12" font="3">2</text>
<text top="821" left="100" width="120" height="12" font="3">f o r ( u n i f o r m i n t</text>
<text top="821" left="233" width="138" height="12" font="3">i =0; i &lt;s i z e ; i ++) {</text>
<text top="837" left="67" width="7" height="12" font="3">3</text>
<text top="837" left="115" width="178" height="12" font="3">c [ i ]= a [ i ]+b [ b I n d s [ i ] ] ;</text>
<text top="854" left="67" width="7" height="12" font="3">4</text>
<text top="853" left="98" width="7" height="13" font="3">}</text>
<text top="870" left="67" width="22" height="12" font="3">5 }</text>
<text top="898" left="54" width="398" height="15" font="1">Listing 3: Source Code for Vector-Vector Addition with</text>
<text top="918" left="54" width="78" height="15" font="1">Indirection</text>
<text top="978" left="54" width="398" height="15" font="1">increased linearly as the vectors increased in size, as did</text>
<text top="998" left="54" width="398" height="15" font="1">the execution time. This indicates that the application</text>
<text top="1019" left="54" width="398" height="15" font="1">was not able eﬀectively overlap computation with mem-</text>
<text top="1039" left="54" width="92" height="15" font="1">ory accesses.</text>
<text top="1039" left="161" width="290" height="15" font="1">The reason for this is that the latency</text>
<text top="1059" left="54" width="398" height="15" font="1">caused by the indirection dominated the actual compu-</text>
<text top="1080" left="54" width="47" height="15" font="1">tation.</text>
<text top="370" left="466" width="398" height="15" font="1">Figure 6: Total Cycles taken by Vector Addition with</text>
<text top="390" left="466" width="78" height="15" font="1">Indirection</text>
<text top="435" left="466" width="26" height="16" font="2">5.3</text>
<text top="435" left="512" width="136" height="16" font="2">Image Filtering</text>
<text top="467" left="492" width="372" height="15" font="1">The third application attempted was a simple 2 di-</text>
<text top="488" left="466" width="398" height="15" font="1">mensional image ﬁlter. This ﬁlter uses a sliding window</text>
<text top="508" left="466" width="398" height="15" font="1">that moves across the image, and multiplies each element</text>
<text top="528" left="466" width="398" height="15" font="1">within that window by the corresponding element of a</text>
<text top="549" left="466" width="398" height="15" font="1">ﬁlter. The source code for this application is included</text>
<text top="569" left="466" width="398" height="15" font="1">in Listing <a href="pdfxml.html#10">4. </a>This application takes the ﬁlter and ﬁl-</text>
<text top="589" left="466" width="398" height="15" font="1">ter size as a parameter, which allows it to be used with</text>
<text top="610" left="466" width="398" height="15" font="1">a number of ﬁlters such as a box ﬁlter, which evenly</text>
<text top="630" left="466" width="398" height="15" font="1">weights all of the ﬁlter elements, or a Gaussian ﬁlter,</text>
<text top="650" left="466" width="398" height="15" font="1">which weights pixels close to the center of the window</text>
<text top="671" left="466" width="398" height="15" font="1">much more strongly than the outer pixels. The intent</text>
<text top="691" left="466" width="398" height="15" font="1">of this experiment was to see how well a slightly diﬀer-</text>
<text top="711" left="466" width="398" height="15" font="1">ent memory access pattern - which still included a high</text>
<text top="732" left="466" width="398" height="15" font="1">amount of data reuse - would perform. Ideally, the com-</text>
<text top="752" left="466" width="398" height="15" font="1">piler would support some sort of sliding window memory</text>
<text top="772" left="466" width="398" height="15" font="1">pattern to optimize the amount of data transferred, but</text>
<text top="793" left="466" width="398" height="15" font="1">it was hoped that the current compiler would be suc-</text>
<text top="813" left="466" width="285" height="15" font="1">cessful at implementing this application</text>
<text top="833" left="492" width="372" height="15" font="1">Unfortunately, the compiler was unable to success-</text>
<text top="854" left="466" width="398" height="15" font="1">fully create an FPGA implementation of this applica-</text>
<text top="874" left="466" width="398" height="15" font="1">tion. There are two parts of the application that the</text>
<text top="894" left="466" width="222" height="15" font="1">compiler was unable to handle.</text>
<text top="915" left="492" width="372" height="15" font="1">The ﬁrst problematic area was the loop on line 3</text>
<text top="935" left="466" width="398" height="15" font="1">(and the induction actual induction variable calculation</text>
<text top="955" left="466" width="398" height="15" font="1">on line 4). The ISPC post processing pass was not able</text>
<text top="976" left="466" width="398" height="15" font="1">to totally remove the lane mask code generated by ISPC,</text>
<text top="996" left="466" width="398" height="15" font="1">even though the lane mask code was essentially useless</text>
<text top="1016" left="466" width="398" height="15" font="1">with a 1-wide vector. Listing <a href="pdfxml.html#10">5 </a>contains LLVM assembly</text>
<text top="1036" left="466" width="398" height="15" font="1">of the remaining lane mask code. From examining the</text>
<text top="1057" left="466" width="398" height="15" font="1">code, it is clear that the comparison for r2 (line 4), which</text>
<text top="1077" left="466" width="398" height="15" font="1">becomes the active bit in the lane mask, is 1 until r0 gets</text>
<text top="1140" left="455" width="8" height="15" font="1">9</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1188" width="918">
<text top="87" left="67" width="104" height="12" font="3">1 e x p o r t v o i d</text>
<text top="87" left="183" width="153" height="12" font="3">f i l t e r i s p c ( u n i f o r m</text>
<text top="87" left="349" width="37" height="12" font="3">f l o a t</text>
<text top="87" left="398" width="37" height="12" font="3">i n [ ] ,</text>
<text top="104" left="112" width="55" height="12" font="3">u n i f o r m</text>
<text top="104" left="180" width="94" height="12" font="3">f l o a t o u t [ ] ,</text>
<text top="104" left="286" width="55" height="12" font="3">u n i f o r m</text>
<text top="104" left="354" width="37" height="12" font="3">f l o a t</text>
<text top="104" left="404" width="44" height="12" font="3">f i l t e r</text>
<text top="120" left="114" width="20" height="12" font="3">[ ] ,</text>
<text top="120" left="145" width="88" height="12" font="3">u n i f o r m i n t</text>
<text top="120" left="246" width="129" height="12" font="3">s i z e , u n i f o r m i n t</text>
<text top="137" left="114" width="104" height="12" font="3">f i l t e r s i z e ) {</text>
<text top="153" left="67" width="7" height="12" font="3">2</text>
<text top="153" left="100" width="120" height="12" font="3">f o r ( u n i f o r m i n t</text>
<text top="153" left="233" width="138" height="12" font="3">i =0; i &lt;s i z e ; i ++) {</text>
<text top="170" left="67" width="7" height="12" font="3">3</text>
<text top="170" left="116" width="54" height="12" font="3">f o r ( i n t</text>
<text top="170" left="183" width="263" height="12" font="3">j c =0; j c &lt;s i z e ; j c+=programCount ) {</text>
<text top="186" left="67" width="7" height="12" font="3">4</text>
<text top="186" left="133" width="21" height="12" font="3">i n t</text>
<text top="186" left="166" width="145" height="12" font="3">j=j c+programIndex ;</text>
<text top="202" left="67" width="7" height="12" font="3">5</text>
<text top="202" left="133" width="120" height="12" font="3">f o r ( u n i f o r m i n t</text>
<text top="202" left="266" width="168" height="12" font="3">i i =0; i i &lt; f i l t e r s i z e ; i i</text>
<text top="219" left="160" width="41" height="12" font="3">++) {</text>
<text top="235" left="67" width="7" height="12" font="3">6</text>
<text top="235" left="149" width="21" height="12" font="3">i n t</text>
<text top="235" left="183" width="79" height="12" font="3">i i n d=i+ i i ;</text>
<text top="252" left="67" width="7" height="12" font="3">7</text>
<text top="252" left="149" width="120" height="12" font="3">f o r ( u n i f o r m i n t</text>
<text top="252" left="283" width="153" height="12" font="3">j j =0; j j &lt; f i l t e r s i z e ;</text>
<text top="268" left="180" width="55" height="12" font="3">j j ++) {</text>
<text top="285" left="67" width="7" height="12" font="3">8</text>
<text top="285" left="166" width="21" height="12" font="3">i n t</text>
<text top="285" left="199" width="79" height="12" font="3">j i n d=j+ j j ;</text>
<text top="301" left="67" width="7" height="12" font="3">9</text>
<text top="301" left="165" width="205" height="12" font="3">o u t [ i ∗ s i z e+j ]+= f i l t e r [ i i ∗</text>
<text top="317" left="197" width="231" height="12" font="3">f i l t e r s i z e + j j ] ∗ i n [ i i n d ∗ s i z e+</text>
<text top="334" left="196" width="45" height="12" font="3">j i n d ] ;</text>
<text top="350" left="60" width="14" height="12" font="3">10</text>
<text top="350" left="148" width="7" height="13" font="3">}</text>
<text top="367" left="60" width="14" height="12" font="3">11</text>
<text top="366" left="131" width="7" height="13" font="3">}</text>
<text top="383" left="60" width="14" height="12" font="3">12</text>
<text top="382" left="115" width="7" height="13" font="3">}</text>
<text top="400" left="60" width="14" height="12" font="3">13</text>
<text top="399" left="98" width="7" height="13" font="3">}</text>
<text top="416" left="60" width="29" height="12" font="3">14 }</text>
<text top="444" left="98" width="310" height="15" font="1">Listing 4: Source Code for 2D Image Filter</text>
<text top="496" left="67" width="112" height="12" font="3">1 r 0 = p h i i 3 2</text>
<text top="496" left="191" width="37" height="12" font="3">[ r8 ,</text>
<text top="496" left="241" width="78" height="12" font="3">f o r e x i t 4 9</text>
<text top="496" left="332" width="12" height="12" font="3">] ,</text>
<text top="496" left="357" width="4" height="12" font="3">[</text>
<text top="496" left="373" width="14" height="12" font="3">0 ,</text>
<text top="513" left="113" width="162" height="12" font="3">f o r t e s t 2 8 . p r e h e a d e r</text>
<text top="513" left="287" width="4" height="12" font="3">]</text>
<text top="529" left="67" width="112" height="12" font="3">2 r 1 = p h i i 3 2</text>
<text top="529" left="191" width="37" height="12" font="3">[ r4 ,</text>
<text top="529" left="241" width="78" height="12" font="3">f o r e x i t 4 9</text>
<text top="529" left="332" width="12" height="12" font="3">] ,</text>
<text top="529" left="357" width="39" height="12" font="3">[ −1,</text>
<text top="545" left="113" width="162" height="12" font="3">f o r t e s t 2 8 . p r e h e a d e r</text>
<text top="545" left="287" width="4" height="12" font="3">]</text>
<text top="562" left="67" width="353" height="12" font="3">3 // r 8 = i 3 2 add r0 , i 3 2 1 e l s e w h e r e i n t h e</text>
<text top="578" left="112" width="31" height="12" font="3">c o d e</text>
<text top="595" left="67" width="120" height="12" font="3">4 r 2 = icmp s l t</text>
<text top="595" left="199" width="54" height="12" font="3">i 3 2 r0 ,</text>
<text top="595" left="266" width="37" height="12" font="3">r s i z e</text>
<text top="611" left="67" width="87" height="12" font="3">5 r 3 = s e x t</text>
<text top="611" left="166" width="96" height="12" font="3">i 1 r 2 t o i 3 2</text>
<text top="628" left="67" width="145" height="12" font="3">6 r 4 = and i 3 2 r1 ,</text>
<text top="628" left="223" width="14" height="12" font="3">r 3</text>
<text top="644" left="67" width="194" height="12" font="3">7 rany mm cmp = icmp s l t</text>
<text top="644" left="274" width="72" height="12" font="3">i 3 2 r4 , 0</text>
<text top="661" left="67" width="161" height="12" font="3">8 br i 1 rany mm cmp ,</text>
<text top="661" left="241" width="37" height="12" font="3">l a b e l</text>
<text top="661" left="290" width="87" height="12" font="3">f o r l o o p 3 0 ,</text>
<text top="661" left="390" width="37" height="12" font="3">l a b e l</text>
<text top="677" left="113" width="78" height="12" font="3">f o r e x i t 3 1</text>
<text top="705" left="54" width="398" height="15" font="1">Listing 5: LLVm Assembly for the remaining lane mask</text>
<text top="725" left="54" width="32" height="15" font="1">code</text>
<text top="785" left="54" width="398" height="15" font="1">to rsize. However, the compiler is unable to tell this,</text>
<text top="805" left="54" width="398" height="15" font="1">and is unable to determine how many times the loop</text>
<text top="825" left="54" width="82" height="15" font="1">will iterate.</text>
<text top="846" left="79" width="372" height="15" font="1">This issue would limit parallelism if not ﬁxed, and</text>
<text top="866" left="54" width="398" height="15" font="1">could be ﬁxed with a relatively simple de-masking pass</text>
<text top="886" left="54" width="398" height="15" font="1">but the other issue made it really diﬃcult to make the</text>
<text top="907" left="54" width="398" height="15" font="1">application work - the CoRAMify pass could not resolve</text>
<text top="927" left="54" width="398" height="15" font="1">the information about how the value read from the input</text>
<text top="947" left="54" width="398" height="15" font="1">pointer changed between loop iterations. This variable</text>
<text top="968" left="54" width="398" height="15" font="1">does actually increase by 1 item between the iterations of</text>
<text top="988" left="54" width="398" height="15" font="1">the loop at line 7, and by some amount in the loop at 5,</text>
<text top="1008" left="54" width="398" height="15" font="1">but without being able to determine this, the CoRAM-</text>
<text top="1029" left="54" width="398" height="15" font="1">ify pass could not eﬀectively coalesce any of the memory</text>
<text top="1049" left="54" width="398" height="15" font="1">accesses. This issue could be resolved by more carefully</text>
<text top="1069" left="54" width="398" height="15" font="1">tracing through the scalar evolution data that is avail-</text>
<text top="1090" left="54" width="325" height="15" font="1">able, but not enough time remained to do so.</text>
<text top="85" left="466" width="10" height="16" font="2">6</text>
<text top="85" left="497" width="251" height="16" font="2">Discussion and Future Work</text>
<text top="123" left="492" width="372" height="15" font="1">ISPC is an interesting language to use, and looks like</text>
<text top="143" left="466" width="398" height="15" font="1">it will be an eﬀective mechanism to create SIMD code</text>
<text top="163" left="466" width="398" height="15" font="1">in the future. The availability of an open source LLVM</text>
<text top="184" left="466" width="398" height="15" font="1">based compiler made it an attractive option for this</text>
<text top="204" left="466" width="398" height="15" font="1">work, compared to the CUDA or OpenCL languages,</text>
<text top="224" left="466" width="398" height="15" font="1">for which no open source fully operational compiler was</text>
<text top="245" left="466" width="66" height="15" font="1">available.</text>
<text top="265" left="492" width="372" height="15" font="1">One piece of information that is provided by the</text>
<text top="285" left="466" width="398" height="15" font="1">ISPC language that did not turn out to explicitly be</text>
<text top="306" left="466" width="398" height="15" font="1">useful is the ”uniform” keyword. The language uses this</text>
<text top="326" left="466" width="398" height="15" font="1">keyword to indicate that data does not change in the</text>
<text top="346" left="466" width="398" height="15" font="1">loop that implements the parallelism, which means that</text>
<text top="366" left="466" width="398" height="15" font="1">it is invariant at that level. The scalar evolution frame-</text>
<text top="387" left="466" width="398" height="15" font="1">work within LLVM should be able to infer this informa-</text>
<text top="407" left="466" width="398" height="15" font="1">tion automatically, so this keyword is not strictly nec-</text>
<text top="427" left="466" width="398" height="15" font="1">essary. However, this information does make the com-</text>
<text top="448" left="466" width="398" height="15" font="1">pilation process easier, especially in the case of a larger</text>
<text top="468" left="466" width="398" height="15" font="1">program with many function calls, where tracing them</text>
<text top="488" left="466" width="116" height="15" font="1">could be tricky.</text>
<text top="488" left="597" width="267" height="15" font="1">Such a system could have functions</text>
<text top="509" left="466" width="398" height="15" font="1">where a function is called in such a fashion that a pa-</text>
<text top="529" left="466" width="398" height="15" font="1">rameter is sometimes varying and sometimes uniform,</text>
<text top="549" left="466" width="398" height="15" font="1">although the compiler should be able to tell this as well.</text>
<text top="570" left="492" width="372" height="15" font="1">Given the uniform keyword, there are two places</text>
<text top="590" left="466" width="398" height="15" font="1">where the compiler can use this information. One place</text>
<text top="610" left="466" width="398" height="15" font="1">is a traditional use of knowledge about invariant infor-</text>
<text top="631" left="466" width="398" height="15" font="1">mation - the instructions that compute the invariant</text>
<text top="651" left="466" width="398" height="15" font="1">data can be moved out of the loop, reducing the number</text>
<text top="671" left="466" width="398" height="15" font="1">of instructions in it. LLVM contains standard compiler</text>
<text top="692" left="466" width="398" height="15" font="1">passes for performing this transformation that does not</text>
<text top="712" left="466" width="398" height="15" font="1">require the uniform keyword. The other use of this data</text>
<text top="732" left="466" width="398" height="15" font="1">is speciﬁc to SPMD programs. SPMD programs must</text>
<text top="753" left="466" width="398" height="15" font="1">maintain masks to indicate which lanes are currently</text>
<text top="773" left="466" width="398" height="15" font="1">active and which are not, and they must contain special</text>
<text top="793" left="466" width="398" height="15" font="1">mechanisms to handle divergent control ﬂow. If the vari-</text>
<text top="814" left="466" width="398" height="15" font="1">ables used to determine control ﬂow are uniform, then</text>
<text top="834" left="466" width="398" height="15" font="1">the compiler does not have to instantiate the logic for</text>
<text top="854" left="466" width="398" height="15" font="1">handling divergent control ﬂow, so can produce much</text>
<text top="875" left="466" width="88" height="15" font="1">better code.</text>
<text top="875" left="570" width="294" height="15" font="1">This optimization is not relevant to an</text>
<text top="895" left="466" width="398" height="15" font="1">FPGA implementation because an FPGA implementa-</text>
<text top="915" left="466" width="398" height="15" font="1">tion can actually handle divergent control ﬂow within</text>
<text top="936" left="466" width="398" height="15" font="1">the hardware kernels because they are actually indepen-</text>
<text top="956" left="466" width="398" height="15" font="1">dent of each other - the kernels actually implement con-</text>
<text top="976" left="466" width="398" height="15" font="1">trol ﬂow via predication, which actually also means that</text>
<text top="997" left="466" width="398" height="15" font="1">the number of cycles taken by the kernel (at least in</text>
<text top="1017" left="466" width="398" height="15" font="1">ROCCC’s implementation) does not vary depending on</text>
<text top="1037" left="466" width="234" height="15" font="1">which control ﬂow path is taken.</text>
<text top="1058" left="492" width="372" height="15" font="1">There are a number of places where it would make</text>
<text top="1078" left="466" width="398" height="15" font="1">sense to extend this work in the future, most of which</text>
<text top="1140" left="451" width="16" height="15" font="1">10</text>
</page>
<page number="11" position="absolute" top="0" left="0" height="1188" width="918">
<text top="86" left="54" width="398" height="15" font="1">are enhancements that would allow it to support a larger</text>
<text top="106" left="54" width="163" height="15" font="1">variety of applications.</text>
<text top="127" left="79" width="372" height="15" font="1">It is unlikely that much could be done to reduce the</text>
<text top="147" left="54" width="398" height="15" font="1">latency for the indirection for the vector addition appli-</text>
<text top="167" left="54" width="398" height="15" font="1">cation. The exact same issue cropped up with the man-</text>
<text top="188" left="54" width="398" height="15" font="1">ually created implementation of a sparse vector/matrix</text>
<text top="208" left="54" width="398" height="15" font="1">multiply application for CoRAM, and the conclusion of</text>
<text top="228" left="54" width="398" height="15" font="1">that work was that the indirect workload would need</text>
<text top="249" left="54" width="398" height="15" font="1">a hardened version of CoRAM, which would have lower</text>
<text top="269" left="54" width="398" height="15" font="1">memory access latency, to work well. However, CoRAM-</text>
<text top="289" left="54" width="398" height="15" font="1">ify pass does not perform any memory stream detection</text>
<text top="310" left="54" width="398" height="15" font="1">for indirect memory accesses. Adding support for these</text>
<text top="330" left="54" width="183" height="15" font="1">accesses might help a bit.</text>
<text top="350" left="79" width="372" height="15" font="1">It would make more sense to focus eﬀort on the image</text>
<text top="371" left="54" width="398" height="15" font="1">ﬁltering application, which has enough data reuse that</text>
<text top="391" left="54" width="398" height="15" font="1">it should work well. The two issues encountered in im-</text>
<text top="411" left="54" width="398" height="15" font="1">plementing it - the remnants of the lane mask in ISPC’s</text>
<text top="432" left="54" width="398" height="15" font="1">output and the oﬀset memory access - are not insur-</text>
<text top="452" left="54" width="398" height="15" font="1">mountable. It should also be possible to detect and im-</text>
<text top="472" left="54" width="398" height="15" font="1">plement a memory buﬀer to handle a sliding window ac-</text>
<text top="493" left="54" width="398" height="15" font="1">cess, which would greatly reduce the memory bandwidth</text>
<text top="513" left="54" width="398" height="15" font="1">requirements for such an application. Even without sup-</text>
<text top="533" left="54" width="398" height="15" font="1">porting that pattern, there should be a way to detect</text>
<text top="554" left="54" width="398" height="15" font="1">that this pattern has multiple sequential streams that</text>
<text top="574" left="54" width="398" height="15" font="1">are accessed at the same time and handle them pretty</text>
<text top="594" left="54" width="398" height="15" font="1">well. The Matrix-Matrix Multiply application could be</text>
<text top="615" left="54" width="398" height="15" font="1">modiﬁed to prevent the output buﬀer from needing to</text>
<text top="635" left="54" width="398" height="15" font="1">be zero initialized and read at the start of the compu-</text>
<text top="655" left="54" width="398" height="15" font="1">tation by initializing the input buﬀer to zero directly.</text>
<text top="675" left="54" width="398" height="15" font="1">However, some implementations of Matrix-Matrix Mul-</text>
<text top="696" left="54" width="398" height="15" font="1">tiply use multiple levels of blocking, which would require</text>
<text top="716" left="54" width="398" height="15" font="1">the return of reading in the input buﬀer. Additionally,</text>
<text top="736" left="54" width="398" height="15" font="1">this work has shown that high eﬃciency can be reached</text>
<text top="757" left="54" width="398" height="15" font="1">when there are at least 4x4 blocks in the matrix. In this</text>
<text top="777" left="54" width="398" height="15" font="1">situation, computing a block of C involves bringing in</text>
<text top="797" left="54" width="398" height="15" font="1">the block, writing out the block, and reading 4 blocks</text>
<text top="818" left="54" width="398" height="15" font="1">of A and 4 blocks of B. An implementation that was</text>
<text top="838" left="54" width="398" height="15" font="1">more eﬃcient would not bring in the block of C, and</text>
<text top="858" left="54" width="398" height="15" font="1">would therefore transfer 9 blocks instead of 10 per out-</text>
<text top="879" left="54" width="398" height="15" font="1">put block. This indicates an overhead of 11% for 4x4</text>
<text top="899" left="54" width="398" height="15" font="1">blocks (5.8% for 8x8 blocks), which, while high, is not</text>
<text top="919" left="54" width="398" height="15" font="1">important given that the computation is not bandwidth</text>
<text top="940" left="54" width="55" height="15" font="1">limited.</text>
<text top="984" left="54" width="10" height="16" font="2">7</text>
<text top="984" left="84" width="104" height="16" font="2">Conclusions</text>
<text top="1022" left="79" width="372" height="15" font="1">This work introduced an FPGA compilation work-</text>
<text top="1042" left="54" width="398" height="15" font="1">ﬂow for the ISPC programming language. It demon-</text>
<text top="1062" left="54" width="398" height="15" font="1">strated that ISPC is a good language for writing soft-</text>
<text top="1083" left="54" width="398" height="15" font="1">ware that will be compiled to FPGA, at least for some</text>
<text top="86" left="466" width="398" height="15" font="1">workloads. While constructs such as the uniform key-</text>
<text top="106" left="466" width="398" height="15" font="1">word were not used directly, they allowed the compiler</text>
<text top="127" left="466" width="398" height="15" font="1">to produce code that explicitly has parallelism within it,</text>
<text top="147" left="466" width="398" height="15" font="1">and some features of ISPC - such as the requirement that</text>
<text top="167" left="466" width="398" height="15" font="1">function parameters not alias each other - make explicit</text>
<text top="188" left="466" width="282" height="15" font="1">ideas that had previously been implied.</text>
<text top="208" left="492" width="372" height="15" font="1">Three applications were tested, one that was ex-</text>
<text top="228" left="466" width="398" height="15" font="1">tremely successful, one that worked correctly but not</text>
<text top="249" left="466" width="398" height="15" font="1">eﬃciently, and one that did not work. The issues that</text>
<text top="269" left="466" width="398" height="15" font="1">prevented the image ﬁltering application from working</text>
<text top="289" left="466" width="398" height="15" font="1">were not insurmountable, but time constraints prevented</text>
<text top="310" left="466" width="398" height="15" font="1">them from being resolved. It is likely that this applica-</text>
<text top="330" left="466" width="398" height="15" font="1">tion will be completed in the future, either with the ISPC</text>
<text top="350" left="466" width="398" height="15" font="1">language or for the CoRAMify compiler pass, since it is</text>
<text top="371" left="466" width="293" height="15" font="1">one that should work well on the FPGA.</text>
<text top="415" left="466" width="94" height="16" font="2">References</text>
<text top="453" left="475" width="389" height="15" font="1">[1] D Cabrera, X Martorell, G Gaydadjiev, E Ayguade,</text>
<text top="473" left="500" width="364" height="15" font="1">and D Jimnez-Gonzlez. Openmp extensions for fpga</text>
<text top="493" left="500" width="88" height="15" font="1">accelerators.</text>
<text top="527" left="475" width="389" height="15" font="1">[2] Andrew Canis, Jongsok Choi, Mark Aldham, Vic-</text>
<text top="547" left="500" width="364" height="15" font="1">tor Zhang, Ahmed Kammoona, Jason H. An-</text>
<text top="568" left="500" width="364" height="15" font="1">derson, Stephen Brown, and Tomasz Czajkowski.</text>
<text top="588" left="500" width="364" height="15" font="1">Legup: high-level synthesis for fpga-based proces-</text>
<text top="608" left="500" width="364" height="15" font="1">sor/accelerator systems. In Proceedings of the 19th</text>
<text top="629" left="500" width="364" height="15" font="1">ACM/SIGDA international symposium on Field</text>
<text top="649" left="500" width="364" height="15" font="1">programmable gate arrays, FPGA ’11, pages 33–36,</text>
<text top="669" left="500" width="245" height="15" font="1">New York, NY, USA, 2011. ACM.</text>
<text top="703" left="475" width="389" height="15" font="1">[3] Eric S. Chung, James C. Hoe, and Ken Mai.</text>
<text top="724" left="500" width="364" height="15" font="1">Coram: an in-fabric memory architecture for fpga-</text>
<text top="744" left="500" width="132" height="15" font="1">based computing.</text>
<text top="744" left="657" width="207" height="15" font="1">In Proceedings of the 19th</text>
<text top="764" left="500" width="364" height="15" font="1">ACM/SIGDA International Symposium on Field</text>
<text top="784" left="500" width="364" height="15" font="1">Programmable Gate Arrays, FPGA ’11, pages 97–</text>
<text top="805" left="500" width="280" height="15" font="1">106, New York, NY, USA, 2011. ACM.</text>
<text top="839" left="475" width="389" height="15" font="1">[4] Eric S Chung, Peter A Milder, James C Hoe, and</text>
<text top="859" left="500" width="364" height="15" font="1">Ken Mai. Single-chip heterogeneous computing :</text>
<text top="879" left="500" width="364" height="15" font="1">Does the future include custom logic , fpgas , and</text>
<text top="900" left="500" width="66" height="15" font="1">gpgpus ?</text>
<text top="900" left="587" width="277" height="15" font="1">International Symposium on Microar-</text>
<text top="920" left="500" width="364" height="15" font="1">chitecture (MICRO-43), Atlanta, GA, 2010, pages</text>
<text top="940" left="500" width="105" height="15" font="1">225–236, 2010.</text>
<text top="974" left="475" width="389" height="15" font="1">[5] Hadi Esmaeilzadeh, Emily Blem, Renee St. Amant,</text>
<text top="994" left="500" width="364" height="15" font="1">Karthikeyan Sankaralingam, and Doug Burger.</text>
<text top="1015" left="500" width="364" height="15" font="1">Dark silicon and the end of multicore scaling.</text>
<text top="1035" left="500" width="266" height="15" font="1">SIGARCH Comput. Archit. News,</text>
<text top="1035" left="781" width="83" height="15" font="1">39:365–376,</text>
<text top="1055" left="500" width="77" height="15" font="1">June 2011.</text>
<text top="1140" left="451" width="16" height="15" font="1">11</text>
</page>
<page number="12" position="absolute" top="0" left="0" height="1188" width="918">
<text top="86" left="62" width="389" height="15" font="1">[6] Y Y Leow, C Y Ng, and W F Wong. Generat-</text>
<text top="106" left="88" width="364" height="15" font="1">ing hardware from OpenMP programs, pages 73–80.</text>
<text top="127" left="88" width="75" height="15" font="1">Ieee, 2006.</text>
<text top="161" left="62" width="389" height="15" font="1">[7] M C McFarland, A C Parker, and R Camposano.</text>
<text top="181" left="88" width="364" height="15" font="1">The high-level synthesis of digital systems. Proceed-</text>
<text top="201" left="88" width="277" height="15" font="1">ings of the IEEE, 78(2):301–318, 1990.</text>
<text top="235" left="62" width="389" height="15" font="1">[8] Alexandros Papakonstantinou, Karthik Gururaj,</text>
<text top="255" left="88" width="364" height="15" font="1">John A Stratton, Deming Chen, Jason Cong, and</text>
<text top="276" left="88" width="364" height="15" font="1">Wen-Mei W Hwu. Fcuda: Enabling eﬃcient com-</text>
<text top="296" left="88" width="266" height="15" font="1">pilation of cuda kernels onto fpgas.</text>
<text top="296" left="370" width="82" height="15" font="1">2009 IEEE</text>
<text top="316" left="88" width="364" height="15" font="1">7th Symposium on Application Speciﬁc Processors,</text>
<text top="337" left="88" width="133" height="15" font="1">pages 35–42, 2009.</text>
<text top="370" left="62" width="360" height="15" font="1">[9] <a href="http://ark.intel.com/products/codename/42360/Stellarton">http://ark.intel.com/products/codename/</a></text>
<text top="392" left="88" width="142" height="14" font="1"><a href="http://ark.intel.com/products/codename/42360/Stellarton">42360/Stellarton.</a></text>
<text top="424" left="54" width="227" height="15" font="1">[10] <a href="http://ispc.github.com">http://ispc.github.com.</a></text>
<text top="458" left="54" width="296" height="15" font="1">[11] <a href="http://www.khronos.org/opencl/">http://www.khronos.org/opencl/.</a></text>
<text top="492" left="54" width="369" height="15" font="1">[12] <a href="http://www.nvidia.com/object/cuda_home_new.html">http://www.nvidia.com/object/cuda_home_</a></text>
<text top="514" left="88" width="73" height="14" font="1"><a href="http://www.nvidia.com/object/cuda_home_new.html">new.html.</a></text>
<text top="546" left="54" width="236" height="15" font="1">[13] <a href="http://www.autoesl.com/">http://www.autoesl.com/.</a></text>
<text top="580" left="54" width="394" height="15" font="1">[14] <a href="http://www.bdti.com/MyBDTI/pubs/AutoPilot.pdf">http://www.bdti.com/MyBDTI/pubs/AutoPilot.</a></text>
<text top="602" left="88" width="30" height="14" font="1"><a href="http://www.bdti.com/MyBDTI/pubs/AutoPilot.pdf">pdf.</a></text>
<text top="634" left="54" width="369" height="15" font="1">[15] <a href="http://www.altera.com/literature/ug/ug_nios2_c2h_compiler.pdf">http://www.altera.com/literature/ug/ug_</a></text>
<text top="656" left="88" width="194" height="14" font="1"><a href="http://www.altera.com/literature/ug/ug_nios2_c2h_compiler.pdf">nios2_c2h_compiler.pdf.</a></text>
<text top="688" left="54" width="373" height="15" font="1">[16] <a href="http://www.jacquardcomputing.com/roccc/">http://www.jacquardcomputing.com/roccc/.</a></text>
<text top="722" left="54" width="236" height="15" font="1">[17] <a href="http://www.bluespec.com">http://www.bluespec.com.</a></text>
<text top="756" left="54" width="394" height="18" font="1">[18] <a href="http://www.eecg.toronto.edu/~jayar/fpga11/Singh_Altera_OpenCL_FPGA11.pdf">http://www.eecg.toronto.edu/~jayar/fpga11/</a></text>
<text top="777" left="88" width="262" height="14" font="1"><a href="http://www.eecg.toronto.edu/~jayar/fpga11/Singh_Altera_OpenCL_FPGA11.pdf">Singh_Altera_OpenCL_FPGA11.pdf.</a></text>
<text top="1140" left="451" width="16" height="15" font="1">12</text>
</page>
</pdf2xml>
