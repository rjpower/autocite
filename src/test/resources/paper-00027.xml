<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="24" family="Times" color="#000000"/>
	<fontspec id="1" size="14" family="Times" color="#000000"/>
	<fontspec id="2" size="9" family="Times" color="#000000"/>
	<fontspec id="3" size="11" family="Times" color="#000000"/>
	<fontspec id="4" size="6" family="Times" color="#000000"/>
	<fontspec id="5" size="8" family="Times" color="#000000"/>
<text top="118" left="95" width="725" height="24" font="0">GKLEE: Concolic Veriﬁcation and Test Generation for GPUs</text>
<text top="180" left="153" width="80" height="15" font="1">Guodong Li</text>
<text top="176" left="235" width="6" height="11" font="2">∗</text>
<text top="204" left="109" width="176" height="12" font="3">Fujitsu Laboratories of America,</text>
<text top="219" left="121" width="152" height="12" font="3">Sunnyvale, CA 94085, USA</text>
<text top="237" left="146" width="103" height="12" font="3">gli@us.fujitsu.com</text>
<text top="180" left="374" width="52" height="15" font="1">Peng Li</text>
<text top="180" left="454" width="88" height="15" font="1">Geof Sawaya</text>
<text top="199" left="379" width="157" height="15" font="1">Ganesh Gopalakrishnan</text>
<text top="224" left="398" width="119" height="12" font="3">School of Computing,</text>
<text top="238" left="406" width="104" height="12" font="3">University of Utah,</text>
<text top="253" left="372" width="172" height="12" font="3">Salt Lake City, UT 84112, USA</text>
<text top="270" left="348" width="220" height="13" font="3">{peterlee,sawaya,ganesh}@cs.utah.edu</text>
<text top="180" left="661" width="113" height="15" font="1">Indradeep Ghosh</text>
<text top="199" left="656" width="124" height="15" font="1">Sreeranga P. Rajan</text>
<text top="224" left="629" width="176" height="12" font="3">Fujitsu Laboratories of America,</text>
<text top="238" left="641" width="152" height="12" font="3">Sunnyvale, CA 94085, USA</text>
<text top="255" left="618" width="198" height="13" font="3">{ighosh,sree.rajan}@us.fujitsu.com</text>
<text top="356" left="81" width="61" height="15" font="1">Abstract</text>
<text top="379" left="81" width="359" height="12" font="3">Programs written for GPUs often contain correctness errors such</text>
<text top="394" left="81" width="359" height="12" font="3">as races, deadlocks, or may compute the wrong result. Existing</text>
<text top="409" left="81" width="359" height="12" font="3">debugging tools often miss these errors because of their limited</text>
<text top="424" left="81" width="359" height="12" font="3">input-space and execution-space exploration. Existing tools based</text>
<text top="439" left="81" width="359" height="12" font="3">on conservative static analysis or conservative modeling of SIMD</text>
<text top="454" left="81" width="359" height="12" font="3">concurrency generate false alarms resulting in wasted bug-hunting.</text>
<text top="469" left="81" width="359" height="12" font="3">They also often do not target performance bugs (non-coalesced</text>
<text top="484" left="81" width="359" height="12" font="3">memory accesses, memory bank conﬂicts, and divergent warps).</text>
<text top="499" left="81" width="196" height="12" font="3">We provide a new framework called</text>
<text top="500" left="281" width="39" height="11" font="2">GKLEE</text>
<text top="499" left="324" width="116" height="12" font="3">that can analyze C++</text>
<text top="514" left="81" width="359" height="12" font="3">GPU programs, locating the aforesaid correctness and performance</text>
<text top="529" left="81" width="141" height="12" font="3">bugs. For these programs,</text>
<text top="530" left="226" width="39" height="11" font="2">GKLEE</text>
<text top="529" left="269" width="171" height="12" font="3">can also automatically generate</text>
<text top="544" left="81" width="359" height="12" font="3">tests that provide high coverage. These tests serve as concrete wit-</text>
<text top="559" left="81" width="359" height="12" font="3">nesses for every reported bug. They can also be used for down-</text>
<text top="574" left="81" width="359" height="12" font="3">stream debugging, for example to test the kernel on the actual hard-</text>
<text top="589" left="81" width="203" height="12" font="3">ware. We describe the architecture of</text>
<text top="590" left="288" width="39" height="11" font="2">GKLEE</text>
<text top="589" left="327" width="113" height="12" font="3">, its symbolic virtual</text>
<text top="603" left="81" width="359" height="12" font="3">machine model, and describe previously unknown bugs and per-</text>
<text top="618" left="81" width="359" height="12" font="3">formance issues that it detected on commercial SDK kernels. We</text>
<text top="633" left="81" width="45" height="12" font="3">describe</text>
<text top="634" left="130" width="39" height="11" font="2">GKLEE</text>
<text top="633" left="169" width="270" height="12" font="3">’s test-case reduction heuristics, and the resulting</text>
<text top="648" left="81" width="280" height="12" font="3">scalability improvement for a given coverage target.</text>
<text top="667" left="81" width="359" height="12" font="3">Categories and Subject Descriptors: D.2.4 [Software Engineer-</text>
<text top="682" left="81" width="262" height="12" font="3">ing]: Software/Program Veriﬁcation—Validation</text>
<text top="701" left="81" width="219" height="12" font="3">General Terms: Reliability, Veriﬁcation</text>
<text top="721" left="81" width="359" height="12" font="3">Keywords: GPU, CUDA, Parallelism, Symbolic Execution, For-</text>
<text top="736" left="81" width="333" height="12" font="3">mal Veriﬁcation, Automatic Test Generation, Virtual Machine</text>
<text top="766" left="81" width="12" height="15" font="1">1.</text>
<text top="766" left="110" width="89" height="15" font="1">Introduction</text>
<text top="790" left="81" width="359" height="12" font="3">Multicore CPUs and GPUs are making inroads into virtually all</text>
<text top="805" left="81" width="359" height="12" font="3">aspects of computing, from portable information appliances to su-</text>
<text top="819" left="81" width="359" height="12" font="3">percomputers. Unfortunately, programming multicore systems to</text>
<text top="834" left="81" width="359" height="12" font="3">achieve high performance often requires many intricate optimiza-</text>
<text top="849" left="81" width="359" height="12" font="3">tions involving memory bandwidth and the CPU/GPU occupancy.</text>
<text top="864" left="81" width="359" height="12" font="3">A majority of these optimizations are still being carried out manu-</text>
<text top="879" left="81" width="359" height="12" font="3">ally. Given the sheer complexity of these optimizations in the con-</text>
<text top="894" left="81" width="359" height="12" font="3">text of actual problems, designers routinely introduce correctness</text>
<text top="909" left="81" width="359" height="12" font="3">and performance bugs. Locating these bugs using today’s commer-</text>
<text top="935" left="81" width="6" height="8" font="4">∗</text>
<text top="938" left="89" width="333" height="11" font="2">Guodong Li started this project while a student of University of Utah.</text>
<text top="1001" left="81" width="359" height="9" font="5">Permission to make digital or hard copies of all or part of this work for personal or</text>
<text top="1013" left="81" width="359" height="9" font="5">classroom use is granted without fee provided that copies are not made or distributed</text>
<text top="1025" left="81" width="359" height="9" font="5">for proﬁt or commercial advantage and that copies bear this notice and the full citation</text>
<text top="1037" left="81" width="359" height="9" font="5">on the ﬁrst page. To copy otherwise, to republish, to post on servers or to redistribute</text>
<text top="1049" left="81" width="227" height="9" font="5">to lists, requires prior speciﬁc permission and/or a fee.</text>
<text top="1064" left="81" width="45" height="9" font="5">PPoPP’12,</text>
<text top="1064" left="137" width="228" height="9" font="5">February 25–29, 2012, New Orleans, Louisiana, USA.</text>
<text top="1076" left="81" width="259" height="9" font="5">Copyright c 2012 ACM 978-1-4503-1160-1/12/02. . . $10.00</text>
<text top="358" left="476" width="359" height="12" font="3">cial debuggers is always a ‘hit-or-miss’ affair: one has to be lucky in</text>
<text top="373" left="476" width="359" height="12" font="3">so many ways, including (i) picking the right test inputs, (ii) ability</text>
<text top="388" left="476" width="359" height="12" font="3">to observe of data corruption (and be able to reliably attribute it to</text>
<text top="403" left="476" width="359" height="12" font="3">races), (iii) whether the compiler optimization match programmer</text>
<text top="418" left="476" width="359" height="12" font="3">assumptions, and (iv) whether the platform masks bugs because of</text>
<text top="433" left="476" width="359" height="12" font="3">the speciﬁc thread/warp scheduling algorithms used. If the execu-</text>
<text top="448" left="476" width="334" height="12" font="3">tion deadlocks, one has to manually reason out the root-cause.</text>
<text top="463" left="493" width="341" height="12" font="3">Recent formal and semi-formal analysis based tools [1–3] have</text>
<text top="478" left="476" width="359" height="12" font="3">improved the situation in many ways. They, in effect, examine</text>
<text top="493" left="476" width="359" height="12" font="3">whole classes of inputs and executions, by resorting to symbolic</text>
<text top="508" left="476" width="359" height="12" font="3">analysis or static analysis methods. They also analyze abstract GPU</text>
<text top="523" left="476" width="359" height="12" font="3">models without making hardware-speciﬁc thread scheduling as-</text>
<text top="538" left="476" width="359" height="12" font="3">sumptions. These tools also have many drawbacks. The ﬁrst prob-</text>
<text top="553" left="476" width="359" height="12" font="3">lem with predominantly static analysis based approaches is false</text>
<text top="568" left="476" width="37" height="12" font="3">alarms</text>
<text top="568" left="513" width="321" height="12" font="3">. False alarms waste precious designer time and may dis-</text>
<text top="583" left="476" width="359" height="12" font="3">suade them from using a tool. Another limitation of today’s tools</text>
<text top="597" left="476" width="359" height="12" font="3">is that they do not help generate tests that achieve high code cover-</text>
<text top="612" left="476" width="359" height="12" font="3">age. Such tests are important for unearthing compiler bugs or “un-</text>
<text top="627" left="476" width="359" height="12" font="3">expected” bugs that surface during hardware execution. Existing</text>
<text top="642" left="476" width="359" height="12" font="3">tools also do not cover one new data race category that we identify</text>
<text top="657" left="476" width="359" height="12" font="3">(we call it warp-divergence race). Compilation based approaches</text>
<text top="672" left="476" width="359" height="12" font="3">can, in many cases, eliminate the drudgery of GPU program op-</text>
<text top="687" left="476" width="359" height="12" font="3">timization; however, their code transformation scripts are seldom</text>
<text top="702" left="476" width="152" height="12" font="3">separately formally veriﬁed.</text>
<text top="717" left="493" width="221" height="12" font="3">We present a new tool framework called</text>
<text top="718" left="719" width="39" height="11" font="2">GKLEE</text>
<text top="717" left="762" width="72" height="12" font="3">for analyzing</text>
<text top="732" left="476" width="359" height="12" font="3">GPU programs with respect to important correctness and perfor-</text>
<text top="747" left="476" width="301" height="12" font="3">mance issues (the tool name coming from “GPU” and “</text>
<text top="748" left="777" width="31" height="11" font="2">KLEE</text>
<text top="747" left="811" width="24" height="12" font="3">[4]).</text>
<text top="763" left="476" width="39" height="11" font="2">GKLEE</text>
<text top="762" left="520" width="65" height="12" font="3">proﬁts from</text>
<text top="763" left="590" width="31" height="11" font="2">KLEE</text>
<text top="762" left="620" width="214" height="12" font="3">’s code base and philosophy of testing</text>
<text top="777" left="476" width="359" height="12" font="3">a given program using concrete plus symbolic (“concolic”) execu-</text>
<text top="792" left="476" width="24" height="12" font="3">tion.</text>
<text top="793" left="503" width="39" height="11" font="2">GKLEE</text>
<text top="792" left="546" width="288" height="12" font="3">is the ﬁrst concolic veriﬁer and test generator tailored</text>
<text top="807" left="476" width="359" height="12" font="3">for GPU programs. Concolic veriﬁers allow designers to declare</text>
<text top="822" left="476" width="359" height="12" font="3">certain input variables as ‘symbolic’ (the remaining inputs are con-</text>
<text top="837" left="476" width="34" height="12" font="3">crete).</text>
<text top="852" left="493" width="11" height="12" font="3">In</text>
<text top="853" left="510" width="39" height="11" font="2">GKLEE</text>
<text top="852" left="549" width="285" height="12" font="3">, the execution of a program expression containing</text>
<text top="866" left="476" width="359" height="12" font="3">symbolic variables results in constraints amongst the program vari-</text>
<text top="881" left="476" width="359" height="12" font="3">ables, including constraints due to conditionals, and explicit con-</text>
<text top="896" left="476" width="359" height="12" font="3">straints (assume statements) on symbolic inputs. Conditionals are</text>
<text top="911" left="476" width="359" height="12" font="3">resolved by KLEE’s decision procedures (“SMT solvers [5]”) that</text>
<text top="926" left="476" width="359" height="12" font="3">ﬁnd solutions for symbolic program inputs. This approach helps</text>
<text top="941" left="476" width="359" height="12" font="3">concolic veriﬁers do something beyond bug-hunting: they can au-</text>
<text top="956" left="476" width="359" height="12" font="3">tomatically enumerate test inputs in a demand-driven manner. That</text>
<text top="971" left="476" width="359" height="12" font="3">is, if there is a control/branch decision that can be affected by some</text>
<text top="986" left="476" width="359" height="12" font="3">input, a concolic veriﬁer can automatically compute and record</text>
<text top="1001" left="476" width="359" height="12" font="3">the input value in a test which is valuable for downstream debug-</text>
<text top="1016" left="476" width="359" height="12" font="3">ging. Recent experience shows that formal methods often have the</text>
<text top="1031" left="476" width="359" height="12" font="3">biggest impact when they can compute tests automatically, expos-</text>
<text top="1046" left="476" width="242" height="12" font="3">ing software defects and vulnerability [6–8].</text>
<text top="1061" left="493" width="106" height="12" font="3">The architecture of</text>
<text top="1062" left="605" width="39" height="11" font="2">GKLEE</text>
<text top="1061" left="649" width="185" height="12" font="3">is shown in Figure 1. It employs</text>
<text top="1076" left="476" width="359" height="12" font="3">a C/C++ front-end based on LLVM-GCC (with our customized</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="81" width="359" height="12" font="3">extensions for CUDA syntax) to parse CUDA programs. It supports</text>
<text top="126" left="81" width="258" height="12" font="3">the execution of both CPU code and GPU code.</text>
<text top="127" left="342" width="39" height="11" font="2">GKLEE</text>
<text top="126" left="385" width="55" height="12" font="3">employs a</text>
<text top="141" left="81" width="359" height="12" font="3">new approach to model the symbolic state (recording the execution</text>
<text top="156" left="81" width="328" height="12" font="3">status of a kernel) with respect to the CUDA memory model.</text>
<text top="181" left="81" width="81" height="12" font="3">Contributions:</text>
<text top="181" left="176" width="264" height="12" font="3">Our main contribution is a symbolic virtual ma-</text>
<text top="196" left="81" width="359" height="12" font="3">chine (VM) to model the execution of GPU programs on open in-</text>
<text top="211" left="81" width="359" height="12" font="3">puts. We detail the construction and operation of this virtual ma-</text>
<text top="226" left="81" width="359" height="12" font="3">chine, showing exactly how it elegantly integrates error-detection</text>
<text top="241" left="81" width="359" height="12" font="3">and analysis, while not generating false alarms or missing exe-</text>
<text top="256" left="81" width="359" height="12" font="3">cution paths when generating concrete tests. This approach also</text>
<text top="271" left="81" width="359" height="12" font="3">allows one to effect scalability/coverage tradeoffs. The following</text>
<text top="286" left="81" width="299" height="12" font="3">features are integrated into our symbolic VM approach:</text>
<text top="300" left="81" width="359" height="13" font="3">• GPU programs can suffer from several classes of insidious data</text>
<text top="315" left="81" width="31" height="12" font="3">races.</text>
<text top="316" left="115" width="39" height="11" font="2">GKLEE</text>
<text top="315" left="157" width="283" height="12" font="3">ﬁnds such races (sometimes even in well-tested GPU</text>
<text top="330" left="81" width="47" height="12" font="3">kernels).</text>
<text top="344" left="81" width="7" height="13" font="3">•</text>
<text top="346" left="91" width="39" height="11" font="2">GKLEE</text>
<text top="345" left="133" width="306" height="12" font="3">detects and reports occurrences of divergent thread warps</text>
<text top="360" left="81" width="359" height="12" font="3">(branches inside SIMD paths), as these can degrade performance.</text>
<text top="375" left="81" width="63" height="12" font="3">In addition,</text>
<text top="376" left="148" width="39" height="11" font="2">GKLEE</text>
<text top="375" left="191" width="249" height="12" font="3">guarantees to ﬁnd deadlocks caused by diver-</text>
<text top="390" left="81" width="359" height="12" font="3">gent warps in which two threads may encounter different sequences</text>
<text top="405" left="81" width="200" height="12" font="3">of barrier (__syncthreads()) calls.</text>
<text top="419" left="81" width="7" height="13" font="3">•</text>
<text top="421" left="93" width="39" height="11" font="2">GKLEE</text>
<text top="420" left="132" width="308" height="12" font="3">’s symbolic virtual machine can systematically generate</text>
<text top="435" left="81" width="359" height="12" font="3">concrete tests while also taking into account any input constraints</text>
<text top="450" left="81" width="352" height="12" font="3">the programmer may have expressed through assume statements.</text>
<text top="464" left="81" width="154" height="13" font="3">• While tests generated by</text>
<text top="466" left="241" width="39" height="11" font="2">GKLEE</text>
<text top="465" left="286" width="153" height="12" font="3">guarantee high coverage, it</text>
<text top="480" left="81" width="152" height="12" font="3">may lead to test explosion.</text>
<text top="481" left="239" width="39" height="11" font="2">GKLEE</text>
<text top="480" left="283" width="156" height="12" font="3">employs powerful heuristics</text>
<text top="495" left="81" width="359" height="12" font="3">for reducing the number of tests. We evaluate these heuristics on</text>
<text top="510" left="81" width="359" height="12" font="3">a variety of examples and identify those heuristics that result in</text>
<text top="525" left="81" width="284" height="12" font="3">high coverage while still only generating fewer tests.</text>
<text top="539" left="81" width="153" height="13" font="3">• We can automatically run</text>
<text top="541" left="239" width="39" height="11" font="2">GKLEE</text>
<text top="540" left="278" width="162" height="12" font="3">-generated tests on the actual</text>
<text top="555" left="81" width="359" height="12" font="3">hardware; one such experiment alerted us to the need for a new</text>
<text top="570" left="81" width="232" height="12" font="3">error-check type, which we have added to</text>
<text top="571" left="317" width="39" height="11" font="2">GKLEE</text>
<text top="570" left="356" width="83" height="12" font="3">: has a volatile</text>
<text top="585" left="81" width="197" height="12" font="3">declaration been possibly forgotten?</text>
<text top="584" left="281" width="158" height="12" font="3">This can help eliminate silent</text>
<text top="599" left="81" width="359" height="12" font="3">data corruption caused by reads that may pick up stale write values.</text>
<text top="613" left="81" width="359" height="13" font="3">• We target two classes of memory access inefﬁciencies, namely</text>
<text top="629" left="81" width="359" height="12" font="3">non-coalesced global memory accesses and shared memory ac-</text>
<text top="644" left="81" width="268" height="12" font="3">cesses that result in bank conﬂicts, and show how</text>
<text top="645" left="352" width="39" height="11" font="2">GKLEE</text>
<text top="644" left="395" width="45" height="12" font="3">can spot</text>
<text top="659" left="81" width="359" height="12" font="3">these inefﬁciencies, also “understanding” platform rules (i.e., com-</text>
<text top="674" left="81" width="359" height="12" font="3">pute capability 1.x or 2.x). Some kernels originally thought free of</text>
<text top="689" left="81" width="167" height="12" font="3">these errors are actually not so.</text>
<text top="703" left="81" width="7" height="13" font="3">•</text>
<text top="705" left="92" width="39" height="11" font="2">GKLEE</text>
<text top="704" left="131" width="309" height="12" font="3">’s VM incorporates the CUDA memory model within its</text>
<text top="719" left="81" width="359" height="12" font="3">concolic execution framework, while (i) accurately modeling the</text>
<text top="734" left="81" width="359" height="12" font="3">SIMD concurrency of GPUs, (ii) avoiding interleaving enumera-</text>
<text top="749" left="81" width="359" height="12" font="3">tion through an approach based on race checking, and (iii) scaling</text>
<text top="764" left="81" width="102" height="12" font="3">to large code sizes.</text>
<text top="778" left="81" width="7" height="13" font="3">•</text>
<text top="780" left="94" width="39" height="11" font="2">GKLEE</text>
<text top="779" left="140" width="299" height="12" font="3">handles many C++/CUDA features including: struct,</text>
<text top="794" left="81" width="359" height="12" font="3">class, template, pointer, inheritance, CUDA’s variable and function</text>
<text top="809" left="81" width="226" height="12" font="3">derivatives, and CUDA speciﬁc functions.</text>
<text top="823" left="81" width="7" height="13" font="3">•</text>
<text top="825" left="94" width="39" height="11" font="2">GKLEE</text>
<text top="824" left="133" width="307" height="12" font="3">’s analysis occurs on LLVM byte-codes (also targeted</text>
<text top="839" left="81" width="359" height="12" font="3">by Fortran and Clang). Byte-code level analysis can help cover</text>
<text top="853" left="81" width="359" height="12" font="3">pertinent compiler-induced bugs in addition to supporting future</text>
<text top="868" left="81" width="161" height="12" font="3">work on other binary formats.</text>
<text top="1041" left="172" width="51" height="12" font="3">Figure 1.</text>
<text top="1043" left="230" width="39" height="11" font="2">GKLEE</text>
<text top="1042" left="269" width="79" height="12" font="3">’s architecture.</text>
<text top="1061" left="81" width="309" height="12" font="3">Roadmap: § 2 explains the error-classes covered by</text>
<text top="1062" left="397" width="39" height="11" font="2">GKLEE</text>
<text top="1061" left="436" width="3" height="12" font="3">.</text>
<text top="1075" left="81" width="66" height="13" font="3">§ 3 presents</text>
<text top="1077" left="152" width="39" height="11" font="2">GKLEE</text>
<text top="1076" left="191" width="249" height="12" font="3">’s concolic veriﬁcation: state model, memory</text>
<text top="111" left="476" width="359" height="12" font="3">type inference, and concolic execution (§ 3.1) and error check-</text>
<text top="126" left="476" width="359" height="12" font="3">ing/analysis (§ 3.2). § 5 presents experimental results, covering</text>
<text top="141" left="476" width="359" height="12" font="3">issues pertaining to correctness checking/performance (§ 5.1) and</text>
<text top="156" left="476" width="359" height="12" font="3">test set generation/reduction (§ 5.2). § 6 presents related work and</text>
<text top="170" left="476" width="77" height="13" font="3">§ 7 concludes.</text>
<text top="206" left="476" width="12" height="15" font="1">2.</text>
<text top="206" left="504" width="278" height="15" font="1">Examples of our Analysis/Testing Goals</text>
<text top="229" left="476" width="17" height="12" font="3">2.1</text>
<text top="229" left="506" width="142" height="12" font="3">Basics of GPU Programs</text>
<text top="251" left="476" width="39" height="11" font="2">GKLEE</text>
<text top="250" left="517" width="317" height="12" font="3">currently supports the CUDA [9] syntax (with OpenCL [10]</text>
<text top="265" left="476" width="359" height="12" font="3">to be addressed in future). A CUDA kernel is launched as an 1D or</text>
<text top="280" left="476" width="285" height="12" font="3">2D grid of thread blocks. The total size of a 2D grid is</text>
<text top="282" left="764" width="57" height="10" font="2">gridDim.x</text>
<text top="279" left="823" width="11" height="13" font="3">×</text>
<text top="297" left="476" width="57" height="10" font="2">gridDim.y</text>
<text top="295" left="533" width="131" height="12" font="3">. Each block at location</text>
<text top="297" left="673" width="134" height="10" font="2">blockIdx.x, blockIdx.y</text>
<text top="295" left="816" width="18" height="12" font="3">has</text>
<text top="310" left="476" width="61" height="12" font="3">dimensions</text>
<text top="312" left="541" width="64" height="10" font="2">blockDim.x</text>
<text top="310" left="604" width="3" height="12" font="3">,</text>
<text top="312" left="612" width="64" height="10" font="2">blockDim.y</text>
<text top="310" left="679" width="19" height="12" font="3">and</text>
<text top="312" left="703" width="64" height="10" font="2">blockDim.z</text>
<text top="310" left="766" width="68" height="12" font="3">. Each block</text>
<text top="325" left="476" width="45" height="12" font="3">contains</text>
<text top="327" left="526" width="231" height="10" font="2">blockDim.x × blockDim.y × blockDim.z</text>
<text top="325" left="762" width="72" height="12" font="3">threads, with</text>
<text top="340" left="476" width="19" height="12" font="3">IDs</text>
<text top="342" left="503" width="221" height="10" font="2">threadIdx.x, threadIdx.y, threadIdx.z</text>
<text top="340" left="732" width="102" height="12" font="3">. These threads can</text>
<text top="355" left="476" width="359" height="12" font="3">share information via shared memory, and synchronize via barri-</text>
<text top="370" left="476" width="16" height="12" font="3">ers</text>
<text top="370" left="492" width="342" height="12" font="3">. Threads belonging to distinct blocks must use the much slower</text>
<text top="385" left="476" width="83" height="12" font="3">global memory</text>
<text top="385" left="563" width="271" height="12" font="3">to communicate, and may not synchronize using</text>
<text top="400" left="476" width="122" height="12" font="3">barriers. The values of</text>
<text top="402" left="601" width="44" height="10" font="2">gridDim</text>
<text top="400" left="649" width="19" height="12" font="3">and</text>
<text top="402" left="673" width="51" height="10" font="2">blockDim</text>
<text top="400" left="727" width="107" height="12" font="3">determines the con-</text>
<text top="415" left="476" width="53" height="12" font="3">ﬁguration</text>
<text top="415" left="532" width="302" height="12" font="3">of the system, e.g. the sizes of the grid and each block.</text>
<text top="430" left="476" width="70" height="12" font="3">For a thread,</text>
<text top="431" left="550" width="51" height="10" font="2">blockIdx</text>
<text top="430" left="605" width="19" height="12" font="3">and</text>
<text top="431" left="629" width="57" height="10" font="2">threadIdx</text>
<text top="430" left="691" width="144" height="12" font="3">give its block index in the</text>
<text top="445" left="476" width="359" height="12" font="3">grid and its thread index in the block respectively. For brevity,</text>
<text top="459" left="476" width="137" height="12" font="3">we use gdim to denote</text>
<text top="460" left="619" width="50" height="11" font="2">gridDim</text>
<text top="459" left="668" width="50" height="12" font="3">, bid for</text>
<text top="460" left="724" width="48" height="11" font="2">blockIdx</text>
<text top="459" left="772" width="62" height="12" font="3">, bdim for</text>
<text top="475" left="476" width="54" height="11" font="2">blockDim</text>
<text top="474" left="530" width="67" height="12" font="3">, and tid for</text>
<text top="475" left="600" width="57" height="11" font="2">threadIdx</text>
<text top="474" left="657" width="90" height="12" font="3">. The constraints</text>
<text top="475" left="751" width="83" height="11" font="2">bid.∗ &lt; gdim.∗</text>
<text top="490" left="476" width="77" height="11" font="2">for ∗ ∈ {x, y}</text>
<text top="489" left="558" width="19" height="12" font="3">and</text>
<text top="490" left="582" width="178" height="11" font="2">tid.∗ &lt; bdim.∗ for ∗ ∈ {x, y, z}</text>
<text top="489" left="765" width="69" height="12" font="3">always hold.</text>
<text top="504" left="476" width="359" height="12" font="3">Groups of 32 (a “warp”) consecutively numbered threads within a</text>
<text top="519" left="476" width="359" height="12" font="3">thread block are scheduled at a time in a Single Instruction Multiple</text>
<text top="534" left="476" width="118" height="12" font="3">Data (SIMD) fashion.</text>
<text top="563" left="476" width="17" height="12" font="3">2.2</text>
<text top="563" left="506" width="240" height="12" font="3">CUDA Error Classes and Test Generation</text>
<text top="584" left="476" width="27" height="12" font="3">2.2.1</text>
<text top="584" left="516" width="59" height="12" font="3">Deadlocks</text>
<text top="604" left="476" width="359" height="12" font="3">Deadlocks occur when any two threads in a thread block fail to</text>
<text top="617" left="476" width="359" height="12" font="3">encounter the same textually aligned barriers [11], as in kernel</text>
<text top="632" left="476" width="232" height="11" font="3">deadlock below. Here, threads satisfying</text>
<text top="632" left="713" width="57" height="10" font="2">tid.x + i</text>
<text top="632" left="775" width="7" height="11" font="3">&gt;</text>
<text top="632" left="787" width="6" height="10" font="2">0</text>
<text top="631" left="799" width="36" height="12" font="3">invoke</text>
<text top="644" left="476" width="223" height="12" font="3">the barrier while the other threads do not:</text>
<text top="668" left="476" width="210" height="10" font="2">__global__ void deadlock(int i) {</text>
<text top="681" left="488" width="114" height="10" font="2">if (tid.x + i &gt; 0)</text>
<text top="695" left="501" width="159" height="10" font="2">{ ...; __syncthreads(); }</text>
<text top="695" left="679" width="6" height="10" font="2">}</text>
<text top="717" left="493" width="341" height="12" font="3">Random test input generation does not guarantee path cover-</text>
<text top="732" left="476" width="359" height="12" font="3">age especially when conditionals are deeply embedded, whereas</text>
<text top="748" left="476" width="39" height="11" font="2">GKLEE</text>
<text top="747" left="515" width="319" height="12" font="3">’s directed test generation based on SMT-solving ensures</text>
<text top="761" left="476" width="359" height="12" font="3">coverage. While the basic techniques for such test generation have</text>
<text top="776" left="476" width="173" height="12" font="3">been well researched in the past,</text>
<text top="777" left="651" width="39" height="11" font="2">GKLEE</text>
<text top="776" left="690" width="144" height="12" font="3">’s contributions in this area</text>
<text top="791" left="476" width="359" height="12" font="3">include addressing the CUDA semantics and memory model, and</text>
<text top="806" left="476" width="359" height="12" font="3">detecting non-textually aligned barriers, a simple example of which</text>
<text top="821" left="476" width="359" height="12" font="3">is below. Here, the threads encounter different barrier calls if they</text>
<text top="836" left="476" width="130" height="12" font="3">diverge on the condition</text>
<text top="837" left="609" width="69" height="11" font="2">tid.x + i &gt; 0</text>
<text top="836" left="678" width="3" height="12" font="3">.</text>
<text top="864" left="488" width="279" height="10" font="2">if (tid.x + i &gt; 0) { ...; __syncthreads(); }</text>
<text top="878" left="488" width="191" height="10" font="2">else { ...; __syncthreads(); }</text>
<text top="905" left="476" width="27" height="12" font="3">2.2.2</text>
<text top="905" left="516" width="65" height="12" font="3">Data Races</text>
<text top="926" left="476" width="359" height="12" font="3">There are three broad classes of races: intra-warp races, inter-</text>
<text top="941" left="476" width="359" height="12" font="3">warp races, and device/CPU memory races. Intra-warp races can</text>
<text top="956" left="476" width="359" height="12" font="3">be further classiﬁed into intra-warp races without warp divergence,</text>
<text top="971" left="476" width="232" height="12" font="3">and intra-warp races with warp divergence.</text>
<text top="995" left="476" width="245" height="12" font="3">Intra-warp Races Without Warp Divergence:</text>
<text top="996" left="734" width="100" height="12" font="3">Given that any two</text>
<text top="1009" left="476" width="359" height="12" font="3">threads within a warp execute the same instruction, an intra-warp</text>
<text top="1022" left="476" width="359" height="12" font="3">race (without involving warp divergence) has to be a write-write</text>
<text top="1036" left="476" width="314" height="12" font="3">race. The following is an example of such a race which</text>
<text top="1037" left="795" width="39" height="11" font="2">GKLEE</text>
<text top="1049" left="476" width="359" height="12" font="3">can successfully report. In this example, writes to shared array v[]</text>
<text top="1063" left="476" width="359" height="12" font="3">overlap; e.g., thread 0 and 1 concurrently write four bytes beginning</text>
<text top="1076" left="476" width="153" height="12" font="3">at v[0] (in a 32-bit system).</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
<text top="113" left="81" width="140" height="10" font="2">__global__ void race()</text>
<text top="126" left="81" width="6" height="10" font="2">{</text>
<text top="126" left="100" width="222" height="10" font="2">x = tid.x &gt;&gt; 2; v[x] = x + tid.x; }</text>
<text top="145" left="81" width="234" height="12" font="3">Intra-warp Races With Warp Divergence:</text>
<text top="145" left="329" width="111" height="12" font="3">In a divergent warp,</text>
<text top="159" left="81" width="359" height="12" font="3">a conditional statement causes some of the threads to execute the</text>
<text top="172" left="81" width="23" height="12" font="3">then</text>
<text top="172" left="110" width="330" height="12" font="3">part while others execute the else part. But because of the</text>
<text top="186" left="81" width="359" height="12" font="3">SIMD nature, both parts are executed with respect to all the threads</text>
<text top="199" left="81" width="359" height="12" font="3">in some unspeciﬁed order (undeﬁned in the standard). Thus, in</text>
<text top="212" left="81" width="359" height="12" font="3">example ‘race’, depending on the hardware platform: (i) the even</text>
<text top="226" left="81" width="359" height="12" font="3">threads may read v ﬁrst, and then the odd threads write v; or (ii) the</text>
<text top="239" left="81" width="337" height="12" font="3">odd threads may write v and then the even threads may read v:</text>
<text top="262" left="81" width="140" height="10" font="2">__global__ void race()</text>
<text top="262" left="284" width="6" height="10" font="2">{</text>
<text top="275" left="94" width="178" height="10" font="2">if (tid.x % 2) { ... = v ; }</text>
<text top="289" left="94" width="114" height="10" font="2">else { v = ... ; }</text>
<text top="289" left="284" width="6" height="10" font="2">}</text>
<text top="309" left="81" width="359" height="12" font="3">While on a given machine the results are predictable (either the</text>
<text top="325" left="81" width="359" height="11" font="3">then or the else happens ﬁrst) an unpleasant surprise can result</text>
<text top="339" left="81" width="359" height="12" font="3">when this code is ported to a future machine where the else</text>
<text top="354" left="81" width="359" height="12" font="3">happens ﬁrst (think of it as a “porting race”—race-like outcome</text>
<text top="369" left="81" width="359" height="12" font="3">that surfaces when the code is ported). The culprit is of course</text>
<text top="384" left="81" width="359" height="12" font="3">overlapped accesses across divergent-warp threads, but if v is a</text>
<text top="399" left="81" width="359" height="12" font="3">complicated array expression, this fact is virtually impossible to</text>
<text top="413" left="81" width="97" height="12" font="3">discern manually.</text>
<text top="414" left="184" width="39" height="11" font="2">GKLEE</text>
<text top="413" left="224" width="216" height="12" font="3">’s novel contribution is to detect such</text>
<text top="428" left="81" width="359" height="12" font="3">overlaps exactly regardless of the complexity of the conditionals</text>
<text top="443" left="81" width="359" height="12" font="3">or the array accesses. (For simplicity, we do not illustrate a variant</text>
<text top="458" left="81" width="291" height="12" font="3">of this example where both accesses are updates to v.)</text>
<text top="473" left="99" width="278" height="12" font="3">This example also covers another check done by</text>
<text top="474" left="383" width="39" height="11" font="2">GKLEE</text>
<text top="473" left="423" width="17" height="12" font="3">: it</text>
<text top="488" left="81" width="359" height="12" font="3">reports the number of occurrences of divergent warps over the</text>
<text top="503" left="81" width="85" height="12" font="3">whole program.</text>
<text top="524" left="81" width="102" height="12" font="3">Inter-warp Races:</text>
<text top="524" left="197" width="243" height="12" font="3">Inter-warp races could be read-write, write-</text>
<text top="538" left="81" width="359" height="12" font="3">read, or write-write: we illustrate a read-write race below. Here</text>
<text top="551" left="81" width="359" height="12" font="3">there is the danger that thread 0 and thread bdim.x − 1 may access</text>
<text top="564" left="81" width="359" height="12" font="3">v[0] simultaneously while these two threads also belong to different</text>
<text top="578" left="81" width="129" height="12" font="3">warps in a thread block.</text>
<text top="601" left="81" width="152" height="10" font="2">__global__ void race() {</text>
<text top="614" left="94" width="235" height="10" font="2">v[tid.x] = v[(tid.x + 1) % bdim.x]; }</text>
<text top="634" left="81" width="359" height="12" font="3">Testing may fail to reveal this bug because this bug is typically</text>
<text top="649" left="81" width="359" height="12" font="3">noticed only when the write by one thread occurs before the read by</text>
<text top="664" left="81" width="359" height="12" font="3">the other thread. However, the execution order of threads in a GPU</text>
<text top="679" left="81" width="359" height="12" font="3">is non-deterministic depending on the scheduling, and latencies of</text>
<text top="694" left="81" width="97" height="12" font="3">memory accesses.</text>
<text top="695" left="181" width="39" height="11" font="2">GKLEE</text>
<text top="694" left="224" width="205" height="12" font="3">guarantees to expose this type of race.</text>
<text top="715" left="81" width="133" height="12" font="3">Global Memory Races:</text>
<text top="716" left="226" width="39" height="11" font="2">GKLEE</text>
<text top="715" left="272" width="168" height="12" font="3">also detects and reports races</text>
<text top="728" left="81" width="199" height="12" font="3">occurring on global device variables:</text>
<text top="751" left="81" width="83" height="10" font="2">__device__ x;</text>
<text top="764" left="81" width="140" height="10" font="2">__global__ void race()</text>
<text top="778" left="81" width="6" height="10" font="2">{</text>
<text top="778" left="100" width="305" height="10" font="2">...conflicting accesses to x by two threads... }</text>
<text top="801" left="81" width="27" height="12" font="3">2.2.3</text>
<text top="801" left="121" width="169" height="12" font="3">Memory Access Inefﬁciencies</text>
<text top="822" left="81" width="359" height="12" font="3">There are two kinds of memory access inefﬁciencies: bank conﬂicts</text>
<text top="837" left="81" width="201" height="12" font="3">and non-coalesced memory accesses.</text>
<text top="838" left="286" width="39" height="11" font="2">GKLEE</text>
<text top="837" left="328" width="111" height="12" font="3">reports their severity</text>
<text top="852" left="81" width="359" height="12" font="3">by reporting the absolute number and the percentage of accesses</text>
<text top="867" left="81" width="339" height="12" font="3">that suffer from this inefﬁciency, as described in § 5.1 in detail.</text>
<text top="889" left="81" width="181" height="12" font="3">Shared Memory Bank Conﬂicts:</text>
<text top="889" left="275" width="164" height="12" font="3">Bank conﬂicts result when the</text>
<text top="904" left="81" width="359" height="12" font="3">threads in a half warp (for the CUDA compute capability 1.x</text>
<text top="919" left="81" width="359" height="12" font="3">model) or entire warp (for capability 1.2) access the same mem-</text>
<text top="934" left="81" width="52" height="12" font="3">ory bank.</text>
<text top="935" left="137" width="39" height="11" font="2">GKLEE</text>
<text top="934" left="180" width="259" height="12" font="3">checks for conﬂicts by symbolically comparing</text>
<text top="949" left="81" width="302" height="12" font="3">whether two such accesses can fall into a memory bank.</text>
<text top="971" left="81" width="230" height="12" font="3">Non-coalesced Device Memory Accesses:</text>
<text top="972" left="324" width="115" height="12" font="3">Non-coalesced mem-</text>
<text top="987" left="81" width="359" height="12" font="3">ory accesses waste considerable bus bandwidth when fetching data</text>
<text top="1001" left="81" width="359" height="12" font="3">from the device memory. Memory coalescing is achieved by fol-</text>
<text top="1016" left="81" width="333" height="12" font="3">lowing access rules speciﬁc to the GPU compute capability.</text>
<text top="1017" left="418" width="21" height="11" font="2">GK-</text>
<text top="1032" left="81" width="22" height="11" font="2">LEE</text>
<text top="1031" left="107" width="333" height="12" font="3">faithfully models all 1.x and 2.x compute capability coalesc-</text>
<text top="1046" left="81" width="359" height="12" font="3">ing rules, and can be run with the compute capability speciﬁed as</text>
<text top="1061" left="81" width="359" height="12" font="3">a ﬂag option (illustrates the ﬂexibility to accommodate future such</text>
<text top="1076" left="81" width="188" height="12" font="3">options from other manufacturers).</text>
<text top="111" left="476" width="27" height="12" font="3">2.2.4</text>
<text top="111" left="516" width="92" height="12" font="3">Test Generation</text>
<text top="132" left="476" width="359" height="12" font="3">The ability to automatically generate high quality tests and verify</text>
<text top="147" left="476" width="287" height="12" font="3">kernels over all possible inputs is a unique feature of</text>
<text top="148" left="767" width="39" height="11" font="2">GKLEE</text>
<text top="147" left="806" width="28" height="12" font="3">. The</text>
<text top="163" left="476" width="359" height="11" font="3">BitonicSort (Figure 2) kernel taken from CUDA SDK 2.0 [9]</text>
<text top="177" left="476" width="359" height="12" font="3">sorts values’s elements in an ascending order. The steps taken</text>
<text top="192" left="476" width="359" height="12" font="3">in this kernel to improve performance (coalescing global memory</text>
<text top="206" left="476" width="359" height="12" font="3">accesses, minimizing bank conﬂicts, avoiding redundant barriers,</text>
<text top="221" left="476" width="359" height="12" font="3">and better address generation through bit operations) unfortunately</text>
<text top="236" left="476" width="359" height="12" font="3">end up obfuscating the code. Manual testing or random input-</text>
<text top="251" left="476" width="359" height="12" font="3">based testing does not ensure sufﬁcient coverage. Instead, given</text>
<text top="266" left="476" width="359" height="12" font="3">a post-condition pertaining to the sortedness of the output array,</text>
<text top="282" left="476" width="39" height="11" font="2">GKLEE</text>
<text top="281" left="519" width="315" height="12" font="3">generates targeted tests that help exercise all conditional-</text>
<text top="296" left="476" width="252" height="12" font="3">guarded ﬂows. Also, running this kernel under</text>
<text top="297" left="732" width="39" height="11" font="2">GKLEE</text>
<text top="296" left="775" width="60" height="12" font="3">by keeping</text>
<text top="311" left="476" width="359" height="12" font="3">all conﬁguration parameters symbolic, we could learn (through</text>
<text top="327" left="476" width="39" height="11" font="2">GKLEE</text>
<text top="326" left="515" width="319" height="12" font="3">’s error message) that this kernel works only if bdim.x is</text>
<text top="341" left="476" width="202" height="12" font="3">a power of 2 (an undocumented fact).</text>
<text top="356" left="493" width="341" height="12" font="3">Covering all control-ﬂow branches can result in too many tests.</text>
<text top="372" left="476" width="39" height="11" font="2">GKLEE</text>
<text top="371" left="519" width="315" height="12" font="3">includes heuristics for test-case minimization, as detailed</text>
<text top="386" left="476" width="33" height="12" font="3">in § 4.</text>
<text top="420" left="476" width="203" height="10" font="2">__shared__ unsigned shared[NUM];</text>
<text top="447" left="476" width="267" height="10" font="2">inline void swap(unsigned&amp; a, unsigned&amp; b)</text>
<text top="460" left="476" width="6" height="10" font="2">{</text>
<text top="460" left="495" width="222" height="10" font="2">unsigned tmp = a; a = b; b = tmp; }</text>
<text top="487" left="476" width="311" height="10" font="2">__global__ void BitonicKernel(unsigned* values) {</text>
<text top="501" left="476" width="13" height="10" font="2">1:</text>
<text top="501" left="507" width="159" height="10" font="2">unsigned int tid = tid.x;</text>
<text top="514" left="476" width="13" height="10" font="2">2:</text>
<text top="514" left="507" width="178" height="10" font="2">// Copy input to shared mem.</text>
<text top="528" left="476" width="13" height="10" font="2">3:</text>
<text top="528" left="507" width="165" height="10" font="2">shared[tid] = values[tid];</text>
<text top="541" left="476" width="13" height="10" font="2">4:</text>
<text top="541" left="507" width="102" height="10" font="2">__syncthreads();</text>
<text top="554" left="476" width="13" height="10" font="2">5:</text>
<text top="568" left="476" width="13" height="10" font="2">6:</text>
<text top="568" left="507" width="159" height="10" font="2">// Parallel bitonic sort.</text>
<text top="581" left="476" width="13" height="10" font="2">7:</text>
<text top="581" left="507" width="260" height="10" font="2">for (unsigned k = 2; k &lt;= bdim.x; k *= 2)</text>
<text top="595" left="476" width="13" height="10" font="2">8:</text>
<text top="595" left="520" width="260" height="10" font="2">for (unsigned j = k / 2; j &gt; 0; j /= 2) {</text>
<text top="608" left="476" width="13" height="10" font="2">9:</text>
<text top="608" left="533" width="146" height="10" font="2">unsigned ixj = tid ^ j;</text>
<text top="622" left="476" width="19" height="10" font="2">10:</text>
<text top="622" left="533" width="102" height="10" font="2">if (ixj &gt; tid) {</text>
<text top="635" left="476" width="19" height="10" font="2">11:</text>
<text top="635" left="545" width="121" height="10" font="2">if ((tid &amp; k) == 0)</text>
<text top="649" left="476" width="19" height="10" font="2">12:</text>
<text top="649" left="558" width="191" height="10" font="2">if (shared[tid] &gt; shared[ixj])</text>
<text top="662" left="476" width="19" height="10" font="2">13:</text>
<text top="662" left="571" width="197" height="10" font="2">swap(shared[tid], shared[ixj]);</text>
<text top="675" left="476" width="19" height="10" font="2">14:</text>
<text top="675" left="545" width="25" height="10" font="2">else</text>
<text top="689" left="476" width="19" height="10" font="2">15:</text>
<text top="689" left="558" width="191" height="10" font="2">if (shared[tid] &lt; shared[ixj])</text>
<text top="702" left="476" width="19" height="10" font="2">16:</text>
<text top="702" left="571" width="197" height="10" font="2">swap(shared[tid], shared[ixj]);</text>
<text top="716" left="476" width="19" height="10" font="2">17:</text>
<text top="716" left="533" width="6" height="10" font="2">}</text>
<text top="729" left="476" width="19" height="10" font="2">18:</text>
<text top="729" left="533" width="102" height="10" font="2">__syncthreads();</text>
<text top="743" left="476" width="19" height="10" font="2">19:</text>
<text top="743" left="520" width="6" height="10" font="2">}</text>
<text top="756" left="476" width="19" height="10" font="2">20:</text>
<text top="770" left="476" width="19" height="10" font="2">21:</text>
<text top="770" left="507" width="102" height="10" font="2">// Write result.</text>
<text top="783" left="476" width="19" height="10" font="2">22:</text>
<text top="783" left="507" width="165" height="10" font="2">values[tid] = shared[tid];</text>
<text top="797" left="476" width="6" height="10" font="2">}</text>
<text top="815" left="561" width="187" height="12" font="3">Figure 2. The Bitonic Sort Kernel</text>
<text top="874" left="476" width="12" height="15" font="1">3.</text>
<text top="874" left="504" width="288" height="15" font="1">Algorithms for Analysis, Test Generation</text>
<text top="897" left="476" width="151" height="12" font="3">Given a C++ program, the</text>
<text top="898" left="632" width="39" height="11" font="2">GKLEE</text>
<text top="897" left="677" width="158" height="12" font="3">VM (Figure 1) executes the</text>
<text top="912" left="476" width="359" height="12" font="3">following steps, in order, for each control-ﬂow path pursued during</text>
<text top="927" left="476" width="359" height="12" font="3">execution (to a ﬁrst approximation, one can think of a control-ﬂow</text>
<text top="942" left="476" width="359" height="12" font="3">tree and imagine all the following steps occurring for each tree path</text>
<text top="957" left="476" width="359" height="12" font="3">and for each barrier interval along the path). Deadlock checking</text>
<text top="971" left="476" width="359" height="12" font="3">and test generation occur per path (spanning barrier intervals; the</text>
<text top="986" left="476" width="257" height="12" font="3">notion of barrier intervals is explained in § 3.2).</text>
<text top="987" left="736" width="39" height="11" font="2">GKLEE</text>
<text top="986" left="778" width="56" height="12" font="3">checks for</text>
<text top="1001" left="476" width="359" height="12" font="3">barriers being textually aligned and applies a canonical schedule</text>
<text top="1016" left="476" width="299" height="12" font="3">going from one textually aligned barrier to another one.</text>
<text top="1039" left="483" width="6" height="11" font="2">•</text>
<text top="1040" left="495" width="339" height="12" font="3">Create the GPU memory objects as per state model; infer mem-</text>
<text top="1055" left="495" width="317" height="12" font="3">ory regions representing GPU memory dynamically (§ 3.1)</text>
<text top="1075" left="483" width="6" height="11" font="2">•</text>
<text top="1076" left="495" width="337" height="12" font="3">Execute GPU kernel threads via the canonical schedule (§ 3.2)</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="6" size="5" family="Times" color="#000000"/>
<text top="110" left="89" width="6" height="11" font="2">•</text>
<text top="111" left="100" width="339" height="12" font="3">Fork new states upon non-determinism due to symbolic values,</text>
<text top="126" left="100" width="328" height="12" font="3">apply search heuristics and path reduction if needed (§ 2.2.4)</text>
<text top="146" left="89" width="6" height="11" font="2">•</text>
<text top="147" left="100" width="339" height="12" font="3">In a state, at the end of the barrier interval or other synchro-</text>
<text top="162" left="100" width="339" height="12" font="3">nization points, perform checks for data races, warp divergence,</text>
<text top="177" left="100" width="317" height="12" font="3">bank conﬂicts, and non-coalesced memory accesses (§ 3.2)</text>
<text top="196" left="89" width="6" height="11" font="2">•</text>
<text top="198" left="100" width="339" height="12" font="3">When execution path ends, report deadlocks and global mem-</text>
<text top="212" left="100" width="339" height="12" font="3">ory races (if any), perform test-case selection, and write out a</text>
<text top="227" left="100" width="117" height="12" font="3">concrete test ﬁle (§ 4)</text>
<text top="253" left="81" width="17" height="12" font="3">3.1</text>
<text top="253" left="111" width="39" height="12" font="3">LLVM</text>
<text top="258" left="150" width="23" height="8" font="4">cuda</text>
<text top="274" left="81" width="359" height="12" font="3">The front-end compiles a C/C++ kernel program into LLVM byte-</text>
<text top="289" left="81" width="359" height="12" font="3">code with extensions for CUDA. Figure 3 shows an excerpt of its</text>
<text top="304" left="81" width="359" height="12" font="3">syntax. One main extension is that a variable is attached with its</text>
<text top="319" left="81" width="272" height="12" font="3">memory sort indicating which memory it refers to.</text>
<text top="353" left="108" width="6" height="11" font="2">τ</text>
<text top="353" left="166" width="13" height="11" font="2">:=</text>
<text top="353" left="194" width="21" height="11" font="2">τ , τ</text>
<text top="357" left="215" width="4" height="8" font="4">l</text>
<text top="353" left="219" width="11" height="11" font="2">, τ</text>
<text top="357" left="231" width="5" height="8" font="4">s</text>
<text top="353" left="237" width="11" height="11" font="2">, τ</text>
<text top="357" left="248" width="6" height="8" font="4">d</text>
<text top="353" left="254" width="11" height="11" font="2">, τ</text>
<text top="357" left="266" width="7" height="8" font="4">h</text>
<text top="353" left="302" width="61" height="11" font="2">memory sort</text>
<text top="367" left="108" width="19" height="11" font="2">var</text>
<text top="367" left="166" width="13" height="11" font="2">:=</text>
<text top="367" left="194" width="19" height="11" font="2">var</text>
<text top="371" left="213" width="23" height="8" font="4">cuda</text>
<text top="366" left="241" width="30" height="11" font="2">| v : τ</text>
<text top="367" left="302" width="38" height="11" font="2">variable</text>
<text top="380" left="108" width="19" height="11" font="2">var</text>
<text top="384" left="127" width="23" height="8" font="4">cuda</text>
<text top="380" left="166" width="13" height="11" font="2">:=</text>
<text top="380" left="194" width="58" height="11" font="2">tid, bid, . . .</text>
<text top="380" left="302" width="71" height="11" font="2">CUDA built-in</text>
<text top="394" left="108" width="16" height="11" font="2">lab</text>
<text top="394" left="166" width="13" height="11" font="2">:=</text>
<text top="394" left="194" width="4" height="11" font="2">l</text>
<text top="397" left="198" width="5" height="8" font="4">1</text>
<text top="394" left="204" width="9" height="11" font="2">, l</text>
<text top="397" left="214" width="5" height="8" font="4">2</text>
<text top="394" left="220" width="20" height="11" font="2">, . . .</text>
<text top="394" left="302" width="23" height="11" font="2">label</text>
<text top="407" left="108" width="6" height="11" font="2">e</text>
<text top="407" left="166" width="13" height="11" font="2">:=</text>
<text top="407" left="194" width="38" height="11" font="2">var | n</text>
<text top="407" left="302" width="86" height="11" font="2">atomic expression</text>
<text top="420" left="108" width="28" height="11" font="2">instr</text>
<text top="420" left="166" width="13" height="11" font="2">:=</text>
<text top="420" left="194" width="72" height="11" font="2">br v lab1 lab2</text>
<text top="421" left="302" width="89" height="11" font="2">conditional branch</text>
<text top="433" left="171" width="4" height="11" font="2">|</text>
<text top="434" left="194" width="31" height="11" font="2">br lab</text>
<text top="434" left="302" width="93" height="11" font="2">unconditional jump</text>
<text top="447" left="171" width="4" height="11" font="2">|</text>
<text top="448" left="194" width="50" height="10" font="2">store e v</text>
<text top="448" left="302" width="23" height="11" font="2">store</text>
<text top="460" left="171" width="4" height="11" font="2">|</text>
<text top="461" left="194" width="58" height="11" font="2">v = load v</text>
<text top="461" left="302" width="21" height="11" font="2">load</text>
<text top="474" left="171" width="4" height="11" font="2">|</text>
<text top="474" left="194" width="73" height="11" font="2">v = binop e e</text>
<text top="474" left="302" width="79" height="11" font="2">binary operation</text>
<text top="487" left="171" width="4" height="11" font="2">|</text>
<text top="488" left="194" width="75" height="11" font="2">v = alloc n τ</text>
<text top="488" left="302" width="90" height="11" font="2">memory allocation</text>
<text top="501" left="171" width="4" height="11" font="2">|</text>
<text top="501" left="194" width="93" height="11" font="2">v = getelptr v e</text>
<text top="501" left="302" width="91" height="11" font="2">address calculation</text>
<text top="514" left="171" width="4" height="11" font="2">|</text>
<text top="516" left="194" width="25" height="10" font="2">sync</text>
<text top="515" left="302" width="111" height="11" font="2">synchronization barrier</text>
<text top="547" left="147" width="150" height="12" font="3">Figure 3. Syntax of LLVM</text>
<text top="552" left="297" width="23" height="8" font="4">cuda</text>
<text top="547" left="325" width="48" height="12" font="3">(excerpt)</text>
<text top="575" left="99" width="314" height="12" font="3">Figure 4 gives a small-step operational semantics of LLVM</text>
<text top="580" left="415" width="23" height="8" font="4">cuda</text>
<text top="590" left="81" width="359" height="12" font="3">using the following elements. A program is a map from labels to</text>
<text top="605" left="81" width="359" height="12" font="3">instructions; a value consists of one or more bytes (our model has</text>
<text top="620" left="81" width="359" height="12" font="3">byte-level accuracy); a memory or store maps variables to values,</text>
<text top="635" left="81" width="359" height="12" font="3">where each variable is assigned an integer address by the compiler.</text>
<text top="651" left="81" width="39" height="11" font="2">GKLEE</text>
<text top="650" left="124" width="315" height="12" font="3">models CUDA’s memory hierarchy in a symbolic state as</text>
<text top="665" left="81" width="359" height="12" font="3">in Figure 5: each thread has its own local memory and stack (we</text>
<text top="680" left="81" width="227" height="12" font="3">combine them into a single local state in</text>
<text top="681" left="312" width="39" height="11" font="2">GKLEE</text>
<text top="680" left="352" width="88" height="12" font="3">); the threads in</text>
<text top="695" left="81" width="359" height="12" font="3">a block shares the shared memory; and all blocks share the device</text>
<text top="710" left="81" width="359" height="12" font="3">memory and the CPU memory. Each thread has a program counter</text>
<text top="725" left="81" width="266" height="12" font="3">(pc) recording the label of the current instruction.</text>
<text top="755" left="126" width="41" height="11" font="2">Program</text>
<text top="755" left="221" width="13" height="11" font="2">:=</text>
<text top="758" left="249" width="89" height="10" font="2">L ⊂ lab → instr</text>
<text top="769" left="126" width="27" height="11" font="2">Value</text>
<text top="769" left="221" width="13" height="11" font="2">:=</text>
<text top="772" left="249" width="51" height="10" font="2">V ⊂ byte</text>
<text top="767" left="300" width="8" height="8" font="4">+</text>
<text top="782" left="126" width="72" height="11" font="2">Memory, Store</text>
<text top="782" left="221" width="13" height="11" font="2">:=</text>
<text top="782" left="249" width="78" height="12" font="2">M ⊂ var → V</text>
<text top="796" left="126" width="58" height="11" font="2">Shared state</text>
<text top="796" left="221" width="13" height="11" font="2">:=</text>
<text top="798" left="249" width="144" height="10" font="2">M ⊂ (bid → M ) × M × M</text>
<text top="809" left="126" width="52" height="11" font="2">Local state</text>
<text top="809" left="221" width="13" height="11" font="2">:=</text>
<text top="809" left="249" width="72" height="12" font="2">σ ⊂ var → V</text>
<text top="823" left="126" width="49" height="11" font="2">Data State</text>
<text top="823" left="221" width="13" height="11" font="2">:=</text>
<text top="823" left="249" width="106" height="12" font="2">Σ ⊂ (tid → σ) × M</text>
<text top="836" left="126" width="80" height="11" font="2">Program counter</text>
<text top="836" left="221" width="13" height="11" font="2">:=</text>
<text top="839" left="249" width="76" height="10" font="2">P ⊂ tid → lab</text>
<text top="850" left="126" width="24" height="11" font="2">State</text>
<text top="850" left="221" width="13" height="11" font="2">:=</text>
<text top="850" left="249" width="58" height="12" font="2">Φ ⊂ Σ × P</text>
<text top="874" left="99" width="341" height="14" font="3">A state Φ consists of a data state Σ and a PC P. Thread t’s pc</text>
<text top="889" left="81" width="204" height="14" font="3">is given by P[t]. Notations Σ[v] and</text>
<text top="890" left="290" width="56" height="11" font="2">Σ[v → k]</text>
<text top="889" left="352" width="88" height="12" font="3">indicate reading</text>
<text top="904" left="81" width="359" height="12" font="3">v’s value from Σ and updating v’s value in Σ to k respectively.</text>
<text top="919" left="81" width="60" height="12" font="3">Notation Σ</text>
<text top="919" left="158" width="176" height="12" font="3">e evaluates e’s value over Σ, e.g.</text>
<text top="920" left="337" width="9" height="11" font="2">Σ</text>
<text top="920" left="362" width="6" height="11" font="2">e</text>
<text top="923" left="368" width="5" height="8" font="4">1</text>
<text top="920" left="377" width="19" height="11" font="2">= e</text>
<text top="923" left="397" width="5" height="8" font="4">2</text>
<text top="919" left="406" width="33" height="12" font="3">is true</text>
<text top="934" left="81" width="8" height="12" font="3">if</text>
<text top="935" left="93" width="19" height="11" font="2">Σ[e</text>
<text top="938" left="112" width="5" height="8" font="4">1</text>
<text top="935" left="118" width="42" height="11" font="2">] = Σ[e</text>
<text top="938" left="160" width="5" height="8" font="4">2</text>
<text top="935" left="166" width="4" height="11" font="2">]</text>
<text top="934" left="169" width="270" height="12" font="3">. The semantics of an instruction is modeled by a</text>
<text top="949" left="81" width="359" height="12" font="3">state transition, e.g. the execution of an instruction br l’ at thread</text>
<text top="963" left="81" width="359" height="12" font="3">t updates the t’s pc to l and keeps the data state unchanged. Rule</text>
<text top="979" left="81" width="359" height="12" font="3">9 speciﬁes the barrier’s semantics: a thread can proceed to the next</text>
<text top="993" left="81" width="359" height="12" font="3">instruction only after all the threads in the same block have reached</text>
<text top="1008" left="81" width="359" height="12" font="3">the barrier. As indicated by other rules, non-barrier instructions are</text>
<text top="1023" left="81" width="359" height="12" font="3">executed without synchronizing with other threads (except for lock-</text>
<text top="1038" left="81" width="218" height="12" font="3">step requirement for intra-warp threads).</text>
<text top="1061" left="81" width="91" height="12" font="3">Memory Typing.</text>
<text top="1061" left="186" width="254" height="12" font="3">After a source program is compiled into LLVM</text>
<text top="1076" left="81" width="359" height="12" font="3">bytecode, it is difﬁcult to determine which memory is used when an</text>
<text top="118" left="477" width="12" height="15" font="1">1.</text>
<text top="116" left="527" width="52" height="10" font="2">L[l]=br l</text>
<text top="127" left="497" width="32" height="12" font="2">(Σ, P)</text>
<text top="123" left="528" width="13" height="15" font="1">−</text>
<text top="123" left="528" width="16" height="15" font="1">→</text>
<text top="132" left="545" width="4" height="7" font="6">t</text>
<text top="127" left="550" width="64" height="12" font="2">(Σ, P[t→l ])</text>
<text top="152" left="477" width="12" height="15" font="1">2.</text>
<text top="149" left="497" width="62" height="10" font="2">L[l]=br v l</text>
<text top="152" left="559" width="4" height="6" font="6">1</text>
<text top="147" left="568" width="6" height="10" font="2">l</text>
<text top="152" left="574" width="4" height="6" font="6">2</text>
<text top="147" left="595" width="9" height="11" font="2">Σ</text>
<text top="147" left="619" width="6" height="11" font="2">v</text>
<text top="160" left="502" width="32" height="12" font="2">(Σ, P)</text>
<text top="156" left="534" width="13" height="15" font="1">−</text>
<text top="156" left="534" width="16" height="15" font="1">→</text>
<text top="165" left="550" width="4" height="7" font="6">t</text>
<text top="160" left="555" width="51" height="12" font="2">(Σ, P[t→l</text>
<text top="165" left="606" width="5" height="7" font="6">1</text>
<text top="160" left="612" width="8" height="11" font="2">])</text>
<text top="149" left="646" width="62" height="10" font="2">L[l]=br v l</text>
<text top="152" left="708" width="4" height="6" font="6">1</text>
<text top="147" left="717" width="6" height="10" font="2">l</text>
<text top="152" left="723" width="4" height="6" font="6">2</text>
<text top="147" left="744" width="9" height="11" font="2">Σ</text>
<text top="146" left="768" width="15" height="11" font="2">¬v</text>
<text top="160" left="655" width="32" height="12" font="2">(Σ, P)</text>
<text top="156" left="687" width="13" height="15" font="1">−</text>
<text top="156" left="687" width="16" height="15" font="1">→</text>
<text top="165" left="703" width="4" height="7" font="6">t</text>
<text top="160" left="708" width="51" height="12" font="2">(Σ, P[t→l</text>
<text top="165" left="760" width="5" height="7" font="6">2</text>
<text top="160" left="766" width="8" height="11" font="2">])</text>
<text top="185" left="477" width="12" height="15" font="1">3.</text>
<text top="182" left="537" width="108" height="10" font="2">L[l]=(v=alloc n τ )</text>
<text top="194" left="497" width="32" height="12" font="2">(Σ, P)</text>
<text top="190" left="528" width="13" height="15" font="1">−</text>
<text top="190" left="528" width="16" height="15" font="1">→</text>
<text top="198" left="545" width="4" height="7" font="6">t</text>
<text top="194" left="550" width="64" height="11" font="2">(Σ[(v:τ )→0</text>
<text top="193" left="614" width="7" height="7" font="6">n</text>
<text top="194" left="621" width="66" height="12" font="2">], P[t→l+1])</text>
<text top="218" left="477" width="12" height="15" font="1">4.</text>
<text top="216" left="539" width="40" height="10" font="2">L[l]=(v</text>
<text top="218" left="578" width="5" height="7" font="6">2</text>
<text top="213" left="584" width="71" height="11" font="2">=getelptr v</text>
<text top="218" left="655" width="5" height="7" font="6">1</text>
<text top="213" left="661" width="25" height="11" font="2">:τ e)</text>
<text top="227" left="497" width="32" height="12" font="2">(Σ, P)</text>
<text top="223" left="528" width="13" height="15" font="1">−</text>
<text top="223" left="528" width="16" height="15" font="1">→</text>
<text top="232" left="545" width="4" height="7" font="6">t</text>
<text top="227" left="550" width="24" height="11" font="2">(Σ[v</text>
<text top="232" left="574" width="5" height="7" font="6">2</text>
<text top="227" left="579" width="42" height="11" font="2">:τ →Σ[v</text>
<text top="232" left="622" width="5" height="7" font="6">1</text>
<text top="227" left="627" width="101" height="12" font="2">]+Σ[e]], P[t→l+1])</text>
<text top="252" left="477" width="12" height="15" font="1">5.</text>
<text top="249" left="560" width="92" height="10" font="2">L[l]=(v=binop e</text>
<text top="251" left="651" width="5" height="7" font="6">1</text>
<text top="247" left="657" width="21" height="11" font="2">:τ e</text>
<text top="251" left="678" width="5" height="7" font="6">2</text>
<text top="247" left="683" width="18" height="11" font="2">:τ )</text>
<text top="261" left="497" width="32" height="12" font="2">(Σ, P)</text>
<text top="257" left="528" width="13" height="15" font="1">−</text>
<text top="257" left="528" width="16" height="15" font="1">→</text>
<text top="265" left="545" width="4" height="7" font="6">t</text>
<text top="261" left="550" width="103" height="11" font="2">(Σ[v:τ →binop(Σ[e</text>
<text top="265" left="653" width="5" height="7" font="6">1</text>
<text top="261" left="658" width="26" height="11" font="2">],Σ[e</text>
<text top="265" left="684" width="5" height="7" font="6">2</text>
<text top="261" left="690" width="74" height="12" font="2">])], P[t→l+1])</text>
<text top="285" left="477" width="12" height="15" font="1">6.</text>
<text top="283" left="520" width="40" height="10" font="2">L[l]=(v</text>
<text top="285" left="560" width="5" height="7" font="6">2</text>
<text top="280" left="566" width="46" height="11" font="2">=load v</text>
<text top="285" left="611" width="5" height="7" font="6">1</text>
<text top="280" left="617" width="15" height="11" font="2">:τ )</text>
<text top="280" left="649" width="23" height="11" font="2">τ =τ</text>
<text top="294" left="497" width="32" height="12" font="2">(Σ, P)</text>
<text top="290" left="528" width="13" height="15" font="1">−</text>
<text top="290" left="528" width="16" height="15" font="1">→</text>
<text top="298" left="545" width="4" height="7" font="6">t</text>
<text top="294" left="550" width="24" height="11" font="2">(Σ[v</text>
<text top="298" left="574" width="5" height="7" font="6">2</text>
<text top="294" left="579" width="44" height="11" font="2">:τ →Σ[v</text>
<text top="298" left="624" width="5" height="7" font="6">1</text>
<text top="294" left="630" width="69" height="12" font="2">]], P[t→l+1])</text>
<text top="318" left="477" width="12" height="15" font="1">7.</text>
<text top="316" left="519" width="101" height="10" font="2">L[l]=(store e v:τ )</text>
<text top="313" left="637" width="23" height="11" font="2">τ =τ</text>
<text top="327" left="497" width="32" height="12" font="2">(Σ, P)</text>
<text top="323" left="528" width="13" height="15" font="1">−</text>
<text top="323" left="528" width="16" height="15" font="1">→</text>
<text top="332" left="545" width="4" height="7" font="6">t</text>
<text top="327" left="550" width="135" height="12" font="2">(Σ[v:τ →Σ[e]], P[t→l+1])</text>
<text top="352" left="477" width="12" height="15" font="1">8.</text>
<text top="347" left="497" width="16" height="11" font="2">v:τ</text>
<text top="347" left="533" width="89" height="11" font="2">((v :τ )→k) ∈ Σ</text>
<text top="347" left="638" width="9" height="11" font="2">Σ</text>
<text top="347" left="662" width="112" height="11" font="2">v ≤v≤v +sizeof(k)</text>
<text top="360" left="625" width="16" height="11" font="2">v:τ</text>
<text top="382" left="477" width="12" height="15" font="1">9.</text>
<text top="379" left="497" width="54" height="10" font="2">L[l]=sync</text>
<text top="376" left="567" width="157" height="13" font="2">∀t ∈blk of(t) : P[t ]∈{l,l+1}</text>
<text top="391" left="546" width="32" height="12" font="2">(Σ, P)</text>
<text top="387" left="577" width="13" height="15" font="1">−</text>
<text top="387" left="577" width="16" height="15" font="1">→</text>
<text top="395" left="594" width="4" height="7" font="6">t</text>
<text top="391" left="599" width="76" height="12" font="2">(Σ, P[t→l+1])</text>
<text top="425" left="501" width="233" height="12" font="3">Figure 4. Operational semantics of LLVM</text>
<text top="430" left="733" width="23" height="8" font="4">cuda</text>
<text top="425" left="761" width="48" height="12" font="3">(excerpt)</text>
<text top="588" left="536" width="238" height="12" font="3">Figure 5. Components in a Symbolic State.</text>
<text top="619" left="476" width="359" height="12" font="3">access is made because the address of this access may be calculated</text>
<text top="634" left="476" width="359" height="12" font="3">by multiple bytecode instructions. We employ a novel and simple</text>
<text top="649" left="476" width="359" height="12" font="3">GPU-speciﬁc memory sort inference method by computing for</text>
<text top="664" left="476" width="355" height="12" font="3">each (possibly symbolic) expression a sort τ which is either τ</text>
<text top="679" left="476" width="72" height="12" font="3">(unknown), τ</text>
<text top="684" left="547" width="4" height="8" font="4">l</text>
<text top="679" left="555" width="48" height="12" font="3">(local), τ</text>
<text top="684" left="604" width="5" height="8" font="4">s</text>
<text top="679" left="613" width="57" height="12" font="3">(shared), τ</text>
<text top="684" left="671" width="6" height="8" font="4">d</text>
<text top="679" left="681" width="72" height="12" font="3">(device), or τ</text>
<text top="684" left="753" width="7" height="8" font="4">h</text>
<text top="679" left="764" width="71" height="12" font="3">(host), as per</text>
<text top="694" left="476" width="359" height="12" font="3">the rules (here we present the simpliﬁed version) in Figure 4. In our</text>
<text top="709" left="476" width="359" height="12" font="3">experience, these rules have been found to be sufﬁciently precise on</text>
<text top="724" left="476" width="166" height="12" font="3">all the kernels we have applied</text>
<text top="725" left="644" width="39" height="11" font="2">GKLEE</text>
<text top="724" left="687" width="14" height="12" font="3">to.</text>
<text top="739" left="493" width="341" height="12" font="3">For example, Rule 4 models getelptr which refers to pointer</text>
<text top="754" left="476" width="122" height="12" font="3">dereferencing where v</text>
<text top="758" left="598" width="5" height="8" font="4">2</text>
<text top="754" left="604" width="143" height="12" font="3">’s type is obtained from v</text>
<text top="758" left="747" width="5" height="8" font="4">1</text>
<text top="754" left="753" width="81" height="12" font="3">’s type. Rule 6</text>
<text top="769" left="476" width="359" height="12" font="3">indicates that a load instruction can be executed only if the address</text>
<text top="784" left="476" width="359" height="12" font="3">type is known; and the value loaded from memory has unknown</text>
<text top="799" left="476" width="359" height="12" font="3">type. Rule 8 says that a valid type is found for v if there exists a</text>
<text top="814" left="476" width="359" height="12" font="3">memory object associated with v such that v’s value falls within</text>
<text top="829" left="476" width="359" height="12" font="3">this object. Basically it searches the memory hierarchy to locate</text>
<text top="844" left="476" width="359" height="12" font="3">the target memory when the previous analysis fails to ﬁnd v’s</text>
<text top="858" left="476" width="359" height="12" font="3">type. If v represents a pointer which can refer to multiple objects</text>
<text top="873" left="476" width="359" height="12" font="3">(determined by SMT solving), then multiple states are generated,</text>
<text top="888" left="476" width="359" height="12" font="3">each of which needs to apply this rule. This often reveals memory</text>
<text top="903" left="476" width="359" height="12" font="3">type related bugs in the source kernel, e.g. mixing up the CPU</text>
<text top="918" left="476" width="359" height="12" font="3">and GPU memory. We plan to use Clang’s ongoing support for</text>
<text top="933" left="476" width="359" height="12" font="3">LLVM+CUDA [12] to simplify such inference. More semantics</text>
<text top="948" left="476" width="253" height="12" font="3">rules (with sort inference) are available in [13].</text>
<text top="971" left="476" width="207" height="12" font="3">State Model. In a symbolic state in</text>
<text top="973" left="688" width="39" height="11" font="2">GKLEE</text>
<text top="972" left="728" width="107" height="12" font="3">, each thread (in a</text>
<text top="987" left="476" width="359" height="12" font="3">block) has its own stack and local memory; each block has a shared</text>
<text top="1001" left="476" width="359" height="12" font="3">memory; all blocks can access the device memory in the GPU and</text>
<text top="1016" left="476" width="359" height="12" font="3">the main memory in the CPU. Figure 5 gives an example state for</text>
<text top="1031" left="476" width="359" height="12" font="3">a GPU with grid size n × m and block size 32 × i. Each block</text>
<text top="1046" left="476" width="359" height="12" font="3">consists of i of warps; each warp contains 32 threads. To support</text>
<text top="1061" left="476" width="359" height="12" font="3">test generation, a state also contains a path condition recording the</text>
<text top="1076" left="476" width="176" height="12" font="3">branching decisions made so far.</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="81" width="359" height="12" font="3">CUDA Built-in Variables. CUDA built-in variables include the</text>
<text top="124" left="81" width="359" height="12" font="3">block size, block id, thread id, and so on, The executor accesses</text>
<text top="138" left="81" width="196" height="12" font="3">these variables during the execution.</text>
<text top="139" left="280" width="39" height="11" font="2">GKLEE</text>
<text top="138" left="322" width="117" height="12" font="3">sets their values in re-</text>
<text top="151" left="81" width="359" height="12" font="3">spective memories before the execution. For example, the variable</text>
<text top="165" left="81" width="359" height="12" font="3">for the thread id, tid, is assigned three 32 bit words in the local</text>
<text top="178" left="81" width="359" height="12" font="3">memory of each thread. These words record the tid’s values in di-</text>
<text top="192" left="81" width="174" height="12" font="3">mension x, y and z respectively.</text>
<text top="216" left="208" width="28" height="11" font="2">tid : τ</text>
<text top="220" left="235" width="4" height="8" font="4">l</text>
<text top="216" left="255" width="26" height="11" font="2">(96b)</text>
<text top="216" left="324" width="13" height="11" font="2">. . .</text>
<text top="229" left="182" width="124" height="12" font="2">{x : 32b, y : 32b, z : 32b}</text>
<text top="230" left="324" width="13" height="11" font="2">. . .</text>
<text top="260" left="81" width="17" height="12" font="3">3.2</text>
<text top="260" left="111" width="240" height="12" font="3">Canonical Scheduling and Race Checking</text>
<text top="281" left="81" width="359" height="12" font="3">We now focus on the interleavings of all the threads within a thread</text>
<text top="296" left="81" width="359" height="12" font="3">block from one barrier call to another (global memory accesses</text>
<text top="311" left="81" width="359" height="12" font="3">across thread blocks are discussed later). Naively interleaving these</text>
<text top="326" left="81" width="359" height="12" font="3">threads will result in an astronomical number of interleavings.</text>
<text top="342" left="81" width="39" height="11" font="2">GKLEE</text>
<text top="341" left="124" width="288" height="12" font="3">employs the following schedule generation approach:</text>
<text top="364" left="89" width="6" height="11" font="2">•</text>
<text top="365" left="100" width="339" height="12" font="3">Pursue just one schedule, namely the canonical schedule shown</text>
<text top="380" left="100" width="339" height="12" font="3">in Figure 6 where each thread is fully executed within a barrier</text>
<text top="395" left="100" width="237" height="12" font="3">interval before moving on to another thread.</text>
<text top="415" left="89" width="6" height="11" font="2">•</text>
<text top="416" left="100" width="339" height="12" font="3">During the execution of all the threads in the current barrier</text>
<text top="431" left="100" width="339" height="12" font="3">interval, build a read-set R and a write set W, recording in</text>
<text top="446" left="100" width="339" height="12" font="3">them (respectively) all loads and stores (these will be in mixed</text>
<text top="461" left="100" width="294" height="12" font="3">symbolic/concrete form) encountered in the execution.</text>
<text top="481" left="89" width="6" height="11" font="2">•</text>
<text top="482" left="100" width="339" height="12" font="3">After the check points (as shown in Figure 6), build all possible</text>
<text top="497" left="100" width="157" height="12" font="3">conﬂict pairs, where a pair r</text>
<text top="501" left="257" width="5" height="8" font="4">1</text>
<text top="497" left="264" width="16" height="12" font="3">, w</text>
<text top="501" left="280" width="5" height="8" font="4">1</text>
<text top="497" left="294" width="30" height="12" font="3">or w</text>
<text top="501" left="324" width="5" height="8" font="4">2</text>
<text top="497" left="330" width="16" height="12" font="3">, w</text>
<text top="501" left="346" width="5" height="8" font="4">1</text>
<text top="497" left="361" width="79" height="12" font="3">is any pair that</text>
<text top="512" left="100" width="214" height="12" font="3">could potentially race or other conﬂicts.</text>
<text top="531" left="89" width="6" height="11" font="2">•</text>
<text top="533" left="100" width="339" height="12" font="3">Through SMT-solving, decide whether any of these conﬂicts are</text>
<text top="548" left="100" width="339" height="12" font="3">races. If none are races (do not overlap in terms of a memory</text>
<text top="562" left="100" width="339" height="12" font="3">address), then the canonical schedule is equivalent to any other</text>
<text top="577" left="100" width="339" height="12" font="3">schedule. Thus, we can carry on to the next barrier interval with</text>
<text top="592" left="100" width="293" height="12" font="3">the next-state calculated as per the canonical schedule.</text>
<text top="617" left="81" width="359" height="12" font="3">Canonical scheduling is sound for safety properties (will neither</text>
<text top="632" left="81" width="359" height="12" font="3">result in omissions or false alarms). The caveats that go with this</text>
<text top="647" left="81" width="359" height="12" font="3">argument are that C/C++ has no standard shared memory con-</text>
<text top="662" left="81" width="359" height="12" font="3">sistency semantics to deﬁne safe compiler optimizations, and the</text>
<text top="677" left="81" width="359" height="12" font="3">CUDA programming guide [14] provides only an informal charac-</text>
<text top="692" left="81" width="359" height="12" font="3">terization of CUDA’s weak execution semantics. Assume that the</text>
<text top="707" left="81" width="359" height="12" font="3">instructions within CUDA threads in a barrier interval can be re-</text>
<text top="722" left="81" width="359" height="12" font="3">ordered; then under no conﬂicts (DRF), reordering transformations</text>
<text top="737" left="81" width="359" height="12" font="3">are sound [15]. This result also stems from [16] where it is shown</text>
<text top="751" left="81" width="359" height="12" font="3">that race detectors for sequential consistency can detect the earli-</text>
<text top="767" left="81" width="43" height="12" font="3">est race</text>
<text top="766" left="128" width="312" height="12" font="3">even under weak orderings. One can also infer this result</text>
<text top="781" left="81" width="359" height="12" font="3">directly from [17] where it is shown that under the absence of con-</text>
<text top="796" left="81" width="359" height="12" font="3">ﬂict edges, the delay set (set of required program orderings) can</text>
<text top="811" left="81" width="359" height="12" font="3">be empty. We further elaborate on the soundness of the canonical</text>
<text top="826" left="81" width="337" height="12" font="3">scheduling method (also considering SIMD execution) in [13].</text>
<text top="841" left="99" width="341" height="12" font="3">Consider the following two schedules, we record the writes and</text>
<text top="856" left="81" width="57" height="12" font="3">reads on v</text>
<text top="860" left="138" width="5" height="8" font="4">1</text>
<text top="856" left="148" width="30" height="12" font="3">and v</text>
<text top="860" left="178" width="5" height="8" font="4">2</text>
<text top="856" left="184" width="255" height="12" font="3">, and see whether these accesses overlap at the</text>
<text top="871" left="81" width="359" height="12" font="3">end point (the check is denoted by a “!”). A race occurs in schedule</text>
<text top="886" left="81" width="232" height="12" font="3">2 if and only if it also occurs in schedule 1.</text>
<text top="923" left="106" width="67" height="11" font="2">Schedule 1 : ·</text>
<text top="915" left="180" width="11" height="11" font="2">W</text>
<text top="917" left="194" width="6" height="8" font="4">v</text>
<text top="920" left="200" width="5" height="7" font="6">1</text>
<text top="922" left="176" width="10" height="11" font="2">−</text>
<text top="922" left="180" width="24" height="11" font="2">−−−</text>
<text top="922" left="198" width="13" height="11" font="2">→</text>
<text top="926" left="211" width="4" height="8" font="4">t</text>
<text top="929" left="215" width="5" height="7" font="6">1</text>
<text top="922" left="225" width="4" height="11" font="2">·</text>
<text top="915" left="236" width="11" height="11" font="2">W</text>
<text top="917" left="250" width="6" height="8" font="4">v</text>
<text top="920" left="256" width="5" height="7" font="6">2</text>
<text top="922" left="232" width="10" height="11" font="2">−</text>
<text top="922" left="236" width="24" height="11" font="2">−−−</text>
<text top="922" left="254" width="13" height="11" font="2">→</text>
<text top="926" left="267" width="4" height="8" font="4">t</text>
<text top="929" left="271" width="5" height="7" font="6">1</text>
<text top="922" left="281" width="4" height="11" font="2">·</text>
<text top="915" left="295" width="8" height="11" font="2">R</text>
<text top="917" left="306" width="6" height="8" font="4">v</text>
<text top="920" left="311" width="5" height="7" font="6">1</text>
<text top="922" left="291" width="31" height="11" font="2">−−−→</text>
<text top="926" left="323" width="4" height="8" font="4">t</text>
<text top="929" left="327" width="5" height="7" font="6">2</text>
<text top="922" left="337" width="78" height="11" font="2">· → · · · → ·(!)</text>
<text top="944" left="106" width="67" height="11" font="2">Schedule 2 : ·</text>
<text top="936" left="180" width="8" height="11" font="2">R</text>
<text top="938" left="191" width="6" height="8" font="4">v</text>
<text top="941" left="196" width="5" height="7" font="6">1</text>
<text top="943" left="176" width="31" height="11" font="2">−−−→</text>
<text top="947" left="208" width="4" height="8" font="4">t</text>
<text top="950" left="212" width="5" height="7" font="6">2</text>
<text top="943" left="222" width="4" height="11" font="2">·</text>
<text top="936" left="232" width="11" height="11" font="2">W</text>
<text top="938" left="247" width="6" height="8" font="4">v</text>
<text top="941" left="252" width="5" height="7" font="6">2</text>
<text top="943" left="229" width="10" height="11" font="2">−</text>
<text top="943" left="233" width="24" height="11" font="2">−−−</text>
<text top="943" left="251" width="13" height="11" font="2">→</text>
<text top="947" left="264" width="4" height="8" font="4">t</text>
<text top="950" left="268" width="5" height="7" font="6">1</text>
<text top="943" left="278" width="4" height="11" font="2">·</text>
<text top="936" left="292" width="11" height="11" font="2">W</text>
<text top="938" left="306" width="6" height="8" font="4">v</text>
<text top="941" left="311" width="5" height="7" font="6">1</text>
<text top="943" left="288" width="10" height="11" font="2">−</text>
<text top="943" left="292" width="24" height="11" font="2">−−−</text>
<text top="943" left="310" width="13" height="11" font="2">→</text>
<text top="947" left="323" width="4" height="8" font="4">t</text>
<text top="950" left="327" width="5" height="7" font="6">1</text>
<text top="943" left="337" width="78" height="11" font="2">· → · · · → ·(!)</text>
<text top="971" left="81" width="128" height="12" font="3">Intra-warp scheduling.</text>
<text top="972" left="222" width="217" height="12" font="3">A schedule is a sequence of state transi-</text>
<text top="987" left="81" width="359" height="12" font="3">tions made by the threads. The threads within a warp are executed</text>
<text top="1001" left="81" width="359" height="12" font="3">in lock-step manner, and if they diverge on a condition, then one</text>
<text top="1016" left="81" width="359" height="12" font="3">side (e.g. the “then” side) is executed ﬁrst, with the threads in the</text>
<text top="1031" left="81" width="359" height="12" font="3">other side blocked; and then the other side is executed (this is sound</text>
<text top="1046" left="81" width="334" height="12" font="3">after checking for the absence of intra-warp races). (Note that</text>
<text top="1047" left="418" width="21" height="11" font="2">GK-</text>
<text top="1062" left="81" width="22" height="11" font="2">LEE</text>
<text top="1061" left="108" width="332" height="12" font="3">executes LLVM byte-codes, and is therefore able to capture</text>
<text top="1076" left="81" width="200" height="12" font="3">the effect of compiler optimizations.)</text>
<text top="111" left="493" width="11" height="12" font="3">In</text>
<text top="112" left="508" width="39" height="11" font="2">GKLEE</text>
<text top="111" left="547" width="287" height="12" font="3">, we schedule these threads in a lock-step manner, and</text>
<text top="126" left="476" width="359" height="12" font="3">provide an option to not execute the two sides sequentially. Now we</text>
<text top="141" left="476" width="359" height="12" font="3">show that these two scheduling methods are equivalent if no data</text>
<text top="156" left="476" width="351" height="12" font="3">race occurs. Speciﬁcally, the sequence (up to the next joint point)</text>
<text top="183" left="517" width="9" height="11" font="2">Φ</text>
<text top="187" left="526" width="5" height="8" font="4">0</text>
<text top="178" left="539" width="5" height="8" font="4">c</text>
<text top="183" left="535" width="10" height="11" font="2">−</text>
<text top="183" left="537" width="13" height="11" font="2">→</text>
<text top="187" left="549" width="4" height="8" font="4">t</text>
<text top="190" left="554" width="5" height="7" font="6">1</text>
<text top="183" left="564" width="9" height="11" font="2">Φ</text>
<text top="187" left="573" width="5" height="8" font="4">1</text>
<text top="178" left="586" width="5" height="8" font="4">c</text>
<text top="183" left="583" width="10" height="11" font="2">−</text>
<text top="183" left="584" width="13" height="11" font="2">→</text>
<text top="187" left="597" width="4" height="8" font="4">t</text>
<text top="190" left="601" width="5" height="7" font="6">2</text>
<text top="183" left="611" width="15" height="11" font="2">· · ·</text>
<text top="178" left="633" width="5" height="8" font="4">c</text>
<text top="183" left="629" width="10" height="11" font="2">−</text>
<text top="183" left="631" width="13" height="11" font="2">→</text>
<text top="187" left="643" width="4" height="8" font="4">t</text>
<text top="189" left="648" width="7" height="7" font="6">n</text>
<text top="183" left="659" width="9" height="11" font="2">Φ</text>
<text top="187" left="668" width="7" height="8" font="4">n</text>
<text top="178" left="683" width="12" height="8" font="4">¬c</text>
<text top="183" left="679" width="21" height="11" font="2">−−→</text>
<text top="187" left="701" width="4" height="8" font="4">t</text>
<text top="190" left="705" width="5" height="7" font="6">1</text>
<text top="183" left="715" width="15" height="11" font="2">· · ·</text>
<text top="178" left="737" width="12" height="8" font="4">¬c</text>
<text top="183" left="734" width="21" height="11" font="2">−−→</text>
<text top="187" left="755" width="4" height="8" font="4">t</text>
<text top="189" left="759" width="7" height="7" font="6">n</text>
<text top="183" left="771" width="9" height="11" font="2">Φ</text>
<text top="187" left="780" width="12" height="8" font="4">2n</text>
<text top="208" left="476" width="359" height="12" font="3">can be shufﬂed into the following one provided that it is race-free.</text>
<text top="225" left="476" width="41" height="12" font="3">We use</text>
<text top="220" left="525" width="5" height="8" font="4">c</text>
<text top="224" left="521" width="11" height="13" font="3">−</text>
<text top="224" left="522" width="14" height="13" font="3">→</text>
<text top="229" left="535" width="4" height="8" font="4">t</text>
<text top="232" left="540" width="4" height="7" font="6">i</text>
<text top="225" left="550" width="133" height="12" font="3">to indicate that thread t</text>
<text top="229" left="683" width="4" height="8" font="4">i</text>
<text top="225" left="693" width="141" height="12" font="3">makes the transition with</text>
<text top="240" left="476" width="64" height="12" font="3">condition c.</text>
<text top="265" left="506" width="9" height="11" font="2">Φ</text>
<text top="269" left="516" width="5" height="8" font="4">0</text>
<text top="260" left="529" width="5" height="8" font="4">c</text>
<text top="264" left="525" width="10" height="11" font="2">−</text>
<text top="264" left="527" width="13" height="11" font="2">→</text>
<text top="269" left="539" width="4" height="8" font="4">t</text>
<text top="271" left="544" width="5" height="7" font="6">1</text>
<text top="265" left="554" width="9" height="11" font="2">Φ</text>
<text top="269" left="563" width="5" height="8" font="4">1</text>
<text top="260" left="576" width="12" height="8" font="4">¬c</text>
<text top="264" left="573" width="21" height="11" font="2">−−→</text>
<text top="269" left="594" width="4" height="8" font="4">t</text>
<text top="271" left="598" width="5" height="7" font="6">1</text>
<text top="265" left="608" width="9" height="11" font="2">Φ</text>
<text top="271" left="618" width="5" height="8" font="4">2</text>
<text top="260" left="631" width="5" height="8" font="4">c</text>
<text top="264" left="627" width="10" height="11" font="2">−</text>
<text top="264" left="629" width="13" height="11" font="2">→</text>
<text top="269" left="641" width="4" height="8" font="4">t</text>
<text top="271" left="645" width="5" height="7" font="6">2</text>
<text top="264" left="656" width="15" height="11" font="2">· · ·</text>
<text top="260" left="677" width="5" height="8" font="4">c</text>
<text top="264" left="674" width="10" height="11" font="2">−</text>
<text top="264" left="675" width="13" height="11" font="2">→</text>
<text top="269" left="688" width="4" height="8" font="4">t</text>
<text top="271" left="692" width="7" height="7" font="6">n</text>
<text top="265" left="704" width="9" height="11" font="2">Φ</text>
<text top="271" left="713" width="26" height="8" font="4">2n−1</text>
<text top="260" left="747" width="12" height="8" font="4">¬c</text>
<text top="264" left="744" width="21" height="11" font="2">−−→</text>
<text top="269" left="765" width="4" height="8" font="4">t</text>
<text top="271" left="769" width="7" height="7" font="6">n</text>
<text top="265" left="781" width="9" height="11" font="2">Φ</text>
<text top="269" left="790" width="12" height="8" font="4">2n</text>
<text top="290" left="493" width="341" height="12" font="3">Since c exclusive-or (⊕) ¬c holds for a thread, the sequence is</text>
<text top="305" left="476" width="224" height="12" font="3">equivalent to the following one (where Φ</text>
<text top="310" left="699" width="7" height="8" font="4">n</text>
<text top="305" left="712" width="25" height="12" font="3">= Φ</text>
<text top="309" left="737" width="12" height="8" font="4">2n</text>
<text top="305" left="750" width="41" height="12" font="3">) which</text>
<text top="306" left="795" width="39" height="11" font="2">GKLEE</text>
<text top="320" left="476" width="332" height="12" font="3">produces. This is the canonical schedule for intra-warp steps.</text>
<text top="350" left="543" width="9" height="11" font="2">Φ</text>
<text top="353" left="552" width="5" height="8" font="4">0</text>
<text top="345" left="565" width="26" height="8" font="4">c⊕¬c</text>
<text top="349" left="562" width="10" height="11" font="2">−</text>
<text top="349" left="566" width="24" height="11" font="2">−−−</text>
<text top="349" left="584" width="13" height="11" font="2">→</text>
<text top="353" left="597" width="4" height="8" font="4">t</text>
<text top="356" left="601" width="5" height="7" font="6">1</text>
<text top="350" left="611" width="9" height="11" font="2">Φ</text>
<text top="355" left="620" width="5" height="8" font="4">1</text>
<text top="345" left="635" width="26" height="8" font="4">c⊕¬c</text>
<text top="349" left="631" width="10" height="11" font="2">−</text>
<text top="349" left="635" width="24" height="11" font="2">−−−</text>
<text top="349" left="654" width="13" height="11" font="2">→</text>
<text top="353" left="666" width="4" height="8" font="4">t</text>
<text top="356" left="671" width="5" height="7" font="6">2</text>
<text top="349" left="681" width="15" height="11" font="2">· · ·</text>
<text top="345" left="703" width="26" height="8" font="4">c⊕¬c</text>
<text top="349" left="699" width="10" height="11" font="2">−</text>
<text top="349" left="703" width="24" height="11" font="2">−−−</text>
<text top="349" left="721" width="13" height="11" font="2">→</text>
<text top="353" left="734" width="4" height="8" font="4">t</text>
<text top="356" left="738" width="7" height="7" font="6">n</text>
<text top="350" left="750" width="9" height="11" font="2">Φ</text>
<text top="355" left="759" width="7" height="8" font="4">n</text>
<text top="375" left="493" width="34" height="12" font="3">Hence</text>
<text top="376" left="533" width="39" height="11" font="2">GKLEE</text>
<text top="375" left="572" width="262" height="12" font="3">’s intra-warp scheduling is an equivalent model</text>
<text top="390" left="476" width="359" height="12" font="3">of the CUDA hardware’s. It eases formal analysis and boosts the</text>
<text top="404" left="476" width="84" height="12" font="3">performance of</text>
<text top="405" left="565" width="39" height="11" font="2">GKLEE</text>
<text top="404" left="604" width="230" height="12" font="3">. Similarly, as in Figure 6 we can reduce</text>
<text top="419" left="476" width="359" height="12" font="3">a race-free schedule to a canonical one for inter-warps, multi-</text>
<text top="434" left="476" width="359" height="12" font="3">blocks, and barrier intervals (BIs). These transition relations are</text>
<text top="449" left="476" width="96" height="12" font="3">represented by →</text>
<text top="454" left="572" width="8" height="8" font="4">w</text>
<text top="449" left="581" width="21" height="12" font="3">, →</text>
<text top="454" left="601" width="5" height="8" font="4">b</text>
<text top="449" left="607" width="43" height="12" font="3">, and →</text>
<text top="454" left="650" width="9" height="8" font="4">bi</text>
<text top="449" left="663" width="67" height="12" font="3">respectively.</text>
<text top="485" left="512" width="13" height="11" font="2">→</text>
<text top="489" left="525" width="4" height="8" font="4">t</text>
<text top="492" left="529" width="5" height="7" font="6">0</text>
<text top="485" left="539" width="20" height="11" font="2">· →</text>
<text top="489" left="559" width="4" height="8" font="4">t</text>
<text top="492" left="563" width="5" height="7" font="6">1</text>
<text top="485" left="573" width="31" height="11" font="2">· · · →</text>
<text top="489" left="604" width="4" height="8" font="4">t</text>
<text top="492" left="609" width="10" height="7" font="6">31</text>
<text top="485" left="624" width="4" height="11" font="2">·</text>
<text top="485" left="642" width="13" height="11" font="2">→</text>
<text top="489" left="655" width="4" height="8" font="4">t</text>
<text top="492" left="659" width="10" height="7" font="6">32</text>
<text top="485" left="675" width="20" height="11" font="2">· →</text>
<text top="489" left="694" width="4" height="8" font="4">t</text>
<text top="492" left="699" width="10" height="7" font="6">33</text>
<text top="485" left="714" width="31" height="11" font="2">· · · →</text>
<text top="489" left="745" width="4" height="8" font="4">t</text>
<text top="492" left="749" width="10" height="7" font="6">63</text>
<text top="485" left="764" width="4" height="11" font="2">·</text>
<text top="485" left="783" width="15" height="11" font="2">· · ·</text>
<text top="508" left="512" width="13" height="11" font="2">→</text>
<text top="512" left="525" width="8" height="8" font="4">w</text>
<text top="515" left="533" width="5" height="7" font="6">0</text>
<text top="508" left="543" width="12" height="11" font="2">·(!</text>
<text top="513" left="555" width="5" height="8" font="4">1</text>
<text top="509" left="565" width="62" height="11" font="2">: intra warp)</text>
<text top="508" left="648" width="13" height="11" font="2">→</text>
<text top="512" left="660" width="8" height="8" font="4">w</text>
<text top="515" left="669" width="5" height="7" font="6">1</text>
<text top="508" left="679" width="12" height="11" font="2">·(!</text>
<text top="513" left="691" width="5" height="8" font="4">1</text>
<text top="509" left="700" width="62" height="11" font="2">: intra warp)</text>
<text top="508" left="783" width="15" height="11" font="2">· · ·</text>
<text top="532" left="599" width="13" height="11" font="2">→</text>
<text top="537" left="612" width="5" height="8" font="4">b</text>
<text top="540" left="617" width="5" height="7" font="6">0</text>
<text top="532" left="627" width="12" height="11" font="2">·(!</text>
<text top="537" left="639" width="5" height="8" font="4">2</text>
<text top="533" left="649" width="62" height="11" font="2">: inter warp)</text>
<text top="563" left="517" width="13" height="11" font="2">→</text>
<text top="568" left="530" width="5" height="8" font="4">b</text>
<text top="571" left="535" width="5" height="7" font="6">0</text>
<text top="563" left="545" width="20" height="11" font="2">· →</text>
<text top="568" left="564" width="5" height="8" font="4">b</text>
<text top="571" left="569" width="5" height="7" font="6">1</text>
<text top="563" left="579" width="15" height="11" font="2">· · ·</text>
<text top="563" left="609" width="15" height="11" font="2">· · ·</text>
<text top="563" left="641" width="13" height="11" font="2">→</text>
<text top="568" left="654" width="5" height="8" font="4">b</text>
<text top="571" left="659" width="5" height="7" font="6">0</text>
<text top="563" left="669" width="20" height="11" font="2">· →</text>
<text top="568" left="689" width="5" height="8" font="4">b</text>
<text top="571" left="694" width="5" height="7" font="6">1</text>
<text top="563" left="704" width="15" height="11" font="2">· · ·</text>
<text top="587" left="538" width="13" height="11" font="2">→</text>
<text top="592" left="551" width="9" height="8" font="4">bi</text>
<text top="595" left="560" width="5" height="7" font="6">0</text>
<text top="587" left="570" width="4" height="11" font="2">·</text>
<text top="587" left="609" width="15" height="11" font="2">· · ·</text>
<text top="587" left="665" width="13" height="11" font="2">→</text>
<text top="592" left="678" width="9" height="8" font="4">bi</text>
<text top="595" left="687" width="9" height="7" font="6">m</text>
<text top="587" left="701" width="12" height="11" font="2">·(!</text>
<text top="592" left="713" width="5" height="8" font="4">3</text>
<text top="588" left="723" width="70" height="11" font="2">: global mem)</text>
<text top="620" left="479" width="306" height="12" font="3">Figure 6. Canonical scheduling and conﬂict checking in</text>
<text top="621" left="788" width="39" height="11" font="2">GKLEE</text>
<text top="620" left="828" width="3" height="12" font="3">.</text>
<text top="660" left="476" width="102" height="12" font="3">Conﬂict checking:</text>
<text top="660" left="591" width="121" height="12" font="3">Figure 6 indicates that</text>
<text top="661" left="717" width="39" height="11" font="2">GKLEE</text>
<text top="660" left="760" width="75" height="12" font="3">supports vari-</text>
<text top="675" left="476" width="118" height="12" font="3">ous conﬂict checking:</text>
<text top="697" left="483" width="6" height="11" font="2">•</text>
<text top="698" left="495" width="158" height="12" font="3">Intra-warp race (denoted as !</text>
<text top="702" left="653" width="5" height="8" font="4">1</text>
<text top="698" left="659" width="175" height="12" font="3">), checked at the end of a warp.</text>
<text top="713" left="495" width="53" height="12" font="3">Threads t</text>
<text top="717" left="548" width="5" height="8" font="4">1</text>
<text top="713" left="559" width="29" height="12" font="3">and t</text>
<text top="717" left="588" width="5" height="8" font="4">2</text>
<text top="713" left="599" width="236" height="12" font="3">incur such a WW race if they write differ-</text>
<text top="728" left="495" width="339" height="12" font="3">ent values to the same memory location in the same store in-</text>
<text top="743" left="495" width="51" height="12" font="3">struction:</text>
<text top="743" left="551" width="172" height="13" font="2">∃l : L[l] = store e v ∧ P[t</text>
<text top="747" left="723" width="5" height="8" font="4">1</text>
<text top="744" left="729" width="43" height="12" font="2">] = P[t</text>
<text top="747" left="772" width="5" height="8" font="4">2</text>
<text top="744" left="778" width="31" height="11" font="2">] = l</text>
<text top="743" left="815" width="19" height="12" font="3">and</text>
<text top="759" left="495" width="9" height="11" font="2">Σ</text>
<text top="759" left="530" width="6" height="11" font="2">v</text>
<text top="762" left="536" width="4" height="8" font="4">t</text>
<text top="765" left="540" width="5" height="7" font="6">1</text>
<text top="759" left="553" width="23" height="11" font="2">= v</text>
<text top="762" left="576" width="4" height="8" font="4">t</text>
<text top="765" left="581" width="5" height="7" font="6">2</text>
<text top="758" left="598" width="25" height="11" font="2">∧ e</text>
<text top="762" left="623" width="4" height="8" font="4">t</text>
<text top="765" left="627" width="5" height="7" font="6">1</text>
<text top="759" left="641" width="23" height="11" font="2">= e</text>
<text top="762" left="663" width="4" height="8" font="4">t</text>
<text top="765" left="668" width="5" height="7" font="6">2</text>
<text top="758" left="679" width="4" height="12" font="3">(</text>
<text top="759" left="684" width="39" height="11" font="2">GKLEE</text>
<text top="758" left="728" width="106" height="12" font="3">issues a warning if</text>
<text top="773" left="495" width="6" height="11" font="2">e</text>
<text top="777" left="501" width="4" height="8" font="4">t</text>
<text top="780" left="505" width="5" height="7" font="6">1</text>
<text top="773" left="517" width="21" height="11" font="2">= e</text>
<text top="777" left="538" width="4" height="8" font="4">t</text>
<text top="780" left="543" width="5" height="7" font="6">2</text>
<text top="773" left="549" width="285" height="12" font="3">). For a diverged warp, RW and WW races are also</text>
<text top="788" left="495" width="339" height="12" font="3">checked by considering whether the accesses in both sides can</text>
<text top="803" left="495" width="185" height="12" font="3">conﬂict (discussed in Section 2.2).</text>
<text top="822" left="483" width="6" height="11" font="2">•</text>
<text top="823" left="495" width="158" height="12" font="3">Inter-warp race (denoted as !</text>
<text top="828" left="653" width="5" height="8" font="4">2</text>
<text top="823" left="659" width="175" height="12" font="3">), checked at the end of a block</text>
<text top="838" left="495" width="119" height="12" font="3">for each BI. Thread t</text>
<text top="843" left="614" width="5" height="8" font="4">1</text>
<text top="838" left="625" width="29" height="12" font="3">and t</text>
<text top="843" left="654" width="5" height="8" font="4">2</text>
<text top="838" left="665" width="169" height="12" font="3">(in different warps) incur such</text>
<text top="853" left="495" width="339" height="12" font="3">a race if they access the same memory location, and one of</text>
<text top="868" left="495" width="339" height="12" font="3">them is a write, and different values are written if both accesses</text>
<text top="883" left="495" width="339" height="12" font="3">are writes. Formally, let R t, v, e and W t, v, e denote that</text>
<text top="898" left="495" width="339" height="12" font="3">thread t reads e from location v and writes e to v respectively.</text>
<text top="913" left="495" width="141" height="12" font="3">Then a RW race occurs if</text>
<text top="913" left="640" width="26" height="11" font="2">∃R t</text>
<text top="918" left="666" width="5" height="8" font="4">1</text>
<text top="914" left="673" width="12" height="11" font="2">, v</text>
<text top="918" left="685" width="5" height="8" font="4">1</text>
<text top="914" left="691" width="12" height="11" font="2">, e</text>
<text top="918" left="702" width="5" height="8" font="4">1</text>
<text top="914" left="713" width="29" height="11" font="2">, W t</text>
<text top="918" left="742" width="5" height="8" font="4">2</text>
<text top="914" left="749" width="12" height="11" font="2">, v</text>
<text top="918" left="760" width="5" height="8" font="4">2</text>
<text top="914" left="767" width="12" height="11" font="2">, e</text>
<text top="918" left="778" width="5" height="8" font="4">2</text>
<text top="914" left="798" width="21" height="11" font="2">: Σ</text>
<text top="929" left="495" width="6" height="11" font="2">v</text>
<text top="933" left="501" width="5" height="8" font="4">1</text>
<text top="929" left="514" width="23" height="11" font="2">= v</text>
<text top="933" left="537" width="5" height="8" font="4">2</text>
<text top="928" left="549" width="160" height="12" font="3">(or the case of exchanging t</text>
<text top="932" left="709" width="5" height="8" font="4">1</text>
<text top="928" left="720" width="30" height="12" font="3">and t</text>
<text top="932" left="750" width="5" height="8" font="4">2</text>
<text top="928" left="756" width="78" height="12" font="3">); a WW race</text>
<text top="943" left="495" width="47" height="12" font="3">occurs if</text>
<text top="943" left="545" width="30" height="11" font="2">∃W t</text>
<text top="948" left="576" width="5" height="8" font="4">1</text>
<text top="944" left="582" width="12" height="11" font="2">, v</text>
<text top="948" left="594" width="5" height="8" font="4">1</text>
<text top="944" left="600" width="12" height="11" font="2">, e</text>
<text top="948" left="611" width="5" height="8" font="4">1</text>
<text top="944" left="623" width="29" height="11" font="2">, W t</text>
<text top="948" left="651" width="5" height="8" font="4">2</text>
<text top="944" left="658" width="12" height="11" font="2">, v</text>
<text top="948" left="670" width="5" height="8" font="4">2</text>
<text top="944" left="676" width="12" height="11" font="2">, e</text>
<text top="948" left="687" width="5" height="8" font="4">2</text>
<text top="944" left="705" width="20" height="11" font="2">: Σ</text>
<text top="944" left="744" width="6" height="11" font="2">v</text>
<text top="948" left="751" width="5" height="8" font="4">1</text>
<text top="944" left="761" width="20" height="11" font="2">= v</text>
<text top="948" left="780" width="5" height="8" font="4">2</text>
<text top="943" left="793" width="21" height="11" font="2">∧ e</text>
<text top="948" left="814" width="5" height="8" font="4">1</text>
<text top="944" left="824" width="10" height="11" font="2">=</text>
<text top="959" left="495" width="6" height="11" font="2">e</text>
<text top="963" left="501" width="5" height="8" font="4">2</text>
<text top="958" left="510" width="34" height="12" font="3">(again</text>
<text top="959" left="547" width="39" height="11" font="2">GKLEE</text>
<text top="958" left="590" width="166" height="12" font="3">will prompt for investigation if</text>
<text top="959" left="759" width="6" height="11" font="2">e</text>
<text top="962" left="765" width="4" height="8" font="4">t</text>
<text top="965" left="769" width="5" height="7" font="6">1</text>
<text top="959" left="779" width="19" height="11" font="2">= e</text>
<text top="962" left="799" width="4" height="8" font="4">t</text>
<text top="965" left="803" width="5" height="7" font="6">2</text>
<text top="958" left="809" width="8" height="12" font="3">).</text>
<text top="978" left="483" width="6" height="11" font="2">•</text>
<text top="979" left="495" width="141" height="12" font="3">Global race (denoted as !</text>
<text top="983" left="635" width="5" height="8" font="4">3</text>
<text top="979" left="642" width="192" height="12" font="3">), checked at the end of the kernel</text>
<text top="994" left="495" width="339" height="12" font="3">execution. Similar to inter-warp race but on the device or CPU</text>
<text top="1009" left="495" width="220" height="12" font="3">memory. Deadlocks are also checked at !</text>
<text top="1013" left="715" width="5" height="8" font="4">3</text>
<text top="1009" left="721" width="3" height="12" font="3">.</text>
<text top="1031" left="493" width="341" height="12" font="3">Conﬂict checking is performed at the byte level to faithfully</text>
<text top="1046" left="476" width="271" height="12" font="3">model the hardware. Suppose a thread reads n</text>
<text top="1051" left="746" width="5" height="8" font="4">1</text>
<text top="1046" left="759" width="75" height="12" font="3">bytes starting</text>
<text top="1061" left="476" width="82" height="12" font="3">from address a</text>
<text top="1066" left="557" width="5" height="8" font="4">1</text>
<text top="1061" left="563" width="158" height="12" font="3">, and another thread writes n</text>
<text top="1066" left="721" width="5" height="8" font="4">2</text>
<text top="1061" left="731" width="103" height="12" font="3">bytes starting from</text>
<text top="1076" left="476" width="51" height="12" font="3">address a</text>
<text top="1081" left="527" width="5" height="8" font="4">2</text>
<text top="1076" left="533" width="299" height="12" font="3">, then a overlap exists iff the following constraint holds.</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1188" width="918">
<text top="109" left="81" width="295" height="9" font="5">__global__ void histogram64Kernel(unsigned *d_Result,</text>
<text top="121" left="270" width="161" height="9" font="5">unsigned *d_Data, int dataN){</text>
<text top="133" left="98" width="117" height="9" font="5">const int threadPos =</text>
<text top="145" left="125" width="167" height="9" font="5">((threadIdx.x &amp; (~63)) &gt;&gt; 0) |</text>
<text top="157" left="125" width="83" height="9" font="5">((threadIdx.x &amp;</text>
<text top="157" left="231" width="61" height="9" font="5">15) &lt;&lt; 2) |</text>
<text top="169" left="125" width="83" height="9" font="5">((threadIdx.x &amp;</text>
<text top="169" left="231" width="56" height="9" font="5">48) &gt;&gt; 4);</text>
<text top="169" left="320" width="17" height="9" font="5">...</text>
<text top="181" left="103" width="89" height="9" font="5">__syncthreads();</text>
<text top="193" left="103" width="317" height="9" font="5">for(int pos = IMUL(blockIdx.x, blockDim.x) + threadIdx.x;</text>
<text top="205" left="125" width="267" height="9" font="5">pos &lt; dataN; pos += IMUL(blockDim.x, gridDim.x))</text>
<text top="205" left="414" width="6" height="9" font="5">{</text>
<text top="216" left="114" width="311" height="9" font="5">unsigned data4 = d_Data[pos]; // top 10 is symb. for t5,</text>
<text top="228" left="114" width="17" height="9" font="5">...</text>
<text top="240" left="114" width="289" height="9" font="5">addData64(s_Hist, threadPos, (data4 &gt;&gt; 26) &amp; 0x3FU);</text>
<text top="240" left="414" width="6" height="9" font="5">}</text>
<text top="252" left="98" width="111" height="9" font="5">__syncthreads(); ...</text>
<text top="264" left="81" width="6" height="9" font="5">}</text>
<text top="276" left="81" width="328" height="9" font="5">inline void addData64(unsigned char *s_Hist, int threadPos,</text>
<text top="288" left="203" width="100" height="9" font="5">unsigned int data)</text>
<text top="288" left="414" width="6" height="9" font="5">{</text>
<text top="300" left="103" width="283" height="9" font="5">// Race of T5 and T13 with threadPos of 20,52 resp.</text>
<text top="312" left="103" width="300" height="9" font="5">s_Hist[threadPos + IMUL(data, THREAD_N)]++; //&lt;- Race!</text>
<text top="312" left="414" width="6" height="9" font="5">}</text>
<text top="343" left="114" width="293" height="12" font="3">Figure 7. Write-write race in Histogram64 (SDK 2.0)</text>
<text top="384" left="103" width="12" height="11" font="2">(a</text>
<text top="388" left="115" width="5" height="8" font="4">1</text>
<text top="383" left="125" width="20" height="11" font="2">≤ a</text>
<text top="388" left="145" width="5" height="8" font="4">2</text>
<text top="383" left="158" width="22" height="11" font="2">∧ a</text>
<text top="388" left="179" width="5" height="8" font="4">2</text>
<text top="384" left="189" width="20" height="11" font="2">&lt; a</text>
<text top="388" left="209" width="5" height="8" font="4">1</text>
<text top="384" left="218" width="20" height="11" font="2">+ n</text>
<text top="388" left="239" width="5" height="8" font="4">1</text>
<text top="384" left="245" width="38" height="11" font="2">) ∨ (a</text>
<text top="388" left="283" width="5" height="8" font="4">2</text>
<text top="383" left="292" width="20" height="11" font="2">≤ a</text>
<text top="388" left="313" width="5" height="8" font="4">1</text>
<text top="383" left="325" width="22" height="11" font="2">∧ a</text>
<text top="388" left="347" width="5" height="8" font="4">1</text>
<text top="384" left="356" width="20" height="11" font="2">&lt; a</text>
<text top="388" left="377" width="5" height="8" font="4">2</text>
<text top="384" left="386" width="20" height="11" font="2">+ n</text>
<text top="388" left="406" width="5" height="8" font="4">2</text>
<text top="384" left="412" width="5" height="11" font="2">)</text>
<text top="408" left="99" width="213" height="12" font="3">Without abstracting pointers and arrays,</text>
<text top="409" left="315" width="39" height="11" font="2">GKLEE</text>
<text top="408" left="357" width="40" height="12" font="3">inherits</text>
<text top="409" left="400" width="31" height="11" font="2">KLEE</text>
<text top="408" left="431" width="9" height="12" font="3">’s</text>
<text top="423" left="81" width="359" height="12" font="3">methods for handling them: suppose there are n arrays declared in</text>
<text top="437" left="81" width="359" height="12" font="3">a program. Then, when ∗p is evaluated, for every array the concolic</text>
<text top="452" left="81" width="359" height="12" font="3">executor will check whether p can fall within the array, spawning a</text>
<text top="467" left="81" width="359" height="12" font="3">new state if so (works particularly well for CUDA, where pointers</text>
<text top="482" left="81" width="246" height="12" font="3">are usually used for indexing array elements).</text>
<text top="497" left="99" width="341" height="12" font="3">Note that our method reports accurate results in contrast to static</text>
<text top="512" left="81" width="359" height="12" font="3">analysis methods such as [18] (where no decision procedures are</text>
<text top="527" left="81" width="359" height="12" font="3">applied) and [1] (which uses SMT solving but relies heavily on</text>
<text top="542" left="81" width="359" height="12" font="3">abstractions). The method in [2] uses run-time checking to rule out</text>
<text top="557" left="81" width="265" height="12" font="3">false alarms produced by its static analyzer; while</text>
<text top="558" left="349" width="39" height="11" font="2">GKLEE</text>
<text top="557" left="391" width="49" height="12" font="3">builds all</text>
<text top="572" left="81" width="284" height="12" font="3">the checks into its VM and produces no false alarms.</text>
<text top="598" left="81" width="17" height="12" font="3">3.3</text>
<text top="598" left="111" width="159" height="12" font="3">Power of Symbolic Analysis</text>
<text top="619" left="81" width="119" height="12" font="3">We now present how</text>
<text top="620" left="206" width="39" height="11" font="2">GKLEE</text>
<text top="619" left="251" width="189" height="12" font="3">detected a WW race condition in</text>
<text top="634" left="81" width="359" height="11" font="3">histogram64Kernel (Figure 7), a CUDA SDK 2.0 kernel. Since</text>
<text top="648" left="81" width="359" height="12" font="3">the invocation of this kernel in main passes d_Data that can be</text>
<text top="663" left="81" width="114" height="12" font="3">quite large, a user of</text>
<text top="664" left="199" width="39" height="11" font="2">GKLEE</text>
<text top="663" left="242" width="197" height="12" font="3">(in this case, us) chose to keep only</text>
<text top="678" left="81" width="359" height="12" font="3">the ﬁrst ten locations of this array symbolic, and the rest con-</text>
<text top="693" left="81" width="359" height="12" font="3">crete at value 0. (This is the only manual step needed; without</text>
<text top="708" left="81" width="23" height="12" font="3">this,</text>
<text top="709" left="109" width="39" height="11" font="2">GKLEE</text>
<text top="708" left="148" width="291" height="12" font="3">’s solver will be inundated, trying to enumerate ev-</text>
<text top="723" left="81" width="106" height="12" font="3">ery array location).</text>
<text top="724" left="192" width="39" height="11" font="2">GKLEE</text>
<text top="723" left="236" width="204" height="12" font="3">now determines that addData64 can</text>
<text top="738" left="81" width="359" height="12" font="3">be called concurrently by two distinct threads. Drilling into this</text>
<text top="753" left="81" width="48" height="12" font="3">function,</text>
<text top="754" left="133" width="39" height="11" font="2">GKLEE</text>
<text top="753" left="176" width="264" height="12" font="3">generates constraints for s_Hist[threadPos +</text>
<text top="769" left="81" width="359" height="11" font="3">IMUL(data, THREAD_N)]++ (not marked atomic) to race. The</text>
<text top="783" left="81" width="359" height="12" font="3">SMT solver picks two thread IDs 5 and 13; for this, threadPos</text>
<text top="798" left="81" width="359" height="12" font="3">assumes values 20 and 52, respectively. What ﬂows into data</text>
<text top="813" left="81" width="359" height="12" font="3">is data4 &gt;&gt; 26 &amp; 0x3FU, where data4 obtains the value of</text>
<text top="829" left="81" width="359" height="11" font="3">d_Data[pos]. Since the top 10 elements of d Data[DATA N] are</text>
<text top="843" left="81" width="359" height="12" font="3">symbolic, thread 5 assigns a symbolic value denoted by d Data[5]</text>
<text top="858" left="81" width="359" height="12" font="3">to data4, while thread 13 assigns the concrete value of 0 to</text>
<text top="874" left="81" width="339" height="11" font="3">d Data[13]. The SMT solver now solves 20 + ((d Data[5]</text>
<text top="887" left="81" width="125" height="12" font="3">21)&amp;2016) = 52 + 0 (</text>
<text top="887" left="224" width="75" height="12" font="3">26 changed to</text>
<text top="887" left="320" width="119" height="12" font="3">21 because THREAD_N</text>
<text top="903" left="81" width="359" height="12" font="3">is 32), resulting in d Data[5] obtaining value 0x04040404 which</text>
<text top="917" left="81" width="359" height="12" font="3">causes a race! The user not only obtains an automatic race alert,</text>
<text top="932" left="81" width="359" height="12" font="3">but also the concrete input of 0x04040404 to set d Data[5] to, in</text>
<text top="947" left="81" width="314" height="12" font="3">case they want to study this race through any other means.</text>
<text top="978" left="81" width="12" height="15" font="1">4.</text>
<text top="978" left="110" width="112" height="15" font="1">Test Generation</text>
<text top="1001" left="81" width="165" height="12" font="3">During its symbolic execution,</text>
<text top="1003" left="249" width="39" height="11" font="2">GKLEE</text>
<text top="1001" left="289" width="151" height="12" font="3">’s VM has the ability to fork</text>
<text top="1016" left="81" width="359" height="12" font="3">two execution paths whenever it “encounters a non-deterministic</text>
<text top="1031" left="81" width="359" height="12" font="3">situation;” e.g. when a conditional is evaluated and both choices</text>
<text top="1046" left="81" width="359" height="12" font="3">are true, or when a symbolic pointer is accessed, and it may point to</text>
<text top="1061" left="81" width="137" height="12" font="3">multiple memory objects.</text>
<text top="1062" left="221" width="39" height="11" font="2">GKLEE</text>
<text top="1061" left="264" width="176" height="12" font="3">organizes the resulting execution</text>
<text top="1076" left="81" width="359" height="12" font="3">states as a tree. The initial state of the GPU kernel forms the root of</text>
<text top="111" left="476" width="359" height="12" font="3">this tree. It then searches the state space guided by various search</text>
<text top="126" left="476" width="109" height="12" font="3">reduction heuristics.</text>
<text top="145" left="476" width="200" height="12" font="3">The essence of the VM executor:</text>
<text top="146" left="681" width="39" height="11" font="2">GKLEE</text>
<text top="145" left="727" width="108" height="12" font="3">can be regarded as</text>
<text top="160" left="476" width="359" height="12" font="3">a symbolic model checker (for GPU kernels) with the symbolic</text>
<text top="175" left="476" width="359" height="12" font="3">state modeling the hardware state and the transitions modeling non-</text>
<text top="190" left="476" width="196" height="12" font="3">determinism due to symbolic inputs.</text>
<text top="209" left="493" width="170" height="12" font="3">With this view, it is natural that</text>
<text top="210" left="667" width="39" height="11" font="2">GKLEE</text>
<text top="209" left="710" width="124" height="12" font="3">supports facilities such</text>
<text top="224" left="476" width="359" height="12" font="3">as state caching and search heuristics (e.g. depth-ﬁrst, weighted-</text>
<text top="239" left="476" width="359" height="12" font="3">random, bump-merging, etc.), all of which are inherited from</text>
<text top="255" left="476" width="31" height="11" font="2">KLEE</text>
<text top="254" left="506" width="328" height="12" font="3">. The checks discussed in Section 3 are essentially built-in</text>
<text top="269" left="476" width="359" height="12" font="3">global safety properties examined at each state. In the state space</text>
<text top="284" left="476" width="359" height="12" font="3">tree, a path from the root to a leaf represents a valid computation</text>
<text top="299" left="476" width="359" height="12" font="3">with a path condition recording all the branching decisions made</text>
<text top="314" left="476" width="359" height="12" font="3">by all the threads. At a leaf state, we can generate a test case by</text>
<text top="329" left="476" width="359" height="12" font="3">solving the satisﬁability of this path condition. This ability makes</text>
<text top="345" left="476" width="39" height="11" font="2">GKLEE</text>
<text top="343" left="518" width="136" height="12" font="3">a powerful test generator.</text>
<text top="363" left="476" width="359" height="12" font="3">Soundness and completeness of the test generator: Given a race</text>
<text top="378" left="476" width="217" height="12" font="3">free kernel with a set of symbolic inputs,</text>
<text top="379" left="695" width="39" height="11" font="2">GKLEE</text>
<text top="378" left="737" width="97" height="12" font="3">visits a path if and</text>
<text top="393" left="476" width="359" height="12" font="3">only if there exists a schedule where the decisions made by threads</text>
<text top="408" left="476" width="239" height="12" font="3">(recorded in the path condition) are feasible.</text>
<text top="427" left="493" width="341" height="12" font="3">Note that the feasibility of a path condition is calculated by SMT</text>
<text top="442" left="476" width="359" height="12" font="3">solving, which is precise without any approximation. At the ﬁrst</text>
<text top="457" left="476" width="359" height="12" font="3">glance, the completeness of test generation may be not be obvious</text>
<text top="472" left="476" width="359" height="12" font="3">since we consider only one (canonical) schedule, while another</text>
<text top="487" left="476" width="296" height="12" font="3">schedule may apply the branchings in a different order.</text>
<text top="501" left="493" width="334" height="12" font="3">To clarify this, consider the following situation where thread t</text>
<text top="506" left="828" width="5" height="8" font="4">0</text>
<text top="516" left="476" width="9" height="12" font="3">(t</text>
<text top="521" left="485" width="5" height="8" font="4">1</text>
<text top="516" left="491" width="141" height="12" font="3">) branches on conditions c</text>
<text top="521" left="632" width="14" height="8" font="4">0,0</text>
<text top="516" left="651" width="10" height="12" font="3">(c</text>
<text top="521" left="661" width="14" height="8" font="4">1,0</text>
<text top="516" left="676" width="8" height="12" font="3">):</text>
<text top="545" left="610" width="5" height="11" font="2">t</text>
<text top="549" left="615" width="5" height="8" font="4">0</text>
<text top="545" left="689" width="5" height="11" font="2">t</text>
<text top="549" left="693" width="5" height="8" font="4">1</text>
<text top="559" left="584" width="21" height="11" font="2">if (c</text>
<text top="562" left="605" width="14" height="8" font="4">0,0</text>
<text top="559" left="620" width="28" height="11" font="2">) . . . ;</text>
<text top="559" left="662" width="21" height="11" font="2">if (c</text>
<text top="562" left="683" width="14" height="8" font="4">1,0</text>
<text top="559" left="698" width="28" height="11" font="2">) . . . ;</text>
<text top="586" left="493" width="18" height="12" font="3">If t</text>
<text top="591" left="511" width="5" height="8" font="4">0</text>
<text top="586" left="522" width="93" height="12" font="3">executes before t</text>
<text top="591" left="615" width="5" height="8" font="4">1</text>
<text top="586" left="621" width="213" height="12" font="3">, then a depth-ﬁrst search visits 4 paths</text>
<text top="601" left="476" width="113" height="12" font="3">with path conditions</text>
<text top="602" left="593" width="6" height="11" font="2">c</text>
<text top="606" left="598" width="14" height="8" font="4">0,0</text>
<text top="601" left="617" width="18" height="11" font="2">∧ c</text>
<text top="606" left="635" width="14" height="8" font="4">1,0</text>
<text top="601" left="650" width="3" height="12" font="3">,</text>
<text top="602" left="658" width="6" height="11" font="2">c</text>
<text top="606" left="664" width="14" height="8" font="4">0,0</text>
<text top="601" left="683" width="26" height="11" font="2">∧ ¬c</text>
<text top="606" left="709" width="14" height="8" font="4">1,0</text>
<text top="601" left="724" width="53" height="12" font="3">, . . . . If t</text>
<text top="606" left="777" width="5" height="8" font="4">1</text>
<text top="601" left="788" width="46" height="12" font="3">executes</text>
<text top="616" left="476" width="42" height="12" font="3">before t</text>
<text top="621" left="518" width="5" height="8" font="4">0</text>
<text top="616" left="524" width="188" height="12" font="3">, then the 4 path conditions become</text>
<text top="617" left="715" width="6" height="11" font="2">c</text>
<text top="621" left="721" width="14" height="8" font="4">1,0</text>
<text top="616" left="737" width="15" height="11" font="2">∧ c</text>
<text top="621" left="752" width="14" height="8" font="4">0,0</text>
<text top="616" left="767" width="3" height="12" font="3">,</text>
<text top="617" left="774" width="6" height="11" font="2">c</text>
<text top="621" left="779" width="14" height="8" font="4">1,0</text>
<text top="616" left="795" width="24" height="11" font="2">∧ ¬c</text>
<text top="621" left="819" width="14" height="8" font="4">0,0</text>
<text top="631" left="476" width="359" height="12" font="3">. . . . The commutativity of the ∧ operator ensures, under the race-</text>
<text top="646" left="476" width="359" height="12" font="3">free constraint, the equivalence of these two path sets. Hence, it</text>
<text top="661" left="476" width="359" height="12" font="3">sufﬁces to consider only one canonical schedule in test generation</text>
<text top="676" left="476" width="187" height="12" font="3">as in conﬂict checking (Section 3).</text>
<text top="704" left="476" width="53" height="12" font="3">Example.</text>
<text top="704" left="542" width="293" height="12" font="3">Consider the Bitonic kernel running on one block with</text>
<text top="719" left="476" width="359" height="12" font="3">4 threads. Suppose the input values is of size 4 and has sym-</text>
<text top="734" left="476" width="286" height="12" font="3">bolic value v. Lines 1-4 copy the input to shared:</text>
<text top="734" left="766" width="68" height="11" font="2">∀i ∈ [0, 3] :</text>
<text top="750" left="476" width="86" height="11" font="2">shared[i] = v[i]</text>
<text top="749" left="562" width="272" height="12" font="3">. For thread 0, since lines 7-8 involve no symbolic</text>
<text top="764" left="476" width="359" height="12" font="3">values, they are executed concretely. In the ﬁrst iteration of the in-</text>
<text top="779" left="476" width="100" height="12" font="3">ner loop, we have</text>
<text top="780" left="581" width="36" height="11" font="2">k = 2</text>
<text top="779" left="617" width="3" height="12" font="3">,</text>
<text top="780" left="625" width="35" height="11" font="2">j = 1</text>
<text top="779" left="660" width="28" height="12" font="3">, and</text>
<text top="780" left="693" width="46" height="11" font="2">ixj = 1</text>
<text top="779" left="739" width="95" height="12" font="3">. The conditional</text>
<text top="794" left="476" width="359" height="12" font="3">branch at line 10 is evaluated to be true; so does that at line 11.</text>
<text top="809" left="476" width="272" height="12" font="3">Then the execution reaches the branch at line 12.</text>
<text top="810" left="752" width="39" height="11" font="2">GKLEE</text>
<text top="809" left="795" width="39" height="12" font="3">queries</text>
<text top="824" left="476" width="359" height="12" font="3">the constraint solver to determine that both branches are possible;</text>
<text top="838" left="476" width="359" height="12" font="3">it explores both paths and proceeds to the loop’s next iteration. Fi-</text>
<text top="853" left="476" width="326" height="12" font="3">nally the execution terminates with 28 paths (and test cases).</text>
<text top="881" left="476" width="235" height="12" font="3">Coverage Directed State/Path Reduction.</text>
<text top="881" left="724" width="111" height="12" font="3">Given that a kernel</text>
<text top="896" left="476" width="359" height="12" font="3">is usually executed by a large number of threads, there is a real</text>
<text top="911" left="476" width="359" height="12" font="3">danger, especially with complex/large kernels, that multiple threads</text>
<text top="926" left="476" width="359" height="12" font="3">may end up covering some line/branch while no threads visit other</text>
<text top="942" left="476" width="80" height="12" font="3">lines/branches.</text>
<text top="939" left="556" width="4" height="8" font="4">1</text>
<text top="942" left="561" width="273" height="12" font="3">We have experimented with several heuristics that</text>
<text top="957" left="476" width="23" height="12" font="3">help</text>
<text top="958" left="502" width="39" height="11" font="2">GKLEE</text>
<text top="957" left="544" width="290" height="12" font="3">achieve coverage directed search reduction. Basically,</text>
<text top="972" left="476" width="359" height="12" font="3">we keep track of whether some feature (line or branch) is covered</text>
<text top="987" left="476" width="359" height="12" font="3">by all the threads at least once, or some thread at least once. These</text>
<text top="1001" left="476" width="103" height="12" font="3">measurements help</text>
<text top="1003" left="582" width="39" height="11" font="2">GKLEE</text>
<text top="1001" left="624" width="210" height="12" font="3">avoid exploring states/paths that do not</text>
<text top="1016" left="476" width="134" height="12" font="3">result in added coverage.</text>
<text top="1031" left="493" width="341" height="12" font="3">Another usage of these metrics is to perform test case selection</text>
<text top="1046" left="476" width="359" height="12" font="3">which still explores the entire state space, but outputs only a subset</text>
<text top="1061" left="476" width="359" height="12" font="3">of test cases (for downstream debugging use) after the entire execu-</text>
<text top="1076" left="476" width="359" height="12" font="3">tion is over, with no net loss of coverage. Details of these heuristics</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="81" width="359" height="12" font="3">are discussed in § 5.2. To the best of our knowledge, coverage mea-</text>
<text top="126" left="81" width="321" height="12" font="3">sures for SIMD programs have not been previously studied.</text>
<text top="160" left="81" width="12" height="15" font="1">5.</text>
<text top="160" left="110" width="151" height="15" font="1">Experimental Results</text>
<text top="183" left="81" width="359" height="12" font="3">As described in Section 1, a GPU kernel along with a CPU driver</text>
<text top="198" left="81" width="359" height="12" font="3">is compiled into LLVM bytecode, which is symbolically executed</text>
<text top="213" left="81" width="13" height="12" font="3">by</text>
<text top="214" left="98" width="39" height="11" font="2">GKLEE</text>
<text top="213" left="137" width="37" height="12" font="3">. Since</text>
<text top="214" left="177" width="39" height="11" font="2">GKLEE</text>
<text top="213" left="219" width="220" height="12" font="3">can handle GPU and CPU style code, we</text>
<text top="228" left="81" width="359" height="12" font="3">can mix the computation of CPU and GPU, e.g. execute multiple</text>
<text top="243" left="81" width="118" height="12" font="3">kernels in a sequence.</text>
<text top="269" left="100" width="273" height="10" font="2">CPU code; GPU code; CPU code; GPU code; ...</text>
<text top="294" left="81" width="38" height="12" font="3">Driver.</text>
<text top="294" left="133" width="307" height="12" font="3">The user may give as input a kernel ﬁle to test together</text>
<text top="309" left="81" width="359" height="12" font="3">with a driver representing the main (CPU side) program. To cater</text>
<text top="324" left="81" width="359" height="12" font="3">for the need of LLVM-GCC, we redeﬁne some CUDA speciﬁc</text>
<text top="339" left="81" width="359" height="12" font="3">directives and functions, e.g. we use C attributes to interpret them,</text>
<text top="354" left="81" width="230" height="12" font="3">as illustrated by the following deﬁnition of</text>
<text top="354" left="324" width="50" height="12" font="3">shared .</text>
<text top="380" left="81" width="100" height="9" font="5">#define __shared__</text>
<text top="392" left="125" width="206" height="9" font="5">__attribute((section (&#34;__shared__&#34;)))</text>
<text top="416" left="81" width="144" height="9" font="5">#define cutilSafeCall(f) f</text>
<text top="428" left="81" width="250" height="9" font="5">void cudaMalloc(void** devPtr, size_t size) {</text>
<text top="440" left="92" width="128" height="9" font="5">*devPtr = malloc(size);</text>
<text top="452" left="81" width="6" height="9" font="5">}</text>
<text top="464" left="81" width="283" height="9" font="5">void cudaMemcpy(void* a, void* b, size_t size, ...)</text>
<text top="476" left="81" width="122" height="9" font="5">{ memcpy(a,b,size); };</text>
<text top="500" left="99" width="341" height="12" font="3">We show below an example driver for the Bitonic Sort ker-</text>
<text top="515" left="81" width="359" height="12" font="3">nel. The user speciﬁes what input values should have symbolic</text>
<text top="530" left="81" width="359" height="12" font="3">values; and may place assert assertions anywhere in the code,</text>
<text top="545" left="81" width="359" height="12" font="3">which will be checked during execution. Particularly, the pre- and</text>
<text top="560" left="81" width="359" height="12" font="3">post- conditions are speciﬁed before and after the GPU code re-</text>
<text top="574" left="81" width="110" height="12" font="3">spectively. Function</text>
<text top="575" left="207" width="233" height="11" font="3">begin GPU(NUM) (a more general format</text>
<text top="589" left="81" width="9" height="12" font="3">is</text>
<text top="591" left="107" width="328" height="10" font="2">begin GPU(bdim.x,bdim.y,bdim.z,gdim.x,gdim.y,gdim.z)</text>
<text top="589" left="435" width="4" height="12" font="3">)</text>
<text top="604" left="81" width="301" height="12" font="3">speciﬁes that the x dimension of the block size is NUM.</text>
<text top="631" left="81" width="67" height="9" font="5">int main() {</text>
<text top="643" left="92" width="89" height="9" font="5">int values[NUM];</text>
<text top="655" left="92" width="233" height="9" font="5">gklee_make_symbolic(values, NUM, &#34;input&#34;);</text>
<text top="678" left="92" width="72" height="9" font="5">int* dvalues;</text>
<text top="690" left="92" width="233" height="9" font="5">cutilSafeCall(cudaMalloc((void**)&amp;dvalues,</text>
<text top="702" left="170" width="100" height="9" font="5">sizeof(int)*NUM));</text>
<text top="714" left="92" width="228" height="9" font="5">cutilSafeCall(cudaMemcpy(dvalues, values,</text>
<text top="726" left="109" width="233" height="9" font="5">sizeof(int)*NUM, cudaMemcpyHostToDevice));</text>
<text top="750" left="92" width="200" height="9" font="5">// &lt;&lt;&lt;...&gt;&gt;&gt;(BitonicKernel(dvalues))</text>
<text top="762" left="92" width="94" height="9" font="5">__begin_GPU(NUM);</text>
<text top="762" left="231" width="117" height="9" font="5">// block size = &lt;NUM&gt;</text>
<text top="774" left="92" width="128" height="9" font="5">BitonicKernel(dvalues);</text>
<text top="786" left="92" width="67" height="9" font="5">__end_GPU();</text>
<text top="810" left="92" width="117" height="9" font="5">// the post-condition</text>
<text top="822" left="92" width="161" height="9" font="5">for (int i = 1; i &lt; NUM; i++)</text>
<text top="834" left="103" width="195" height="9" font="5">assert(dvalues[i-1] &lt;= dvalues[i]);</text>
<text top="858" left="92" width="183" height="9" font="5">cutilSafeCall(cudaFree(dvalues));</text>
<text top="870" left="81" width="6" height="9" font="5">}</text>
<text top="894" left="99" width="341" height="12" font="3">A concrete GPU conﬁguration can be speciﬁed at the com-</text>
<text top="909" left="81" width="359" height="12" font="3">mand line. For instance, option –blocksize=[4,2] indicates that</text>
<text top="923" left="81" width="359" height="12" font="3">each block is of size 4 × 2. These values can also be made symbolic</text>
<text top="938" left="81" width="215" height="12" font="3">so as to reveal conﬁguration limitations.</text>
<text top="966" left="81" width="17" height="12" font="3">5.1</text>
<text top="966" left="111" width="244" height="12" font="3">Results I: Symbolic Identiﬁcation of Issues</text>
<text top="988" left="81" width="39" height="11" font="2">GKLEE</text>
<text top="987" left="124" width="316" height="12" font="3">supports (through command-line arguments) bank conﬂict</text>
<text top="1002" left="81" width="359" height="12" font="3">detection for 1.x (memory coalescing checks cover 1.0 &amp; 1.1, and</text>
<text top="1017" left="81" width="359" height="12" font="3">1.2 &amp; 1.3), as well as 2.x device capabilities. Table 1 presents</text>
<text top="1032" left="81" width="359" height="12" font="3">results from SDK 2.0 kernels while Table 2 presents those from</text>
<text top="1062" left="81" width="4" height="8" font="4">1</text>
<text top="1064" left="88" width="352" height="11" font="2">We have extended GKLEE’s symbolic VM to measure statement and</text>
<text top="1077" left="81" width="281" height="11" font="2">branch coverage in terms of LLVM byte-code instructions.</text>
<text top="111" left="476" width="359" height="12" font="3">SDK 4.0 (many of these are written for 2.x). These are widely</text>
<text top="126" left="476" width="359" height="12" font="3">publicized kernels. Our results are with respect to symbolic inputs.</text>
<text top="141" left="476" width="359" height="12" font="3">Tables (1 and 2 ): (#T denoting the number of threads analyzed)</text>
<text top="156" left="476" width="359" height="12" font="3">asserts that, under valid conﬁgurations, (i) all barriers were found</text>
<text top="171" left="476" width="359" height="12" font="3">to be well synchronized; (ii) the functional correctness is veriﬁed</text>
<text top="186" left="476" width="359" height="12" font="3">(w.r.t the conﬁgurations); but only the canonical schedule is con-</text>
<text top="201" left="476" width="246" height="12" font="3">sidered for cases with races (marked with *)</text>
<text top="201" left="726" width="108" height="12" font="3">(thus for cases with</text>
<text top="215" left="476" width="359" height="12" font="3">fatal races, we are unsure of the overall functional correctness);</text>
<text top="230" left="476" width="359" height="12" font="3">(iii) performance defects (to speciﬁc degrees) were found in many</text>
<text top="245" left="476" width="359" height="12" font="3">kernels; (iv) two races were observed (Histogram64 and RadixSort</text>
<text top="260" left="476" width="359" height="12" font="3">kernels); and (v) several alerts pertaining to the use of volatile</text>
<text top="275" left="476" width="359" height="12" font="3">declarations were reported. ‘WW’ denotes write-write races; they</text>
<text top="290" left="476" width="359" height="12" font="3">are marked benign (ben.) if the same value is written in our concrete</text>
<text top="305" left="476" width="350" height="12" font="3">execution trace. The computation is expected to be deterministic.</text>
<text top="320" left="493" width="232" height="12" font="3">The race in Radix Sort was within function</text>
<text top="337" left="476" width="152" height="10" font="2">radixSortBlockKeysOnly()</text>
<text top="335" left="632" width="51" height="12" font="3">involving</text>
<text top="337" left="688" width="102" height="10" font="2">sMem1[0] = key.x</text>
<text top="335" left="794" width="40" height="12" font="3">for dis-</text>
<text top="350" left="476" width="24" height="12" font="3">tinct</text>
<text top="352" left="503" width="32" height="10" font="2">key.x</text>
<text top="350" left="539" width="296" height="12" font="3">written by two threads. In Histogram64, we mark the</text>
<text top="366" left="476" width="50" height="12" font="3">race WW</text>
<text top="363" left="526" width="5" height="8" font="4">?</text>
<text top="366" left="535" width="300" height="12" font="3">as we are unsure whether s Hist[..]++ of Figure 7 ex-</text>
<text top="381" left="476" width="359" height="12" font="3">ecuted by two threads within one warp is fatal (apparently, CUDA</text>
<text top="396" left="476" width="58" height="12" font="3">guarantees</text>
<text top="393" left="533" width="4" height="8" font="4">2</text>
<text top="396" left="543" width="292" height="12" font="3">a net increment by 1). It is poor coding practice any-</text>
<text top="411" left="476" width="234" height="12" font="3">how (we notate correctness as ‘Unknown’).</text>
<text top="426" left="493" width="341" height="12" font="3">One row result is presented for Bank Conﬂicts, Memory Coa-</text>
<text top="441" left="476" width="359" height="12" font="3">lescing, and Warp Divergence, this row averaging over barrier in-</text>
<text top="456" left="476" width="359" height="12" font="3">tervals. The 71% for Scan Best under Bank Conﬂict (compute ca-</text>
<text top="471" left="476" width="359" height="12" font="3">pability 2.x) is obtained by: 14 BIs were analyzed, and out of it,</text>
<text top="486" left="476" width="359" height="12" font="3">10 had bank conﬂicts, which is 71%. All other “z%” entries may</text>
<text top="501" left="476" width="359" height="12" font="3">be read similarly. This sort of a feedback enables a programmer</text>
<text top="516" left="476" width="359" height="12" font="3">to attempt various optimizations to improve performance. When</text>
<text top="531" left="476" width="359" height="12" font="3">a kernel’s execution contains multiple paths (states), the average</text>
<text top="545" left="476" width="258" height="12" font="3">numbers for these paths are reported. Also, with</text>
<text top="546" left="737" width="39" height="11" font="2">GKLEE</text>
<text top="545" left="776" width="58" height="12" font="3">’s help, we</text>
<text top="560" left="476" width="359" height="12" font="3">tried a variety of conﬁgurations (e.g. symbolic conﬁgurations) and</text>
<text top="575" left="476" width="359" height="12" font="3">discovered undocumented constraints on kernel conﬁgurations and</text>
<text top="590" left="476" width="36" height="12" font="3">inputs.</text>
<text top="605" left="493" width="202" height="12" font="3">To show that the numbers reported by</text>
<text top="606" left="699" width="39" height="11" font="2">GKLEE</text>
<text top="605" left="741" width="93" height="12" font="3">track CUDA pro-</text>
<text top="620" left="476" width="359" height="12" font="3">ﬁler reports, we employed GKLEE-generated concrete test cases</text>
<text top="635" left="476" width="332" height="12" font="3">and ran selected kernels on the Nvidia GTX 480 hardware.</text>
<text top="636" left="813" width="21" height="11" font="2">GK-</text>
<text top="651" left="476" width="22" height="11" font="2">LEE</text>
<text top="650" left="502" width="332" height="12" font="3">includes a utility script, gklee-replay, that compiles the ker-</text>
<text top="665" left="476" width="359" height="12" font="3">nels using nvcc, executes them on the hardware and optionally in-</text>
<text top="680" left="476" width="359" height="12" font="3">vokes the NVIDIA command line proﬁler (which is the back end to</text>
<text top="695" left="476" width="227" height="12" font="3">their Compute Visual Proﬁler). We found</text>
<text top="696" left="707" width="39" height="11" font="2">GKLEE</text>
<text top="695" left="746" width="88" height="12" font="3">’s ﬁndings to be</text>
<text top="710" left="476" width="270" height="12" font="3">in agreement with that discovered by the proﬁler.</text>
<text top="711" left="750" width="39" height="11" font="2">GKLEE</text>
<text top="710" left="789" width="45" height="12" font="3">’s statis-</text>
<text top="725" left="476" width="359" height="12" font="3">tics can be used for early detection of these performance issues on</text>
<text top="740" left="476" width="89" height="12" font="3">symbolic inputs.</text>
<text top="763" left="476" width="160" height="12" font="3">Volatile Checking Heuristic</text>
<text top="764" left="640" width="39" height="11" font="2">GKLEE</text>
<text top="763" left="684" width="150" height="12" font="3">employs a heuristic to help</text>
<text top="778" left="476" width="359" height="12" font="3">users check for potentially missed volatile qualiﬁers. Basically,</text>
<text top="794" left="476" width="39" height="11" font="2">GKLEE</text>
<text top="793" left="518" width="317" height="12" font="3">analyzes for data sharings between threads within one warp</text>
<text top="808" left="476" width="359" height="12" font="3">involving two distinct SIMD instructions. The gist of an example</text>
<text top="823" left="476" width="359" height="12" font="3">(taken from the CUDA SDK 2.0) when it was compiled for device</text>
<text top="838" left="476" width="359" height="12" font="3">capability of 2.x, was as follows: a sequence ‘a;b’ occurred inside</text>
<text top="853" left="476" width="352" height="12" font="3">a warp where SIMD instruction ‘a’ writes a value into addresses a</text>
<text top="857" left="828" width="5" height="8" font="4">1</text>
<text top="868" left="476" width="31" height="12" font="3">and a</text>
<text top="872" left="506" width="5" height="8" font="4">2</text>
<text top="868" left="516" width="75" height="12" font="3">on behalf of t</text>
<text top="872" left="591" width="5" height="8" font="4">0</text>
<text top="868" left="602" width="28" height="12" font="3">and t</text>
<text top="872" left="630" width="5" height="8" font="4">1</text>
<text top="868" left="636" width="198" height="12" font="3">, respectively; and SIMD instruction</text>
<text top="883" left="476" width="60" height="12" font="3">’b’ reads a</text>
<text top="887" left="536" width="5" height="8" font="4">0</text>
<text top="883" left="546" width="31" height="12" font="3">and a</text>
<text top="887" left="577" width="5" height="8" font="4">1</text>
<text top="883" left="587" width="20" height="12" font="3">in t</text>
<text top="887" left="607" width="5" height="8" font="4">0</text>
<text top="883" left="617" width="29" height="12" font="3">and t</text>
<text top="887" left="646" width="5" height="8" font="4">1</text>
<text top="883" left="652" width="114" height="12" font="3">, respectively. Now t</text>
<text top="887" left="766" width="5" height="8" font="4">1</text>
<text top="883" left="776" width="58" height="12" font="3">was meant</text>
<text top="898" left="476" width="169" height="12" font="3">to see the value written into a</text>
<text top="902" left="645" width="5" height="8" font="4">1</text>
<text top="898" left="651" width="183" height="12" font="3">, but it did not, as the value was</text>
<text top="913" left="476" width="359" height="12" font="3">held in a register and not written back (a volatile declaration was</text>
<text top="928" left="476" width="359" height="12" font="3">missing in the SDK 2.0 version of the example). An Nvidia expert</text>
<text top="943" left="476" width="359" height="12" font="3">conﬁrmed our observation and has updated the example to now</text>
<text top="957" left="476" width="155" height="12" font="3">have the volatile declaration.</text>
<text top="972" left="493" width="341" height="12" font="3">We now provide a few more details on this issue. The SDK 4.0</text>
<text top="987" left="476" width="359" height="12" font="3">version of this example has the volatile declaration in place. We</text>
<text top="1002" left="476" width="359" height="12" font="3">exposed this bug when we took a newer release of the nvcc com-</text>
<text top="1017" left="476" width="359" height="12" font="3">piler (released around SDK 4.0 and does volatile optimizations),</text>
<text top="1032" left="476" width="359" height="12" font="3">compiled the SDK 2.0 version of this example (which omits the</text>
<text top="1047" left="476" width="359" height="12" font="3">volatile), ran the program on our GTX 480 hardware, ﬁnding incor-</text>
<text top="1075" left="476" width="4" height="8" font="4">2</text>
<text top="1077" left="482" width="286" height="11" font="2">As conﬁrmed through discussions with engineers at Nvidia.</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="81" width="205" height="12" font="3">rect results emerging. The solution in</text>
<text top="112" left="290" width="39" height="11" font="2">GKLEE</text>
<text top="111" left="333" width="106" height="12" font="3">is to ﬂag for poten-</text>
<text top="126" left="81" width="359" height="12" font="3">tially missed volatiles in the aforesaid manner; in future, we hope</text>
<text top="141" left="81" width="50" height="12" font="3">to extend</text>
<text top="142" left="134" width="39" height="11" font="2">GKLEE</text>
<text top="141" left="177" width="262" height="12" font="3">to “understand” compiler optimizations and deal</text>
<text top="156" left="81" width="173" height="12" font="3">with this issue more thoroughly.</text>
<text top="179" left="81" width="216" height="12" font="3">Table 3 compares the execution times of</text>
<text top="180" left="300" width="39" height="11" font="2">GKLEE</text>
<text top="179" left="342" width="98" height="12" font="3">and our functional</text>
<text top="194" left="81" width="143" height="12" font="3">correctness checking tool</text>
<text top="195" left="231" width="24" height="11" font="2">PUG</text>
<text top="194" left="261" width="179" height="12" font="3">[1]. This result shows the pros</text>
<text top="209" left="81" width="294" height="12" font="3">and cons of a full SMT based static analyzer (like</text>
<text top="210" left="381" width="24" height="11" font="2">PUG</text>
<text top="209" left="405" width="34" height="12" font="3">) or a</text>
<text top="224" left="81" width="155" height="12" font="3">testing based approach (like</text>
<text top="225" left="241" width="39" height="11" font="2">GKLEE</text>
<text top="224" left="280" width="160" height="12" font="3">) which is far more scalable.</text>
<text top="239" left="81" width="359" height="12" font="3">We performed experiments on a laptop with an Intel Core(TM)2</text>
<text top="254" left="81" width="359" height="12" font="3">Duo 1.60GHz processor and 2GB memory. Here the GPU times</text>
<text top="269" left="81" width="10" height="12" font="3">in</text>
<text top="270" left="97" width="39" height="11" font="2">GKLEE</text>
<text top="269" left="142" width="298" height="12" font="3">count in sanity checking and test generation. Similar</text>
<text top="284" left="81" width="10" height="12" font="3">to</text>
<text top="285" left="98" width="39" height="11" font="2">GKLEE</text>
<text top="284" left="137" width="3" height="12" font="3">,</text>
<text top="285" left="146" width="24" height="11" font="2">PUG</text>
<text top="284" left="177" width="263" height="12" font="3">also sequentializes the threads and unrolls the</text>
<text top="299" left="81" width="244" height="12" font="3">loops when checking functional correctness.</text>
<text top="300" left="330" width="39" height="11" font="2">GKLEE</text>
<text top="299" left="374" width="66" height="12" font="3">outperforms</text>
<text top="315" left="81" width="24" height="11" font="2">PUG</text>
<text top="314" left="110" width="330" height="12" font="3">due partially to its various optimizations such as expression</text>
<text top="329" left="81" width="359" height="12" font="3">rewriting, value concretization, constraint independence, and so on.</text>
<text top="343" left="81" width="175" height="12" font="3">A more important factor is that</text>
<text top="345" left="261" width="39" height="11" font="2">GKLEE</text>
<text top="343" left="305" width="134" height="12" font="3">is a concolic tool which</text>
<text top="358" left="81" width="359" height="12" font="3">simpliﬁes the expressions on-the-ﬂy and puts much less burden to</text>
<text top="373" left="81" width="359" height="12" font="3">the SMT solver, in addition to generating concrete tests, which</text>
<text top="389" left="81" width="24" height="11" font="2">PUG</text>
<text top="388" left="110" width="329" height="12" font="3">does not. Both tools perform poorly on the “Bitonic Sort”</text>
<text top="403" left="81" width="359" height="12" font="3">kernel since the relation between this kernel’s input elements are</text>
<text top="418" left="81" width="116" height="12" font="3">complicated, e.g. thus</text>
<text top="419" left="200" width="39" height="11" font="2">GKLEE</text>
<text top="418" left="242" width="197" height="12" font="3">needs to explore many paths. Section</text>
<text top="433" left="81" width="74" height="12" font="3">2.2.4 presents</text>
<text top="434" left="159" width="39" height="11" font="2">GKLEE</text>
<text top="433" left="198" width="218" height="12" font="3">’s reduction heuristics to ameliorate this.</text>
<text top="448" left="99" width="164" height="12" font="3">As an added check, we tested</text>
<text top="449" left="268" width="39" height="11" font="2">GKLEE</text>
<text top="448" left="312" width="128" height="12" font="3">on the same 57 kernels</text>
<text top="463" left="81" width="66" height="12" font="3">used in [1].</text>
<text top="464" left="153" width="39" height="11" font="2">GKLEE</text>
<text top="463" left="198" width="242" height="12" font="3">found the same 2 real bugs (one deadlock</text>
<text top="478" left="81" width="359" height="12" font="3">and one WR race). It also revealed that 4 of other kernels contain</text>
<text top="493" left="81" width="150" height="12" font="3">functional correctness bugs.</text>
<text top="517" left="81" width="17" height="12" font="3">5.2</text>
<text top="517" left="111" width="188" height="12" font="3">Results II: Testing and Coverage</text>
<text top="538" left="81" width="55" height="12" font="3">We assess</text>
<text top="539" left="140" width="39" height="11" font="2">GKLEE</text>
<text top="538" left="184" width="256" height="12" font="3">with respect to newly proposed coverage mea-</text>
<text top="553" left="81" width="359" height="12" font="3">sures and coverage directed execution pruning. In Table 4, we at-</text>
<text top="568" left="81" width="359" height="12" font="3">tempt to measure the source-code coverage by converting the given</text>
<text top="583" left="81" width="359" height="12" font="3">kernel into a sequential version (through Perl scripts) and apply-</text>
<text top="598" left="81" width="359" height="12" font="3">ing the gcov tool (better means are part of future work). The point</text>
<text top="613" left="81" width="359" height="12" font="3">is that source-code coverage may be deceptively high, as shown</text>
<text top="628" left="81" width="359" height="12" font="3">(“a/b” means “statements/branches” covered; collectively, we call</text>
<text top="643" left="81" width="359" height="12" font="3">this a target). This is the reason we rely upon only byte-code mea-</text>
<text top="658" left="81" width="161" height="12" font="3">sures, described in the sequel.</text>
<text top="674" left="99" width="39" height="11" font="2">GKLEE</text>
<text top="673" left="142" width="297" height="12" font="3">ﬁrst generated tests for the shown kernels covering all</text>
<text top="688" left="81" width="359" height="12" font="3">feasible paths, and subsequently performed test case selection. For</text>
<text top="703" left="81" width="359" height="12" font="3">example, it ﬁrst generated the 28 execution paths of Bitonic Sort;</text>
<text top="718" left="81" width="359" height="12" font="3">then it trimmed back the paths to just 5 because these ﬁve tests</text>
<text top="733" left="81" width="334" height="12" font="3">covered all the statements and branches at the byte-code level.</text>
<text top="747" left="99" width="341" height="12" font="3">Four byte-code based target coverage measures were assessed</text>
<text top="762" left="81" width="100" height="12" font="3">ﬁrst: (i) avg. Cov</text>
<text top="760" left="181" width="4" height="8" font="4">t</text>
<text top="762" left="193" width="247" height="12" font="3">measures the number of targets covered by</text>
<text top="777" left="81" width="359" height="12" font="3">threads across the whole program, averaged over the threads,</text>
<text top="792" left="81" width="71" height="12" font="3">(ii) max. Cov</text>
<text top="789" left="152" width="4" height="8" font="4">t</text>
<text top="792" left="161" width="279" height="12" font="3">that measures the maximum by any thread, (iii) avg.</text>
<text top="807" left="81" width="36" height="12" font="3">CovBI</text>
<text top="804" left="117" width="4" height="8" font="4">t</text>
<text top="807" left="125" width="77" height="12" font="3">computes Cov</text>
<text top="804" left="203" width="4" height="8" font="4">t</text>
<text top="807" left="212" width="228" height="12" font="3">separately for each barrier interval and re-</text>
<text top="822" left="81" width="257" height="12" font="3">ports the overall average, and (iv) max. CovBI</text>
<text top="819" left="338" width="4" height="8" font="4">t</text>
<text top="822" left="347" width="93" height="12" font="3">is similar to avg.</text>
<text top="837" left="81" width="36" height="12" font="3">CovBI</text>
<text top="834" left="117" width="4" height="8" font="4">t</text>
<text top="837" left="127" width="312" height="12" font="3">except for taking a maximum value. From Table 4, we</text>
<text top="852" left="81" width="359" height="12" font="3">conclude that the maximum measures give an overly optimistic</text>
<text top="867" left="81" width="312" height="12" font="3">impression, so we set them aside. We choose avg. CovBI</text>
<text top="864" left="393" width="4" height="8" font="4">t</text>
<text top="867" left="402" width="38" height="12" font="3">for our</text>
<text top="882" left="81" width="359" height="12" font="3">baseline because activities occurring within barrier intervals are</text>
<text top="897" left="81" width="359" height="12" font="3">closely related, and hence separately measuring target coverage</text>
<text top="912" left="81" width="232" height="12" font="3">within BIs tracks programmer intent better.</text>
<text top="927" left="99" width="138" height="12" font="3">Armed with avg. CovBI</text>
<text top="924" left="237" width="4" height="8" font="4">t</text>
<text top="927" left="248" width="191" height="12" font="3">and min #tests, we assess several</text>
<text top="942" left="81" width="359" height="12" font="3">benchmarks (Table 5) with ‘No Reductions’, and two test reduction</text>
<text top="957" left="81" width="359" height="12" font="3">schemes. Runs with ‘No Reductions’ and no test case selection</text>
<text top="972" left="81" width="359" height="12" font="3">applied show the total number of paths in the kernels, and the upper</text>
<text top="987" left="81" width="359" height="12" font="3">limits of target coverage (albeit at the expense of considerable</text>
<text top="1001" left="81" width="99" height="12" font="3">testing time). Red</text>
<text top="1006" left="180" width="16" height="8" font="4">T B</text>
<text top="1001" left="202" width="238" height="12" font="3">is a reduction heuristic where we separately</text>
<text top="1016" left="81" width="359" height="12" font="3">keep track of the coverage contributions by different threads. We</text>
<text top="1031" left="81" width="359" height="12" font="3">continue searching till each thread is given a chance to hit a test</text>
<text top="1046" left="81" width="359" height="12" font="3">target. For instance, in one barrier interval, if one target is reachable</text>
<text top="1061" left="81" width="359" height="12" font="3">by all the threads, we continue exploring all these threads; but</text>
<text top="1076" left="81" width="359" height="12" font="3">if the same target is reachable again (say in a loop), we cut off</text>
<text top="111" left="476" width="258" height="12" font="3">the search through the loop. In contrast, Red</text>
<text top="115" left="733" width="14" height="8" font="4">BI</text>
<text top="111" left="754" width="80" height="12" font="3">only looks for</text>
<text top="126" left="476" width="359" height="12" font="3">some thread reaching each target; once that thread has, subsequent</text>
<text top="141" left="476" width="359" height="12" font="3">thread explorations to that target are truncated (more aggressive</text>
<text top="156" left="476" width="359" height="12" font="3">reductions). While the coverage achieved is nearly the same (due</text>
<text top="171" left="476" width="359" height="12" font="3">to the largely SIMD nature of the computations), it is clear that</text>
<text top="185" left="476" width="24" height="12" font="3">Red</text>
<text top="190" left="500" width="16" height="8" font="4">T B</text>
<text top="186" left="520" width="122" height="12" font="3">is a bit more thorough.</text>
<text top="201" left="493" width="341" height="12" font="3">The overall conclusion is that to achieve high target coverage</text>
<text top="215" left="476" width="359" height="12" font="3">(virtually the same coverage as with ‘No Reductions’), reduction</text>
<text top="230" left="476" width="359" height="12" font="3">heuristics are of paramount importance, as they help contain test</text>
<text top="245" left="476" width="359" height="12" font="3">explosion. Speciﬁcally, the number of paths explored with reduc-</text>
<text top="260" left="476" width="359" height="12" font="3">tions is much lower than that done with ‘No Reductions.’ A pow-</text>
<text top="275" left="476" width="81" height="12" font="3">erful feature of</text>
<text top="276" left="560" width="39" height="11" font="2">GKLEE</text>
<text top="275" left="603" width="231" height="12" font="3">is therefore its ability to output these mini-</text>
<text top="290" left="476" width="280" height="12" font="3">mized high-quality tests for downstream debugging.</text>
<text top="305" left="476" width="359" height="12" font="3">Additional sanity-checking: we generated purely random inputs (as</text>
<text top="320" left="476" width="180" height="12" font="3">a designer might do); in all cases,</text>
<text top="321" left="659" width="39" height="11" font="2">GKLEE</text>
<text top="320" left="698" width="136" height="12" font="3">’s test generation and test</text>
<text top="335" left="476" width="359" height="12" font="3">reduction heuristics provided far superior coverage with far fewer</text>
<text top="350" left="476" width="27" height="12" font="3">tests.</text>
<text top="381" left="476" width="12" height="15" font="1">6.</text>
<text top="381" left="504" width="98" height="15" font="1">Related Work</text>
<text top="404" left="476" width="359" height="12" font="3">Traditional CUDA program debuggers [19–21] do not solve path</text>
<text top="419" left="476" width="359" height="12" font="3">constraints to home into relevant inputs that can trigger bugs. They</text>
<text top="434" left="476" width="309" height="12" font="3">examine bugs that occur only within platform executions.</text>
<text top="449" left="493" width="341" height="12" font="3">Symbolic techniques for program analysis go back to works</text>
<text top="464" left="476" width="359" height="12" font="3">such as [22] with concolic versions proposed in [6, 8] and more</text>
<text top="478" left="476" width="59" height="12" font="3">recently in</text>
<text top="479" left="541" width="31" height="11" font="2">KLEE</text>
<text top="478" left="577" width="19" height="12" font="3">[4].</text>
<text top="479" left="601" width="39" height="11" font="2">GKLEE</text>
<text top="478" left="641" width="194" height="12" font="3">’s approach is based on [4] which</text>
<text top="493" left="476" width="359" height="12" font="3">has inspired many projects [7] similar to ours. Concolic-execution</text>
<text top="508" left="476" width="359" height="12" font="3">based solvers for special domains also exist. None of these methods</text>
<text top="523" left="476" width="359" height="12" font="3">incorporate ways to deal with SIMD concurrency in GPUs and look</text>
<text top="538" left="476" width="280" height="12" font="3">for GPU-speciﬁc correctness or performance issues.</text>
<text top="553" left="493" width="58" height="12" font="3">Except for</text>
<text top="554" left="556" width="39" height="11" font="2">GKLEE</text>
<text top="553" left="595" width="239" height="12" font="3">, there are only few GPU-speciﬁc checkers</text>
<text top="568" left="476" width="359" height="12" font="3">reported in the past. Table 6 gives a comparison of these tools. An</text>
<text top="583" left="476" width="359" height="12" font="3">instrumentation based technique is reported [3] to ﬁnd races and</text>
<text top="598" left="476" width="359" height="12" font="3">shared memory bank conﬂicts. This is an ad-hoc testing approach,</text>
<text top="613" left="476" width="359" height="12" font="3">where the program is instrumented with checking code, and only</text>
<text top="628" left="476" width="359" height="12" font="3">those executions occurring in a platform-speciﬁc manner are con-</text>
<text top="643" left="476" width="359" height="12" font="3">sidered. A similar method [2] is used to ﬁnd races with the help of</text>
<text top="658" left="476" width="359" height="12" font="3">a static analysis phase. Static analysis is performed ﬁrst to locate</text>
<text top="673" left="476" width="359" height="12" font="3">possible candidates so as to reduce the runtime overheads caused</text>
<text top="688" left="476" width="359" height="12" font="3">by instrumented code. These runtime methods cannot accept sym-</text>
<text top="703" left="476" width="359" height="12" font="3">bolic inputs and verify function correctness on open inputs, not to</text>
<text top="718" left="476" width="191" height="12" font="3">mention test generation. Moreover</text>
<text top="719" left="671" width="39" height="11" font="2">GKLEE</text>
<text top="718" left="715" width="119" height="12" font="3">supports a rich set of</text>
<text top="733" left="476" width="359" height="12" font="3">C++ language features (including those considered speciﬁcally in</text>
<text top="747" left="476" width="359" height="12" font="3">tools such as [23]) which other tools do not handle. In [24], a static</text>
<text top="762" left="476" width="359" height="12" font="3">analysis based method for divergence analysis and code optimiza-</text>
<text top="777" left="476" width="92" height="12" font="3">tion is presented.</text>
<text top="792" left="493" width="341" height="12" font="3">Aiken and Gay [18] proposed a type system to check global</text>
<text top="807" left="476" width="359" height="12" font="3">synchronization errors by applying a simple single-value analysis,</text>
<text top="822" left="476" width="359" height="12" font="3">which may produce false alarms by rejecting correct programs.</text>
<text top="838" left="476" width="39" height="11" font="2">GKLEE</text>
<text top="837" left="521" width="314" height="12" font="3">uses SMT solving to compare expressions and is more</text>
<text top="852" left="476" width="41" height="12" font="3">precise.</text>
<text top="867" left="493" width="126" height="12" font="3">While the approach of</text>
<text top="868" left="625" width="24" height="11" font="2">PUG</text>
<text top="867" left="655" width="180" height="12" font="3">[1] is SMT-based, it is not very</text>
<text top="882" left="476" width="359" height="12" font="3">scalable as shown in Table 3. Recently, simple analysis for memory</text>
<text top="897" left="476" width="183" height="12" font="3">coalescing was added to it [25].</text>
<text top="898" left="664" width="24" height="11" font="2">PUG</text>
<text top="897" left="694" width="141" height="12" font="3">is also a kernel-at-a-time</text>
<text top="912" left="476" width="79" height="12" font="3">analyzer while</text>
<text top="913" left="558" width="39" height="11" font="2">GKLEE</text>
<text top="912" left="600" width="187" height="12" font="3">can analyze whole GPU programs.</text>
<text top="927" left="493" width="341" height="12" font="3">Even if we narrow down to race detection on concrete inputs,</text>
<text top="942" left="476" width="359" height="12" font="3">instrumentation based tools may suffer from performance or exten-</text>
<text top="957" left="476" width="359" height="12" font="3">sibility problems because it is hard to implement sophisticated ex-</text>
<text top="972" left="476" width="359" height="12" font="3">ecution controls and decision procedures on the source level, while</text>
<text top="988" left="476" width="39" height="11" font="2">GKLEE</text>
<text top="987" left="520" width="314" height="12" font="3">does everything over an optimized symbolic virtual ma-</text>
<text top="1001" left="476" width="359" height="12" font="3">chine. As pointed out by Boyer [3], although it is possible to run an</text>
<text top="1016" left="476" width="359" height="12" font="3">instrumentation based tool on the GPU (thus parallelizing its exe-</text>
<text top="1031" left="476" width="359" height="12" font="3">cution), CUDA only supports useful features (e.g. display debug-</text>
<text top="1046" left="476" width="359" height="12" font="3">ging information, or recording traces in a ﬁle) in emulation mode</text>
<text top="1061" left="476" width="244" height="12" font="3">which disables parallelism in GPU. Note that</text>
<text top="1062" left="724" width="39" height="11" font="2">GKLEE</text>
<text top="1061" left="766" width="68" height="12" font="3">supports test</text>
<text top="1076" left="476" width="359" height="12" font="3">case replaying on the GPU. It also supports kernel simulation on</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="7" size="10" family="Times" color="#000000"/>
<text top="110" left="108" width="42" height="11" font="7">Kernels</text>
<text top="110" left="227" width="20" height="11" font="7">Loc</text>
<text top="110" left="270" width="26" height="11" font="7">Race</text>
<text top="110" left="326" width="29" height="11" font="7">Func.</text>
<text top="110" left="385" width="14" height="11" font="7">#T</text>
<text top="110" left="417" width="71" height="11" font="7">Bank Conﬂict</text>
<text top="110" left="510" width="148" height="11" font="7">Coalesced Accesses (↑ perf.)</text>
<text top="110" left="679" width="69" height="11" font="7">Warp Diverg.</text>
<text top="110" left="768" width="40" height="11" font="7">Volatile</text>
<text top="124" left="327" width="26" height="11" font="7">Corr.</text>
<text top="124" left="431" width="42" height="11" font="7">(↓ perf.)</text>
<text top="124" left="693" width="42" height="11" font="7">(↓ perf.)</text>
<text top="124" left="768" width="39" height="11" font="7">Needed</text>
<text top="139" left="419" width="16" height="11" font="7">1.x</text>
<text top="139" left="463" width="16" height="11" font="7">2.x</text>
<text top="139" left="505" width="48" height="11" font="7">1.0 &amp; 1.1</text>
<text top="139" left="570" width="48" height="11" font="7">1.2 &amp; 1.3</text>
<text top="139" left="641" width="16" height="11" font="7">2.x</text>
<text top="154" left="108" width="62" height="11" font="7">Bitonic Sort</text>
<text top="154" left="231" width="13" height="11" font="7">30</text>
<text top="154" left="332" width="17" height="11" font="7">yes</text>
<text top="154" left="389" width="6" height="11" font="7">4</text>
<text top="155" left="419" width="15" height="10" font="2">0%</text>
<text top="155" left="464" width="15" height="10" font="2">0%</text>
<text top="155" left="516" width="27" height="10" font="2">100%</text>
<text top="155" left="581" width="27" height="10" font="2">100%</text>
<text top="155" left="636" width="27" height="10" font="2">100%</text>
<text top="155" left="703" width="21" height="10" font="2">60%</text>
<text top="154" left="781" width="13" height="11" font="7">no</text>
<text top="168" left="108" width="75" height="11" font="7">Scalar Product</text>
<text top="168" left="231" width="13" height="11" font="7">30</text>
<text top="168" left="332" width="17" height="11" font="7">yes</text>
<text top="168" left="386" width="13" height="11" font="7">64</text>
<text top="169" left="419" width="15" height="10" font="2">0%</text>
<text top="169" left="464" width="15" height="10" font="2">0%</text>
<text top="169" left="519" width="21" height="10" font="2">11%</text>
<text top="169" left="581" width="27" height="10" font="2">100%</text>
<text top="169" left="636" width="27" height="10" font="2">100%</text>
<text top="169" left="700" width="27" height="10" font="2">100%</text>
<text top="168" left="779" width="17" height="11" font="7">yes</text>
<text top="182" left="108" width="63" height="11" font="7">Matrix Mult</text>
<text top="182" left="231" width="13" height="11" font="7">61</text>
<text top="182" left="332" width="17" height="11" font="7">yes</text>
<text top="182" left="386" width="13" height="11" font="7">64</text>
<text top="183" left="419" width="15" height="10" font="2">0%</text>
<text top="183" left="464" width="15" height="10" font="2">0%</text>
<text top="183" left="516" width="27" height="10" font="2">100%</text>
<text top="183" left="581" width="27" height="10" font="2">100%</text>
<text top="183" left="636" width="27" height="10" font="2">100%</text>
<text top="183" left="706" width="15" height="10" font="2">0%</text>
<text top="182" left="781" width="13" height="11" font="7">no</text>
<text top="198" left="108" width="67" height="11" font="7">Histogram64</text>
<text top="195" left="175" width="12" height="8" font="4">tb.</text>
<text top="198" left="231" width="13" height="11" font="7">69</text>
<text top="198" left="268" width="24" height="11" font="7">WW</text>
<text top="195" left="293" width="5" height="8" font="4">?</text>
<text top="198" left="315" width="50" height="11" font="7">Unknown</text>
<text top="198" left="386" width="13" height="11" font="7">32</text>
<text top="199" left="417" width="21" height="10" font="2">66%</text>
<text top="199" left="461" width="21" height="10" font="2">66%</text>
<text top="199" left="516" width="27" height="10" font="2">100%</text>
<text top="199" left="581" width="27" height="10" font="2">100%</text>
<text top="199" left="636" width="27" height="10" font="2">100%</text>
<text top="199" left="706" width="15" height="10" font="2">0%</text>
<text top="198" left="779" width="17" height="11" font="7">yes</text>
<text top="212" left="108" width="71" height="11" font="7">Reduction (7)</text>
<text top="212" left="227" width="19" height="11" font="7">231</text>
<text top="212" left="332" width="17" height="11" font="7">yes</text>
<text top="212" left="386" width="13" height="11" font="7">16</text>
<text top="213" left="419" width="15" height="10" font="2">0%</text>
<text top="213" left="464" width="15" height="10" font="2">0%</text>
<text top="213" left="516" width="27" height="10" font="2">100%</text>
<text top="213" left="581" width="27" height="10" font="2">100%</text>
<text top="213" left="636" width="27" height="10" font="2">100%</text>
<text top="213" left="693" width="42" height="10" font="2">16∼83%</text>
<text top="212" left="779" width="17" height="11" font="7">yes</text>
<text top="226" left="108" width="51" height="11" font="7">Scan Best</text>
<text top="226" left="231" width="13" height="11" font="7">78</text>
<text top="226" left="332" width="17" height="11" font="7">yes</text>
<text top="226" left="386" width="13" height="11" font="7">32</text>
<text top="227" left="417" width="21" height="10" font="2">71%</text>
<text top="227" left="461" width="21" height="10" font="2">71%</text>
<text top="227" left="516" width="27" height="10" font="2">100%</text>
<text top="227" left="581" width="27" height="10" font="2">100%</text>
<text top="227" left="636" width="27" height="10" font="2">100%</text>
<text top="227" left="703" width="21" height="10" font="2">71%</text>
<text top="226" left="781" width="13" height="11" font="7">no</text>
<text top="240" left="108" width="58" height="11" font="7">Scan Naive</text>
<text top="240" left="231" width="13" height="11" font="7">28</text>
<text top="240" left="332" width="17" height="11" font="7">yes</text>
<text top="240" left="386" width="13" height="11" font="7">32</text>
<text top="241" left="419" width="15" height="10" font="2">0%</text>
<text top="241" left="464" width="15" height="10" font="2">0%</text>
<text top="241" left="519" width="21" height="10" font="2">50%</text>
<text top="241" left="581" width="27" height="10" font="2">100%</text>
<text top="241" left="636" width="27" height="10" font="2">100%</text>
<text top="241" left="703" width="21" height="10" font="2">85%</text>
<text top="240" left="779" width="17" height="11" font="7">yes</text>
<text top="254" left="108" width="98" height="11" font="7">Scan Workefﬁcient</text>
<text top="254" left="231" width="13" height="11" font="7">60</text>
<text top="254" left="332" width="17" height="11" font="7">yes</text>
<text top="254" left="386" width="13" height="11" font="7">32</text>
<text top="255" left="417" width="21" height="10" font="2">83%</text>
<text top="255" left="461" width="21" height="10" font="2">16%</text>
<text top="255" left="522" width="15" height="10" font="2">0%</text>
<text top="255" left="581" width="27" height="10" font="2">100%</text>
<text top="255" left="641" width="15" height="10" font="2">0%</text>
<text top="255" left="703" width="21" height="10" font="2">83%</text>
<text top="254" left="781" width="13" height="11" font="7">no</text>
<text top="269" left="108" width="58" height="11" font="7">Scan Large</text>
<text top="269" left="227" width="19" height="11" font="7">196</text>
<text top="269" left="332" width="17" height="11" font="7">yes</text>
<text top="269" left="386" width="13" height="11" font="7">32</text>
<text top="270" left="417" width="21" height="10" font="2">71%</text>
<text top="270" left="461" width="21" height="10" font="2">71%</text>
<text top="270" left="516" width="27" height="10" font="2">100%</text>
<text top="270" left="581" width="27" height="10" font="2">100%</text>
<text top="270" left="636" width="27" height="10" font="2">100%</text>
<text top="270" left="703" width="21" height="10" font="2">71%</text>
<text top="269" left="781" width="13" height="11" font="7">no</text>
<text top="283" left="108" width="55" height="11" font="7">Radix Sort</text>
<text top="283" left="227" width="19" height="11" font="7">750</text>
<text top="283" left="271" width="24" height="11" font="7">WW</text>
<text top="283" left="329" width="23" height="11" font="7">yes*</text>
<text top="283" left="386" width="13" height="11" font="7">16</text>
<text top="284" left="419" width="15" height="10" font="2">3%</text>
<text top="284" left="464" width="15" height="10" font="2">0%</text>
<text top="284" left="522" width="15" height="10" font="2">0%</text>
<text top="284" left="581" width="27" height="10" font="2">100%</text>
<text top="284" left="636" width="27" height="10" font="2">100%</text>
<text top="284" left="706" width="15" height="10" font="2">5%</text>
<text top="283" left="779" width="17" height="11" font="7">yes</text>
<text top="297" left="108" width="65" height="11" font="7">Bisect Small</text>
<text top="297" left="223" width="29" height="11" font="7">1,000</text>
<text top="297" left="271" width="24" height="11" font="7">WW</text>
<text top="297" left="337" width="6" height="11" font="7">–</text>
<text top="297" left="386" width="13" height="11" font="7">16</text>
<text top="298" left="417" width="21" height="10" font="2">38%</text>
<text top="298" left="464" width="15" height="10" font="2">0%</text>
<text top="298" left="519" width="21" height="10" font="2">97%</text>
<text top="298" left="581" width="27" height="10" font="2">100%</text>
<text top="298" left="636" width="27" height="10" font="2">100%</text>
<text top="298" left="703" width="21" height="10" font="2">43%</text>
<text top="297" left="779" width="17" height="11" font="7">yes</text>
<text top="313" left="108" width="65" height="11" font="7">Bisect Large</text>
<text top="310" left="173" width="12" height="8" font="4">tb.</text>
<text top="313" left="223" width="29" height="11" font="7">1,400</text>
<text top="313" left="272" width="22" height="11" font="7">ben.</text>
<text top="313" left="337" width="6" height="11" font="7">–</text>
<text top="313" left="386" width="13" height="11" font="7">16</text>
<text top="314" left="417" width="21" height="10" font="2">15%</text>
<text top="314" left="464" width="15" height="10" font="2">0%</text>
<text top="314" left="519" width="21" height="10" font="2">99%</text>
<text top="314" left="581" width="27" height="10" font="2">100%</text>
<text top="314" left="636" width="27" height="10" font="2">100%</text>
<text top="314" left="703" width="21" height="10" font="2">53%</text>
<text top="313" left="779" width="17" height="11" font="7">yes</text>
<text top="339" left="81" width="46" height="12" font="3">Table 1.</text>
<text top="340" left="134" width="700" height="11" font="2">SDK 2.0 Kernel results. “Reduction” contains 7 kernels with different implementations; we average the results. Results for “Histogram64,” and</text>
<text top="353" left="81" width="753" height="11" font="2">“Bisect Large” are time-bounded (tb.) to 20 mins. Func. Corr. results about ﬂoat values are skipped at –. We checked the integer version of “Radix Sort”; and</text>
<text top="367" left="81" width="313" height="11" font="2">CUDPP library calls involved in “Radix Sort” were not analyzed.</text>
<text top="397" left="128" width="39" height="11" font="2">Kernels</text>
<text top="398" left="223" width="19" height="11" font="2">Loc</text>
<text top="398" left="261" width="24" height="11" font="2">Race</text>
<text top="398" left="306" width="13" height="11" font="2">#T</text>
<text top="398" left="338" width="106" height="11" font="2">Bank Conﬂict(↓ perf.)</text>
<text top="398" left="471" width="138" height="11" font="2">Coalesced Accesses (↑ perf.)</text>
<text top="398" left="637" width="64" height="11" font="2">Warp Diverg.</text>
<text top="398" left="719" width="67" height="11" font="2">Volatile(N/M)</text>
<text top="411" left="347" width="15" height="11" font="2">1.x</text>
<text top="411" left="408" width="15" height="11" font="2">2.x</text>
<text top="411" left="460" width="45" height="11" font="2">1.0 &amp; 1.1</text>
<text top="411" left="521" width="45" height="11" font="2">1.2 &amp; 1.3</text>
<text top="411" left="594" width="15" height="11" font="2">2.x</text>
<text top="411" left="649" width="39" height="11" font="2">(↓ perf.)</text>
<text top="425" left="128" width="29" height="11" font="2">Clock</text>
<text top="425" left="226" width="12" height="11" font="2">38</text>
<text top="425" left="307" width="12" height="11" font="2">64</text>
<text top="426" left="347" width="14" height="9" font="5">0%</text>
<text top="426" left="408" width="14" height="9" font="5">0%</text>
<text top="426" left="475" width="14" height="9" font="5">0%</text>
<text top="426" left="531" width="25" height="9" font="5">100%</text>
<text top="426" left="589" width="25" height="9" font="5">100%</text>
<text top="426" left="659" width="19" height="9" font="5">85%</text>
<text top="425" left="739" width="27" height="11" font="2">no/no</text>
<text top="438" left="128" width="70" height="11" font="2">Scalar Product</text>
<text top="438" left="226" width="12" height="11" font="2">47</text>
<text top="438" left="304" width="18" height="11" font="2">128</text>
<text top="439" left="347" width="14" height="9" font="5">0%</text>
<text top="439" left="408" width="14" height="9" font="5">0%</text>
<text top="439" left="473" width="19" height="9" font="5">50%</text>
<text top="439" left="531" width="25" height="9" font="5">100%</text>
<text top="439" left="589" width="25" height="9" font="5">100%</text>
<text top="439" left="659" width="19" height="9" font="5">36%</text>
<text top="438" left="739" width="27" height="11" font="2">no/no</text>
<text top="453" left="128" width="62" height="11" font="2">Histogram64</text>
<text top="451" left="191" width="11" height="7" font="6">tb.</text>
<text top="453" left="226" width="12" height="11" font="2">70</text>
<text top="453" left="307" width="12" height="11" font="2">64</text>
<text top="454" left="347" width="14" height="9" font="5">0%</text>
<text top="454" left="406" width="19" height="9" font="5">33%</text>
<text top="454" left="475" width="14" height="9" font="5">0%</text>
<text top="454" left="536" width="14" height="9" font="5">0%</text>
<text top="454" left="594" width="14" height="9" font="5">0%</text>
<text top="454" left="662" width="14" height="9" font="5">0%</text>
<text top="453" left="739" width="27" height="11" font="2">no/no</text>
<text top="466" left="128" width="52" height="11" font="2">Scan Short</text>
<text top="466" left="223" width="18" height="11" font="2">103</text>
<text top="466" left="307" width="12" height="11" font="2">64</text>
<text top="467" left="347" width="14" height="9" font="5">0%</text>
<text top="467" left="408" width="14" height="9" font="5">0%</text>
<text top="467" left="475" width="14" height="9" font="5">0%</text>
<text top="467" left="531" width="25" height="9" font="5">100%</text>
<text top="467" left="589" width="25" height="9" font="5">100%</text>
<text top="467" left="662" width="14" height="9" font="5">0%</text>
<text top="466" left="737" width="31" height="11" font="2">yes/no</text>
<text top="480" left="128" width="54" height="11" font="2">Scan Large</text>
<text top="480" left="223" width="18" height="11" font="2">226</text>
<text top="480" left="307" width="12" height="11" font="2">64</text>
<text top="481" left="347" width="14" height="9" font="5">0%</text>
<text top="481" left="408" width="14" height="9" font="5">0%</text>
<text top="481" left="475" width="14" height="9" font="5">0%</text>
<text top="481" left="534" width="19" height="9" font="5">67%</text>
<text top="481" left="592" width="19" height="9" font="5">67%</text>
<text top="481" left="659" width="19" height="9" font="5">25%</text>
<text top="480" left="737" width="31" height="11" font="2">yes/no</text>
<text top="493" left="128" width="66" height="11" font="2">Transpose (8)</text>
<text top="493" left="223" width="18" height="11" font="2">172</text>
<text top="493" left="304" width="18" height="11" font="2">256</text>
<text top="494" left="338" width="34" height="9" font="5">0∼50%</text>
<text top="494" left="396" width="39" height="9" font="5">0∼100%</text>
<text top="494" left="463" width="39" height="9" font="5">0∼100%</text>
<text top="494" left="524" width="39" height="9" font="5">0∼100%</text>
<text top="494" left="582" width="39" height="9" font="5">0∼100%</text>
<text top="494" left="662" width="14" height="9" font="5">0%</text>
<text top="493" left="739" width="27" height="11" font="2">no/no</text>
<text top="506" left="128" width="61" height="11" font="2">Bisect Small</text>
<text top="506" left="219" width="27" height="11" font="2">1,000</text>
<text top="506" left="262" width="23" height="11" font="2">WW</text>
<text top="506" left="307" width="12" height="11" font="2">16</text>
<text top="507" left="345" width="19" height="9" font="5">38%</text>
<text top="507" left="408" width="14" height="9" font="5">0%</text>
<text top="507" left="473" width="19" height="9" font="5">97%</text>
<text top="507" left="531" width="25" height="9" font="5">100%</text>
<text top="507" left="589" width="25" height="9" font="5">100%</text>
<text top="507" left="659" width="19" height="9" font="5">43%</text>
<text top="506" left="735" width="35" height="11" font="2">yes/yes</text>
<text top="531" left="81" width="753" height="12" font="3">Table 2. SDK 4.0 Kernel results. If volatiles needed (N) is ’yes’ and missed (M) is ’no’, the code annotation is correct. Examples with both</text>
<text top="546" left="81" width="753" height="12" font="3">’yes’ (missed volatiles) were found. Transpose contains 8 different implementations; we report the results as a range through “∼”. Kernels</text>
<text top="561" left="81" width="669" height="12" font="3">having the same results as their SDK 2.0 versions, including Bitonic Sort, MatrixMult and Bisect Large, are not presented.</text>
<text top="593" left="178" width="39" height="11" font="2">Kernels</text>
<text top="594" left="309" width="32" height="11" font="2">#T = 4</text>
<text top="594" left="435" width="38" height="11" font="2">#T = 16</text>
<text top="594" left="543" width="38" height="11" font="2">#T = 64</text>
<text top="594" left="619" width="44" height="11" font="2">#T = 256</text>
<text top="594" left="685" width="53" height="11" font="2">#T = 1,024</text>
<text top="608" left="269" width="24" height="11" font="2">PUG</text>
<text top="608" left="326" width="39" height="11" font="2">GKLEE</text>
<text top="608" left="398" width="24" height="11" font="2">PUG</text>
<text top="608" left="455" width="39" height="11" font="2">GKLEE</text>
<text top="608" left="542" width="39" height="11" font="2">GKLEE</text>
<text top="608" left="621" width="39" height="11" font="2">GKLEE</text>
<text top="608" left="691" width="39" height="11" font="2">GKLEE</text>
<text top="622" left="178" width="74" height="11" font="2">Simple Reduct.</text>
<text top="622" left="274" width="15" height="11" font="2">2.8</text>
<text top="622" left="311" width="69" height="11" font="2">&lt; 0.1(&lt; 0.1)</text>
<text top="622" left="401" width="18" height="11" font="2">T.O</text>
<text top="622" left="440" width="69" height="11" font="2">&lt; 0.1(&lt; 0.1)</text>
<text top="622" left="527" width="69" height="11" font="2">&lt; 0.1(&lt; 0.1)</text>
<text top="622" left="619" width="42" height="11" font="2">0.2(0.3)</text>
<text top="622" left="690" width="42" height="11" font="2">2.3(2.9)</text>
<text top="635" left="178" width="71" height="11" font="2">Matrix Transp.</text>
<text top="635" left="274" width="15" height="11" font="2">1.9</text>
<text top="635" left="311" width="69" height="11" font="2">&lt; 0.1(&lt; 0.1)</text>
<text top="635" left="401" width="18" height="11" font="2">T.O</text>
<text top="635" left="447" width="56" height="11" font="2">&lt; 0.1(0.3)</text>
<text top="635" left="534" width="56" height="11" font="2">&lt; 0.1(3.2)</text>
<text top="635" left="614" width="52" height="11" font="2">&lt; 0.1(63)</text>
<text top="635" left="690" width="42" height="11" font="2">0.9(T.O)</text>
<text top="649" left="178" width="58" height="11" font="2">Bitonic Sort</text>
<text top="649" left="274" width="15" height="11" font="2">3.7</text>
<text top="648" left="330" width="32" height="11" font="2">0.9(1)</text>
<text top="649" left="401" width="18" height="11" font="2">T.O</text>
<text top="649" left="466" width="18" height="11" font="2">T.O</text>
<text top="649" left="553" width="18" height="11" font="2">T.O</text>
<text top="649" left="631" width="18" height="11" font="2">T.O</text>
<text top="649" left="702" width="18" height="11" font="2">T.O</text>
<text top="662" left="178" width="54" height="11" font="2">Scan Large</text>
<text top="662" left="278" width="6" height="11" font="2">–</text>
<text top="662" left="311" width="69" height="11" font="2">&lt; 0.1(&lt; 0.1)</text>
<text top="662" left="407" width="6" height="11" font="2">–</text>
<text top="662" left="440" width="69" height="11" font="2">&lt; 0.1(&lt; 0.1)</text>
<text top="662" left="541" width="42" height="11" font="2">0.1(0.2)</text>
<text top="662" left="624" width="32" height="11" font="2">1.6(3)</text>
<text top="662" left="695" width="32" height="11" font="2">22(51)</text>
<text top="698" left="81" width="221" height="12" font="3">Table 3. Execution times (in seconds) of</text>
<text top="699" left="305" width="39" height="11" font="2">GKLEE</text>
<text top="698" left="347" width="19" height="12" font="3">and</text>
<text top="699" left="370" width="24" height="11" font="2">PUG</text>
<text top="698" left="397" width="437" height="12" font="3">[1] on some kernels for functional correctness check. #T is the number of threads.</text>
<text top="713" left="81" width="454" height="12" font="3">Time is reported in the format of GPU time (entire time); T.O means &gt; 5 minutes.</text>
<text top="741" left="146" width="39" height="11" font="2">Kernels</text>
<text top="742" left="251" width="88" height="11" font="2">src. code coverage</text>
<text top="742" left="357" width="44" height="11" font="2">min #test</text>
<text top="742" left="422" width="43" height="11" font="2">avg. Cov</text>
<text top="739" left="465" width="4" height="8" font="4">t</text>
<text top="742" left="491" width="46" height="11" font="2">max. Cov</text>
<text top="739" left="538" width="4" height="8" font="4">t</text>
<text top="742" left="561" width="55" height="11" font="2">avg. CovBI</text>
<text top="739" left="616" width="4" height="8" font="4">t</text>
<text top="742" left="639" width="58" height="11" font="2">max. CovBI</text>
<text top="739" left="697" width="4" height="8" font="4">t</text>
<text top="742" left="720" width="49" height="11" font="2">exec. time</text>
<text top="756" left="146" width="58" height="11" font="2">Bitonic Sort</text>
<text top="756" left="266" width="59" height="11" font="2">100%/100%</text>
<text top="756" left="376" width="6" height="11" font="2">5</text>
<text top="756" left="422" width="47" height="11" font="2">78%/76%</text>
<text top="756" left="490" width="53" height="11" font="2">100%/94%</text>
<text top="756" left="568" width="47" height="11" font="2">79%/66%</text>
<text top="756" left="647" width="47" height="11" font="2">90%/76%</text>
<text top="756" left="739" width="11" height="11" font="2">1s</text>
<text top="769" left="146" width="54" height="11" font="2">Merge Sort</text>
<text top="769" left="266" width="59" height="11" font="2">100%/100%</text>
<text top="769" left="376" width="6" height="11" font="2">6</text>
<text top="769" left="422" width="47" height="11" font="2">88%/70%</text>
<text top="769" left="490" width="53" height="11" font="2">100%/85%</text>
<text top="769" left="568" width="47" height="11" font="2">93%/86%</text>
<text top="769" left="641" width="59" height="11" font="2">100%/100%</text>
<text top="769" left="735" width="20" height="11" font="2">1.6s</text>
<text top="783" left="146" width="62" height="11" font="2">Word Search</text>
<text top="783" left="266" width="59" height="11" font="2">100%/100%</text>
<text top="783" left="376" width="6" height="11" font="2">2</text>
<text top="783" left="419" width="53" height="11" font="2">100%/81%</text>
<text top="783" left="490" width="53" height="11" font="2">100%/85%</text>
<text top="783" left="565" width="53" height="11" font="2">100%/97%</text>
<text top="783" left="641" width="59" height="11" font="2">100%/100%</text>
<text top="783" left="735" width="20" height="11" font="2">0.1s</text>
<text top="796" left="146" width="87" height="11" font="2">Sufﬁx Tree Match</text>
<text top="796" left="269" width="53" height="11" font="2">100%/90%</text>
<text top="796" left="376" width="6" height="11" font="2">7</text>
<text top="796" left="422" width="47" height="11" font="2">55%/49%</text>
<text top="796" left="493" width="47" height="11" font="2">98%/66%</text>
<text top="796" left="568" width="47" height="11" font="2">55%/49%</text>
<text top="796" left="647" width="47" height="11" font="2">98%/83%</text>
<text top="796" left="736" width="17" height="11" font="2">31s</text>
<text top="811" left="146" width="62" height="11" font="2">Histogram64</text>
<text top="808" left="209" width="13" height="8" font="4">tb.</text>
<text top="811" left="266" width="59" height="11" font="2">100%/100%</text>
<text top="811" left="376" width="6" height="11" font="2">9</text>
<text top="811" left="419" width="53" height="11" font="2">100%/75%</text>
<text top="811" left="490" width="53" height="11" font="2">100%/75%</text>
<text top="811" left="562" width="59" height="11" font="2">100%/100%</text>
<text top="811" left="641" width="59" height="11" font="2">100%/100%</text>
<text top="811" left="733" width="23" height="11" font="2">600s</text>
<text top="840" left="81" width="74" height="12" font="3">Table 4. Cov</text>
<text top="837" left="155" width="4" height="8" font="4">t</text>
<text top="840" left="163" width="62" height="12" font="3">and CovTB</text>
<text top="837" left="224" width="4" height="8" font="4">t</text>
<text top="840" left="233" width="602" height="12" font="3">measure bytecode coverage w.r.t threads. min #test tests are obtained by performing test case selection after the</text>
<text top="855" left="81" width="747" height="12" font="3">execution. Result for “Histogram64” is limited to 600 s. No test reductions used in generating this table. Exec. time on typical workstation.</text>
<text top="882" left="81" width="315" height="12" font="3">the CPU as the CUDA debugger does. Last but not least,</text>
<text top="883" left="400" width="39" height="11" font="2">GKLEE</text>
<text top="897" left="81" width="319" height="12" font="3">can look for compiler-related bugs due to omitted volatiles.</text>
<text top="912" left="99" width="171" height="12" font="3">The KLEE-FP [26] tool extends</text>
<text top="913" left="273" width="31" height="11" font="2">KLEE</text>
<text top="912" left="307" width="133" height="12" font="3">to cross-check IEEE 754</text>
<text top="927" left="81" width="359" height="12" font="3">ﬂoating-point programs and their SIMD-vectorized versions. Two</text>
<text top="942" left="81" width="359" height="12" font="3">ﬂoating-point expressions are equivalent if they can be normalized</text>
<text top="957" left="81" width="359" height="12" font="3">to the same form. This tool does not address the same class of cor-</text>
<text top="972" left="81" width="183" height="12" font="3">rectness and performance bugs as</text>
<text top="973" left="268" width="39" height="11" font="2">GKLEE</text>
<text top="972" left="307" width="132" height="12" font="3">, neither does it produce</text>
<text top="987" left="81" width="359" height="12" font="3">concrete test cases. However, its ﬂoating-point package can help</text>
<text top="1002" left="81" width="53" height="12" font="3">overcome</text>
<text top="1003" left="138" width="39" height="11" font="2">GKLEE</text>
<text top="1002" left="177" width="262" height="12" font="3">’s current inability to handle ﬂoat numbers. Re-</text>
<text top="1017" left="81" width="218" height="12" font="3">cently KLEE-FP has been extended [27]</text>
<text top="1015" left="303" width="4" height="8" font="4">3</text>
<text top="1017" left="308" width="132" height="12" font="3">to handle OpenCL code,</text>
<text top="1032" left="81" width="359" height="12" font="3">targeted in particular at crosschecking OpenCL code against an ini-</text>
<text top="1047" left="81" width="342" height="12" font="3">tial scalar sequential version, and on ﬁnding races in such code.</text>
<text top="1075" left="81" width="4" height="8" font="4">3</text>
<text top="1077" left="88" width="317" height="11" font="2">This work and that in this paper were concurrent and independent.</text>
<text top="882" left="476" width="122" height="12" font="3">Some Limitations of</text>
<text top="883" left="604" width="43" height="11" font="2">GKLEE</text>
<text top="882" left="646" width="3" height="12" font="3">.</text>
<text top="883" left="656" width="39" height="11" font="2">GKLEE</text>
<text top="882" left="702" width="132" height="12" font="3">cannot be used to ana-</text>
<text top="897" left="476" width="359" height="12" font="3">lyze the functional correctness of CUDA applications that involve</text>
<text top="912" left="476" width="359" height="12" font="3">ﬂoating-point calculations (efﬁcient SMT methods for ﬂoating-</text>
<text top="927" left="476" width="359" height="12" font="3">point arithmetic, when available, will help here). The concolic na-</text>
<text top="942" left="476" width="37" height="12" font="3">ture of</text>
<text top="943" left="518" width="39" height="11" font="2">GKLEE</text>
<text top="942" left="562" width="272" height="12" font="3">can help ameliorate this drawback by sometimes</text>
<text top="957" left="476" width="359" height="12" font="3">“concretizing” the ﬂoating numbers to integers. All other analyses</text>
<text top="972" left="476" width="43" height="12" font="3">done by</text>
<text top="973" left="522" width="39" height="11" font="2">GKLEE</text>
<text top="972" left="564" width="270" height="12" font="3">are unaffected by ﬂoating-point types, as typically</text>
<text top="987" left="476" width="269" height="12" font="3">variable addresses involve only unsigned integers.</text>
<text top="1023" left="476" width="12" height="15" font="1">7.</text>
<text top="1023" left="504" width="149" height="15" font="1">Concluding Remarks</text>
<text top="1046" left="476" width="72" height="12" font="3">We presented</text>
<text top="1047" left="551" width="39" height="11" font="2">GKLEE</text>
<text top="1046" left="590" width="244" height="12" font="3">, the ﬁrst symbolic virtual machine based cor-</text>
<text top="1061" left="476" width="359" height="12" font="3">rectness checker and test generator for GPU programs written in</text>
<text top="1076" left="476" width="359" height="12" font="3">CUDA/C++. It checks several error categories, including one pre-</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1188" width="918">
<text top="110" left="231" width="39" height="11" font="2">Kernels</text>
<text top="110" left="352" width="71" height="11" font="2">No Reductions</text>
<text top="110" left="492" width="19" height="11" font="2">Red</text>
<text top="114" left="511" width="16" height="8" font="4">T B</text>
<text top="110" left="615" width="19" height="11" font="2">Red</text>
<text top="114" left="634" width="14" height="8" font="4">BI</text>
<text top="124" left="336" width="27" height="11" font="2">#path</text>
<text top="124" left="381" width="55" height="11" font="2">avg. CovBI</text>
<text top="122" left="435" width="4" height="8" font="4">t</text>
<text top="124" left="458" width="27" height="11" font="2">#path</text>
<text top="124" left="504" width="52" height="11" font="2">avg.CovBI</text>
<text top="122" left="556" width="4" height="8" font="4">t</text>
<text top="124" left="580" width="27" height="11" font="2">#path</text>
<text top="124" left="624" width="55" height="11" font="2">avg. CovBI</text>
<text top="122" left="679" width="4" height="8" font="4">t</text>
<text top="138" left="231" width="58" height="11" font="2">Bitonic Sort</text>
<text top="138" left="343" width="12" height="11" font="2">28</text>
<text top="138" left="387" width="47" height="11" font="2">79%/66%</text>
<text top="138" left="469" width="6" height="11" font="2">5</text>
<text top="138" left="509" width="47" height="11" font="2">79%/66%</text>
<text top="138" left="590" width="6" height="11" font="2">5</text>
<text top="138" left="631" width="47" height="11" font="2">79%/65%</text>
<text top="152" left="231" width="54" height="11" font="2">Merge Sort</text>
<text top="152" left="343" width="12" height="11" font="2">34</text>
<text top="152" left="387" width="47" height="11" font="2">93%/86%</text>
<text top="152" left="469" width="6" height="11" font="2">4</text>
<text top="152" left="509" width="47" height="11" font="2">92%/84%</text>
<text top="152" left="590" width="6" height="11" font="2">4</text>
<text top="152" left="631" width="47" height="11" font="2">92%/84%</text>
<text top="165" left="231" width="62" height="11" font="2">Word Search</text>
<text top="165" left="346" width="6" height="11" font="2">8</text>
<text top="165" left="384" width="53" height="11" font="2">100%/97%</text>
<text top="165" left="469" width="6" height="11" font="2">2</text>
<text top="165" left="506" width="53" height="11" font="2">100%/97%</text>
<text top="165" left="590" width="6" height="11" font="2">2</text>
<text top="165" left="631" width="47" height="11" font="2">94%/85%</text>
<text top="179" left="231" width="87" height="11" font="2">Sufﬁx Tree Match</text>
<text top="179" left="343" width="12" height="11" font="2">31</text>
<text top="179" left="387" width="47" height="11" font="2">55%/49%</text>
<text top="179" left="469" width="6" height="11" font="2">6</text>
<text top="179" left="509" width="47" height="11" font="2">55%/49%</text>
<text top="179" left="590" width="6" height="11" font="2">6</text>
<text top="179" left="631" width="47" height="11" font="2">55%/49%</text>
<text top="192" left="231" width="62" height="11" font="2">Histogram64</text>
<text top="192" left="343" width="12" height="11" font="2">13</text>
<text top="192" left="381" width="59" height="11" font="2">100%/100%</text>
<text top="192" left="469" width="6" height="11" font="2">5</text>
<text top="192" left="503" width="59" height="11" font="2">100%/100%</text>
<text top="192" left="590" width="6" height="11" font="2">5</text>
<text top="192" left="625" width="59" height="11" font="2">100%/100%</text>
<text top="219" left="337" width="237" height="12" font="3">Table 5. Reduction Heuristic Comparisons.</text>
<text top="246" left="91" width="63" height="11" font="2">Comparison</text>
<text top="261" left="91" width="54" height="11" font="2">Categories</text>
<text top="261" left="265" width="39" height="11" font="2">GKLEE</text>
<text top="261" left="437" width="41" height="11" font="2">PUG [1]</text>
<text top="261" left="585" width="46" height="11" font="2">GRace[2]</text>
<text top="261" left="754" width="14" height="11" font="2">[3]</text>
<text top="275" left="91" width="64" height="11" font="2">Methodology</text>
<text top="275" left="204" width="163" height="11" font="2">Concolic Exec. in virtual machine</text>
<text top="275" left="412" width="91" height="11" font="2">Symbolic Analysis</text>
<text top="275" left="538" width="142" height="11" font="2">Static Analysis + Dyn. Check</text>
<text top="275" left="722" width="77" height="11" font="2">Dynamic Check</text>
<text top="289" left="91" width="85" height="11" font="2">Level of Analysis</text>
<text top="289" left="245" width="81" height="11" font="2">LLVM Bytecode</text>
<text top="289" left="426" width="61" height="11" font="2">Source Code</text>
<text top="289" left="545" width="127" height="11" font="2">Source Code (Instrument.)</text>
<text top="289" left="697" width="127" height="11" font="2">Source Code (Instrument.)</text>
<text top="304" left="91" width="69" height="11" font="2">Bugs Targeted</text>
<text top="304" left="195" width="180" height="11" font="2">Race (intra-/inter- warp, all memory),</text>
<text top="304" left="410" width="94" height="11" font="2">Shared Mem. Race,</text>
<text top="304" left="553" width="112" height="11" font="2">Intra-/Inter- Warp Race</text>
<text top="304" left="716" width="90" height="11" font="2">Shared Mem. race,</text>
<text top="317" left="214" width="142" height="11" font="2">Warp Divergence, Deadlocks,</text>
<text top="317" left="396" width="123" height="11" font="2">Deadlocks, Bank Conﬂict</text>
<text top="317" left="728" width="67" height="11" font="2">Bank Conﬂict</text>
<text top="330" left="203" width="165" height="11" font="2">Memory Coalesce, Bank Conﬂicts</text>
<text top="344" left="193" width="184" height="11" font="2">Compilation level bugs (e.g. Volatiles)</text>
<text top="358" left="91" width="83" height="11" font="2">False alarm elim.</text>
<text top="358" left="215" width="141" height="11" font="2">SMT-solving, GPU replaying</text>
<text top="358" left="395" width="125" height="11" font="2">Auto./Manual Reﬁnement</text>
<text top="358" left="561" width="95" height="11" font="2">Dynamic Execution</text>
<text top="358" left="713" width="95" height="11" font="2">Dynamic Execution</text>
<text top="372" left="91" width="76" height="11" font="2">Test Generation</text>
<text top="372" left="206" width="158" height="11" font="2">Automatic, Hardware Execution,</text>
<text top="372" left="423" width="68" height="11" font="2">Not supported</text>
<text top="372" left="574" width="68" height="11" font="2">Not supported</text>
<text top="372" left="727" width="68" height="11" font="2">Not supported</text>
<text top="385" left="199" width="172" height="11" font="2">Coverage Measures, Test Reduction</text>
<text top="421" left="296" width="323" height="12" font="3">Table 6. Comparison of Formal Veriﬁers of GPU Programs</text>
<text top="457" left="81" width="359" height="12" font="3">viously unidentiﬁed race type. We discussed logical errors and per-</text>
<text top="472" left="81" width="179" height="12" font="3">formance bottlenecks detected by</text>
<text top="473" left="262" width="39" height="11" font="2">GKLEE</text>
<text top="472" left="304" width="135" height="12" font="3">in real-world kernels. For</text>
<text top="487" left="81" width="359" height="12" font="3">many realistic kernels, ﬁnding these issues takes less than a minute</text>
<text top="502" left="81" width="359" height="12" font="3">on a modern workstation. We propose several novel code coverage</text>
<text top="517" left="81" width="133" height="12" font="3">measures and show that</text>
<text top="518" left="219" width="39" height="11" font="2">GKLEE</text>
<text top="517" left="258" width="182" height="12" font="3">’s test generation and test reduc-</text>
<text top="532" left="81" width="359" height="12" font="3">tion heuristics achieve high coverage. Several future directions are</text>
<text top="547" left="81" width="359" height="12" font="3">planned: (i) OpenCL [10] support, (ii) handling formats other than</text>
<text top="562" left="81" width="359" height="12" font="3">LLVM (e.g., Nvidia’s PTX) using frameworks such as Ocelot [28],</text>
<text top="577" left="81" width="359" height="12" font="3">(iii) scalability enhancement, including parameterized methods for</text>
<text top="592" left="81" width="359" height="12" font="3">SIMD programs, and (iv) using static performance analysis results</text>
<text top="607" left="81" width="11" height="12" font="3">of</text>
<text top="608" left="96" width="39" height="11" font="2">GKLEE</text>
<text top="607" left="139" width="301" height="12" font="3">to guide dynamic performance analysis on typical input</text>
<text top="622" left="81" width="49" height="12" font="3">data sets.</text>
<text top="637" left="81" width="359" height="12" font="3">Acknowledgements: We thank the authors of [4] for releasing</text>
<text top="653" left="81" width="31" height="11" font="2">KLEE</text>
<text top="652" left="115" width="324" height="12" font="3">well designed and documented. The Utah authors were sup-</text>
<text top="667" left="81" width="301" height="12" font="3">porte by NSF awards CNS-1035658 and CCF-0935858.</text>
<text top="699" left="81" width="76" height="15" font="1">References</text>
<text top="721" left="87" width="353" height="11" font="2">[1] G. Li and G. Gopalakrishnan, “Scalable SMT-based veriﬁcation of</text>
<text top="735" left="106" width="230" height="11" font="2">GPU kernel functions,” in SIGSOFT FSE, 2010.</text>
<text top="753" left="87" width="353" height="11" font="2">[2] M. Zheng, V. T. Ravi, F. Qin, and G. Agrawal, “GRace: A low-</text>
<text top="766" left="106" width="334" height="11" font="2">overhead mechanism for detecting data races in GPU programs,” in</text>
<text top="780" left="106" width="34" height="10" font="2">PPoPP</text>
<text top="780" left="140" width="33" height="11" font="2">, 2011.</text>
<text top="797" left="87" width="353" height="11" font="2">[3] M. Boyer, K. Skadron, and W. Weimer, “Automated dynamic analysis</text>
<text top="811" left="106" width="334" height="11" font="2">of CUDA programs,” in Third Workshop on Software Tools for Multi-</text>
<text top="824" left="106" width="64" height="10" font="2">Core Systems</text>
<text top="824" left="170" width="33" height="11" font="2">, 2008.</text>
<text top="842" left="87" width="353" height="11" font="2">[4] C. Cadar, D. Dunbar, and D. R. Engler, “KLEE: Unassisted and au-</text>
<text top="856" left="106" width="334" height="11" font="2">tomatic generation of high-coverage tests for complex systems pro-</text>
<text top="869" left="106" width="235" height="11" font="2">grams,” in OSDI, 8th USENIX Symposium, 2008.</text>
<text top="887" left="87" width="271" height="11" font="2">[5] “SMT-COMP. http://www.smtcomp.org/2011.”</text>
<text top="905" left="87" width="353" height="11" font="2">[6] P. Godefroid, N. Klarlund, and K. Sen, “DART: Directed automated</text>
<text top="918" left="106" width="154" height="11" font="2">random testing,” in PLDI, 2005.</text>
<text top="936" left="87" width="353" height="11" font="2">[7] “KLEE open projects,” http://klee.llvm.org/OpenProjects.</text>
<text top="951" left="106" width="28" height="10" font="2">html.</text>
<text top="968" left="87" width="353" height="11" font="2">[8] K. Sen, D. Marinov, and G. Agha, “CUTE: a concolic unit testing</text>
<text top="981" left="106" width="192" height="11" font="2">engine for C,” in 10th ESEC/FSE, 2005.</text>
<text top="999" left="87" width="326" height="11" font="2">[9] “CUDA zone. www.nvidia.com/object/cuda_home.html.”</text>
<text top="1017" left="81" width="259" height="11" font="2">[10] OpenCL. http://www.khronos.org/opencl.</text>
<text top="458" left="476" width="359" height="11" font="2">[11] A. Kamil and K. A. Yelick, “Concurrency Analysis for Parallel Pro-</text>
<text top="472" left="501" width="270" height="11" font="2">grams with Textually Aligned Barriers,” in LCPC, 2005.</text>
<text top="490" left="476" width="338" height="11" font="2">[12] “The LLVM compiler infrastructure. http://www.llvm.org/.”</text>
<text top="505" left="476" width="70" height="11" font="2">[13] “GKLEE</text>
<text top="505" left="559" width="46" height="11" font="2">Technical</text>
<text top="505" left="619" width="36" height="11" font="2">Report.</text>
<text top="506" left="669" width="165" height="10" font="2">http://www.cs.utah.edu/fv/</text>
<text top="519" left="501" width="39" height="10" font="2">GKLEE.”</text>
<text top="537" left="476" width="359" height="11" font="2">[14] “Cuda programming guide version 4.0. http://developer.</text>
<text top="551" left="501" width="318" height="10" font="2">download.nvidia.com/compute/cuda/4_0/toolkit/docs/</text>
<text top="564" left="501" width="185" height="10" font="2">CUDA_C_Programming_Guide.pdf.”</text>
<text top="581" left="476" width="359" height="11" font="2">[15] J. Sevcik, “Safe Optimisations for Shared-Memory Concurrent Pro-</text>
<text top="595" left="501" width="111" height="11" font="2">grams,” in PLDI, 2011.</text>
<text top="613" left="476" width="359" height="11" font="2">[16] S. V. Adve, M. D. Hill, B. P. Miller, and R. H. Netzer, “Detecting data</text>
<text top="626" left="501" width="232" height="11" font="2">races on weak memory systems,” in ISCA, 1991.</text>
<text top="644" left="476" width="359" height="11" font="2">[17] D. Shasa and M. Snir, “Efﬁcient and correct execution of parallel</text>
<text top="658" left="501" width="334" height="11" font="2">programs that share memory,” ACM TOPLAS, vol. 10, no. 2, pp. 282–</text>
<text top="671" left="501" width="51" height="11" font="2">312, 1988.</text>
<text top="689" left="476" width="304" height="11" font="2">[18] A. Aiken and D. Gay, “Barrier inference,” in POPL, 1998.</text>
<text top="707" left="476" width="359" height="11" font="2">[19] NVIDIA, “CUDA-GDB,” Jan. 2009, an extension to the GDB debug-</text>
<text top="720" left="501" width="239" height="11" font="2">ger for debugging CUDA kernels in the hardware.</text>
<text top="738" left="476" width="197" height="11" font="2">[20] Nvidia, “Parallel Nsight,” Jul. 2010.</text>
<text top="756" left="476" width="258" height="11" font="2">[21] Rogue Wave, “Totalview for CUDA,” Jan. 2010.</text>
<text top="774" left="476" width="359" height="11" font="2">[22] J. M. Cobleigh, L. A. Clarke, and L. J. Osterweil, “Flavers: A ﬁnite</text>
<text top="788" left="501" width="334" height="11" font="2">state veriﬁcation technique for software systems,” IBM Systems Jour-</text>
<text top="801" left="501" width="15" height="10" font="2">nal</text>
<text top="801" left="516" width="102" height="11" font="2">, vol. 41, no. 1, 2002.</text>
<text top="819" left="476" width="359" height="11" font="2">[23] S. K. Lahiri, S. Qadeer, and Z. Rakamaric, “Static and precise detec-</text>
<text top="832" left="501" width="334" height="11" font="2">tion of concurrency errors in systems code using SMT solvers,” in 21st</text>
<text top="846" left="501" width="169" height="10" font="2">Computer Aided Veriﬁcation (CAV)</text>
<text top="846" left="670" width="33" height="11" font="2">, 2009.</text>
<text top="864" left="476" width="359" height="11" font="2">[24] B. Coutinho, D. Sampaio, F. M. Quintao Pereira, and W. Meira Jr.,</text>
<text top="877" left="501" width="273" height="11" font="2">“Divergence analysis and optimizations,” in PACT, 2011.</text>
<text top="895" left="476" width="359" height="11" font="2">[25] J. Lv, G. Li, A. Humphrey, and G. Gopalakrishnan, “Performance</text>
<text top="909" left="501" width="302" height="11" font="2">degradation analysis of GPU kernels,” in EC2 Workshop, 2011.</text>
<text top="927" left="476" width="359" height="11" font="2">[26] P. Collingbourne, C. Cadar, and P. H. J. Kelly, “Symbolic crosscheck-</text>
<text top="940" left="501" width="270" height="11" font="2">ing of ﬂoating-point and SIMD code,” in EuroSys, 2011.</text>
<text top="958" left="476" width="359" height="11" font="2">[27] P. Collingbourne, C. Cadar, and P. Kelly, “Symbolic testing of OpenCL</text>
<text top="971" left="501" width="256" height="11" font="2">code,” in Haifa Veriﬁcation Conference (HVC), 2011.</text>
<text top="989" left="476" width="359" height="11" font="2">[28] G. F. Diamos, A. R. Kerr, S. Yalamanchili, and N. Clark, “Ocelot: a</text>
<text top="1003" left="501" width="334" height="11" font="2">dynamic optimization framework for bulk-synchronous applications</text>
<text top="1016" left="501" width="206" height="11" font="2">in heterogeneous systems,” in PACT, 2010.</text>
</page>
</pdf2xml>
