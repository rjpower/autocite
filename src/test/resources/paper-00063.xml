<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1262" width="892">
	<fontspec id="0" size="19" family="Times" color="#000000"/>
	<fontspec id="1" size="14" family="Times" color="#000000"/>
	<fontspec id="2" size="9" family="Times" color="#000000"/>
	<fontspec id="3" size="6" family="Times" color="#000000"/>
	<fontspec id="4" size="11" family="Times" color="#000000"/>
	<fontspec id="5" size="15" family="Times" color="#000000"/>
<text top="178" left="218" width="488" height="19" font="0">Challenges for Dynamic Analysis of iOS Applications</text>
<text top="236" left="252" width="125" height="15" font="1">Martin Szydlowski</text>
<text top="233" left="376" width="6" height="11" font="2">1</text>
<text top="236" left="384" width="100" height="15" font="1">, Manuel Egele</text>
<text top="233" left="483" width="6" height="11" font="2">2</text>
<text top="236" left="490" width="142" height="15" font="1">, Christopher Kruegel</text>
<text top="233" left="632" width="6" height="11" font="2">2</text>
<text top="236" left="639" width="32" height="15" font="1">, and</text>
<text top="257" left="404" width="103" height="15" font="1">Giovanni Vigna</text>
<text top="254" left="508" width="6" height="11" font="2">2</text>
<text top="287" left="285" width="5" height="8" font="3">1</text>
<text top="290" left="298" width="340" height="12" font="4">Secure Systems Lab, Vienna University of Technology, Austria</text>
<text top="307" left="369" width="186" height="10" font="4">msz@seclab.tuwien.ac.at</text>
<text top="320" left="349" width="5" height="8" font="3">2</text>
<text top="323" left="362" width="211" height="12" font="4">University of California, Santa Barbara</text>
<text top="338" left="342" width="240" height="13" font="4">{maeg,chris,vigna}@cs.ucsb.edu</text>
<text top="401" left="245" width="434" height="12" font="4">Abstract. Recent research indicates that mobile platforms, such as Android and</text>
<text top="417" left="245" width="434" height="12" font="4">Apple’s iOS increasingly face the threat of malware. These threats range from</text>
<text top="434" left="245" width="434" height="12" font="4">spyware that steals privacy sensitive information, such as location data or address</text>
<text top="450" left="245" width="434" height="12" font="4">book contents to malware that tries to collect ransom from users by locking the</text>
<text top="467" left="245" width="434" height="12" font="4">device and therefore rendering the device useless. Therefore, powerful analysis</text>
<text top="483" left="245" width="434" height="12" font="4">techniques and tools are necessary to quickly provide an analyst with the neces-</text>
<text top="500" left="245" width="434" height="12" font="4">sary information about an application to assess whether this application contains</text>
<text top="516" left="245" width="188" height="12" font="4">potentially malicious functionality.</text>
<text top="532" left="245" width="434" height="12" font="4">In this work, we focus on the challenges and open problems that have to be over-</text>
<text top="549" left="245" width="434" height="12" font="4">come to create dynamic analysis solutions for iOS applications. Additionally,</text>
<text top="565" left="245" width="434" height="12" font="4">we present two proof-of-concept implementations tackling two of these chal-</text>
<text top="582" left="245" width="434" height="12" font="4">lenges. First, we present a basic dynamic analysis approach for iOS applications</text>
<text top="598" left="245" width="434" height="12" font="4">demonstrating the feasibility of dynamic analysis on iOS. Second, addressing the</text>
<text top="614" left="245" width="434" height="12" font="4">challenge that iOS applications are almost always user interface driven, we also</text>
<text top="631" left="245" width="434" height="12" font="4">present an approach to automatically exercise an application’s user interface. The</text>
<text top="647" left="245" width="434" height="12" font="4">necessity of exercising application user interfaces is demonstrated by the dif-</text>
<text top="664" left="245" width="434" height="12" font="4">ference in code coverage that we achieve with (69%) and without (16%) such</text>
<text top="680" left="245" width="434" height="12" font="4">techniques. Therefore, this work is a ﬁrst step towards comprehensive dynamic</text>
<text top="697" left="245" width="158" height="12" font="4">analysis for iOS applications.</text>
<text top="744" left="202" width="9" height="16" font="5">1</text>
<text top="744" left="229" width="97" height="16" font="5">Introduction</text>
<text top="783" left="202" width="519" height="15" font="1">Mobile devices and especially smart phones have become ubiquitous in recent</text>
<text top="803" left="202" width="519" height="15" font="1">years. They evolved from simple organizers and phones to full featured enter-</text>
<text top="824" left="202" width="519" height="15" font="1">tainment devices, capable of browsing the web, storing the user’s address book,</text>
<text top="844" left="202" width="519" height="15" font="1">and provide turn-by-turn navigation through built in GPS receivers. Further-</text>
<text top="864" left="202" width="519" height="15" font="1">more, most mobile platforms offer the possibility to extend the functionality of</text>
<text top="885" left="202" width="519" height="15" font="1">the supported devices by means of third party applications. Google’s Android</text>
<text top="905" left="202" width="519" height="15" font="1">system, for example, has the ofﬁcial Android Market [1], and a series of unof-</text>
<text top="925" left="202" width="519" height="15" font="1">ﬁcial descendants that provide third party applications to users. Similarly, Ap-</text>
<text top="946" left="202" width="519" height="15" font="1">ple initially created the AppStore for third party applications for their iPhones.</text>
<text top="966" left="202" width="519" height="15" font="1">Nowadays, all devices running iOS (i.e., iPhone, iPod Touch, and iPad) can ac-</text>
<text top="986" left="202" width="519" height="15" font="1">cess and download applications from the AppStore. To ensure the quality and</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1262" width="892">
<text top="182" left="202" width="519" height="15" font="1">weed out potentially malicious applications, Apple scrutinizes each submitted</text>
<text top="202" left="202" width="519" height="15" font="1">application before it is distributed through the AppStore. This vetting process</text>
<text top="223" left="202" width="519" height="15" font="1">is designed to ascertain that only applications conforming to the iPhone De-</text>
<text top="243" left="202" width="519" height="15" font="1">veloper Program License Agreement [3] are available on the AppStore. How-</text>
<text top="263" left="202" width="519" height="15" font="1">ever, anecdotal evidence has shown that this vetting process is not always effec-</text>
<text top="284" left="202" width="519" height="15" font="1">tive. More precisely, multiple incidents have become public where applications</text>
<text top="304" left="202" width="519" height="15" font="1">distributed through the AppStore blatantly violate the user’s privacy [6, 16], or</text>
<text top="324" left="202" width="519" height="15" font="1">provide functionality that was prohibited by the license agreement [26]. After</text>
<text top="345" left="202" width="519" height="15" font="1">Apple removed the offending applications from the AppStore no new victims</text>
<text top="365" left="202" width="519" height="15" font="1">could download these apps. However, users that installed and used these apps</text>
<text top="385" left="202" width="519" height="15" font="1">prior to Apple noticing the offending behavior had to assume that their privacy</text>
<text top="406" left="202" width="126" height="15" font="1">had been breached.</text>
<text top="426" left="228" width="493" height="15" font="1">Recent research [9, 13] indicates that AppStore applications regularly ac-</text>
<text top="446" left="202" width="519" height="15" font="1">cess and transmit privacy sensitive information to the Internet. Therefore, it is</text>
<text top="467" left="202" width="519" height="15" font="1">obvious that the current vetting process as employed by Apple requires improve-</text>
<text top="487" left="202" width="519" height="15" font="1">ment. With static analysis tools available to investigate the functionality of ma-</text>
<text top="507" left="202" width="519" height="15" font="1">licious applications, one has to assume that attackers become more aware of</text>
<text top="528" left="202" width="519" height="15" font="1">the risk of getting their malicious applications identiﬁed and rejected from the</text>
<text top="548" left="202" width="519" height="15" font="1">AppStore. Thus, we assume attackers become more sophisticated in hiding ma-</text>
<text top="568" left="202" width="519" height="15" font="1">licious functionality in their applications. Therefore, we think it is necessary to</text>
<text top="589" left="202" width="519" height="15" font="1">complement existing static analysis techniques for iOS applications with their</text>
<text top="609" left="202" width="519" height="15" font="1">dynamic counterparts to keep the platform’s users protected. We are convinced</text>
<text top="629" left="202" width="519" height="15" font="1">that the combination of static and dynamic analysis techniques make a strong</text>
<text top="650" left="202" width="519" height="15" font="1">ensemble capable of identifying malicious applications. To this end, this paper</text>
<text top="670" left="202" width="228" height="15" font="1">makes the following contributions:</text>
<text top="703" left="211" width="510" height="15" font="1">– We highlight the challenges that are imposed on dynamic analysis tech-</text>
<text top="723" left="228" width="351" height="15" font="1">niques when targeting a mobile platform such as iOS.</text>
<text top="743" left="211" width="510" height="15" font="1">– We implement and evaluate a dynamic analysis approach that are suitable</text>
<text top="763" left="228" width="137" height="15" font="1">for the iOS platform.</text>
<text top="783" left="211" width="510" height="15" font="1">– We create an automated system that exercises different aspects of the appli-</text>
<text top="803" left="228" width="474" height="15" font="1">cation under analysis by interacting with the application’s user interface.</text>
<text top="848" left="202" width="9" height="16" font="5">2</text>
<text top="848" left="229" width="138" height="16" font="5">Dynamic Analysis</text>
<text top="885" left="202" width="519" height="15" font="1">Dynamic analysis refers to a set of techniques that monitor the behavior of a</text>
<text top="905" left="202" width="519" height="15" font="1">program while it is executed. These techniques can monitor different aspects of</text>
<text top="925" left="202" width="519" height="15" font="1">program execution. For example, systems have been developed to record dif-</text>
<text top="946" left="202" width="519" height="15" font="1">ferent classes of function calls, such as API calls to the Windows API [25],</text>
<text top="966" left="202" width="519" height="15" font="1">or system calls for Windows [8] or Linux [20]. Systems performing function</text>
<text top="986" left="202" width="519" height="15" font="1">call monitoring can be implemented at different layers of abstraction within the</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1262" width="892">
<text top="182" left="202" width="519" height="15" font="1">operating system. For example, the JavaScript interpreter of a browser can be in-</text>
<text top="202" left="202" width="519" height="15" font="1">strumented to record function and method calls within JavaScript code [17]. Dy-</text>
<text top="223" left="202" width="519" height="15" font="1">namic binary rewriting [18] can be leveraged to monitor the invocation of func-</text>
<text top="243" left="202" width="519" height="15" font="1">tions implemented by an application or dynamically linked libraries. Similarly,</text>
<text top="263" left="202" width="519" height="15" font="1">debugging mechanisms can be employed to gather such information [22–24].</text>
<text top="284" left="202" width="519" height="15" font="1">Furthermore, the operating system used to perform the analysis might provide a</text>
<text top="304" left="202" width="519" height="15" font="1">useful hooking infrastructure. Windows, for example, provides such hooks for</text>
<text top="324" left="202" width="519" height="15" font="1">keyboard and mouse events. The dtrace [2] infrastructure available on Solaris,</text>
<text top="345" left="202" width="438" height="15" font="1">FreeBSD, and Mac OS X can also be used to monitor system calls.</text>
<text top="366" left="228" width="493" height="15" font="1">An orthogonal approach to function call monitoring is information ﬂow</text>
<text top="386" left="202" width="519" height="15" font="1">analysis. That is, instead of focusing on the sequence of function calls during</text>
<text top="406" left="202" width="519" height="15" font="1">program execution, the focus is on monitoring how the program operates on</text>
<text top="427" left="202" width="519" height="15" font="1">interesting input data [7]. This data could, for example, be the packets that are</text>
<text top="447" left="202" width="519" height="15" font="1">received from the network, or privacy relevant information that is stored on the</text>
<text top="467" left="202" width="519" height="15" font="1">device. By tracking how this data is propagated through the system, informa-</text>
<text top="488" left="202" width="519" height="15" font="1">tion ﬂow monitoring tools can raise an alert if such sensitive data is about to be</text>
<text top="508" left="202" width="519" height="15" font="1">transmitted to the network [10, 27]. In the case of incoming network packets the</text>
<text top="528" left="202" width="519" height="15" font="1">same technique can be applied to detect attacks that divert the control ﬂow of an</text>
<text top="549" left="202" width="385" height="15" font="1">application in order to exploit a security vulnerability [21].</text>
<text top="598" left="202" width="9" height="16" font="5">3</text>
<text top="598" left="229" width="411" height="16" font="5">Challenges for Dynamic Analysis on the iOS Platform</text>
<text top="641" left="202" width="104" height="14" font="1">State of the art.</text>
<text top="641" left="316" width="405" height="15" font="1">Existing dynamic analysis techniques are geared towards ap-</text>
<text top="661" left="202" width="519" height="15" font="1">plications and systems that execute on commodity PCs and operating systems.</text>
<text top="681" left="202" width="519" height="15" font="1">Therefore, a plethora of such systems are available to analyze x86 binaries ex-</text>
<text top="702" left="202" width="519" height="15" font="1">ecuting on Linux or Windows. While the x86 architecture is most widely de-</text>
<text top="722" left="202" width="519" height="15" font="1">ployed for desktop and server computers, the landscape for the mobile device</text>
<text top="742" left="202" width="519" height="15" font="1">market has a different shape. In the mobile segment, the ARM architecture is</text>
<text top="763" left="202" width="519" height="15" font="1">most prevalent. The rise of malicious applications [15] for mobile platforms de-</text>
<text top="783" left="202" width="519" height="15" font="1">mands for powerful analysis techniques to be developed for these systems to</text>
<text top="803" left="202" width="519" height="15" font="1">ﬁght such threats. However, existing dynamic analysis techniques available for</text>
<text top="824" left="202" width="519" height="15" font="1">the x86 architecture are not immediately applicable to mobile devices executing</text>
<text top="844" left="202" width="519" height="15" font="1">binaries compiled for the ARM architecture. For example, many dynamic anal-</text>
<text top="864" left="202" width="519" height="15" font="1">ysis approaches rely on full system emulation or vitalization to perform their</text>
<text top="885" left="202" width="519" height="15" font="1">task. For most mobile platforms, however, no such full system emulators are</text>
<text top="905" left="202" width="519" height="15" font="1">available. While Apple, for example, includes an emulator with their XCode de-</text>
<text top="925" left="202" width="519" height="15" font="1">velopment environment, this emulator executes x86 instructions, and therefore</text>
<text top="946" left="202" width="519" height="15" font="1">requires that the application to emulate is recompiled. Thus, only applications</text>
<text top="966" left="202" width="519" height="15" font="1">that are available in source code can be executed in this emulator. However,</text>
<text top="986" left="202" width="519" height="15" font="1">the AppStore only distributes binary applications, which cannot be executed in</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1262" width="892">
<text top="182" left="202" width="519" height="15" font="1">the emulator. Furthermore, the emulator’s source code is not publicly available,</text>
<text top="202" left="202" width="519" height="15" font="1">and therefore, cannot be extended to perform additional analysis tasks. OS X</text>
<text top="223" left="202" width="244" height="15" font="1">contains the comprehensive dtrace</text>
<text top="220" left="446" width="6" height="11" font="2">1</text>
<text top="223" left="456" width="265" height="15" font="1">instrumentation infrastructure. Although</text>
<text top="243" left="202" width="519" height="15" font="1">the iOS kernels and OS X kernels are quite similar iOS does not provide this</text>
<text top="263" left="202" width="87" height="15" font="1">functionality.</text>
<text top="299" left="202" width="216" height="14" font="1">Graphical user interfaces (GUI).</text>
<text top="299" left="426" width="295" height="15" font="1">An additional challenge results from the very</text>
<text top="319" left="202" width="519" height="15" font="1">nature of iOS applications. That is, most iOS applications are making heavy use</text>
<text top="339" left="202" width="519" height="15" font="1">of event driven graphical user interfaces. Therefore, launching an application</text>
<text top="360" left="202" width="519" height="15" font="1">and executing the sample for a given amount of time might not be sufﬁcient</text>
<text top="380" left="202" width="519" height="15" font="1">to collect enough information to assess whether the analyzed application poses</text>
<text top="400" left="202" width="519" height="15" font="1">a threat to the user or not. That is, without GUI interaction only a minimal</text>
<text top="421" left="202" width="519" height="15" font="1">amount of execution paths will be covered during analysis. Therefore, to cover</text>
<text top="441" left="202" width="519" height="15" font="1">a wide range of execution paths, any dynamic analysis system targeting iOS</text>
<text top="461" left="202" width="480" height="15" font="1">applications has to be able to automatically operate an applications’ GUI.</text>
<text top="497" left="202" width="176" height="14" font="1">Source vs. binary analysis.</text>
<text top="497" left="386" width="334" height="15" font="1">Combined static and dynamic analysis approaches,</text>
<text top="517" left="202" width="519" height="15" font="1">such as Avgerinos et al. [4], can derive a semantically rich representation of</text>
<text top="537" left="202" width="519" height="15" font="1">an application by analyzing its source code. However, applications distributed</text>
<text top="558" left="202" width="519" height="15" font="1">through the AppStore are available in binary form only. Therefore, any analysis</text>
<text top="578" left="202" width="492" height="15" font="1">system that targets iOS applications can only operate on compiled binaries.</text>
<text top="613" left="202" width="155" height="14" font="1">Analyzing Objective-C.</text>
<text top="613" left="368" width="353" height="15" font="1">The most prevalent programming language to create</text>
<text top="633" left="202" width="519" height="15" font="1">iOS applications is Objective-C. Although Objective-C is a strict superset of the</text>
<text top="654" left="202" width="519" height="15" font="1">C programming language it features a powerful runtime environment that pro-</text>
<text top="674" left="202" width="519" height="15" font="1">vides functionality for the object-oriented capabilities of the language. With re-</text>
<text top="694" left="202" width="519" height="15" font="1">gard to analyzing a binary created from Objective-C it is especially noteworthy</text>
<text top="715" left="202" width="519" height="15" font="1">that member functions (i.e., methods) of objects are not called directly. Instead,</text>
<text top="735" left="202" width="519" height="15" font="1">the runtime provides a dynamic dispatch mechanism that accepts a pointer to an</text>
<text top="755" left="202" width="519" height="15" font="1">object and the name of a method to call. The dispatch function is responsible</text>
<text top="776" left="202" width="519" height="15" font="1">for traversing the object’s class hierarchy and identifying the implementation of</text>
<text top="796" left="202" width="175" height="15" font="1">the corresponding method.</text>
<text top="816" left="228" width="493" height="15" font="1">The above mentioned problems combined with the constraint hardware re-</text>
<text top="837" left="202" width="519" height="15" font="1">sources of mobile devices pose signiﬁcant challenges that need to be addressed</text>
<text top="857" left="202" width="467" height="15" font="1">before a dynamic analysis system for the iOS platform becomes viable.</text>
<text top="901" left="202" width="9" height="16" font="5">4</text>
<text top="901" left="229" width="309" height="16" font="5">Strategies to Overcome these Challenges</text>
<text top="937" left="202" width="519" height="15" font="1">To tackle the above mentioned challenges, this work makes two major contri-</text>
<text top="957" left="202" width="519" height="15" font="1">butions. First, we implement and evaluate a dynamic analysis approach that is</text>
<text top="986" left="210" width="4" height="8" font="3">1</text>
<text top="988" left="219" width="306" height="12" font="4">http://developers.sun.com/solaris/docs/o-s-dtrace-htg.pdf</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1262" width="892">
<text top="182" left="202" width="519" height="15" font="1">suitable for the iOS platform and provides a trace of method calls as observed</text>
<text top="202" left="202" width="519" height="15" font="1">during program execution. Second, we create an automated system that exer-</text>
<text top="223" left="202" width="519" height="15" font="1">cises different functionality of the application under analysis by interacting with</text>
<text top="243" left="202" width="204" height="15" font="1">the application’s user interface.</text>
<text top="289" left="202" width="20" height="15" font="1">4.1</text>
<text top="289" left="239" width="206" height="15" font="1">Dynamic analysis approaches</text>
<text top="320" left="202" width="519" height="15" font="1">As mentioned above not all dynamic analysis techniques available on the x86</text>
<text top="340" left="202" width="519" height="15" font="1">architecture are feasible on iOS devices executing ARM instructions. Although</text>
<text top="360" left="202" width="519" height="15" font="1">there are many different approaches to dynamic analysis, we think that function</text>
<text top="380" left="202" width="519" height="15" font="1">call traces are a viable ﬁrst step in providing detailed insights into an applica-</text>
<text top="401" left="202" width="519" height="15" font="1">tion’s behavior. Therefore, in this section we elaborate on the lessons we learned</text>
<text top="421" left="202" width="519" height="15" font="1">while implementing a system that allows us to monitor the invocation of func-</text>
<text top="441" left="202" width="194" height="15" font="1">tion calls of iOS applications.</text>
<text top="462" left="228" width="493" height="15" font="1">Objective-C is the most prevalent programming language used to create</text>
<text top="482" left="202" width="519" height="15" font="1">applications for the iOS platform. However, as opposed to C++ where meth-</text>
<text top="502" left="202" width="519" height="15" font="1">ods (i.e., class member functions) are invoked via the use of vtable pointers,</text>
<text top="523" left="202" width="519" height="15" font="1">in Objective-C methods are invoked fundamentally different. More precisely,</text>
<text top="543" left="202" width="519" height="15" font="1">methods are not called but instead a so-called message is sent to a receiver ob-</text>
<text top="563" left="202" width="474" height="15" font="1">ject. These messages are handled by the dynamic dispatch routine called</text>
<text top="585" left="202" width="114" height="13" font="1">objc msgSend</text>
<text top="584" left="316" width="405" height="15" font="1">. This dispatch routine is responsible for identifying and in-</text>
<text top="604" left="202" width="519" height="15" font="1">voking the implementation for the method that corresponds to a message. The</text>
<text top="624" left="202" width="519" height="15" font="1">ﬁrst argument to this dispatch routine is always a pointer to the so-called re-</text>
<text top="645" left="202" width="40" height="14" font="1">ceiver</text>
<text top="645" left="246" width="474" height="15" font="1">object. That is, the object on which the method should get invoked (e.g.,</text>
<text top="665" left="202" width="519" height="15" font="1">an instance of the class NSMutableString). The second argument is a so-</text>
<text top="685" left="202" width="519" height="15" font="1">called selector. This selector is a string representation of the name of the method</text>
<text top="706" left="202" width="519" height="15" font="1">that should get invoked (e.g., appendString). All remaining arguments are</text>
<text top="726" left="202" width="519" height="15" font="1">of no immediate concern to the dispatch function. That is, these arguments get</text>
<text top="746" left="202" width="519" height="15" font="1">passed to the target method once it is resolved. To perform this resolution, the</text>
<text top="768" left="202" width="104" height="13" font="1">obj msgSend</text>
<text top="767" left="312" width="408" height="15" font="1">function traverses the class hierarchy starting at the receiver</text>
<text top="787" left="202" width="519" height="15" font="1">and searches for a method whose name corresponds to the selector. Should no</text>
<text top="807" left="202" width="519" height="15" font="1">match be found in the receiver class, its superclasses are searched recursively.</text>
<text top="828" left="202" width="519" height="15" font="1">Once the corresponding method is identiﬁed, the dispatch routine invokes this</text>
<text top="848" left="202" width="519" height="15" font="1">method and passes along the necessary arguments. Due to the prevalence of</text>
<text top="868" left="202" width="519" height="15" font="1">Objective-C to create iOS applications we chose to implement a dynamic anal-</text>
<text top="889" left="202" width="519" height="15" font="1">ysis approach that monitors the invocation of Objective-C methods instead of</text>
<text top="909" left="202" width="128" height="15" font="1">classic C functions.</text>
<text top="946" left="202" width="174" height="14" font="1">Monitoring the dispatcher.</text>
<text top="946" left="384" width="337" height="15" font="1">One approach of monitoring all method invocations</text>
<text top="966" left="202" width="519" height="15" font="1">through the dynamic dispatch routine would be to hook the dispatch function</text>
<text top="986" left="202" width="519" height="15" font="1">itself. This could be achieved by following an approach similar to Detours [18].</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1262" width="892">
<text top="182" left="202" width="519" height="15" font="1">That is, one would copy the initial instructions of the dynamic dispatcher be-</text>
<text top="202" left="202" width="519" height="15" font="1">fore replacing them in memory with an unconditional jump to divert the control</text>
<text top="223" left="202" width="519" height="15" font="1">ﬂow to a dedicated hook function. This hook function could then perform the</text>
<text top="243" left="202" width="519" height="15" font="1">necessary analysis, such as resolving parameter values, and logging the method</text>
<text top="263" left="202" width="519" height="15" font="1">invocation to the analysis report. Once the hook function ﬁnished executing,</text>
<text top="284" left="202" width="519" height="15" font="1">control would be transferred back to the dispatch function and regular execution</text>
<text top="304" left="202" width="519" height="15" font="1">could continue. Of course, the backed up initial instructions that got overwritten</text>
<text top="324" left="202" width="519" height="15" font="1">in the dispatcher need to be executed too before control is transferred back to</text>
<text top="345" left="202" width="519" height="15" font="1">the dispatch function. Although such an approach seems straight forward, the</text>
<text top="365" left="202" width="519" height="15" font="1">comprehensive libraries available to iOS applications also make extensive use</text>
<text top="385" left="202" width="519" height="15" font="1">of the Objective-C runtime. Therefore, such a generic approach would collect</text>
<text top="406" left="202" width="519" height="15" font="1">function call traces not only on the code the application developer created but</text>
<text top="426" left="202" width="519" height="15" font="1">also on all code that is executed within dynamically linked libraries. Often, how-</text>
<text top="446" left="202" width="519" height="15" font="1">ever, function call traces collected from libraries are repetitive. Thus, we chose</text>
<text top="467" left="202" width="519" height="15" font="1">to implement our approach to only trace method invocations that are performed</text>
<text top="487" left="202" width="213" height="15" font="1">by the code the developer wrote.</text>
<text top="527" left="202" width="190" height="14" font="1">Identifying method call sites.</text>
<text top="527" left="400" width="321" height="15" font="1">As a ﬁrst step in monitoring Objective-C method</text>
<text top="547" left="202" width="519" height="15" font="1">calls we leverage our previous work PiOS [9] to generate a list of call sites to</text>
<text top="567" left="202" width="519" height="15" font="1">the dynamic dispatch function. Furthermore, PiOS is often capable of determin-</text>
<text top="588" left="202" width="519" height="15" font="1">ing the number and types of arguments that are passed to the invoked method.</text>
<text top="608" left="202" width="519" height="15" font="1">This information is recorded along with the above mentioned call sites. Subse-</text>
<text top="628" left="202" width="386" height="15" font="1">quently, this information is post processed to generate gdb</text>
<text top="625" left="589" width="6" height="11" font="2">2</text>
<text top="628" left="599" width="121" height="15" font="1">script ﬁles that log</text>
<text top="649" left="202" width="519" height="15" font="1">the corresponding information to the analysis report. More precisely, for each</text>
<text top="669" left="202" width="519" height="15" font="1">call site to the dynamic dispatch function, the script will contain a breakpoint.</text>
<text top="689" left="202" width="519" height="15" font="1">Furthermore, for each breakpoint hit the type (i.e., class) of the receiver as well</text>
<text top="710" left="202" width="519" height="15" font="1">as the name of the invoked method (i.e., the selector) get logged. Additionally,</text>
<text top="730" left="202" width="519" height="15" font="1">if PiOS successfully determined the number of arguments and their types, this</text>
<text top="750" left="202" width="210" height="15" font="1">information will also be logged.</text>
<text top="799" left="202" width="20" height="15" font="1">4.2</text>
<text top="799" left="239" width="193" height="15" font="1">Automated GUI interaction</text>
<text top="833" left="202" width="519" height="15" font="1">Most iOS applications feature a rich graphical user interface. Furthermore, most</text>
<text top="853" left="202" width="519" height="15" font="1">functionality within those applications gets executed in response to user inter-</text>
<text top="873" left="202" width="519" height="15" font="1">face events or interactions. This means that unless an application’s user interface</text>
<text top="894" left="202" width="519" height="15" font="1">is exercised, most of the functionality contained in such applications lies dor-</text>
<text top="914" left="202" width="519" height="15" font="1">mant. As dynamic analysis only observes the behavior of code that is executing,</text>
<text top="934" left="202" width="519" height="15" font="1">large parts of functionality in such applications would be missed unless the GUI</text>
<text top="955" left="202" width="96" height="15" font="1">gets exercised.</text>
<text top="986" left="210" width="4" height="8" font="3">2</text>
<text top="988" left="219" width="142" height="12" font="4">http://www.gnu.org/s/gdb/</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1262" width="892">
<text top="182" left="228" width="493" height="15" font="1">Therefore, one of the challenges we address in this work is the automated</text>
<text top="202" left="202" width="519" height="15" font="1">interaction with graphical user interfaces. Such interaction with an application’s</text>
<text top="223" left="202" width="519" height="15" font="1">GUI can be achieved on different levels. Desktop operating systems commonly</text>
<text top="243" left="202" width="519" height="15" font="1">support tools to get identiﬁers or handles for currently displayed GUI elements</text>
<text top="263" left="202" width="519" height="15" font="1">(e.g., UI explorer on Mac OS X). However, no such system is readily available</text>
<text top="284" left="202" width="53" height="15" font="1">for iOS.</text>
<text top="308" left="228" width="493" height="15" font="1">Therefore, we turned our attention to alternative solutions to exercise an</text>
<text top="328" left="202" width="519" height="15" font="1">application’s user interface. A straight forward approach could, for example,</text>
<text top="348" left="202" width="519" height="15" font="1">randomly click on the screen area. This method proved effective in detecting</text>
<text top="369" left="202" width="519" height="15" font="1">click-jacking attacks [5] on the World Wide Web. A more elaborate technique</text>
<text top="389" left="202" width="519" height="15" font="1">could read the contents from the device’s frame buffer and try to identify inter-</text>
<text top="409" left="202" width="519" height="15" font="1">active elements, such as buttons, check-boxes, or text ﬁelds by applying image</text>
<text top="430" left="202" width="519" height="15" font="1">processing techniques. Once such elements are identiﬁed, virtual keystrokes or</text>
<text top="450" left="202" width="519" height="15" font="1">mouse clicks could be triggered in the system to interact with these elements.</text>
<text top="470" left="202" width="519" height="15" font="1">We combined these two approaches into a proof-of-concept prototype that al-</text>
<text top="491" left="202" width="515" height="15" font="1">lows us to automatically exercise graphical user interfaces of iOS applications.</text>
<text top="515" left="228" width="493" height="15" font="1">To interact with the device and get access to the device’s frame buffer we</text>
<text top="535" left="202" width="215" height="15" font="1">leverage the open source Veency</text>
<text top="532" left="417" width="6" height="11" font="2">3</text>
<text top="535" left="428" width="293" height="15" font="1">VNC server. To communicate with the VNC</text>
<text top="555" left="202" width="519" height="15" font="1">server, and perform the detection and manipulation of UI elements, we have</text>
<text top="576" left="202" width="213" height="15" font="1">modiﬁed the python-vnc-viewer</text>
<text top="573" left="415" width="6" height="11" font="2">4</text>
<text top="576" left="422" width="299" height="15" font="1">, an open source VNC client implementation</text>
<text top="596" left="202" width="67" height="15" font="1">in Python.</text>
<text top="620" left="228" width="493" height="15" font="1">The basic idea behind this approach is to sample the screen and tap (i.e.,</text>
<text top="640" left="202" width="519" height="15" font="1">click) locations on the screen that are determined by a regular grid pattern. Ad-</text>
<text top="660" left="202" width="519" height="15" font="1">ditionally, to identify interactive user interface elements, we perform the follow-</text>
<text top="681" left="202" width="519" height="15" font="1">ing steps in a loop: We capture the contents of the screen buffer and compare it</text>
<text top="701" left="202" width="519" height="15" font="1">to the previous screenshot (if present). If a sufﬁciently large fraction of pixels</text>
<text top="721" left="202" width="519" height="15" font="1">has changed between the images, we assume an interactive element has been hit.</text>
<text top="742" left="202" width="519" height="15" font="1">To tell input ﬁelds from other interactive elements apart, the current screenshot</text>
<text top="762" left="202" width="519" height="15" font="1">is compared to a reference image where the on-screen keyboard is displayed.</text>
<text top="782" left="202" width="519" height="15" font="1">This comparison is based on a heuristic that allows slight variations in the key-</text>
<text top="803" left="202" width="519" height="15" font="1">board’s appearance (e.g., different language settings). If we can determine that</text>
<text top="823" left="202" width="519" height="15" font="1">a keyboard is displayed, we send tap events to the ﬁrst four keys in the middle</text>
<text top="843" left="202" width="519" height="15" font="1">row (i.e., ASDF on a US layout) and the return/done key to dismiss the keyboard</text>
<text top="864" left="202" width="519" height="15" font="1">again. When no keyboard is detected, we advance the cursor to the next location</text>
<text top="884" left="202" width="519" height="15" font="1">and send a tap event. In either case, we wait a brief amount of time before re-</text>
<text top="904" left="202" width="519" height="15" font="1">peating the procedure, to give the UI time to respond and complete animations.</text>
<text top="925" left="202" width="445" height="15" font="1">We empirically determined a wait time of 3 seconds to be sufﬁcient.</text>
<text top="969" left="210" width="4" height="8" font="3">3</text>
<text top="971" left="219" width="194" height="12" font="4">http://cydia.saurik.com/info/veency/</text>
<text top="986" left="210" width="4" height="8" font="3">4</text>
<text top="988" left="219" width="244" height="12" font="4">http://code.google.com/p/python-vnc-viewer/</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1262" width="892">
<text top="182" left="228" width="493" height="15" font="1">To avoid hitting the same UI elements repeatedly, we keep a greyscale image</text>
<text top="202" left="202" width="519" height="15" font="1">with dimensions identical to the frame buffer in memory. We call this greyscale</text>
<text top="223" left="202" width="519" height="15" font="1">image a clickmap. For each tap event, we perform a fuzzy ﬂood-ﬁll algorithm</text>
<text top="243" left="202" width="519" height="15" font="1">on the screenshot, originating from the tap coordinates, to determine the extents</text>
<text top="263" left="202" width="519" height="15" font="1">of the element we have tapped. That approach works well for monochrome or</text>
<text top="284" left="202" width="519" height="15" font="1">slightly shaded elements, like the default widgets offered by the interface builder</text>
<text top="304" left="202" width="519" height="15" font="1">for iOS applications. We mark these extents in the clickmap to keep track of</text>
<text top="324" left="202" width="519" height="15" font="1">the elements we have already accessed. That is, before a tap event is actually</text>
<text top="345" left="202" width="519" height="15" font="1">sent, the clickmap is consulted. If the current coordinates belong an element we</text>
<text top="365" left="202" width="519" height="15" font="1">already clicked, no tap event will be sent. Therefore, we avoid hitting the same</text>
<text top="385" left="202" width="519" height="15" font="1">element repeatedly, especially when the element in question is the background.</text>
<text top="406" left="202" width="519" height="15" font="1">Whenever we have a new screenshot containing changes, we clear the changed</text>
<text top="426" left="202" width="519" height="15" font="1">area in the clickmap so that new UI elements that might have appeared will be</text>
<text top="446" left="202" width="90" height="15" font="1">exercised too.</text>
<text top="500" left="202" width="9" height="16" font="5">5</text>
<text top="500" left="229" width="84" height="16" font="5">Evaluation</text>
<text top="547" left="202" width="519" height="15" font="1">In this section we present the results we obtained during the evaluation of our</text>
<text top="567" left="202" width="519" height="15" font="1">prototype implementation. For the purpose of this evaluation we created a sam-</text>
<text top="587" left="202" width="519" height="15" font="1">ple application that contains different user interface components such as buttons,</text>
<text top="608" left="202" width="519" height="15" font="1">text ﬁelds, and on/off switches. A screenshot of the application is depicted in</text>
<text top="628" left="202" width="519" height="15" font="1">Figure 1. The rationale for creating such a sample application is that by creating</text>
<text top="648" left="202" width="519" height="15" font="1">the application, we got intimately familiar with its functionality and operation.</text>
<text top="669" left="202" width="519" height="15" font="1">Furthermore, our experience with the static analysis of iOS applications allowed</text>
<text top="689" left="202" width="519" height="15" font="1">us to build corner cases into the application where we know static analysis can</text>
<text top="709" left="202" width="519" height="15" font="1">only provide limited results. For example, the test application would dynami-</text>
<text top="730" left="202" width="416" height="15" font="1">cally generate a new text ﬁeld, once a speciﬁc button is clicked.</text>
<text top="784" left="202" width="20" height="15" font="1">5.1</text>
<text top="784" left="239" width="158" height="15" font="1">Method Call Coverage</text>
<text top="824" left="202" width="519" height="15" font="1">PiOS identiﬁed a total of 52 calls to the dynamic dispatch function. Once our</text>
<text top="844" left="202" width="519" height="15" font="1">test application is launched, no further method calls are made unless the dif-</text>
<text top="864" left="202" width="519" height="15" font="1">ferent user interface elements are exercised. This is common behavior for iOS</text>
<text top="885" left="202" width="519" height="15" font="1">applications that are heavily user interface driven. During application startup</text>
<text top="905" left="202" width="519" height="15" font="1">only 8 of the 52 method calls (i.e., 16%) are executed. This underlines that</text>
<text top="925" left="202" width="519" height="15" font="1">dynamic analysis approaches that do not take the GUI of an iOS application</text>
<text top="946" left="202" width="519" height="15" font="1">into account, can only provide limited information about the application’s func-</text>
<text top="966" left="202" width="519" height="15" font="1">tionality. Moreover, the methods that can be observed during program startup</text>
<text top="986" left="202" width="519" height="15" font="1">are generically added by Apple’s build system and are almost identical for all</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1262" width="892">
<text top="510" left="202" width="519" height="12" font="4">Fig. 1. A screenshot of the sample application. The lower text ﬁeld is dynamically created upon</text>
<text top="527" left="202" width="177" height="12" font="4">the ﬁrst click to the Reset button.</text>
<text top="586" left="202" width="519" height="15" font="1">applications targeting the iOS platform. Therefore, the valuable insights into ap-</text>
<text top="607" left="202" width="519" height="15" font="1">plication behavior that can be derived solely from the program startup phase are</text>
<text top="627" left="202" width="97" height="15" font="1">limited at best.</text>
<text top="653" left="228" width="493" height="15" font="1">By executing our prototype to exercise the user interface of our test appli-</text>
<text top="673" left="202" width="519" height="15" font="1">cation, we could observe 36 methods being called. That corresponds to 69% of</text>
<text top="694" left="202" width="519" height="15" font="1">all methods being covered. Most importantly, we were able to exercise most of</text>
<text top="714" left="202" width="519" height="15" font="1">the functionality that is not part of the initial startup procedures for the applica-</text>
<text top="734" left="202" width="519" height="15" font="1">tions. Our system did not observe the remaining 16 methods being invoked. One</text>
<text top="755" left="202" width="512" height="15" font="1">method would only be called if the user interface was in a very speciﬁc state.</text>
<text top="752" left="714" width="6" height="11" font="2">5</text>
<text top="775" left="202" width="519" height="15" font="1">However, our technique to exercise the user interface did not put the application</text>
<text top="795" left="202" width="519" height="15" font="1">in that state. All remaining 15 calls were part of the shutdown procedures (e.g.,</text>
<text top="816" left="202" width="519" height="15" font="1">destructors) for the application. However, these methods are only invoked if the</text>
<text top="836" left="202" width="519" height="15" font="1">application terminates voluntarily. If the user presses the home button on the</text>
<text top="856" left="202" width="519" height="15" font="1">device, the application is terminated and no cleanup code is executed. As there</text>
<text top="877" left="202" width="519" height="15" font="1">is not generic way to determine whether a certain user interface element will</text>
<text top="897" left="202" width="519" height="15" font="1">exit an application, our analysis terminates the application by tapping the home</text>
<text top="917" left="202" width="502" height="15" font="1">button. Thus, we did not observe these shutdown procedures being executed.</text>
<text top="969" left="210" width="4" height="8" font="3">5</text>
<text top="972" left="219" width="502" height="12" font="4">If the switch has been switched from the default on setting to off and the Reset button is clicked</text>
<text top="988" left="219" width="432" height="12" font="4">afterwards, a message is sent to animate the switch back to its default on setting.</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1262" width="892">
<text top="182" left="202" width="20" height="15" font="1">5.2</text>
<text top="182" left="239" width="229" height="15" font="1">Comparison with Static Analysis</text>
<text top="214" left="202" width="519" height="15" font="1">There are different possibilities on how to compare the static and dynamic anal-</text>
<text top="235" left="202" width="519" height="15" font="1">ysis results. For example, static analysis covers all possible and thus also infea-</text>
<text top="255" left="202" width="519" height="15" font="1">sible execution paths. Dynamic analysis can only observe the code paths that</text>
<text top="275" left="202" width="519" height="15" font="1">are executed while the program is analyzed. Therefore, we ﬁrst evaluate how</text>
<text top="296" left="202" width="519" height="15" font="1">many and which methods get invoked during dynamic analysis. To compare the</text>
<text top="316" left="202" width="519" height="15" font="1">dynamic and static analysis results we ﬁrst analyzed our test application with</text>
<text top="336" left="202" width="39" height="15" font="1">PiOS.</text>
<text top="375" left="202" width="146" height="14" font="1">Static analysis results.</text>
<text top="375" left="356" width="365" height="15" font="1">PiOS detected 52 calls to the objc msgSend dynamic</text>
<text top="395" left="202" width="519" height="15" font="1">dispatch function. In 49 cases (i.e., 94%) PiOS was able to statically determine</text>
<text top="415" left="202" width="519" height="15" font="1">the class of the receiver object and the value of the selector. Furthermore, PiOS</text>
<text top="436" left="202" width="519" height="15" font="1">validates these results by looking up the class of the receiver in the class hi-</text>
<text top="456" left="202" width="519" height="15" font="1">erarchy. A method call is successfully resolved if the class exists in the class</text>
<text top="476" left="202" width="519" height="15" font="1">hierarchy and this class or one of its superclasses implements a method whose</text>
<text top="497" left="202" width="299" height="15" font="1">name corresponds to the value of the selector.</text>
<text top="517" left="228" width="493" height="15" font="1">The remaining three method calls that PiOS was unable to resolve are part</text>
<text top="537" left="202" width="519" height="15" font="1">of the function that dynamically creates and initializes the new text ﬁeld. In</text>
<text top="558" left="202" width="519" height="15" font="1">our sample application this action is performed the ﬁrst time the Reset button is</text>
<text top="578" left="202" width="51" height="15" font="1">clicked.</text>
<text top="616" left="202" width="85" height="14" font="1">Comparison.</text>
<text top="616" left="298" width="423" height="15" font="1">We compared the receiver and selector for the 36 method calls</text>
<text top="636" left="202" width="519" height="15" font="1">present in the static and dynamic analysis reports. In all but 3 instances the</text>
<text top="657" left="202" width="519" height="15" font="1">results were identical. In two of these three instances PiOS identiﬁed the re-</text>
<text top="677" left="202" width="519" height="15" font="1">ceiver type as NSString, whereas the dynamic analysis indicates that the ac-</text>
<text top="697" left="202" width="519" height="15" font="1">tual type is CFConstantStringClassReference. However, according</text>
<text top="718" left="202" width="170" height="15" font="1">to Apple’s documentation</text>
<text top="715" left="372" width="6" height="11" font="2">6</text>
<text top="718" left="383" width="338" height="15" font="1">these two types can be used interchangeably. In the</text>
<text top="738" left="202" width="519" height="15" font="1">third instance PiOS identiﬁed the receiver as NSString and dynamic anal-</text>
<text top="758" left="202" width="519" height="15" font="1">ysis indicates the correct type to be NSPlaceHolderString. The differ-</text>
<text top="779" left="202" width="519" height="15" font="1">ence is that for NSPlaceHolderString the initialization is not complete</text>
<text top="799" left="202" width="519" height="15" font="1">yet. This inconsistency is plausible as the only time this happened is in a call to</text>
<text top="820" left="202" width="196" height="13" font="1">initStringWithFormat</text>
<text top="819" left="403" width="144" height="15" font="1">to ﬁnish initialization.</text>
<text top="866" left="202" width="20" height="15" font="1">5.3</text>
<text top="866" left="239" width="166" height="15" font="1">Method call arguments.</text>
<text top="899" left="202" width="519" height="15" font="1">For 12 calls PiOS was able to determine the types of the arguments that get</text>
<text top="919" left="202" width="519" height="15" font="1">passed to the invoked methods. Thus, in these cases the dynamic analysis script</text>
<text top="940" left="202" width="519" height="15" font="1">is also logging information pertaining to these arguments. More precisely, for</text>
<text top="969" left="210" width="4" height="8" font="3">6</text>
<text top="972" left="219" width="394" height="12" font="4">http://developer.apple.com/library/mac/#documentation/CoreFoundation/</text>
<text top="988" left="219" width="267" height="12" font="4">Reference/CFStringRef/Reference/reference.html</text>
</page>
<page number="11" position="absolute" top="0" left="0" height="1262" width="892">
<text top="182" left="202" width="519" height="15" font="1">arguments of type NSString or any of its related types, a string representation</text>
<text top="202" left="202" width="519" height="15" font="1">of the argument is printed in the log ﬁle. For all other types, the address of the</text>
<text top="223" left="202" width="279" height="15" font="1">corresponding argument is printed instead.</text>
<text top="286" left="202" width="20" height="15" font="1">5.4</text>
<text top="286" left="239" width="231" height="15" font="1">Improvements for static analysis.</text>
<text top="335" left="202" width="519" height="15" font="1">As mentioned previously, static analysis is sometimes unable to compute the</text>
<text top="356" left="202" width="519" height="15" font="1">target method of an objc msgSend call. More precisely, if PiOS is unable to</text>
<text top="376" left="202" width="519" height="15" font="1">statically determine the type of the receiver object or the value of the selector,</text>
<text top="396" left="202" width="519" height="15" font="1">PiOS cannot resolve the target method. This was the case for 3 method calls in</text>
<text top="417" left="202" width="519" height="15" font="1">our sample application. All 3 instances were part of the function that dynami-</text>
<text top="437" left="202" width="519" height="15" font="1">cally creates the additional text ﬁeld. However, the dynamic analysis exercised</text>
<text top="457" left="202" width="519" height="15" font="1">this functionality and the analysis report contains the type of the receiver object</text>
<text top="478" left="202" width="519" height="15" font="1">and the value of the selector. Thus, the results from dynamic analysis can be</text>
<text top="498" left="202" width="394" height="15" font="1">leveraged to increase precision of our static analysis system.</text>
<text top="561" left="202" width="9" height="16" font="5">6</text>
<text top="561" left="229" width="227" height="16" font="5">Limitations and Future Work</text>
<text top="617" left="202" width="519" height="15" font="1">Our proof-of-concept implementation relies on gdb to collect information about</text>
<text top="637" left="202" width="519" height="15" font="1">the program during execution. Thus, it is easily detectable by applications that</text>
<text top="658" left="202" width="519" height="15" font="1">try to detect whether they are analyzed. Therefore, we plan to evaluate stealthier</text>
<text top="678" left="202" width="519" height="15" font="1">ways of performing the necessary monitoring tasks in the future. Furthermore,</text>
<text top="698" left="202" width="519" height="15" font="1">our current implementation does not take system calls into account. However,</text>
<text top="719" left="202" width="519" height="15" font="1">for example Cydia’s mobile substrate framework could be a good starting point</text>
<text top="739" left="202" width="348" height="15" font="1">to investigate system call monitoring on iOS devices.</text>
<text top="763" left="228" width="493" height="15" font="1">Although our method of exercising the user interface resulted in high code</text>
<text top="783" left="202" width="519" height="15" font="1">coverage when compared to the functionality of program startup alone, we see</text>
<text top="803" left="202" width="519" height="15" font="1">room for improvement in this area too. That is, our current approach does not</text>
<text top="824" left="202" width="519" height="15" font="1">handle highly non-uniform colored (i.e., custom designed) user interface ele-</text>
<text top="844" left="202" width="519" height="15" font="1">ments correctly. More precisely, our system does not detect the boundaries of</text>
<text top="864" left="202" width="519" height="15" font="1">such elements reliably and therefore might tap the same element multiple times.</text>
<text top="885" left="202" width="519" height="15" font="1">Furthermore, we only consider tap events and omit all interactions that use</text>
<text top="905" left="202" width="519" height="15" font="1">swipe or multi touch gestures. Therefore, to improve the automatic user inter-</text>
<text top="925" left="202" width="519" height="15" font="1">face interaction, one could try to extract the information about UI elements from</text>
<text top="946" left="202" width="519" height="15" font="1">the application’s memory during runtime. This would entail getting a reference</text>
<text top="966" left="202" width="519" height="15" font="1">to the current UIView element and ﬁnd a way to enumerate all UI elements</text>
<text top="986" left="202" width="506" height="15" font="1">contained in that view. We plan to investigate such techniques in future work.</text>
</page>
<page number="12" position="absolute" top="0" left="0" height="1262" width="892">
<text top="181" left="202" width="9" height="16" font="5">7</text>
<text top="181" left="229" width="107" height="16" font="5">Related Work</text>
<text top="223" left="202" width="519" height="15" font="1">The wide range of related work in dynamic analysis mainly focuses on desktop</text>
<text top="243" left="202" width="519" height="15" font="1">operating systems. Due to the challenges mentioned above these techniques are</text>
<text top="264" left="202" width="519" height="15" font="1">not readily applicable to mobile platforms. For brevity, we refer the reader for</text>
<text top="284" left="202" width="519" height="15" font="1">such techniques to [11] and focus this section on related work that performs</text>
<text top="304" left="202" width="519" height="15" font="1">analysis for mobile platforms. TaintDroid [12] is the ﬁrst dynamic analysis sys-</text>
<text top="325" left="202" width="519" height="15" font="1">tem for Android applications. However, it is limited to applications that execute</text>
<text top="345" left="202" width="519" height="15" font="1">in the Dalvik virtual machine. Thus, by modifying the open source code of the</text>
<text top="365" left="202" width="519" height="15" font="1">virtual machine, the necessary analysis steps can be readily implemented. How-</text>
<text top="386" left="202" width="519" height="15" font="1">ever, the authors state that ”Native code is unmonitored in TaintDroid”. There-</text>
<text top="406" left="202" width="519" height="15" font="1">fore, systems like TaintDroid are not applicable to the iOS platform as iOS ap-</text>
<text top="426" left="202" width="519" height="15" font="1">plications execute on the hardware directly. That is there is no middle-layer that</text>
<text top="447" left="202" width="303" height="15" font="1">can be instrumented to perform analysis tasks.</text>
<text top="467" left="228" width="493" height="15" font="1">Mulliner et al. [19] use labeling of processes to prevent cross-service at-</text>
<text top="488" left="202" width="519" height="15" font="1">tacks on mobile devices. However, this approach relies on a modiﬁed Linux</text>
<text top="508" left="202" width="519" height="15" font="1">kernel to check and verify which application is accessing which class of de-</text>
<text top="528" left="202" width="519" height="15" font="1">vices. Such checks only reveal the communication interfaces that are used by</text>
<text top="549" left="202" width="519" height="15" font="1">an application. Applications on the AppStore, however, are prevented from ac-</text>
<text top="569" left="202" width="519" height="15" font="1">cessing the GSM modem, and thus can only access the network or Bluetooth</text>
<text top="589" left="202" width="519" height="15" font="1">components. Thus, such a system is too coarse grained to effectively protect</text>
<text top="610" left="202" width="519" height="15" font="1">iOS users. Furthermore, the source code for iOS is not available, and thus the</text>
<text top="630" left="202" width="519" height="15" font="1">necessary modiﬁcations to the operating systems’ kernel cannot be made easily.</text>
<text top="651" left="228" width="493" height="15" font="1">In previous work we presented PiOS [9] as an approach to detect privacy</text>
<text top="671" left="202" width="519" height="15" font="1">leaks in iOS applications using static analysis. This work demonstrated that it is</text>
<text top="692" left="202" width="519" height="15" font="1">indeed common for applications available in the AppStore to transmit privacy</text>
<text top="712" left="202" width="519" height="15" font="1">sensitive data to the network – usually without the users consent or knowledge.</text>
<text top="732" left="202" width="519" height="15" font="1">Furthermore, Enck et al. [14] presented Kirin a system that statically assesses,</text>
<text top="753" left="202" width="519" height="15" font="1">whether the permissions requested by an Android application collide with the</text>
<text top="773" left="202" width="179" height="15" font="1">user’s privacy assumptions.</text>
<text top="822" left="202" width="9" height="16" font="5">8</text>
<text top="822" left="229" width="86" height="16" font="5">Conclusion</text>
<text top="864" left="202" width="519" height="15" font="1">The popularity of Apple’s iOS and the AppStore attracted developers with ma-</text>
<text top="885" left="202" width="519" height="15" font="1">licious intents. Recent events have shown that malicious applications available</text>
<text top="905" left="202" width="519" height="15" font="1">from the AppStore are capable of breaching the user’s privacy by stealing pri-</text>
<text top="925" left="202" width="519" height="15" font="1">vacy sensitive information, such as phone numbers, address book contents, or</text>
<text top="946" left="202" width="519" height="15" font="1">GPS location data from the device. Although static analysis techniques have</text>
<text top="966" left="202" width="519" height="15" font="1">shown that they are capable of detecting such fraudulent applications, we are</text>
<text top="986" left="202" width="519" height="15" font="1">convinced that attackers will employ obfuscation techniques to thwart static</text>
</page>
<page number="13" position="absolute" top="0" left="0" height="1262" width="892">
<text top="182" left="202" width="519" height="15" font="1">analysis. Therefore, this paper discusses the challenges and open problems that</text>
<text top="202" left="202" width="519" height="15" font="1">have to be overcome to provide comprehensive dynamic analysis tools for iOS</text>
<text top="223" left="202" width="519" height="15" font="1">applications. We tackled two of these challenges by providing prototype imple-</text>
<text top="243" left="202" width="519" height="15" font="1">mentations of techniques that are able to generate method call traces for iOS</text>
<text top="263" left="202" width="519" height="15" font="1">applications, as well as exercising application user interfaces. Our evaluation</text>
<text top="284" left="202" width="519" height="15" font="1">highlights the necessity for taking user interfaces into account when performing</text>
<text top="304" left="202" width="253" height="15" font="1">dynamic analysis for iOS applications.</text>
<text top="350" left="202" width="148" height="16" font="5">Acknowledgements</text>
<text top="388" left="202" width="519" height="15" font="1">This work was partially supported by the ONR under grant N000140911042 and</text>
<text top="408" left="202" width="519" height="15" font="1">by the National Science Foundation (NSF) under grants CNS-0845559, CNS-</text>
<text top="429" left="202" width="519" height="15" font="1">0905537, and CNS-0716095. We would also like to thank Yan Shoshitaishvili</text>
<text top="449" left="202" width="254" height="15" font="1">for his help with the evaluation device.</text>
<text top="495" left="202" width="83" height="16" font="5">References</text>
<text top="531" left="209" width="374" height="12" font="4">1. Apps - Android Market. https://market.android.com/.</text>
<text top="547" left="209" width="79" height="12" font="4">2. BigAdmin:</text>
<text top="547" left="301" width="43" height="12" font="4">DTrace.</text>
<text top="548" left="382" width="339" height="10" font="4">http://www.oracle.com/technetwork/systems/</text>
<text top="564" left="227" width="137" height="10" font="4">dtrace/index.html</text>
<text top="563" left="364" width="3" height="12" font="4">.</text>
<text top="580" left="209" width="292" height="12" font="4">3. iPhone Developer Program License Agreement.</text>
<text top="580" left="519" width="202" height="10" font="4">http://www.eff.org/files/</text>
<text top="597" left="227" width="218" height="10" font="4">20100302_iphone_dev_agr.pdf</text>
<text top="596" left="445" width="3" height="12" font="4">.</text>
<text top="612" left="209" width="512" height="12" font="4">4. T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley. Aeg: Automatic exploit generation.</text>
<text top="629" left="227" width="465" height="12" font="4">In 17th Annual Network and Distributed System Security Symposium (NDSS11), 2011.</text>
<text top="645" left="209" width="512" height="12" font="4">5. M. Balduzzi, M. Egele, E. Kirda, D. Balzarotti, and C. Kruegel. A solution for the automated</text>
<text top="661" left="227" width="494" height="12" font="4">detection of clickjacking attacks. In ASIACCS ’10: Proceedings of the 5th ACM Symposium</text>
<text top="678" left="227" width="312" height="12" font="4">on Information, Computer and Communications Security</text>
<text top="678" left="539" width="182" height="12" font="4">, pages 135–144, New York, NY,</text>
<text top="694" left="227" width="101" height="12" font="4">USA, 2010. ACM.</text>
<text top="710" left="209" width="512" height="12" font="4">6. R. Beschizza. iPhone game dev accused of stealing players’ phone numbers. http://</text>
<text top="728" left="227" width="446" height="10" font="4">www.boingboing.net/2009/11/05/iphone-game-dev-accu.html</text>
<text top="727" left="673" width="3" height="12" font="4">.</text>
<text top="743" left="209" width="512" height="12" font="4">7. J. Chow, B. Pfaff, T. Garﬁnkel, K. Christopher, and M. Rosenblum. Understanding data life-</text>
<text top="759" left="227" width="494" height="12" font="4">time via whole system simulation. In Proceedings of the 13th USENIX Security Symposium,</text>
<text top="776" left="227" width="72" height="12" font="4">August 2004.</text>
<text top="792" left="209" width="512" height="12" font="4">8. A. Dinaburg, P. Royal, M. I. Sharif, and W. Lee. Ether: malware analysis via hardware</text>
<text top="808" left="227" width="494" height="12" font="4">virtualization extensions. In ACM Conference on Computer and Communications Security</text>
<text top="825" left="227" width="34" height="12" font="4">(CCS)</text>
<text top="825" left="261" width="111" height="12" font="4">, pages 51–62, 2008.</text>
<text top="841" left="209" width="512" height="12" font="4">9. M. Egele, C. Kruegel, E. Kirda, and G. Vigna. PiOS: Detecting Privacy Leaks in iOS Ap-</text>
<text top="858" left="227" width="494" height="12" font="4">plications. In 17th Annual Network and Distributed System Security Symposium (NDSS11),</text>
<text top="874" left="227" width="30" height="12" font="4">2011.</text>
<text top="890" left="202" width="519" height="12" font="4">10. M. Egele, C. Kruegel, E. Kirda, H. Yin, and D. X. Song. Dynamic spyware analysis. In</text>
<text top="907" left="227" width="342" height="12" font="4">Proceedings of the 2007 USENIX Annual Technical Conference</text>
<text top="907" left="569" width="125" height="12" font="4">, pages 233–246, 2007.</text>
<text top="923" left="202" width="519" height="12" font="4">11. M. Egele, T. Scholte, E. Kirda, and C. Kruegel. A survey on automated dynamic malware</text>
<text top="939" left="227" width="384" height="12" font="4">analysis techniques and tools. In ACM Computing Surveys – to appear.</text>
<text top="955" left="202" width="519" height="12" font="4">12. W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. McDaniel, and A. N. Sheth. Taint-</text>
<text top="972" left="227" width="494" height="12" font="4">Droid: an information-ﬂow tracking system for realtime privacy monitoring on smartphones.</text>
<text top="988" left="227" width="243" height="12" font="4">In Proceedings of OSDI 2010, October 2010.</text>
</page>
<page number="14" position="absolute" top="0" left="0" height="1262" width="892">
<text top="184" left="202" width="519" height="12" font="4">13. W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri. A Study of Android Application</text>
<text top="201" left="227" width="436" height="12" font="4">Security. In Proceedings of the 20th USENIX Security Symposium, August 2011.</text>
<text top="217" left="202" width="519" height="12" font="4">14. W. Enck, M. Ongtang, and P. McDaniel. Understanding android security. IEEE Security and</text>
<text top="234" left="227" width="42" height="12" font="4">Privacy</text>
<text top="233" left="269" width="103" height="12" font="4">, 7(1):50–57, 2009.</text>
<text top="250" left="202" width="519" height="12" font="4">15. A. P. Felt, M. Finifter, E. Chin, S. Hanna, and D. Wagner. A Survey of Mobile Malware in</text>
<text top="266" left="227" width="494" height="12" font="4">the Wild. In ACM Workshop on Security and Privacy in Mobile Devices (SPSM), Chicago,</text>
<text top="283" left="227" width="130" height="12" font="4">IL, USA, October 2011.</text>
<text top="299" left="202" width="164" height="12" font="4">16. B. R. for The Register.</text>
<text top="299" left="385" width="229" height="12" font="4">iphone app grabs your mobile number.</text>
<text top="300" left="632" width="89" height="10" font="4">http://www.</text>
<text top="316" left="227" width="363" height="10" font="4">theregister.co.uk/2009/09/30/iphone_security/</text>
<text top="316" left="590" width="3" height="12" font="4">.</text>
<text top="332" left="202" width="519" height="12" font="4">17. O. Hallaraker and G. Vigna. Detecting malicious javascript code in mozilla. In 10th Inter-</text>
<text top="349" left="227" width="456" height="12" font="4">national Conference on Engineering of Complex Computer Systems (ICECCS 2005)</text>
<text top="348" left="683" width="38" height="12" font="4">, pages</text>
<text top="365" left="227" width="71" height="12" font="4">85–94, 2005.</text>
<text top="381" left="202" width="519" height="12" font="4">18. G. Hunt and D. Brubacher. Detours: binary interception of Win32 functions. In 3rd USENIX</text>
<text top="398" left="227" width="133" height="12" font="4">Windows NT Symposium</text>
<text top="398" left="360" width="361" height="12" font="4">, pages 135–143, Berkeley, CA, USA, 1999. USENIX Association.</text>
<text top="414" left="202" width="519" height="12" font="4">19. C. Mulliner, G. Vigna, D. Dagon, and W. Lee. Using Labeling to Prevent Cross-Service</text>
<text top="431" left="227" width="494" height="12" font="4">Attacks Against Smart Phones. In Proceedings of the Conference on Detection of Intrusions</text>
<text top="447" left="227" width="286" height="12" font="4">and Malware, and Vulnerability Assessment (DIMVA)</text>
<text top="447" left="513" width="208" height="12" font="4">, volume 4064 of LNCS, pages 91–108,</text>
<text top="464" left="227" width="204" height="12" font="4">Berlin, Germany, July 2006. Springer.</text>
<text top="480" left="202" width="519" height="12" font="4">20. D. Mutz, F. Valeur, G. Vigna, and C. Kr¨ugel. Anomalous system call detection. ACM Trans.</text>
<text top="497" left="227" width="82" height="12" font="4">Inf. Syst. Secur.</text>
<text top="496" left="309" width="103" height="12" font="4">, 9(1):61–93, 2006.</text>
<text top="513" left="202" width="519" height="12" font="4">21. G. Portokalidis, A. Slowinska, and H. Bos. Argos: an emulator for ﬁngerprinting zero-day</text>
<text top="529" left="227" width="494" height="12" font="4">attacks for advertised honeypots with automatic signature generation. In Proceedings of the</text>
<text top="546" left="227" width="139" height="12" font="4">2006 EuroSys Conference</text>
<text top="546" left="366" width="111" height="12" font="4">, pages 15–27, 2006.</text>
<text top="562" left="202" width="519" height="12" font="4">22. A. Vasudevan and R. Yerraballi. Stealth breakpoints. In 21st Annual Computer Security</text>
<text top="579" left="227" width="185" height="12" font="4">Applications Conference (ACSAC)</text>
<text top="579" left="413" width="125" height="12" font="4">, pages 381–392, 2005.</text>
<text top="595" left="202" width="211" height="12" font="4">23. A. Vasudevan and R. Yerraballi.</text>
<text top="595" left="428" width="292" height="12" font="4">Cobra: Fine-grained malware analysis using stealth</text>
<text top="611" left="227" width="484" height="12" font="4">localized-executions. In IEEE Symposium on Security and Privacy, pages 264–279, 2006.</text>
<text top="628" left="202" width="519" height="12" font="4">24. A. Vasudevan and R. Yerraballi. Spike: engineering malware analysis tools using unob-</text>
<text top="644" left="227" width="494" height="12" font="4">trusive binary-instrumentation. In Proceedings of the 29th Australasian Computer Science</text>
<text top="661" left="227" width="62" height="12" font="4">Conference</text>
<text top="661" left="289" width="125" height="12" font="4">, pages 311–320, 2006.</text>
<text top="677" left="202" width="519" height="12" font="4">25. C. Willems, T. Holz, and F. Freiling. Toward automated dynamic malware analysis using</text>
<text top="694" left="227" width="326" height="12" font="4">CWSandbox. IEEE Security and Privacy, 5(2):32–39, 2007.</text>
<text top="710" left="202" width="519" height="12" font="4">26. Wired. Apple Approves, Pulls Flashlight App with Hidden Tethering Mode. http://www.</text>
<text top="727" left="227" width="486" height="10" font="4">wired.com/gadgetlab/2010/07/apple-approves-pulls-flashlight%</text>
<text top="744" left="227" width="269" height="10" font="4">2dapp-with-hidden-tethering-mode/</text>
<text top="743" left="496" width="3" height="12" font="4">.</text>
<text top="759" left="202" width="519" height="12" font="4">27. H. Yin, D. X. Song, M. Egele, C. Kruegel, and E. Kirda. Panorama: capturing system-wide</text>
<text top="776" left="227" width="494" height="12" font="4">information ﬂow for malware detection and analysis. In ACM Conference on Computer and</text>
<text top="792" left="227" width="176" height="12" font="4">Communications Security (CCS)</text>
<text top="792" left="403" width="125" height="12" font="4">, pages 116–127, 2007.</text>
</page>
</pdf2xml>
