<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1186" width="892">
	<fontspec id="0" size="10" family="Times" color="#000000"/>
	<fontspec id="1" size="21" family="Times" color="#000000"/>
	<fontspec id="2" size="12" family="Times" color="#000000"/>
	<fontspec id="3" size="12" family="Times" color="#000000"/>
	<fontspec id="4" size="12" family="Times" color="#000000"/>
	<fontspec id="5" size="16" family="Times" color="#000000"/>
	<fontspec id="6" size="10" family="Times" color="#000000"/>
	<fontspec id="7" size="10" family="Times" color="#0000ff"/>
	<fontspec id="8" size="12" family="Times" color="#0000ff"/>
<text top="50" left="76" width="81" height="12" font="0">Cluster Comput</text>
<text top="65" left="76" width="171" height="12" font="0">DOI 10.1007/s10586-011-0196-1</text>
<text top="161" left="76" width="436" height="22" font="1"><b>A dynamic approach to tolerate soft errors</b></text>
<text top="212" left="76" width="63" height="14" font="2"><b>Lei Xiong</b></text>
<text top="208" left="143" width="96" height="19" font="3">· <b>Qingping Tan</b></text>
<text top="365" left="76" width="313" height="12" font="0">Received: 15 September 2011 / Accepted: 27 December 2011</text>
<text top="380" left="76" width="246" height="12" font="0">© Springer Science+Business Media, LLC 2012</text>
<text top="424" left="76" width="357" height="14" font="2"><b>Abstract </b>Dynamic implementation for software-based soft</text>
<text top="443" left="76" width="357" height="14" font="4">error tolerance method which can protect more types of</text>
<text top="461" left="76" width="357" height="14" font="4">codes can cover more soft errors. This paper explores soft</text>
<text top="480" left="76" width="357" height="14" font="4">error tolerance with dynamic software-based method. We</text>
<text top="499" left="76" width="357" height="14" font="4">propose a new dynamic software-based approach to tolerate</text>
<text top="517" left="76" width="357" height="14" font="4">soft errors. In our approach, the objective which is protected</text>
<text top="536" left="76" width="357" height="14" font="4">is dynamic program. For those protected dynamic binary</text>
<text top="555" left="76" width="357" height="14" font="4">codes, we make sure right control ﬂow and right data ﬂow to</text>
<text top="573" left="76" width="357" height="14" font="4">signiﬁcant extent in our approach. Our approach copies ev-</text>
<text top="592" left="76" width="357" height="14" font="4">ery data and operates every operation twice to ensure those</text>
<text top="611" left="76" width="357" height="14" font="4">data stored into memory are right. Additionally, we ensure</text>
<text top="629" left="76" width="357" height="14" font="4">every branch instruction can jump to the right address by</text>
<text top="648" left="76" width="357" height="14" font="4">checking condition and destination address. Our approach is</text>
<text top="666" left="76" width="357" height="14" font="4">implemented by the technique dynamic binary instrumen-</text>
<text top="685" left="76" width="357" height="14" font="4">tation. Speciﬁcally, our tool is implemented on the basis</text>
<text top="704" left="76" width="357" height="14" font="4">of valgrind framework which is a heavyweight dynamic bi-</text>
<text top="722" left="76" width="357" height="14" font="4">nary instrumentation tool. Our experimental results demon-</text>
<text top="741" left="76" width="357" height="14" font="4">strate that our approach can get higher reliability of dynamic</text>
<text top="760" left="76" width="357" height="14" font="4">software than those approaches which is implemented with</text>
<text top="778" left="76" width="357" height="14" font="4">static program protection method. However, our approach is</text>
<text top="797" left="76" width="357" height="14" font="4">only suitable for the system which has a strict requirement</text>
<text top="816" left="76" width="357" height="14" font="4">of reliability because our approach also sacriﬁces more per-</text>
<text top="834" left="76" width="357" height="14" font="4">formance of software than those static program protection</text>
<text top="853" left="76" width="54" height="14" font="4">methods.</text>
<text top="890" left="76" width="135" height="14" font="2"><b>Keywords </b>Soft errors</text>
<text top="886" left="215" width="176" height="19" font="3">· Software-implemented fault</text>
<text top="909" left="76" width="55" height="14" font="4">tolerance</text>
<text top="905" left="135" width="283" height="19" font="3">· Dynamic fault tolerance · Dynamically binary</text>
<text top="927" left="76" width="94" height="14" font="4">instrumentation</text>
<text top="979" left="76" width="53" height="12" font="0">L. Xiong (</text>
<text top="979" left="143" width="4" height="12" font="0">)</text>
<text top="976" left="151" width="41" height="17" font="6">· Q. Tan</text>
<text top="994" left="76" width="333" height="12" font="0">School of Computer, National University of Defense Technology,</text>
<text top="1009" left="76" width="128" height="12" font="0">Changsha 410073, China</text>
<text top="1024" left="76" width="36" height="12" font="0">e-mail:</text>
<text top="1024" left="115" width="113" height="12" font="7"><a href="mailto:leixiong@nudt.edu.cn">leixiong@nudt.edu.cn</a></text>
<text top="1047" left="76" width="34" height="12" font="0">Q. Tan</text>
<text top="1062" left="76" width="36" height="12" font="0">e-mail:</text>
<text top="1062" left="115" width="132" height="12" font="7"><a href="mailto:eric.tan.6508@gmail.com">eric.tan.6508@gmail.com</a></text>
<text top="424" left="459" width="96" height="14" font="2"><b>1 Introduction</b></text>
<text top="457" left="459" width="357" height="14" font="4">Transistors are smaller and faster with the improvement of</text>
<text top="475" left="459" width="357" height="14" font="4">fabrication technology nowadays. However, their threshold</text>
<text top="493" left="459" width="357" height="14" font="4">voltages are lower and their margins of noise are tighter with</text>
<text top="512" left="459" width="357" height="14" font="4">this current. Consequently, transistors are less reliable with</text>
<text top="530" left="459" width="357" height="14" font="4">their performance enhancement. Computer system which</text>
<text top="548" left="459" width="357" height="14" font="4">consists of billions of transistors also faces the reliability</text>
<text top="566" left="459" width="357" height="14" font="4">challenge. If there are energetic particles striking its chip,</text>
<text top="585" left="459" width="357" height="14" font="4">the chip is susceptible to soft errors. Soft error is a kind of</text>
<text top="603" left="459" width="357" height="14" font="4">intermittent fault on hardware. It is behaved by ﬂipped-bits</text>
<text top="621" left="459" width="357" height="14" font="4">which are caused by disturbance of transistor states. If there</text>
<text top="639" left="459" width="357" height="14" font="4">is another operation to the same location on the faulty hard-</text>
<text top="658" left="459" width="357" height="14" font="4">ware, it will return to normal state. Soft errors of hardware</text>
<text top="676" left="459" width="357" height="14" font="4">can affect system reliability. During the execution of pro-</text>
<text top="694" left="459" width="357" height="14" font="4">gram, if the hardware component which happened soft error</text>
<text top="712" left="459" width="357" height="14" font="4">is used, then the result of some instruction may be wrong.</text>
<text top="731" left="459" width="357" height="14" font="4">With the execution ﬂow in the program, the result may prop-</text>
<text top="749" left="459" width="330" height="14" font="4">agate to other data even to the outcome of the program.</text>
<text top="767" left="477" width="339" height="14" font="4">There are two main approaches to tolerate soft errors on</text>
<text top="786" left="459" width="357" height="14" font="4">hardware which are hardware-based approach and software-</text>
<text top="804" left="459" width="357" height="14" font="4">based approach. Compared with hardware-based approach</text>
<text top="822" left="459" width="357" height="14" font="4">which need copy the whole or part of original hardware sys-</text>
<text top="840" left="459" width="33" height="14" font="4">tem <a href="pdfxml.html#7">[</a></text>
<text top="840" left="492" width="7" height="14" font="8"><a href="pdfxml.html#7">1</a></text>
<text top="840" left="500" width="7" height="14" font="4"><a href="pdfxml.html#7">–</a></text>
<text top="840" left="507" width="7" height="14" font="8"><a href="pdfxml.html#7">3</a></text>
<text top="840" left="515" width="301" height="14" font="4"><a href="pdfxml.html#7">], </a>software-based approach is regarded as an ef-</text>
<text top="859" left="459" width="357" height="14" font="4">ﬁcient approach to tolerate soft errors. The mechanism of</text>
<text top="877" left="459" width="357" height="14" font="4">software-based method is time redundancy. In the method,</text>
<text top="895" left="459" width="357" height="14" font="4">every data is stored twice, and every operation is operated</text>
<text top="913" left="459" width="357" height="14" font="4">twice by the original version data and copied version data.</text>
<text top="932" left="459" width="357" height="14" font="4">At some program points such as writing new data to memory</text>
<text top="950" left="459" width="357" height="14" font="4">or branch instructions, the results are compared. If these two</text>
<text top="968" left="459" width="357" height="14" font="4">version data are identical, there is no soft error in system.</text>
<text top="986" left="459" width="357" height="14" font="4">But if they are not, we consider a happened soft error in sys-</text>
<text top="1005" left="459" width="357" height="14" font="4">tem, and recover the error. The objective of software-based</text>
<text top="1023" left="459" width="357" height="14" font="4">approach not only can be source program, but also can be</text>
<text top="1041" left="459" width="357" height="14" font="4">instruction-level program, such as assembly program or ma-</text>
<text top="1059" left="459" width="357" height="14" font="4">chine program. Source program protection only can protect</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1186" width="892">
<text top="50" left="735" width="81" height="12" font="0">Cluster Comput</text>
<text top="84" left="76" width="357" height="14" font="4">those data on memory. On the other hand, instruction level</text>
<text top="103" left="76" width="357" height="14" font="4">software protection not only can protect data in memory but</text>
<text top="121" left="76" width="357" height="14" font="4">also can protect those storage units in processor with thinner</text>
<text top="140" left="76" width="357" height="14" font="4">grain. So detection and recovery of soft errors on instruction</text>
<text top="159" left="76" width="170" height="14" font="4">level are broadly discussed [</text>
<text top="159" left="246" width="7" height="14" font="8"><a href="pdfxml.html#7">4</a></text>
<text top="159" left="253" width="7" height="14" font="4">–</text>
<text top="159" left="261" width="7" height="14" font="8"><a href="pdfxml.html#7">8</a></text>
<text top="159" left="268" width="9" height="14" font="4">].</text>
<text top="178" left="94" width="339" height="14" font="4">Generally, software-based methods are statically imple-</text>
<text top="196" left="76" width="139" height="14" font="4">mented by compiler [</text>
<text top="196" left="215" width="7" height="14" font="8"><a href="pdfxml.html#7">4</a></text>
<text top="196" left="222" width="7" height="14" font="4">–</text>
<text top="196" left="230" width="7" height="14" font="8"><a href="pdfxml.html#7">6</a></text>
<text top="196" left="237" width="196" height="14" font="4">]. The fault tolerance compiler</text>
<text top="215" left="76" width="357" height="14" font="4">which implements redundancy codes algorithm compiles</text>
<text top="234" left="76" width="357" height="14" font="4">static program into redundancy executable codes. How-</text>
<text top="253" left="76" width="357" height="14" font="4">ever, there are some disadvantages to statically implement</text>
<text top="272" left="76" width="357" height="14" font="4">software-based soft error tolerance method. First of all,</text>
<text top="290" left="76" width="357" height="14" font="4">static implementation is dependent on the source of soft-</text>
<text top="309" left="76" width="357" height="14" font="4">ware. If there is no software source, software can not be</text>
<text top="328" left="76" width="357" height="14" font="4">protected. Second, static implementation of software-based</text>
<text top="347" left="76" width="357" height="14" font="4">fault tolerance method cannot protect some kinds of codes</text>
<text top="365" left="76" width="357" height="14" font="4">and data, such as dynamic codes and data. Third, static</text>
<text top="384" left="76" width="357" height="14" font="4">implementation of soft error tolerance method only can</text>
<text top="403" left="76" width="357" height="14" font="4">protect application software. Those software which sup-</text>
<text top="422" left="76" width="357" height="14" font="4">port the execution of application software, such as static</text>
<text top="440" left="76" width="357" height="14" font="4">library or dynamic library, are out of its protection scope.</text>
<text top="459" left="76" width="357" height="14" font="4">Dynamic implementation of software-based method can</text>
<text top="478" left="76" width="357" height="14" font="4">solve these problems above. Dynamic implementation of</text>
<text top="497" left="76" width="357" height="14" font="4">software-based soft error tolerance method can cover those</text>
<text top="515" left="76" width="357" height="14" font="4">dynamic codes and data, as well as those software which</text>
<text top="534" left="76" width="357" height="14" font="4">support the execution of application program. The objective</text>
<text top="553" left="76" width="357" height="14" font="4">of dynamic implementation is executable codes. Dynamic</text>
<text top="572" left="76" width="357" height="14" font="4">implementation for the method bases on dynamic binary</text>
<text top="590" left="76" width="357" height="14" font="4">analysis and dynamic binary instrumentation. According to</text>
<text top="609" left="76" width="357" height="14" font="4">analyses to the execution of software, redundancy codes are</text>
<text top="628" left="76" width="263" height="14" font="4">instrumented into the software dynamically.</text>
<text top="647" left="94" width="339" height="14" font="4">This paper explores dynamic soft error tolerance with</text>
<text top="665" left="76" width="357" height="14" font="4">software-based method. We propose a dynamically soft-</text>
<text top="684" left="76" width="357" height="14" font="4">ware-based soft error tolerance approach. In our approach,</text>
<text top="703" left="76" width="357" height="14" font="4">the objective which is dynamically protected is binary codes</text>
<text top="722" left="76" width="357" height="14" font="4">on the instruction level. For the original executable codes,</text>
<text top="741" left="76" width="357" height="14" font="4">we instrument redundancy codes into them during their exe-</text>
<text top="759" left="76" width="357" height="14" font="4">cution. The redundancy codes include the copy version of</text>
<text top="778" left="76" width="357" height="14" font="4">data, recomputation of instructions, and checked instruc-</text>
<text top="797" left="76" width="357" height="14" font="4">tions. Our approach is implemented with Dynamic Binary</text>
<text top="816" left="76" width="357" height="14" font="4">Instrumentation Framework (DBIF) which supports our re-</text>
<text top="834" left="76" width="357" height="14" font="4">dundancy codes instrumentation. During the execution of</text>
<text top="853" left="76" width="357" height="14" font="4">application program, there are two kinds of software which</text>
<text top="872" left="76" width="357" height="14" font="4">are instrumentation tool and application program. They are</text>
<text top="891" left="76" width="357" height="14" font="4">share the same memory address space. Speciﬁcally, our ap-</text>
<text top="909" left="76" width="357" height="14" font="4">proach is implemented on the basis of valgrind which is a</text>
<text top="928" left="76" width="357" height="14" font="4">heavyweight dynamic binary instrumentation framework. In</text>
<text top="947" left="76" width="357" height="14" font="4">the implementation of our approach, redundancy codes are</text>
<text top="966" left="76" width="357" height="14" font="4">instrumented with the granularity of basic block. By the dy-</text>
<text top="984" left="76" width="357" height="14" font="4">namic redundancy codes instrumentation, the dynamic ex-</text>
<text top="1003" left="76" width="357" height="14" font="4">ecutable codes are protected. Our dynamic protection ap-</text>
<text top="1022" left="76" width="357" height="14" font="4">proach can protect the whole of dynamic application pro-</text>
<text top="1041" left="76" width="357" height="14" font="4">gram and those codes which support the execution of ap-</text>
<text top="1059" left="76" width="357" height="14" font="4">plication program. As a result, our dynamic software-based</text>
<text top="84" left="459" width="357" height="14" font="4">soft error tolerance method can get higher reliability of a</text>
<text top="102" left="459" width="356" height="14" font="4">software task than those static program protection methods.</text>
<text top="121" left="477" width="248" height="14" font="4">Our rest structures are as follows. Section</text>
<text top="121" left="729" width="7" height="14" font="8"><a href="pdfxml.html#2">2</a></text>
<text top="121" left="740" width="76" height="14" font="4">is the related</text>
<text top="139" left="459" width="159" height="14" font="4">work of our paper. In Sect.</text>
<text top="139" left="621" width="7" height="14" font="8"><a href="pdfxml.html#3">3</a></text>
<text top="139" left="629" width="187" height="14" font="4"><a href="pdfxml.html#3">, </a>we represent our dynamic soft</text>
<text top="158" left="459" width="357" height="14" font="4">error tolerance approach. Our dynamic soft error tolerance</text>
<text top="176" left="459" width="281" height="14" font="4">approach is implemented and evaluated in Sect.</text>
<text top="176" left="744" width="7" height="14" font="8"><a href="pdfxml.html#4">4</a></text>
<text top="176" left="751" width="65" height="14" font="4">. In the last</text>
<text top="195" left="459" width="186" height="14" font="4">section, we make a conclusion.</text>
<text top="249" left="459" width="101" height="14" font="2"><b>2 Related work</b></text>
<text top="285" left="459" width="357" height="14" font="4">As we have mentioned that the mechanism of software-</text>
<text top="303" left="459" width="357" height="14" font="4">based method is time redundancy. In the method, every data</text>
<text top="322" left="459" width="357" height="14" font="4">which is in program is stored twice, and every operation is</text>
<text top="340" left="459" width="357" height="14" font="4">operated twice by the original version data and copied data.</text>
<text top="359" left="459" width="357" height="14" font="4">At some check points such as writing new data to memory</text>
<text top="377" left="459" width="357" height="14" font="4">or branch instructions, the results are compared. If these two</text>
<text top="396" left="459" width="357" height="14" font="4">version data are identical, there is no soft error in system.</text>
<text top="414" left="459" width="357" height="14" font="4">But if they are not, we consider a happened soft error in sys-</text>
<text top="433" left="459" width="357" height="14" font="4">tem, and recover the error. All the steps mentioned above are</text>
<text top="451" left="459" width="326" height="14" font="4">implemented by software in software-based method [</text>
<text top="451" left="785" width="7" height="14" font="8"><a href="pdfxml.html#7">4</a></text>
<text top="451" left="792" width="7" height="14" font="4">–</text>
<text top="451" left="800" width="7" height="14" font="8"><a href="pdfxml.html#7">6</a></text>
<text top="451" left="807" width="9" height="14" font="4">].</text>
<text top="470" left="459" width="357" height="14" font="4">Hardware-based method is different from software-based</text>
<text top="488" left="459" width="357" height="14" font="4">method to tolerate soft errors. This method bases on hard-</text>
<text top="507" left="459" width="357" height="14" font="4">ware structure duplication. Both of original system and du-</text>
<text top="526" left="459" width="357" height="14" font="4">plicated system run the same software task. At some check</text>
<text top="544" left="459" width="357" height="14" font="4">points of the software, the results of the original system and</text>
<text top="563" left="459" width="357" height="14" font="4">the results of the duplicated system are checked. The con-</text>
<text top="581" left="459" width="357" height="14" font="4">sistency of the two results shows whether or not there are</text>
<text top="600" left="459" width="167" height="14" font="4">soft errors in one of them <a href="pdfxml.html#7">[</a></text>
<text top="600" left="625" width="7" height="14" font="8"><a href="pdfxml.html#7">1</a></text>
<text top="600" left="633" width="7" height="14" font="4"><a href="pdfxml.html#7">–</a></text>
<text top="600" left="640" width="7" height="14" font="8"><a href="pdfxml.html#7">3</a></text>
<text top="600" left="648" width="168" height="14" font="4"><a href="pdfxml.html#7">]. </a>Compared with software-</text>
<text top="618" left="459" width="357" height="14" font="4">based method, hardware-based method needs to duplicate</text>
<text top="637" left="459" width="357" height="14" font="4">a hardware system to some extent. Apparently, hardware-</text>
<text top="655" left="459" width="189" height="14" font="4">based methods take more costs.</text>
<text top="674" left="477" width="339" height="14" font="4">There are two main approaches to implement software-</text>
<text top="692" left="459" width="357" height="14" font="4">based soft errors tolerance method which are static ap-</text>
<text top="711" left="459" width="357" height="14" font="4">proach and dynamic approach. Static approach implements</text>
<text top="729" left="459" width="357" height="14" font="4">the method with compiler. The objective of static approach</text>
<text top="748" left="459" width="357" height="14" font="4">is static software. Static approach to implement software-</text>
<text top="766" left="459" width="357" height="14" font="4">based soft errors tolerance method can cover most of hap-</text>
<text top="785" left="459" width="110" height="14" font="4">pened soft errors [</text>
<text top="785" left="569" width="7" height="14" font="8"><a href="pdfxml.html#7">4</a></text>
<text top="785" left="576" width="7" height="14" font="4">–</text>
<text top="785" left="584" width="7" height="14" font="8"><a href="pdfxml.html#7">6</a></text>
<text top="785" left="591" width="225" height="14" font="4">]. However, there are still some kinds</text>
<text top="803" left="459" width="357" height="14" font="4">of software errors caused by soft errors which are unable</text>
<text top="822" left="459" width="357" height="14" font="4">to be detected. First, static approach can’t protect dynamic</text>
<text top="840" left="459" width="357" height="14" font="4">codes and dynamic data in software. Those dynamic pro-</text>
<text top="859" left="459" width="357" height="14" font="4">gram and data which are generated during the execution</text>
<text top="877" left="459" width="357" height="14" font="4">of software cannot be protected during compiling. Second,</text>
<text top="896" left="459" width="357" height="14" font="4">static approach cannot protect the software which supports</text>
<text top="914" left="459" width="357" height="14" font="4">the execution of application software. These kinds of soft-</text>
<text top="933" left="459" width="357" height="14" font="4">ware are not in the form of source codes, such as static li-</text>
<text top="951" left="459" width="357" height="14" font="4">brary or dynamic library. Finally, static approach is depen-</text>
<text top="970" left="459" width="357" height="14" font="4">dent of source codes of software. On the other hand, the ob-</text>
<text top="988" left="459" width="357" height="14" font="4">jective of dynamic approach is dynamic binary codes which</text>
<text top="1007" left="459" width="357" height="14" font="4">are the execution of static software. Dynamic method to im-</text>
<text top="1025" left="459" width="357" height="14" font="4">plement software-based soft error tolerance can solve these</text>
<text top="1044" left="459" width="357" height="14" font="4">problems above. This method can protect more codes, so as</text>
<text top="1063" left="459" width="151" height="14" font="4">to cover more soft errors.</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1186" width="892">
<text top="50" left="76" width="81" height="12" font="0">Cluster Comput</text>
<text top="84" left="94" width="339" height="14" font="4">For the method for dynamic implementation of software-</text>
<text top="103" left="76" width="357" height="14" font="4">based fault tolerance, Borin et al. introduce a software-only</text>
<text top="122" left="76" width="232" height="14" font="4">technique using dynamic translation <a href="pdfxml.html#7">[</a></text>
<text top="122" left="308" width="7" height="14" font="8"><a href="pdfxml.html#7">9</a></text>
<text top="122" left="316" width="118" height="14" font="4"><a href="pdfxml.html#7">], </a>but their work is</text>
<text top="141" left="76" width="357" height="14" font="4">limited solely to protecting control-ﬂow. Reis et al. im-</text>
<text top="160" left="76" width="357" height="14" font="4">plement a tool named Spot which also implements the</text>
<text top="179" left="76" width="333" height="14" font="4">software-based method via dynamic binary translation [</text>
<text top="179" left="410" width="15" height="14" font="8"><a href="pdfxml.html#7">10</a></text>
<text top="179" left="425" width="9" height="14" font="4"><a href="pdfxml.html#7">].</a></text>
<text top="198" left="76" width="357" height="14" font="4">Spot is implemented on the basis of the instrumentation tool</text>
<text top="217" left="76" width="357" height="14" font="4">Pin which is a lightweight dynamic binary instrumentation</text>
<text top="236" left="76" width="33" height="14" font="4">tool <a href="pdfxml.html#7">[</a></text>
<text top="236" left="109" width="15" height="14" font="8"><a href="pdfxml.html#7">11</a></text>
<text top="236" left="124" width="309" height="14" font="4">]. The tool can instrument those redundancy codes</text>
<text top="255" left="76" width="357" height="14" font="4">which are only related to data ﬂow protection of the pro-</text>
<text top="274" left="76" width="357" height="14" font="4">gram into the original dynamic software. In our paper, we</text>
<text top="293" left="76" width="357" height="14" font="4">propose and implement a dynamic soft error tolerance ap-</text>
<text top="312" left="76" width="357" height="14" font="4">proach which is also software-based fault tolerance method.</text>
<text top="331" left="76" width="357" height="14" font="4">Both of control ﬂow and data ﬂow of the dynamic software</text>
<text top="350" left="76" width="357" height="14" font="4">are protected in our approach. The implementation of our</text>
<text top="369" left="76" width="357" height="14" font="4">paper also aims x86 architecture which is the same as Spot.</text>
<text top="387" left="76" width="357" height="14" font="4">Previous software-only techniques have targeted the MIPS</text>
<text top="406" left="76" width="80" height="14" font="4">architecture <a href="pdfxml.html#7">[</a></text>
<text top="406" left="156" width="7" height="14" font="8"><a href="pdfxml.html#7">5</a></text>
<text top="406" left="164" width="185" height="14" font="4"><a href="pdfxml.html#7">], </a>the IntelR IPF architecture <a href="pdfxml.html#7">[</a></text>
<text top="406" left="349" width="7" height="14" font="8"><a href="pdfxml.html#7">4</a></text>
<text top="406" left="357" width="77" height="14" font="4"><a href="pdfxml.html#7">], </a>and a Mo-</text>
<text top="425" left="76" width="192" height="14" font="4">torola M68040 microprocessor <a href="pdfxml.html#8">[</a></text>
<text top="425" left="268" width="15" height="14" font="8"><a href="pdfxml.html#8">12</a></text>
<text top="425" left="283" width="150" height="14" font="4"><a href="pdfxml.html#8">]. </a>The ubiquity of proces-</text>
<text top="444" left="76" width="357" height="14" font="4">sor with x86 architecture makes our approach have a broad</text>
<text top="463" left="76" width="107" height="14" font="4">application space.</text>
<text top="526" left="76" width="263" height="14" font="2"><b>3 Dynamic soft error tolerance approach</b></text>
<text top="566" left="76" width="357" height="14" font="4">We have mentioned that the objectives of our dynamic soft</text>
<text top="585" left="76" width="357" height="14" font="4">error tolerance approach are those dynamic binary codes.</text>
<text top="604" left="76" width="357" height="14" font="4">So those protected objectives in our approach are those dy-</text>
<text top="623" left="76" width="357" height="14" font="4">namic binary codes. For those protected codes in dynamic</text>
<text top="642" left="76" width="357" height="14" font="4">software, our approach also follows prior ideas which are</text>
<text top="661" left="76" width="357" height="14" font="4">applied with static program protection method to protect</text>
<text top="680" left="76" width="357" height="14" font="4">software. In our approach, we make sure right control ﬂow</text>
<text top="699" left="76" width="357" height="14" font="4">and right data ﬂow of those dynamic binary codes to signif-</text>
<text top="718" left="76" width="73" height="14" font="4">icant extent.</text>
<text top="737" left="94" width="339" height="14" font="4">Our approach is full dynamic program protection ap-</text>
<text top="756" left="76" width="357" height="14" font="4">proach. The whole dynamic program is protected in our ap-</text>
<text top="775" left="76" width="357" height="14" font="4">proach. Although different parts of dynamic codes which</text>
<text top="794" left="76" width="357" height="14" font="4">have different features may react differently under the ef-</text>
<text top="813" left="76" width="357" height="14" font="4">fects of soft errors on hardware, we still protect the whole</text>
<text top="832" left="76" width="357" height="14" font="4">dynamic codes uniformly. The optimized dynamic soft error</text>
<text top="851" left="76" width="357" height="14" font="4">tolerance approach whose protection emphasizes the vulner-</text>
<text top="870" left="76" width="357" height="14" font="4">able parts of dynamic codes under soft errors is our next</text>
<text top="889" left="76" width="34" height="14" font="4">work.</text>
<text top="908" left="94" width="339" height="14" font="4">For control ﬂow error, the effects of control ﬂow error to</text>
<text top="927" left="76" width="357" height="14" font="4">program outcome are that program outcomes are almost in-</text>
<text top="946" left="76" width="357" height="14" font="4">correct. If there is a control ﬂow error which is caused by</text>
<text top="965" left="76" width="357" height="14" font="4">soft errors on hardware, the error could happen from any in-</text>
<text top="984" left="76" width="357" height="14" font="4">struction to any another instruction. As a result, it is hard to</text>
<text top="1003" left="76" width="357" height="14" font="4">detect control ﬂow error immediately by software method.</text>
<text top="1022" left="76" width="357" height="14" font="4">However, those data which could lead to control ﬂow er-</text>
<text top="1040" left="76" width="357" height="14" font="4">ror are DUE (Detected Unrecoverable Error) data based on</text>
<text top="1059" left="76" width="357" height="14" font="4">our analysis and fault injection experiences. The effects of</text>
<text top="84" left="459" width="357" height="14" font="4">control ﬂow error which lead to exception of program exe-</text>
<text top="103" left="459" width="357" height="14" font="4">cution or incorrect outcome of program could result in pro-</text>
<text top="122" left="459" width="357" height="14" font="4">gram execution halt or incorrect results. In these situations,</text>
<text top="141" left="459" width="357" height="14" font="4">the effects of control ﬂow error could be caught by program</text>
<text top="161" left="459" width="357" height="14" font="4">itself. As a result, in our approach, we only detect the con-</text>
<text top="180" left="459" width="357" height="14" font="4">trol ﬂow error which is caused by branch instruction. We</text>
<text top="199" left="459" width="357" height="14" font="4">ignore other control ﬂow errors because these control ﬂow</text>
<text top="218" left="459" width="357" height="14" font="4">errors are unclear for us, and they could be caught even-</text>
<text top="237" left="459" width="357" height="14" font="4">tually. The control ﬂow error caused by branch instruction</text>
<text top="257" left="459" width="357" height="14" font="4">is behaved by wrong jump of branch instructions. To make</text>
<text top="276" left="459" width="357" height="14" font="4">sure the right control ﬂow, if the branch instruction is con-</text>
<text top="295" left="459" width="357" height="14" font="4">ditional branch instruction, we recomputed the condition to</text>
<text top="314" left="459" width="357" height="14" font="4">make sure that the result of condition is correct. Then, the</text>
<text top="333" left="459" width="357" height="14" font="4">destination address of branch instruction is checked to make</text>
<text top="353" left="459" width="357" height="14" font="4">sure the address is correct. For data ﬂow error, we also as-</text>
<text top="372" left="459" width="357" height="14" font="4">sume memory is protected by parity codes or ECC (Error</text>
<text top="391" left="459" width="357" height="14" font="4">Correcting Codes) with hardware technique. So we do not</text>
<text top="410" left="459" width="357" height="14" font="4">need cover those data error in memory. To make sure data</text>
<text top="429" left="459" width="357" height="14" font="4">ﬂow right, we copy every data stored in register. And every</text>
<text top="448" left="459" width="357" height="14" font="4">operation is operated twice by different versions data. These</text>
<text top="468" left="459" width="357" height="14" font="4">data are checked to ﬁnd out if they are the same before these</text>
<text top="487" left="459" width="357" height="14" font="4">data are stored into memory. If the two data are identical, we</text>
<text top="506" left="459" width="357" height="14" font="4">consider the data is correct. If they are not identical, we take</text>
<text top="525" left="459" width="357" height="14" font="4">this as a data error which caused by happened soft errors.</text>
<text top="544" left="459" width="357" height="14" font="4">After the detection of soft error, we transfer the handle of</text>
<text top="564" left="459" width="54" height="14" font="4">the error.</text>
<text top="583" left="477" width="339" height="14" font="4">Speciﬁcally, our dynamic soft error tolerance approach</text>
<text top="602" left="459" width="141" height="14" font="4">is demonstrated by Fig.</text>
<text top="602" left="604" width="7" height="14" font="8"><a href="pdfxml.html#4">1</a></text>
<text top="602" left="612" width="204" height="14" font="4"><a href="pdfxml.html#4">. </a>We describe our approach to dy-</text>
<text top="621" left="459" width="357" height="14" font="4">namically tolerate soft errors with mips assembly language.</text>
<text top="640" left="459" width="357" height="14" font="4">In the original codes, I5 is a branch instruction. We assume</text>
<text top="660" left="459" width="357" height="14" font="4">that the instruction jump to the destination address ‘branch’</text>
<text top="679" left="459" width="357" height="14" font="4">in dynamic program. In fault tolerance codes, every data</text>
<text top="698" left="459" width="357" height="14" font="4">has two versions which are original version and copy ver-</text>
<text top="717" left="459" width="357" height="14" font="4">sion, and every operation is operated twice. Instructions I11,</text>
<text top="736" left="459" width="357" height="14" font="4">I12, I21, I22, I41, I42, I61, I62, I71, I72, I81, and I82 show</text>
<text top="755" left="459" width="357" height="14" font="4">these mechanisms. Every data which is stored in memory</text>
<text top="775" left="459" width="357" height="14" font="4">are checked to make sure its correctness before it is stored.</text>
<text top="794" left="459" width="40" height="14" font="4">In Fig.</text>
<text top="794" left="504" width="7" height="14" font="8"><a href="pdfxml.html#4">1</a></text>
<text top="794" left="511" width="305" height="14" font="4">, I31 is store instruction. So we add check instruc-</text>
<text top="813" left="459" width="357" height="14" font="4">tions I32, I33 before this instruction. If there are inconsistent</text>
<text top="832" left="459" width="357" height="14" font="4">results between original version and copy version, we con-</text>
<text top="851" left="459" width="357" height="14" font="4">sider there is a soft error on the data, and then we transfer</text>
<text top="871" left="459" width="357" height="14" font="4">to the handle of soft errors. For every branch instruction, if</text>
<text top="890" left="459" width="357" height="14" font="4">it is conditional branch instruction, we must make sure the</text>
<text top="909" left="459" width="357" height="14" font="4">result of its condition is right. Additionally, we must make</text>
<text top="928" left="459" width="357" height="14" font="4">sure its transfer address is right. I51 is a branch instruction.</text>
<text top="947" left="459" width="357" height="14" font="4">We add instructions I52, I53, I54 to ensure its condition. We</text>
<text top="967" left="459" width="357" height="14" font="4">add instruction I55 to ensure its transfer address. In instruc-</text>
<text top="986" left="459" width="357" height="14" font="4">tion I55, there are two branch labels which are “branch” and</text>
<text top="1005" left="459" width="357" height="14" font="4">“branch’ ”. In the instruction, branch’ is a copy version of</text>
<text top="1024" left="459" width="357" height="14" font="4">branch. “branch” and “branch’ ” are used to decide whether</text>
<text top="1043" left="459" width="357" height="14" font="4">the destination address of the branch instruction is correct or</text>
<text top="1062" left="459" width="23" height="14" font="4">not.</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1186" width="892">
	<fontspec id="9" size="10" family="Times" color="#000000"/>
<text top="50" left="735" width="81" height="12" font="0">Cluster Comput</text>
<text top="79" left="77" width="163" height="12" font="9"><b>Fig. 1 </b>Description of protected</text>
<text top="94" left="77" width="124" height="12" font="0">codes with our approach</text>
<text top="450" left="76" width="91" height="14" font="2"><b>4 Experiment</b></text>
<text top="490" left="76" width="219" height="14" font="4">4.1 Implementation of our approach</text>
<text top="530" left="76" width="357" height="14" font="4">We implement our approach to dynamically tolerate soft</text>
<text top="549" left="76" width="357" height="14" font="4">errors based on the DBI (dynamic binary instrumentation)</text>
<text top="568" left="76" width="357" height="14" font="4">framework valgrind. Valgrind is a heavy weight DBA (Dy-</text>
<text top="587" left="76" width="357" height="14" font="4">namic binary analysis) and DBI (dynamic binary instrumen-</text>
<text top="605" left="76" width="357" height="14" font="4">tation) tool which fully analyzes those dynamic binary codes</text>
<text top="624" left="76" width="357" height="14" font="4">and the execution of the tool is as complex as those dynamic</text>
<text top="643" left="76" width="84" height="14" font="4">binary codes [</text>
<text top="643" left="161" width="15" height="14" font="8"><a href="pdfxml.html#8">13</a></text>
<text top="643" left="176" width="7" height="14" font="4"><a href="pdfxml.html#8">–</a></text>
<text top="643" left="183" width="15" height="14" font="8"><a href="pdfxml.html#8">16</a></text>
<text top="643" left="198" width="235" height="14" font="4"><a href="pdfxml.html#8">]. </a>Valgrind is a suitable DBI framework</text>
<text top="662" left="76" width="357" height="14" font="4">to implement our dynamic soft error tolerance approach be-</text>
<text top="681" left="76" width="357" height="14" font="4">cause it use shadow value to implement dynamic binary in-</text>
<text top="700" left="76" width="357" height="14" font="4">strumentation. Valgrind shadows every register and memory</text>
<text top="719" left="76" width="357" height="14" font="4">value with another value in memory. During the dynamic</text>
<text top="738" left="76" width="357" height="14" font="4">codes instrumentation, those codes which contain the oper-</text>
<text top="757" left="76" width="357" height="14" font="4">ation of data in the shadow space are added into the original</text>
<text top="776" left="76" width="357" height="14" font="4">codes. According to our approach mentioned above, our tol-</text>
<text top="795" left="76" width="357" height="14" font="4">erance codes include those original codes and those inserted</text>
<text top="814" left="76" width="357" height="14" font="4">redundancy codes. Those inserted redundancy codes are im-</text>
<text top="832" left="76" width="338" height="14" font="4">plemented as operations of shadow values with valgrind.</text>
<text top="851" left="94" width="339" height="14" font="4">Based on the DBI framework valgrind, we implement a</text>
<text top="870" left="76" width="357" height="14" font="4">valgrind tool called softerror. The valgrind tool is imple-</text>
<text top="889" left="76" width="357" height="14" font="4">mented our above-mentioned dynamic soft error tolerance</text>
<text top="908" left="76" width="357" height="14" font="4">approach. In the framework of valgrind, at ﬁrst it trans-</text>
<text top="927" left="76" width="357" height="14" font="4">forms those binary codes into Intermediate Representation</text>
<text top="946" left="76" width="357" height="14" font="4">(IR). Then the instrumentation is happened on the IR, and</text>
<text top="965" left="76" width="357" height="14" font="4">ﬁnally the tool transforms IR into speciﬁc platform binary</text>
<text top="984" left="76" width="357" height="14" font="4">codes again. Generally, a machine instruction can be trans-</text>
<text top="1003" left="76" width="357" height="14" font="4">formed into one or more instructions of IR. In our tool, the</text>
<text top="1022" left="76" width="357" height="14" font="4">instrumentation is also happened on codes of IR. During the</text>
<text top="1041" left="76" width="357" height="14" font="4">instrumentation on IR, redundancy codes are instrumented</text>
<text top="1059" left="76" width="357" height="14" font="4">with the granularity of basic block. For a basic block, the</text>
<text top="450" left="459" width="357" height="14" font="4">redundancy codes are instrumented into it before its execu-</text>
<text top="468" left="459" width="357" height="14" font="4">tion. When the basic block has been executed, the process</text>
<text top="487" left="459" width="357" height="14" font="4">waits for the instrumentation of the next basic block. Once</text>
<text top="505" left="459" width="357" height="14" font="4">the next basic block has been instrumented, the execution of</text>
<text top="524" left="459" width="357" height="14" font="4">the basic block starts. The whole program is instrumented</text>
<text top="542" left="459" width="357" height="14" font="4">and executed with this way. The transformation of x86 plat-</text>
<text top="561" left="459" width="357" height="14" font="4">form binary codes to IR and the instrumentation to the IR</text>
<text top="580" left="459" width="64" height="14" font="4">are as Fig.</text>
<text top="580" left="527" width="7" height="14" font="8"><a href="pdfxml.html#5">2</a></text>
<text top="580" left="539" width="122" height="14" font="4">descriptions. In Fig.</text>
<text top="580" left="666" width="7" height="14" font="8"><a href="pdfxml.html#5">2</a></text>
<text top="580" left="673" width="143" height="14" font="4">, three x86 platform in-</text>
<text top="598" left="459" width="357" height="14" font="4">structions are transformed to seventeen instructions of IR.</text>
<text top="617" left="459" width="357" height="14" font="4">Actually the transformation is also a transformation from</text>
<text top="635" left="459" width="357" height="14" font="4">CISC instructions to RISC instructions. This paper does not</text>
<text top="654" left="459" width="357" height="14" font="4">focus on the details of the transformation and semantics of</text>
<text top="672" left="459" width="334" height="14" font="4">IR. More details can refer to the manual of valgrind <a href="pdfxml.html#8">[</a></text>
<text top="672" left="792" width="15" height="14" font="8"><a href="pdfxml.html#8">15</a></text>
<text top="672" left="807" width="9" height="14" font="4">].</text>
<text top="691" left="459" width="357" height="14" font="4">As for the instrumentation of IR instructions, these 17 in-</text>
<text top="709" left="459" width="357" height="14" font="4">structions are transformed to 26 instructions. 9 instructions</text>
<text top="728" left="459" width="357" height="14" font="4">are added into the original instructions. From the instrumen-</text>
<text top="747" left="459" width="357" height="14" font="4">tation, we can see that the instrumented codes can sacriﬁce</text>
<text top="765" left="459" width="357" height="14" font="4">performance to some extent. Though our instrumentation is</text>
<text top="784" left="459" width="357" height="14" font="4">happened on IR, the semantics of the instrumentation also</text>
<text top="802" left="459" width="357" height="14" font="4">equal to the semantic of machine instruction duplications</text>
<text top="821" left="459" width="106" height="14" font="4">mentioned above.</text>
<text top="857" left="459" width="91" height="14" font="4">4.2 Evaluation</text>
<text top="893" left="459" width="357" height="14" font="4">We use softerror as a tool to run some client programs in</text>
<text top="911" left="459" width="357" height="14" font="4">our experiments. Those client programs are chosen from</text>
<text top="930" left="459" width="357" height="14" font="4">SPEC2000 benchmarks. We give each of the benchmark a</text>
<text top="948" left="459" width="357" height="14" font="4">ﬁxed input set, and those benchmarks run under our tool</text>
<text top="967" left="459" width="357" height="14" font="4">and platforms. For each benchmark, we take execution time</text>
<text top="985" left="459" width="357" height="14" font="4">as its performance measure of each execution under ﬁxed</text>
<text top="1004" left="459" width="357" height="14" font="4">input set. To evaluate reliability of the dynamic program,</text>
<text top="1022" left="459" width="357" height="14" font="4">we implement a fault injection tool. The fault injection tool</text>
<text top="1041" left="459" width="357" height="14" font="4">which is taken as the other process shares the same mem-</text>
<text top="1059" left="459" width="357" height="14" font="4">ory space with those dynamic client programs. Driven by</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1186" width="892">
	<fontspec id="10" size="9" family="Times" color="#000000"/>
<text top="50" left="76" width="81" height="12" font="0">Cluster Comput</text>
<text top="79" left="77" width="151" height="12" font="9"><b>Fig. 2 </b>The transformation of</text>
<text top="94" left="77" width="156" height="12" font="0">x86 binary codes to IR and the</text>
<text top="109" left="77" width="165" height="12" font="0">instrumentation to the IR. Those</text>
<text top="124" left="77" width="112" height="12" font="0">instructions which are</text>
<text top="139" left="77" width="155" height="12" font="0">instrumented are preﬁxed with</text>
<text top="154" left="77" width="24" height="12" font="0">a ‘*’</text>
<text top="700" left="76" width="357" height="14" font="4">time, it writes a wrong data to those storage units randomly.</text>
<text top="720" left="76" width="357" height="14" font="4">Since inter-arrival times for raw faults in hardware are inde-</text>
<text top="740" left="76" width="357" height="14" font="4">pendent and exponentially distributed with density function</text>
<text top="760" left="76" width="15" height="13" font="3">λe</text>
<text top="754" left="91" width="18" height="15" font="10">−λt</text>
<text top="760" left="115" width="5" height="14" font="4"><a href="pdfxml.html#8">[</a></text>
<text top="760" left="120" width="15" height="14" font="8"><a href="pdfxml.html#8">17</a></text>
<text top="760" left="135" width="298" height="14" font="4">], the time which drive the fault injection tool dis-</text>
<text top="780" left="76" width="218" height="14" font="4">tribute with exponential function λe</text>
<text top="774" left="294" width="18" height="15" font="10">−λt</text>
<text top="780" left="314" width="119" height="14" font="4">. We generate those</text>
<text top="800" left="76" width="273" height="14" font="4">data distributed with exponential function λe</text>
<text top="794" left="350" width="18" height="15" font="10">−λt</text>
<text top="800" left="375" width="59" height="14" font="4">by Monte</text>
<text top="820" left="76" width="357" height="14" font="4">Carlo simulation. We give different speciﬁc λ which is also</text>
<text top="840" left="76" width="357" height="14" font="4">soft error rate to different benchmarks based on their exe-</text>
<text top="860" left="76" width="357" height="14" font="4">cution time. We run those benchmarks directly on platform</text>
<text top="880" left="76" width="357" height="14" font="4">under input set, and those outcomes of those dynamic pro-</text>
<text top="900" left="76" width="357" height="14" font="4">grams are recorded. Under our tool softerror, those bench-</text>
<text top="920" left="76" width="357" height="14" font="4">marks are executed with the fault injection tool. Compared</text>
<text top="940" left="76" width="357" height="14" font="4">with the direct execution results of those benchmarks, in</text>
<text top="960" left="76" width="357" height="14" font="4">these executions which are under our tool softerror and fault</text>
<text top="980" left="76" width="357" height="14" font="4">injection tool, we take the proportion of correct dynamic</text>
<text top="1000" left="76" width="357" height="14" font="4">program outcomes as the reliability of these dynamic pro-</text>
<text top="1020" left="76" width="40" height="14" font="4">grams.</text>
<text top="1040" left="94" width="339" height="14" font="4">With the same input to the same benchmark, we ﬁrst</text>
<text top="1059" left="76" width="357" height="14" font="4">run those benchmarks directly on platforms, and then we</text>
<text top="700" left="459" width="357" height="14" font="4">run those benchmarks under our tool softerror. The perfor-</text>
<text top="719" left="459" width="226" height="14" font="4">mances of these two runs are as Table</text>
<text top="719" left="688" width="7" height="14" font="8"><a href="pdfxml.html#6">1</a></text>
<text top="719" left="699" width="41" height="14" font="4">shows.</text>
<text top="738" left="477" width="50" height="14" font="4">In Table</text>
<text top="738" left="531" width="7" height="14" font="8"><a href="pdfxml.html#6">1</a></text>
<text top="738" left="539" width="277" height="14" font="4"><a href="pdfxml.html#6">, </a>we also give the normalized performance of</text>
<text top="757" left="459" width="324" height="14" font="4">static program protection method SWIFT. From Table</text>
<text top="757" left="787" width="7" height="14" font="8"><a href="pdfxml.html#6">1</a></text>
<text top="757" left="799" width="17" height="14" font="4">we</text>
<text top="776" left="459" width="357" height="14" font="4">can see that dynamic protection of programs sacriﬁce more</text>
<text top="795" left="459" width="357" height="14" font="4">performance compared with static protection of programs.</text>
<text top="814" left="459" width="71" height="14" font="4">From Table</text>
<text top="814" left="536" width="7" height="14" font="8"><a href="pdfxml.html#6">1</a></text>
<text top="814" left="544" width="272" height="14" font="4"><a href="pdfxml.html#6">, </a>performances of static protected programs</text>
<text top="833" left="459" width="66" height="14" font="4">are 1.2–1.8</text>
<text top="829" left="525" width="291" height="19" font="3">× normalized performance of original programs.</text>
<text top="852" left="459" width="357" height="14" font="4">However, performances of dynamic protected programs are</text>
<text top="870" left="459" width="95" height="14" font="4">far more than 2</text>
<text top="867" left="554" width="262" height="19" font="3">× normalized performance of original pro-</text>
<text top="889" left="459" width="357" height="14" font="4">grams. As we have mentioned that valgrind is a heavyweight</text>
<text top="908" left="459" width="357" height="14" font="4">dynamic instrumentation tool and dynamic binary instru-</text>
<text top="927" left="459" width="357" height="14" font="4">mentation happens during the execution of programs, so</text>
<text top="946" left="459" width="357" height="14" font="4">the dynamic instrumentation codes take much more perfor-</text>
<text top="965" left="459" width="43" height="14" font="4">mance.</text>
<text top="984" left="477" width="339" height="14" font="4">Under the condition of fault injection, we run those</text>
<text top="1003" left="459" width="357" height="14" font="4">benchmarks directly on platforms with the ﬁxed input set.</text>
<text top="1022" left="459" width="357" height="14" font="4">Additionally, we run those benchmarks under our tool soft-</text>
<text top="1041" left="459" width="357" height="14" font="4">error and platforms with the condition of fault injection.</text>
<text top="1059" left="459" width="357" height="14" font="4">Compared the results of these executions with original ex-</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1186" width="892">
<text top="50" left="735" width="81" height="12" font="0">Cluster Comput</text>
<text top="79" left="76" width="397" height="12" font="9"><b>Table 1 </b>Performance of benchmarks directly on platforms and under out tool</text>
<text top="108" left="76" width="64" height="12" font="0">Benchmarks</text>
<text top="108" left="245" width="89" height="12" font="0">Original program</text>
<text top="123" left="245" width="104" height="12" font="0">(normalized original</text>
<text top="138" left="245" width="47" height="12" font="0">program)</text>
<text top="108" left="456" width="126" height="12" font="0">Static protected program</text>
<text top="123" left="456" width="104" height="12" font="0">(normalized original</text>
<text top="138" left="456" width="47" height="12" font="0">program)</text>
<text top="108" left="689" width="97" height="12" font="0">Dynamic protected</text>
<text top="123" left="689" width="108" height="12" font="0">program (normalized</text>
<text top="138" left="689" width="90" height="12" font="0">original program)</text>
<text top="171" left="76" width="21" height="12" font="0">Mcf</text>
<text top="171" left="245" width="6" height="12" font="0">1</text>
<text top="171" left="456" width="16" height="12" font="0">1.2</text>
<text top="171" left="695" width="6" height="12" font="0">8</text>
<text top="191" left="76" width="25" height="12" font="0">Gzip</text>
<text top="191" left="245" width="6" height="12" font="0">1</text>
<text top="191" left="456" width="16" height="12" font="0">1.6</text>
<text top="191" left="689" width="13" height="12" font="0">15</text>
<text top="210" left="76" width="32" height="12" font="0">Parser</text>
<text top="210" left="245" width="6" height="12" font="0">1</text>
<text top="210" left="456" width="22" height="12" font="0">1.72</text>
<text top="210" left="689" width="13" height="12" font="0">18</text>
<text top="229" left="76" width="32" height="12" font="0">vortex</text>
<text top="229" left="245" width="6" height="12" font="0">1</text>
<text top="229" left="456" width="16" height="12" font="0">1.8</text>
<text top="229" left="689" width="13" height="12" font="0">39</text>
<text top="556" left="76" width="357" height="12" font="9"><b>Fig. 3 </b>Reliability of benchmarks with original program, static pro-</text>
<text top="571" left="76" width="242" height="12" font="0">tected program and dynamic protected program</text>
<text top="613" left="76" width="357" height="14" font="4">ecution results which are under no fault injection, the relia-</text>
<text top="632" left="76" width="215" height="14" font="4">bility of these executions are as Fig.</text>
<text top="632" left="295" width="7" height="14" font="8"><a href="pdfxml.html#4">1</a></text>
<text top="632" left="306" width="41" height="14" font="4">shows.</text>
<text top="651" left="94" width="42" height="14" font="4">In Fig.</text>
<text top="651" left="142" width="7" height="14" font="8"><a href="pdfxml.html#6">3</a></text>
<text top="651" left="149" width="284" height="14" font="4">, we also add the reliability of static program</text>
<text top="669" left="76" width="226" height="14" font="4">protection method SWIFT. From Fig.</text>
<text top="669" left="307" width="7" height="14" font="8"><a href="pdfxml.html#6">3</a></text>
<text top="669" left="318" width="115" height="14" font="4">we can see that the</text>
<text top="688" left="76" width="357" height="14" font="4">reliability of dynamic protected program is higher than the</text>
<text top="706" left="76" width="357" height="14" font="4">reliability of static protected program. The experimental re-</text>
<text top="725" left="76" width="357" height="14" font="4">sults demonstrate our analyses which are mentioned above.</text>
<text top="744" left="76" width="357" height="14" font="4">Theoretically, the method of dynamic protection to program</text>
<text top="762" left="76" width="357" height="14" font="4">can protect more types of codes, so the method can reach a</text>
<text top="781" left="76" width="357" height="14" font="4">higher reliability. The blind point of dynamic protection to</text>
<text top="799" left="76" width="357" height="14" font="4">program is that those codes and data which are in core space</text>
<text top="818" left="76" width="357" height="14" font="4">can not be protected. For example, system call can not be</text>
<text top="836" left="76" width="357" height="14" font="4">protected with dynamic protection method. This blind point</text>
<text top="855" left="76" width="357" height="14" font="4">is shown in our experimental results that the outcomes of dy-</text>
<text top="874" left="76" width="357" height="14" font="4">namic protected programs are not correct all the time. From</text>
<text top="892" left="76" width="24" height="14" font="4">Fig.</text>
<text top="892" left="103" width="7" height="14" font="8"><a href="pdfxml.html#6">3</a></text>
<text top="892" left="110" width="323" height="14" font="4">, we also can see that the reliability of original program</text>
<text top="911" left="76" width="357" height="14" font="4">is also considerable. The experimental results also show that</text>
<text top="929" left="76" width="357" height="14" font="4">most injected faults are masked in our experiments. The rea-</text>
<text top="948" left="76" width="357" height="14" font="4">son for these experimental results is that those faults are in-</text>
<text top="967" left="76" width="357" height="14" font="4">jected with static method. For a static program, there are</text>
<text top="985" left="76" width="357" height="14" font="4">many cases which can mask faults in dynamic codes, such</text>
<text top="1004" left="76" width="164" height="14" font="4">as dynamically dead codes.</text>
<text top="1022" left="94" width="339" height="14" font="4">We compare our tool with Spot which is also a dynamic</text>
<text top="1041" left="76" width="139" height="14" font="4">binary translation tool [</text>
<text top="1041" left="216" width="15" height="14" font="8"><a href="pdfxml.html#7">10</a></text>
<text top="1041" left="231" width="203" height="14" font="4"><a href="pdfxml.html#7">]. </a>Spot which is based on dynamic</text>
<text top="1059" left="76" width="357" height="14" font="4">binary instrumentation tool pin is a lightweight DBI tool. In</text>
<text top="290" left="459" width="357" height="14" font="4">these experiments, we also use normalized performance to</text>
<text top="308" left="459" width="357" height="14" font="4">original program to compare the two tools. Our mentioned</text>
<text top="327" left="459" width="357" height="14" font="4">reliability measure is useful in our above evaluation of situ-</text>
<text top="346" left="459" width="357" height="14" font="4">ations, but they cannot be used as easily to compare systems</text>
<text top="365" left="459" width="357" height="14" font="4">in which both reliability and performance differ. For exam-</text>
<text top="384" left="459" width="357" height="14" font="4">ple, if a system reduces the SDC (Silent Data Corruption)</text>
<text top="402" left="459" width="342" height="14" font="4">failure rate by 1/2 while increasing execution time by 4</text>
<text top="399" left="800" width="16" height="19" font="3">×,</text>
<text top="421" left="459" width="357" height="14" font="4">the original system will be able to accomplish more work</text>
<text top="440" left="459" width="357" height="14" font="4">between SDC failures. Mean Work To Failure (MWTF) is a</text>
<text top="459" left="459" width="357" height="14" font="4">metric which takes into account both the reliability and the</text>
<text top="477" left="459" width="357" height="14" font="4">performance to give a more meaningful comparison in these</text>
<text top="496" left="459" width="357" height="14" font="4">cases. We take MWTF which is also Mean Work To SDC as</text>
<text top="515" left="459" width="357" height="14" font="4">the measure to compare the reliability of the two tools. The</text>
<text top="534" left="459" width="357" height="14" font="4">normalized performance to original program of benchmarks</text>
<text top="553" left="459" width="357" height="14" font="4">and normalized mean work to SDC under these two tools</text>
<text top="571" left="459" width="62" height="14" font="4">are as Fig.</text>
<text top="571" left="524" width="7" height="14" font="8"><a href="pdfxml.html#7">4</a></text>
<text top="571" left="536" width="41" height="14" font="4">shows.</text>
<text top="590" left="477" width="61" height="14" font="4">From Fig.</text>
<text top="590" left="543" width="7" height="14" font="8"><a href="pdfxml.html#7">4</a></text>
<text top="590" left="555" width="261" height="14" font="4">we can see that the performance of bench-</text>
<text top="609" left="459" width="357" height="14" font="4">marks under our tool is much more than under the tool Spot.</text>
<text top="628" left="459" width="357" height="14" font="4">Our tool is implemented on the basis of valgrind which is</text>
<text top="646" left="459" width="357" height="14" font="4">a heavyweight dynamic binary instrumentation tool. On the</text>
<text top="665" left="459" width="357" height="14" font="4">other hand, Spot is implemented on the basis of pin which</text>
<text top="684" left="459" width="357" height="14" font="4">is a lightweight DBI tool. Valgrind framework use shadow</text>
<text top="703" left="459" width="357" height="14" font="4">operation to instrument codes into the original codes, and</text>
<text top="722" left="459" width="357" height="14" font="4">sometimes those instrumented codes are more than those</text>
<text top="740" left="459" width="357" height="14" font="4">original codes. But pin framework only use just-in-time to</text>
<text top="759" left="459" width="357" height="14" font="4">dynamically compile those original codes to instrumented</text>
<text top="778" left="459" width="357" height="14" font="4">codes. So our tool sacriﬁces more performance than Spot.</text>
<text top="797" left="459" width="60" height="14" font="4">From Fig.</text>
<text top="797" left="524" width="7" height="14" font="8"><a href="pdfxml.html#7">4</a></text>
<text top="797" left="535" width="281" height="14" font="4">we also can see that normalized mean work to</text>
<text top="815" left="459" width="357" height="14" font="4">SDC of benchmarks with tool Spot are higher than those</text>
<text top="834" left="459" width="357" height="14" font="4">normalized mean work to SDC of benchmarks with our tool</text>
<text top="853" left="459" width="357" height="14" font="4">softerror. See above, performances of benchmarks with our</text>
<text top="872" left="459" width="357" height="14" font="4">tool are lower than performances of benchmarks with the</text>
<text top="890" left="459" width="357" height="14" font="4">tool Spot. However, reliabilities of benchmarks with our tool</text>
<text top="909" left="459" width="357" height="14" font="4">are also higher than reliabilities of benchmarks with the tool</text>
<text top="928" left="459" width="357" height="14" font="4">Spot. Synthesizing these two factors, normalized mean work</text>
<text top="947" left="459" width="357" height="14" font="4">to SDC of benchmarks with tool Spot are higher than those</text>
<text top="966" left="459" width="357" height="14" font="4">normalized mean work to SDC of benchmarks with our tool</text>
<text top="984" left="459" width="54" height="14" font="4">softerror.</text>
<text top="1003" left="477" width="339" height="14" font="4">From our experimental results, we can see that our ap-</text>
<text top="1022" left="459" width="357" height="14" font="4">proach is only suitable for those systems which have strict</text>
<text top="1041" left="459" width="357" height="14" font="4">reliability requirement. On the other hand, different parts</text>
<text top="1059" left="459" width="357" height="14" font="4">of dynamic codes may behave differently under the effects</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1186" width="892">
<text top="50" left="76" width="81" height="12" font="0">Cluster Comput</text>
<text top="679" left="76" width="357" height="12" font="9"><b>Fig. 4 </b>Normalized performance and normalized mean work to SDC</text>
<text top="694" left="76" width="180" height="12" font="0">of benchmarks with these two tools</text>
<text top="733" left="76" width="357" height="14" font="4">of soft errors. Based on the different behaviors of different</text>
<text top="751" left="76" width="357" height="14" font="4">parts of dynamic codes, optimization of our approach whose</text>
<text top="770" left="76" width="357" height="14" font="4">purpose is to improve our system performance is our future</text>
<text top="788" left="76" width="34" height="14" font="4">work.</text>
<text top="841" left="76" width="86" height="14" font="2"><b>5 Conclusion</b></text>
<text top="875" left="76" width="357" height="14" font="4">Soft error which is a kind intermittent fault on hardware is</text>
<text top="894" left="76" width="357" height="14" font="4">a serious threat to system reliability with the improvement</text>
<text top="912" left="76" width="357" height="14" font="4">of fabrication technology. Software-based method to toler-</text>
<text top="931" left="76" width="357" height="14" font="4">ate soft errors is regarded as an efﬁcient method compared</text>
<text top="949" left="76" width="357" height="14" font="4">with hardware-based method which needs additional hard-</text>
<text top="967" left="76" width="357" height="14" font="4">ware. Dynamic implementation to software-based method</text>
<text top="986" left="76" width="357" height="14" font="4">can protect more codes in program. Therefore, dynamic im-</text>
<text top="1004" left="76" width="357" height="14" font="4">plementation to software-based method can cover more soft</text>
<text top="1023" left="76" width="39" height="14" font="4">errors.</text>
<text top="1041" left="94" width="339" height="14" font="4">This paper explores soft error tolerance during the dy-</text>
<text top="1059" left="76" width="357" height="14" font="4">namic program. We propose a dynamic software-based ap-</text>
<text top="84" left="459" width="357" height="14" font="4">proach to tolerate soft errors. In our approach, those pro-</text>
<text top="102" left="459" width="357" height="14" font="4">tected objective is dynamic binary codes. Our approach</text>
<text top="121" left="459" width="357" height="14" font="4">makes sure right control ﬂow and right data ﬂow to signiﬁ-</text>
<text top="139" left="459" width="357" height="14" font="4">cant extent for these dynamic codes. For control ﬂow protec-</text>
<text top="158" left="459" width="357" height="14" font="4">tion, we only protect those branch instructions to make sure</text>
<text top="176" left="459" width="357" height="14" font="4">its right jump. We ignore other control ﬂow errors because</text>
<text top="194" left="459" width="357" height="14" font="4">those control ﬂow errors can be caught by dynamic program</text>
<text top="213" left="459" width="357" height="14" font="4">based on our analyses and fault injection experiments. For</text>
<text top="231" left="459" width="357" height="14" font="4">data ﬂow protection, we copy every data and operate every</text>
<text top="250" left="459" width="357" height="14" font="4">operation twice to ensure those data stored into memory are</text>
<text top="268" left="459" width="357" height="14" font="4">correct. Our approach is implemented on the basis of val-</text>
<text top="287" left="459" width="357" height="14" font="4">grind which is a heavyweight dynamic binary instrumenta-</text>
<text top="305" left="459" width="357" height="14" font="4">tion framework. In our experiment, those benchmarks which</text>
<text top="324" left="459" width="357" height="14" font="4">are chosen run under our tool and platforms. Experimental</text>
<text top="342" left="459" width="357" height="14" font="4">results demonstrate that dynamic protection to program can</text>
<text top="360" left="459" width="357" height="14" font="4">reach higher system reliability than the traditional static pro-</text>
<text top="379" left="459" width="357" height="14" font="4">gram protection method. However, from our analyses and</text>
<text top="397" left="459" width="357" height="14" font="4">experimental results, dynamic tolerance approach also sac-</text>
<text top="416" left="459" width="357" height="14" font="4">riﬁces more performance compared with static soft error tol-</text>
<text top="434" left="459" width="357" height="14" font="4">erance approach. Therefore, our approach only can apply</text>
<text top="453" left="459" width="357" height="14" font="4">those systems which have strict reliability requirement. The</text>
<text top="471" left="459" width="357" height="14" font="4">optimization of our approach whose purpose is to improve</text>
<text top="489" left="459" width="236" height="14" font="4">system performance is our future work.</text>
<text top="543" left="459" width="69" height="14" font="2"><b>References</b></text>
<text top="575" left="465" width="351" height="12" font="0">1. Mahmood, A., McCluskey, E.J.: Concurrent error detection using</text>
<text top="590" left="482" width="334" height="12" font="0">watchdog processors a survey. IEEE Trans. Comput. <b>37</b>(2), 160–</text>
<text top="605" left="482" width="56" height="12" font="0">174 (1988)</text>
<text top="619" left="465" width="351" height="12" font="0">2. Austin, T.M.: DIVA: a reliable substrate for deep submicron mi-</text>
<text top="634" left="482" width="334" height="12" font="0">croarchitecture design. In: 32nd Annual International Symposium</text>
<text top="649" left="482" width="267" height="12" font="0">on Microarchitecture (MICRO), pp. 196–207 (1999)</text>
<text top="664" left="465" width="351" height="12" font="0">3. Reinhardt, S.K., et al.: Transient fault detection via simultaneous</text>
<text top="678" left="482" width="334" height="12" font="0">multithreading. In: Proceedings of the 27th Annual International</text>
<text top="693" left="482" width="291" height="12" font="0">Symposium on Computer Architecture, pp. 25–36 (2000)</text>
<text top="708" left="465" width="351" height="12" font="0">4. Reis, G.A., Chang, J., Vachharajani, N., et al.: SWIFT: software-</text>
<text top="723" left="482" width="334" height="12" font="0">implemented fault tolerance. In: Proceedings of the 3rd In-</text>
<text top="737" left="482" width="334" height="12" font="0">ternational Symposium on Code Generation and Optimization,</text>
<text top="752" left="482" width="132" height="12" font="0">pp. 243–254, March 2005</text>
<text top="767" left="465" width="351" height="12" font="0">5. Oh, N., Shirvani, P.P., McCluskey, E.J.: Error detection by dupli-</text>
<text top="782" left="482" width="334" height="12" font="0">cated instructions in super-scalar processors. IEEE Trans. Reliab.</text>
<text top="797" left="482" width="103" height="12" font="9"><b>51</b>(1), 63–75 (2002)</text>
<text top="811" left="465" width="351" height="12" font="0">6. Oh, N., Shirvani, P.P., McCluskey, E.J.: ED4I: error detection by</text>
<text top="826" left="482" width="334" height="12" font="0">diverse data and duplicated instructions. In: IEEE Transactions on</text>
<text top="841" left="482" width="163" height="12" font="0">Computers, pp. 180–199 (2002)</text>
<text top="855" left="465" width="351" height="12" font="0">7. Reis, G.A., Chang, J., Vachharajani, N., et al.: Software-controlled</text>
<text top="870" left="482" width="334" height="12" font="0">fault tolerance. ACM Trans. Archit. Code Optim. <b>V</b>(N), 1–28</text>
<text top="885" left="482" width="34" height="12" font="0">(2005)</text>
<text top="899" left="465" width="351" height="12" font="0">8. Reis, G.A.: Software modulated fault tolerance. A dissertation pre-</text>
<text top="914" left="482" width="261" height="12" font="0">sented to the faculty of Princeton University (2008)</text>
<text top="929" left="465" width="351" height="12" font="0">9. Borin, E., Wang, C., Wu, Y., Araujo, G.: Software-based trans-</text>
<text top="943" left="482" width="334" height="12" font="0">parent and comprehensive control-ﬂow error detection. In: In-</text>
<text top="958" left="482" width="334" height="12" font="0">ternational Symposium on Code Generation and Optimization,</text>
<text top="973" left="482" width="101" height="12" font="0">pp. 333–345 (2006)</text>
<text top="988" left="459" width="357" height="12" font="0">10. Reis, G.A., Chang, J., August, D.I.: Conﬁgurable transient fault</text>
<text top="1003" left="482" width="334" height="12" font="0">detection via dynamic binary translation. In: Proceedings of the</text>
<text top="1017" left="482" width="304" height="12" font="0">2nd Workshop on Architectural Reliability, December 2006</text>
<text top="1032" left="459" width="357" height="12" font="0">11. Luk, C.-K., Cohn, R., Muth, R., Patil, H., et al.: Pin: building cus-</text>
<text top="1047" left="482" width="334" height="12" font="0">tomized program analysis tools with dynamic instrumentation. In:</text>
<text top="1062" left="482" width="264" height="12" font="0">Proceedings of PLDI 2005, pp. 191–200, June 2005</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1186" width="892">
<text top="50" left="735" width="81" height="12" font="0">Cluster Comput</text>
<text top="85" left="76" width="357" height="12" font="0">12. Rebaudengo, M., Reorda, M.S., Violante, M., Torchiano, M.:</text>
<text top="100" left="100" width="334" height="12" font="0">A source-to-source compiler for generating dependable software.</text>
<text top="115" left="100" width="334" height="12" font="0">In: IEEE International Workshop on Source Code Analysis and</text>
<text top="130" left="100" width="163" height="12" font="0">Manipulation, pp. 33–42 (2001)</text>
<text top="145" left="76" width="357" height="12" font="0">13. Nethercote, N.: Dynamic Binary Analysis and Instrumentation.</text>
<text top="160" left="100" width="226" height="12" font="0">University of Cambridge, Cambridge (2004)</text>
<text top="175" left="76" width="357" height="12" font="0">14. Seward, J., Nethercote, N.: Using Valgrind to detect undeﬁned</text>
<text top="190" left="100" width="334" height="12" font="0">value errors with bit-precision. In: Proceedings of the USENIX</text>
<text top="205" left="100" width="229" height="12" font="0">05 Annual Technical Conference, April 2005</text>
<text top="220" left="76" width="16" height="12" font="0">15.</text>
<text top="220" left="100" width="92" height="12" font="7"><a href="http://www.valgrind.org">www.valgrind.org</a></text>
<text top="220" left="195" width="34" height="12" font="0">(2012)</text>
<text top="235" left="76" width="357" height="12" font="0">16. Nethercote, N., Seward, J.: Valgrind: a framework for heavy-</text>
<text top="250" left="100" width="334" height="12" font="0">weight dynamic binary instrumentation. In: Proceedings of PLDI</text>
<text top="265" left="100" width="153" height="12" font="0">2007, pp. 191–200, June 2007</text>
<text top="280" left="76" width="357" height="12" font="0">17. Li, X.: Soft error modeling and analysis for microprocessors.</text>
<text top="295" left="100" width="334" height="12" font="0">A dissertation presented to computer science in the graduate col-</text>
<text top="310" left="100" width="200" height="12" font="0">lege of the University of Illinois (2008)</text>
<text top="353" left="251" width="182" height="12" font="9"><b>Lei Xiong </b>received his PhD degree</text>
<text top="367" left="251" width="182" height="12" font="0">in National University of Defense</text>
<text top="382" left="251" width="182" height="12" font="0">Technology in China. His current</text>
<text top="397" left="251" width="182" height="12" font="0">research interests include tolerance</text>
<text top="412" left="251" width="182" height="12" font="0">computing, program analysis and</text>
<text top="427" left="251" width="110" height="12" font="0">software engineering.</text>
<text top="84" left="634" width="182" height="12" font="9"><b>Qingping Tan </b>received his PhD de-</text>
<text top="99" left="634" width="182" height="12" font="0">gree in National University of De-</text>
<text top="114" left="634" width="182" height="12" font="0">fense Technology in China. He is</text>
<text top="129" left="634" width="182" height="12" font="0">a professor and a PhD supervisor</text>
<text top="144" left="634" width="182" height="12" font="0">in National University of Defense</text>
<text top="158" left="634" width="182" height="12" font="0">Technology. His main research in-</text>
<text top="173" left="634" width="182" height="12" font="0">terests include distribute software</text>
<text top="188" left="634" width="182" height="12" font="0">engineering and high dependable</text>
<text top="203" left="634" width="47" height="12" font="0">software.</text>
</page>
</pdf2xml>
