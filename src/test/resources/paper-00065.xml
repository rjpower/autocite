<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="18" family="Times" color="#000000"/>
	<fontspec id="1" size="14" family="Times" color="#000000"/>
	<fontspec id="2" size="11" family="Times" color="#000000"/>
	<fontspec id="3" size="10" family="Times" color="#000000"/>
	<fontspec id="4" size="11" family="Times" color="#000000"/>
	<fontspec id="5" size="11" family="Times" color="#000000"/>
	<fontspec id="6" size="14" family="Times" color="#000000"/>
	<fontspec id="7" size="8" family="Times" color="#000000"/>
<text top="118" left="376" width="164" height="19" font="0"><b>Execution Mining</b></text>
<text top="175" left="216" width="122" height="16" font="1">Geoffrey Lefebvre</text>
<text top="175" left="362" width="96" height="16" font="1">Brendan Cully</text>
<text top="175" left="482" width="117" height="16" font="1">Christopher Head</text>
<text top="175" left="622" width="77" height="16" font="1">Mark Spear</text>
<text top="194" left="289" width="119" height="16" font="1">Norm Hutchinson</text>
<text top="194" left="431" width="83" height="16" font="1">Mike Feeley</text>
<text top="194" left="537" width="113" height="16" font="1">Andrew Warﬁeld</text>
<text top="219" left="280" width="354" height="13" font="2">Department of Computer Science, University of British Columbia</text>
<text top="236" left="277" width="7" height="13" font="2">{</text>
<text top="237" left="284" width="284" height="12" font="3">geoffrey, brendan, chead, mspear, norm, feeley, andy</text>
<text top="236" left="568" width="7" height="13" font="2">}</text>
<text top="237" left="575" width="63" height="12" font="3">@cs.ubc.ca</text>
<text top="324" left="81" width="50" height="12" font="4"><b>Abstract</b></text>
<text top="346" left="81" width="359" height="13" font="2">Operating systems represent large pieces of complex software that</text>
<text top="361" left="81" width="358" height="13" font="2">are carefully tested and broadly deployed. Despite this, develop-</text>
<text top="376" left="81" width="358" height="13" font="2">ers frequently have little more than their source code to understand</text>
<text top="391" left="81" width="359" height="13" font="2">how they behave. This static representation of a system results in</text>
<text top="405" left="81" width="359" height="13" font="2">limited insight into execution dynamics, such as what code is im-</text>
<text top="420" left="81" width="359" height="13" font="2">portant, how data ﬂows through a system, or how threads inter-</text>
<text top="435" left="81" width="359" height="13" font="2">act with one another. We describe Tralfamadore, a system that pre-</text>
<text top="450" left="81" width="359" height="13" font="2">serves complete traces of machine execution as an artifact that can</text>
<text top="465" left="81" width="359" height="13" font="2">be queried and analyzed with a library of simple, reusable opera-</text>
<text top="480" left="81" width="359" height="13" font="2">tors, making it easy to develop and run new dynamic analyses. We</text>
<text top="495" left="81" width="359" height="13" font="2">demonstrate the beneﬁts of this approach with several example ap-</text>
<text top="510" left="81" width="358" height="13" font="2">plications, including a novel uniﬁed source and execution browser.</text>
<text top="533" left="81" width="202" height="12" font="4"><b>Categories and Subject Descriptors</b></text>
<text top="533" left="298" width="141" height="13" font="2">D.2.5 [<i>Software Engineer-</i></text>
<text top="548" left="81" width="17" height="12" font="5"><i>ing</i></text>
<text top="548" left="98" width="262" height="13" font="2">]: Testing and Debugging—Tracing, Diagnostics</text>
<text top="571" left="81" width="86" height="12" font="4"><b>General Terms</b></text>
<text top="571" left="181" width="258" height="13" font="2">Design, Experimentation, Measurement, Perfor-</text>
<text top="586" left="81" width="35" height="13" font="2">mance</text>
<text top="609" left="81" width="58" height="12" font="4"><b>Keywords</b></text>
<text top="609" left="154" width="286" height="13" font="2">Binary Analysis, Ofﬂine Analysis, Virtual Machine,</text>
<text top="624" left="81" width="76" height="13" font="2">Semantic Gap</text>
<text top="650" left="81" width="12" height="15" font="6"><b>1.</b></text>
<text top="650" left="110" width="89" height="15" font="6"><b>Introduction</b></text>
<text top="675" left="100" width="320" height="12" font="5"><i>“The creatures were friendly, and they could see in four</i></text>
<text top="690" left="100" width="320" height="12" font="5"><i>dimensions. They pitied Earthlings for being able to see only</i></text>
<text top="705" left="100" width="320" height="12" font="5"><i>three. They had many wonderful things to teach Earthlings</i></text>
<text top="719" left="100" width="66" height="12" font="5"><i>about time.”</i></text>
<text top="738" left="100" width="320" height="13" font="2">–A description of the Tralfamadorians from Kurt Von-</text>
<text top="753" left="100" width="189" height="13" font="2">negut’s “Slaughterhouse Five” [35]</text>
<text top="781" left="99" width="341" height="13" font="2">Execution is ﬂeeting. As each moment of execution is lost</text>
<text top="796" left="81" width="359" height="13" font="2">to the past, an important opportunity to understand a system’s</text>
<text top="811" left="81" width="359" height="13" font="2">behavior may be lost as well. In addition to the complexity that is</text>
<text top="826" left="81" width="358" height="13" font="2">inherent in operating system code, developers are often hamstrung</text>
<text top="841" left="81" width="359" height="13" font="2">by a lack of useful tools to assist in understanding how source</text>
<text top="856" left="81" width="359" height="13" font="2">behaves in practice. Where tools such as debuggers, proﬁlers and</text>
<text top="871" left="81" width="359" height="13" font="2">leak detectors are available at all, they operate on only a glimpse of</text>
<text top="886" left="81" width="359" height="13" font="2">execution, either as a point in time or as a predetermined summary.</text>
<text top="901" left="81" width="359" height="13" font="2">These tools are “stuck in time”, and must anticipate or recreate any</text>
<text top="916" left="81" width="359" height="13" font="2">execution scenario they seek to examine. Execution behavior that</text>
<text top="931" left="81" width="296" height="13" font="2">is not anticipated before it occurs can not be examined.</text>
<text top="1001" left="81" width="359" height="10" font="7">Permission to make digital or hard copies of all or part of this work for personal or</text>
<text top="1013" left="81" width="359" height="10" font="7">classroom use is granted without fee provided that copies are not made or distributed</text>
<text top="1025" left="81" width="359" height="10" font="7">for proﬁt or commercial advantage and that copies bear this notice and the full citation</text>
<text top="1037" left="81" width="359" height="10" font="7">on the ﬁrst page. To copy otherwise, to republish, to post on servers or to redistribute</text>
<text top="1049" left="81" width="227" height="10" font="7">to lists, requires prior speciﬁc permission and/or a fee.</text>
<text top="1063" left="81" width="37" height="10" font="7">VEE’12,</text>
<text top="1064" left="129" width="173" height="10" font="7">March 3–4, 2012, London, England, UK.</text>
<text top="1075" left="81" width="258" height="10" font="7">Copyright c 2012 ACM 978-1-4503-1175-5/12/03. . . $10.00</text>
<text top="324" left="493" width="341" height="13" font="2">The lack of insight into how an operating system actually be-</text>
<text top="339" left="476" width="358" height="13" font="2">haves when it runs presents a major challenge to both novice and</text>
<text top="354" left="476" width="358" height="13" font="2">experienced developers: code bases for these systems are large, and</text>
<text top="369" left="476" width="359" height="13" font="2">control ﬂow through a system – whether it has to do with servic-</text>
<text top="384" left="476" width="358" height="13" font="2">ing a system call or delivering a received packet to the appropriate</text>
<text top="398" left="476" width="359" height="13" font="2">application – frequently spans large numbers of source ﬁles and is</text>
<text top="413" left="476" width="358" height="13" font="2">indirected through function pointers and across multiple execution</text>
<text top="428" left="476" width="359" height="13" font="2">contexts. A view of program source alone does not provide an intu-</text>
<text top="443" left="476" width="358" height="13" font="2">ition for where common execution paths are, which regions of code</text>
<text top="458" left="476" width="358" height="13" font="2">are particularly performance sensitive, or how data structures such</text>
<text top="473" left="476" width="288" height="13" font="2">as packets or block requests move across subsystems.</text>
<text top="488" left="493" width="341" height="13" font="2">In this paper, we explore the idea that detailed, CPU-level traces</text>
<text top="503" left="476" width="359" height="13" font="2">of system execution can usefully enable analysis on execution as</text>
<text top="518" left="476" width="359" height="13" font="2">a whole, as opposed to execution in the moment. Rather than</text>
<text top="533" left="476" width="358" height="13" font="2">considering dynamic analysis as a “one-off” task that is performed</text>
<text top="548" left="476" width="359" height="13" font="2">against a running system, we propose performing repeated analysis</text>
<text top="563" left="476" width="358" height="13" font="2">against a persistent trace instance that may be kept and analyzed</text>
<text top="578" left="476" width="262" height="13" font="2">over a long period of time and by multiple users.</text>
<text top="593" left="493" width="341" height="13" font="2">We describe the design and implementation of <i>Tralfamadore</i>,</text>
<text top="608" left="476" width="359" height="13" font="2">an ofﬂine dynamic analysis tool that borrows ideas from stream-</text>
<text top="623" left="476" width="359" height="13" font="2">ing databases [30] to treat a single execution trace as a shared re-</text>
<text top="638" left="476" width="359" height="13" font="2">source that may be used by a community of developers to under-</text>
<text top="652" left="476" width="358" height="13" font="2">stand program behaviour. Tralfamadore explores the opportunities</text>
<text top="667" left="476" width="359" height="13" font="2">that exist where large reference executions, such as regression test</text>
<text top="682" left="476" width="359" height="13" font="2">suites or samples of production execution environments, are treated</text>
<text top="697" left="476" width="359" height="13" font="2">as archival recordings. Our system provides tools to map the low-</text>
<text top="712" left="476" width="359" height="13" font="2">level details of these recordings up to the source-level semantics</text>
<text top="727" left="476" width="359" height="13" font="2">used by developers. This approach allows the cost of analysis to be</text>
<text top="742" left="476" width="359" height="13" font="2">amortized over many users and related queries, making consider-</text>
<text top="757" left="476" width="253" height="13" font="2">ably more complex forms of analysis practical.</text>
<text top="772" left="493" width="341" height="13" font="2">In this manner, Tralfamadore allows developers to better under-</text>
<text top="787" left="476" width="359" height="13" font="2">stand the execution dynamics of the software they are working on:</text>
<text top="802" left="476" width="359" height="13" font="2">they may explore sweeping queries, like “<i>show me a histogram of</i></text>
<text top="817" left="476" width="230" height="12" font="5"><i>all parameters ever passed to this function,</i></text>
<text top="817" left="706" width="128" height="13" font="2">” “<i>summarize all execu-</i></text>
<text top="832" left="476" width="271" height="12" font="5"><i>tion stacks that have ever invoked this line of code,</i></text>
<text top="832" left="746" width="88" height="13" font="2">” or “<i>summarize</i></text>
<text top="847" left="476" width="353" height="12" font="5"><i>the path through the kernel taken by all received UDP packets,</i></text>
<text top="847" left="828" width="6" height="13" font="2">”</text>
<text top="862" left="476" width="359" height="13" font="2">in order to quickly get a sense of how complex system code be-</text>
<text top="877" left="476" width="359" height="13" font="2">haves. Furthermore, as the analyses performed by the system are</text>
<text top="892" left="476" width="359" height="13" font="2">based on the composition of an extensible set of analysis operators,</text>
<text top="907" left="476" width="359" height="13" font="2">we demonstrate how new analyses can be written, often without</text>
<text top="922" left="476" width="359" height="13" font="2">requiring a low-level understanding of the nuances of a speciﬁc ar-</text>
<text top="936" left="476" width="150" height="13" font="2">chitecture or instruction set.</text>
<text top="951" left="493" width="341" height="13" font="2">Our work can be viewed as an extension of recent results that</text>
<text top="966" left="476" width="359" height="13" font="2">decouple dynamic analysis from live execution [10, 27]. However,</text>
<text top="981" left="476" width="359" height="13" font="2">rather than simply running traditional analysis against a system</text>
<text top="996" left="476" width="358" height="13" font="2">recording, we explore the broader set of analyses that are possible</text>
<text top="1011" left="476" width="359" height="13" font="2">across the entirety of an execution trace, and tackle some of the</text>
<text top="1026" left="476" width="359" height="13" font="2">consequent challenges, such as indexing execution for efﬁcient</text>
<text top="1041" left="476" width="359" height="13" font="2">query evaluation. Tralfamadore allows the developer to engage in</text>
<text top="1056" left="476" width="359" height="13" font="2">a dialogue with a system’s execution, bridging the gap between the</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="8" size="9" family="Times" color="#000000"/>
	<fontspec id="9" size="6" family="Times" color="#000000"/>
<text top="111" left="81" width="48" height="12" font="5"><i>intention</i></text>
<text top="110" left="132" width="307" height="13" font="2">expressed in the source code and the <i>experience </i>of actual</text>
<text top="125" left="81" width="55" height="13" font="2">execution.</text>
<text top="152" left="81" width="12" height="15" font="6"><b>2.</b></text>
<text top="152" left="110" width="40" height="15" font="6"><b>Goals</b></text>
<text top="176" left="81" width="359" height="13" font="2">Tralfamadore aims to allow developers to understand large, com-</text>
<text top="191" left="81" width="359" height="13" font="2">plicated code bases that are difﬁcult to analyze with existing tools.</text>
<text top="206" left="81" width="334" height="13" font="2">This problem produced four speciﬁc design goals for our tool:</text>
<text top="230" left="81" width="17" height="12" font="4"><b>2.1</b></text>
<text top="230" left="111" width="173" height="12" font="4"><b>Treat Execution as an Artifact</b></text>
<text top="252" left="81" width="359" height="13" font="2">Traditional dynamic analysis frameworks such as Pin [20] or Val-</text>
<text top="267" left="81" width="359" height="13" font="2">grind [24] are <i>online </i>tools, meaning that they analyze a program as</text>
<text top="282" left="81" width="359" height="13" font="2">it executes. In Tralfamadore, the execution of the system being an-</text>
<text top="297" left="81" width="359" height="13" font="2">alyzed is ﬁrst recorded and stored persistently, and all analyses are</text>
<text top="312" left="81" width="358" height="13" font="2">performed afterwards on this static data set. Tralfamadore analyzes</text>
<text top="326" left="81" width="332" height="13" font="2">executions as opposed to analyzing programs as they execute.</text>
<text top="341" left="99" width="341" height="13" font="2">Running dynamic analyses against a static data set has multi-</text>
<text top="356" left="81" width="359" height="13" font="2">ple advantages, such as enabling new analyses not foreseen at the</text>
<text top="371" left="81" width="359" height="13" font="2">time of recording. This approach allows for repeated analysis over</text>
<text top="386" left="81" width="359" height="13" font="2">the same execution, providing consistency between each run, an</text>
<text top="401" left="81" width="359" height="13" font="2">important asset for developers using dynamic analysis in the cycli-</text>
<text top="416" left="81" width="358" height="13" font="2">cal process of understanding or debugging complex pieces of code</text>
<text top="431" left="81" width="359" height="13" font="2">such as an operating system kernel. Another advantage is that anal-</text>
<text top="446" left="81" width="359" height="13" font="2">yses are no longer “stuck in time” and can freely navigate execu-</text>
<text top="461" left="81" width="359" height="13" font="2">tion by arbitrarily going back in time or jumping ahead. Analyses</text>
<text top="476" left="81" width="358" height="13" font="2">themselves are also easier to debug; their deterministic behaviour</text>
<text top="491" left="81" width="359" height="13" font="2">simpliﬁes the task of validating whether an error in the analysis</text>
<text top="506" left="81" width="359" height="13" font="2">has been ﬁxed or not. An ofﬂine approach also helps alleviate the</text>
<text top="521" left="81" width="359" height="13" font="2">“observer” effect. Although recording may affect the behaviour of</text>
<text top="536" left="81" width="359" height="13" font="2">the system, once an interesting behaviour has been captured, this</text>
<text top="551" left="81" width="359" height="13" font="2">behaviour is guaranteed to manifest for all analyses however intru-</text>
<text top="566" left="81" width="93" height="13" font="2">sive they may be.</text>
<text top="590" left="81" width="17" height="12" font="4"><b>2.2</b></text>
<text top="590" left="111" width="185" height="12" font="4"><b>Support Whole-System Analysis</b></text>
<text top="611" left="81" width="359" height="13" font="2">A motivation of our system is to help developers understand be-</text>
<text top="626" left="81" width="359" height="13" font="2">havior that occurs at any layer of the software stack. In this paper</text>
<text top="641" left="81" width="359" height="13" font="2">we focus on kernel execution, but Tralfamadore is able to record</text>
<text top="656" left="81" width="359" height="13" font="2">the execution of entire systems. As the OS kernel is typically the</text>
<text top="671" left="81" width="359" height="13" font="2">most privileged, lowest-level software installed on a system, this</text>
<text top="686" left="81" width="213" height="13" font="2">goal leads to a number of requirements:</text>
<text top="701" left="99" width="341" height="13" font="2">First, the traces should be <i>comprehensive</i>, meaning that it</text>
<text top="716" left="81" width="359" height="13" font="2">should be possible to record the execution of an entire system,</text>
<text top="731" left="81" width="359" height="13" font="2">including the execution of its operating system kernel and of all</text>
<text top="746" left="81" width="359" height="13" font="2">its applications. Traces should be captured at the hardware level,</text>
<text top="761" left="81" width="359" height="13" font="2">underneath the operating system, to ensure a complete visibility of</text>
<text top="776" left="81" width="359" height="13" font="2">the system’s execution. In this paper we focus on kernel execution,</text>
<text top="791" left="81" width="355" height="13" font="2">but Tralfamadore is able to record the execution of entire systems.</text>
<text top="806" left="99" width="341" height="13" font="2">Second, to capture the execution of unmodiﬁed systems requires</text>
<text top="821" left="81" width="359" height="13" font="2">recording execution <i>transparently </i>without explicitly changing the</text>
<text top="836" left="81" width="359" height="13" font="2">target system. Further, being transparent requires Tralfamadore to</text>
<text top="850" left="81" width="359" height="13" font="2">handle dynamically generated and self-modifying code without the</text>
<text top="865" left="81" width="318" height="13" font="2">need to be explicitly notiﬁed by the system being recorded.</text>
<text top="880" left="99" width="340" height="13" font="2">Third, the information recorded should be <i>complete</i>, meaning</text>
<text top="895" left="81" width="358" height="13" font="2">that the recording should contain sufﬁcient information for analyses</text>
<text top="910" left="81" width="359" height="13" font="2">to inspect the register and memory state of the system at an instruc-</text>
<text top="925" left="81" width="359" height="13" font="2">tion granularity. Section 4.2 describes how Tralfamadore records</text>
<text top="940" left="81" width="359" height="13" font="2">execution and provides more details on how it meets these three</text>
<text top="955" left="81" width="73" height="13" font="2">requirements.</text>
<text top="979" left="81" width="17" height="12" font="4"><b>2.3</b></text>
<text top="979" left="111" width="144" height="12" font="4"><b>Bridge the Semantic Gap</b></text>
<text top="1001" left="81" width="359" height="13" font="2">Doing dynamic program analysis on an executing binary inherently</text>
<text top="1016" left="81" width="359" height="13" font="2">introduces a <i>semantic gap</i>. On one side, the CPU executes a stream</text>
<text top="1031" left="81" width="359" height="13" font="2">of instructions which update the state of the processor and mem-</text>
<text top="1046" left="81" width="359" height="13" font="2">ory, and on the other side, developers expect to be able to reason</text>
<text top="1061" left="81" width="359" height="13" font="2">about a running program at the level of source code. This seman-</text>
<text top="1076" left="81" width="359" height="13" font="2">tic gap makes developing new analyses challenging. An analysis</text>
<text top="109" left="476" width="216" height="10" font="8">int deliver skb(struct sk buff *skb,</text>
<text top="123" left="512" width="139" height="10" font="8">struct packet type *pt,</text>
<text top="136" left="512" width="139" height="10" font="8">struct net device *dev)</text>
<text top="149" left="476" width="6" height="12" font="8">{</text>
<text top="163" left="488" width="145" height="10" font="8">atomic inc(&amp;skb-&gt;users);</text>
<text top="177" left="488" width="244" height="10" font="8">return pt-&gt;func(skb, skb-&gt;dev, pt, dev);</text>
<text top="189" left="476" width="6" height="12" font="8">}</text>
<text top="239" left="476" width="52" height="12" font="4"><b>Figure 1.</b></text>
<text top="238" left="535" width="300" height="13" font="2">Packet delivery via type-speciﬁc function pointer from</text>
<text top="253" left="476" width="94" height="13" font="2">the protocol table</text>
<text top="294" left="476" width="358" height="13" font="2">writer needs to understand many low-level aspects of execution,</text>
<text top="310" left="476" width="359" height="13" font="2">such as how arguments are passed on function calls, or how mem-</text>
<text top="324" left="476" width="358" height="13" font="2">ory is allocated from the heap. This effort can be considerable, and</text>
<text top="339" left="476" width="359" height="13" font="2">requires domain expertise over the instruction set, application bi-</text>
<text top="354" left="476" width="359" height="13" font="2">nary interface (ABI), etc. This gap widens with operating system</text>
<text top="369" left="476" width="358" height="13" font="2">code, which does not provide standardized and stable programming</text>
<text top="384" left="476" width="274" height="13" font="2">interfaces such as POSIX or the C standard library.</text>
<text top="399" left="493" width="341" height="13" font="2">Unfortunately, existing dynamic analysis frameworks force</text>
<text top="414" left="476" width="359" height="13" font="2">analysis writers to constantly reinvent the wheel; low-level aspects</text>
<text top="429" left="476" width="358" height="13" font="2">of execution must be re-learned for every new analysis. A good</text>
<text top="444" left="476" width="359" height="13" font="2">example of this problem is Valgrind [24], which includes two dif-</text>
<text top="459" left="476" width="359" height="13" font="2">ferent race detectors, and to which engineers at Google recently</text>
<text top="475" left="476" width="98" height="13" font="2">added a third one.</text>
<text top="472" left="573" width="5" height="10" font="7">1</text>
<text top="475" left="583" width="251" height="13" font="2">Although all three detectors differ in the algo-</text>
<text top="490" left="476" width="358" height="13" font="2">rithm used to identify races, they each reimplement instrumentation</text>
<text top="504" left="476" width="358" height="13" font="2">to extract the same information (lock acquisition/release, accesses</text>
<text top="519" left="476" width="359" height="13" font="2">to heap memory). The required instrumentation is orthogonal to</text>
<text top="534" left="476" width="359" height="13" font="2">the analysis used and could be shared across implementations if</text>
<text top="549" left="476" width="166" height="13" font="2">Valgrind made it easy to do so.</text>
<text top="571" left="476" width="17" height="12" font="4"><b>2.4</b></text>
<text top="571" left="506" width="156" height="12" font="4"><b>Provide Interactive Results</b></text>
<text top="592" left="476" width="358" height="13" font="2">Finally, as the previous goals lead to a system that performs deep</text>
<text top="607" left="476" width="359" height="13" font="2">and complex analysis over large volumes of execution data there is</text>
<text top="622" left="476" width="359" height="13" font="2">a risk that analysis may take a long time to complete. Tralfama-</text>
<text top="637" left="476" width="359" height="13" font="2">dore aims to enable highly interactive exploration of trace data,</text>
<text top="652" left="476" width="359" height="13" font="2">and so we desire that the system provide interactive results so that</text>
<text top="667" left="476" width="359" height="13" font="2">developers can get answers as quickly as possible. To achieve this,</text>
<text top="682" left="476" width="359" height="13" font="2">Tralfamadore provides mechanisms to generate trace indices that</text>
<text top="697" left="476" width="359" height="13" font="2">subsequent analyses can use to only read the relevant portions of</text>
<text top="712" left="476" width="359" height="13" font="2">a trace. Many analyses end up reading a small fraction (&lt; 1%)</text>
<text top="727" left="476" width="359" height="13" font="2">of the trace. The Tralfamadore framework is based on a dataﬂow</text>
<text top="742" left="476" width="359" height="13" font="2">model that is well suited to produce results in an online manner.</text>
<text top="756" left="476" width="359" height="13" font="2">Analyses can return partial results as soon as they are available.</text>
<text top="771" left="476" width="358" height="13" font="2">This is advantageous for analyses that take a long time to complete</text>
<text top="786" left="476" width="359" height="13" font="2">because they need to read a substantial fraction of the trace. All</text>
<text top="801" left="476" width="359" height="13" font="2">the analyses described in this paper can return partial results within</text>
<text top="816" left="476" width="339" height="13" font="2">seconds, although some of them take much longer to complete.</text>
<text top="840" left="476" width="12" height="15" font="6"><b>3.</b></text>
<text top="840" left="504" width="226" height="15" font="6"><b>An Example: Linux Networking</b></text>
<text top="864" left="476" width="358" height="13" font="2">The Linux network stack is an illustrative example of the challenges</text>
<text top="879" left="476" width="358" height="13" font="2">faced by developers in understanding unfamiliar code. This code</text>
<text top="894" left="476" width="359" height="13" font="2">base has a number of features that contribute to the difﬁculty of</text>
<text top="909" left="476" width="90" height="13" font="2">understanding it.</text>
<text top="925" left="493" width="276" height="13" font="2">First, it is very large. According to SLOCCount</text>
<text top="922" left="769" width="5" height="10" font="7">2</text>
<text top="925" left="775" width="59" height="13" font="2">, there are</text>
<text top="940" left="476" width="358" height="13" font="2">342,536 lines of code in the net subdirectory of the Linux kernel</text>
<text top="955" left="476" width="359" height="13" font="2">(version 2.6.24). Restricting our attention to the most relevant sub-</text>
<text top="970" left="476" width="359" height="13" font="2">components (ipv4, netﬁlter, core, sched, and ethernet) reduces the</text>
<text top="985" left="476" width="359" height="13" font="2">count to 113,110 lines. Second, it spans all the layers of kernel ab-</text>
<text top="999" left="476" width="359" height="13" font="2">stractions from system calls through device drivers. Third, it uses</text>
<text top="1014" left="476" width="359" height="13" font="2">dynamic control ﬂow techniques that are challenging for static tools</text>
<text top="1029" left="476" width="359" height="13" font="2">to understand, such as function pointers (Figure 1 shows one ex-</text>
<text top="1057" left="476" width="4" height="8" font="9">1</text>
<text top="1059" left="482" width="291" height="11" font="8">http://code.google.com/p/data-race-test/wiki/ThreadSanitizer</text>
<text top="1075" left="476" width="4" height="8" font="9">2</text>
<text top="1077" left="482" width="175" height="11" font="8">http://www.dwheeler.com/sloccount/</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="10" size="5" family="Times" color="#000000"/>
	<fontspec id="11" size="4" family="Times" color="#000000"/>
	<fontspec id="12" size="3" family="Times" color="#000000"/>
<text top="113" left="151" width="373" height="7" font="10">__alloc_skb -&gt; ei_receive -&gt; ne2k_pci_block_input -&gt; eth_type_trans -&gt; ei_receive -&gt; netif_rx</text>
<text top="135" left="151" width="149" height="7" font="10">process_backlog -&gt; netif_receive_skb</text>
<text top="158" left="169" width="159" height="7" font="10">ip_rcv -&gt; ip_rcv_finish -&gt; ip_route_input</text>
<text top="204" left="204" width="588" height="7" font="10">tcp_v4_rcv -&gt; __skb_checksum_complete -&gt; __skb_checksum_complete_head -&gt; skb_checksum -&gt; __skb_checksum_complete_head -&gt; tcp_v4_rcv</text>
<text top="227" left="224" width="59" height="7" font="10">tcp_v4_do_rcv </text>
<text top="341" left="259" width="205" height="7" font="10">skb_release_all -&gt; skb_release_data -&gt; __kfree_skb</text>
<text top="273" left="261" width="157" height="7" font="10">tcp_rcv_established -&gt; tcp_data_queue</text>
<text top="296" left="279" width="205" height="7" font="10">skb_release_all -&gt; skb_release_data -&gt; __kfree_skb</text>
<text top="319" left="279" width="508" height="7" font="10">tcp_recvmsg -&gt; skb_release_all -&gt; sk_stream_rfree -&gt; skb_release_all -&gt; skb_release_data -&gt; skb_release_data -&gt; __kfree_skb</text>
<text top="364" left="240" width="543" height="7" font="10">tcp_v4_conn_request -&gt; tcp_parse_options -&gt; tcp_v4_conn_request -&gt; kfree_skb -&gt; skb_release_all -&gt; skb_release_data -&gt; __kfree_skb</text>
<text top="387" left="240" width="489" height="7" font="10">tcp_check_req -&gt; tcp_parse_options -&gt; tcp_check_req -&gt; kfree_skb -&gt; skb_release_all -&gt; skb_release_data -&gt; __kfree_skb</text>
<text top="410" left="240" width="133" height="7" font="10">tcp_rcv_state_process -&gt; tcp_ack</text>
<text top="433" left="259" width="205" height="7" font="10">skb_release_all -&gt; skb_release_data -&gt; __kfree_skb</text>
<text top="456" left="259" width="386" height="7" font="10">tcp_rcv_state_process -&gt; tcp_data_queue -&gt; skb_release_all -&gt; skb_release_data -&gt; __kfree_skb</text>
<text top="250" left="243" width="123" height="7" font="10">tcp_rcv_established -&gt; tcp_ack</text>
<text top="457" left="126" width="4" height="6" font="11">2</text>
<text top="114" left="105" width="25" height="6" font="11">3 7 4 2 7 9</text>
<text top="137" left="105" width="25" height="6" font="11">3 7 4 2 7 9</text>
<text top="160" left="105" width="25" height="6" font="11">3 7 4 2 7 9</text>
<text top="205" left="105" width="25" height="6" font="11">3 7 4 2 7 9</text>
<text top="180" left="105" width="25" height="6" font="11">3 7 4 2 7 9</text>
<text top="228" left="105" width="25" height="6" font="11">3 7 4 2 7 9</text>
<text top="251" left="105" width="25" height="6" font="11">3 5 0 6 0 4</text>
<text top="274" left="105" width="25" height="6" font="11">1 0 5 0 9 9</text>
<text top="343" left="105" width="25" height="6" font="11">2 4 5 5 0 5</text>
<text top="297" left="109" width="21" height="6" font="11">9 7 1 5 4</text>
<text top="320" left="113" width="16" height="6" font="11">7 9 4 5</text>
<text top="366" left="113" width="16" height="6" font="11">7 9 6 0</text>
<text top="389" left="113" width="16" height="6" font="11">7 9 5 2</text>
<text top="411" left="113" width="16" height="6" font="11">7 7 6 3</text>
<text top="434" left="113" width="16" height="6" font="11">7 7 6 1</text>
<text top="181" left="185" width="290" height="7" font="10">ip_rcv_finish -&gt; ip_local_deliver -&gt; ipt_do_table -&gt; ip_local_deliver_finish</text>
<text top="493" left="376" width="51" height="12" font="4"><b>Figure 4.</b></text>
<text top="492" left="434" width="104" height="13" font="2">TCP packet receive</text>
<text top="536" left="81" width="198" height="10" font="8">int netif rx(struct sk buff *skb)</text>
<text top="549" left="81" width="6" height="12" font="8">{</text>
<text top="563" left="93" width="138" height="10" font="8">struct softnet data *q;</text>
<text top="577" left="93" width="192" height="10" font="8">q = &amp; get cpu var(softnet data);</text>
<text top="590" left="102" width="213" height="10" font="8">get cpu var(netdev rx stat).total++;</text>
<text top="603" left="102" width="243" height="10" font="8">skb queue tail(&amp;q-&gt;input pkt queue, skb);</text>
<text top="617" left="93" width="131" height="10" font="8">return NET RX SUCCESS;</text>
<text top="629" left="81" width="6" height="12" font="8">}</text>
<text top="657" left="81" width="206" height="10" font="8">int process backlog(. . ., int quota)</text>
<text top="670" left="81" width="6" height="12" font="8">{</text>
<text top="684" left="93" width="138" height="10" font="8">struct softnet data *q;</text>
<text top="698" left="93" width="192" height="10" font="8">q = &amp; get cpu var(softnet data);</text>
<text top="724" left="93" width="12" height="10" font="8">do</text>
<text top="723" left="111" width="6" height="12" font="8">{</text>
<text top="738" left="105" width="120" height="10" font="8">struct sk buff *skb;</text>
<text top="751" left="105" width="31" height="10" font="8">skb =</text>
<text top="751" left="151" width="196" height="10" font="8">skb dequeue(&amp;q-&gt;input pkt queue);</text>
<text top="765" left="105" width="137" height="10" font="8">netif receive skb(skb);</text>
<text top="777" left="93" width="153" height="12" font="8">} while (++work &lt; quota);</text>
<text top="805" left="93" width="73" height="10" font="8">return work;</text>
<text top="818" left="81" width="6" height="12" font="8">}</text>
<text top="854" left="134" width="51" height="12" font="4"><b>Figure 2.</b></text>
<text top="853" left="192" width="195" height="13" font="2">Top/bottom half network processing</text>
<text top="896" left="81" width="359" height="13" font="2">ample of this, the packet delivery function, which dispatches the</text>
<text top="911" left="81" width="359" height="13" font="2">packet through a type-speciﬁc function pointer). Fourth, the func-</text>
<text top="926" left="81" width="359" height="13" font="2">tionality of the network stack is split in accordance with the stan-</text>
<text top="941" left="81" width="359" height="13" font="2">dard Linux top/bottom driver architecture: the “top half” executes</text>
<text top="956" left="81" width="359" height="13" font="2">in interrupt context, which must complete as quickly as possible.</text>
<text top="971" left="81" width="359" height="13" font="2">It simply receives a packet from a device driver and queues it. Ac-</text>
<text top="986" left="81" width="359" height="13" font="2">tual packet processing (the “bottom half”) is deferred until inter-</text>
<text top="1001" left="81" width="358" height="13" font="2">rupts have been serviced. Figure 2 shows the code used by network</text>
<text top="1016" left="81" width="359" height="13" font="2">card interrupt handlers to queue received packets and the process-</text>
<text top="1031" left="81" width="358" height="13" font="2">ing function that runs asynchronously to dequeue packets to push</text>
<text top="1046" left="81" width="359" height="13" font="2">them up the protocol stack. This causes standard call-ﬂow analysis</text>
<text top="1061" left="81" width="359" height="13" font="2">to be unable to capture the end-to-end processing of packets from</text>
<text top="1076" left="81" width="125" height="13" font="2">arrival to ﬁnal delivery.</text>
<text top="539" left="503" width="322" height="6" font="11">__alloc_skb -&gt; ei_receive -&gt; ne2k_pci_block_input -&gt; eth_type_trans -&gt; ei_receive -&gt; netif_rx</text>
<text top="558" left="503" width="221" height="6" font="11">process_backlog -&gt; netif_receive_skb -&gt; arp_rcv -&gt; arp_process</text>
<text top="578" left="518" width="49" height="6" font="11">ip_route_input</text>
<text top="598" left="534" width="222" height="6" font="11">kfree_skb -&gt; skb_release_all -&gt; skb_release_data -&gt; __kfree_skb</text>
<text top="618" left="534" width="276" height="6" font="11">arp_process -&gt; kfree_skb -&gt; skb_release_all -&gt; skb_release_data -&gt; __kfree_skb</text>
<text top="637" left="518" width="224" height="6" font="11">kfree_skb -&gt; skb_release_all -&gt; skb_release_data -&gt; __kfree_skb </text>
<text top="540" left="478" width="10" height="5" font="12">1 6 2</text>
<text top="559" left="478" width="10" height="5" font="12">1 6 2</text>
<text top="579" left="478" width="10" height="5" font="12">1 6 0</text>
<text top="619" left="481" width="7" height="5" font="12">1 4</text>
<text top="597" left="478" width="10" height="5" font="12">1 4 6</text>
<text top="638" left="485" width="3" height="5" font="12">2</text>
<text top="673" left="499" width="51" height="12" font="4"><b>Figure 3.</b></text>
<text top="673" left="557" width="253" height="13" font="2">ARP packet lifetime through the network stack</text>
<text top="732" left="493" width="341" height="13" font="2">Static analysis tools that perform call ﬂow analysis cannot deal</text>
<text top="747" left="476" width="358" height="13" font="2">with this level of indirection, but even if they could, constructing</text>
<text top="762" left="476" width="359" height="13" font="2">a static call graph only tells part of the story. A large portion of</text>
<text top="777" left="476" width="359" height="13" font="2">system code is there to handle errors and rare corner cases. Static</text>
<text top="792" left="476" width="359" height="13" font="2">analysis cannot guide a developer to concentrate on the important</text>
<text top="807" left="476" width="359" height="13" font="2">or most commonly used functionality of the network stack, nor can</text>
<text top="821" left="476" width="221" height="13" font="2">it identify unused or outlying code paths.</text>
<text top="836" left="493" width="341" height="13" font="2">The network stack is inherently data-driven and has a single data</text>
<text top="851" left="476" width="359" height="13" font="2">structure (the packet) at its core. Developers who want to under-</text>
<text top="866" left="476" width="359" height="13" font="2">stand the stack typically want to begin with understanding how a</text>
<text top="881" left="476" width="358" height="13" font="2">speciﬁc subset of packets ﬂow through it. What if a developer could</text>
<text top="896" left="476" width="358" height="13" font="2">point to a function in the source code and ask, “Where are packets</text>
<text top="911" left="476" width="359" height="13" font="2">processed by this function coming from and where are they go-</text>
<text top="926" left="476" width="359" height="13" font="2">ing to?” The answer to this question for the function arp rcv is</text>
<text top="941" left="476" width="359" height="13" font="2">illustrated in Figure 3 which shows a tree produced by our tool</text>
<text top="956" left="476" width="358" height="13" font="2">of the functions that access every packet which passes through</text>
<text top="972" left="476" width="46" height="11" font="2">arp rcv</text>
<text top="971" left="521" width="312" height="13" font="2">, from its allocation to is eventual release. Function names</text>
<text top="986" left="476" width="359" height="13" font="2">in the ﬁrst, shaded text box are executed in device interrupt con-</text>
<text top="1001" left="476" width="358" height="13" font="2">text, while subsequent processing occurs in a soft irq. Numbers</text>
<text top="1016" left="476" width="359" height="13" font="2">to the left of the ﬁgure indicate the number of packets that take the</text>
<text top="1031" left="476" width="359" height="13" font="2">indicated path through the code. Looking at the ﬁgure, the devel-</text>
<text top="1046" left="476" width="358" height="13" font="2">oper can quickly learn that packets are allocated by the function</text>
<text top="1061" left="484" width="60" height="11" font="2">alloc skb</text>
<text top="1061" left="544" width="290" height="13" font="2">, are operated on at the ARP level primarily by the</text>
<text top="1076" left="476" width="274" height="13" font="2">function arp process, and are eventually freed by</text>
<text top="1076" left="763" width="60" height="11" font="2">kfree skb</text>
<text top="1076" left="822" width="3" height="13" font="2">.</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="13" size="7" family="Times" color="#000000"/>
<text top="110" left="99" width="341" height="13" font="2">Having understood this simple ﬂow for ARP packets, the de-</text>
<text top="125" left="81" width="359" height="13" font="2">veloper might then ask about packets processed by another func-</text>
<text top="140" left="81" width="359" height="13" font="2">tion, perhaps for a more complex protocol such as TCP. The ﬂow</text>
<text top="155" left="81" width="359" height="13" font="2">of packets going through the function tcp v4 do rcv is shown in</text>
<text top="170" left="81" width="359" height="13" font="2">Figure 4. The graph is much larger, representing the increased com-</text>
<text top="185" left="81" width="229" height="13" font="2">plexity of TCP processing relative to ARP.</text>
<text top="200" left="99" width="341" height="13" font="2">The ﬁgures in this section were generated from a trace of a</text>
<text top="215" left="81" width="359" height="13" font="2">virtual machine running the Apache web server on Linux. The data</text>
<text top="230" left="81" width="359" height="13" font="2">used to generate these ﬁgures is obtained with a new analysis we</text>
<text top="245" left="81" width="359" height="13" font="2">have dubbed <i>Heap Slicing </i>which we describe in Section 5.4, after</text>
<text top="260" left="81" width="315" height="13" font="2">we have explained the overall architecture of our platform.</text>
<text top="287" left="81" width="12" height="15" font="6"><b>4.</b></text>
<text top="287" left="110" width="188" height="15" font="6"><b>The Trace Analysis Engine</b></text>
<text top="312" left="81" width="359" height="13" font="2">Figure 5 illustrates the Tralfamadore architecture. Analysis starts</text>
<text top="326" left="81" width="358" height="13" font="2">with an execution trace, which is captured at the virtual machine</text>
<text top="341" left="81" width="359" height="13" font="2">level and stored as a database which the analysis engine uses to an-</text>
<text top="356" left="81" width="358" height="13" font="2">swer queries. User queries are constructed out of simple modules</text>
<text top="371" left="81" width="359" height="13" font="2">under a dataﬂow model similar to network packet processing en-</text>
<text top="386" left="81" width="359" height="13" font="2">gines such as Click [16] and Bro [28]. In this paradigm, data is pro-</text>
<text top="401" left="81" width="358" height="13" font="2">cessed by single-function components, which are called <i>operators</i></text>
<text top="416" left="81" width="359" height="13" font="2">in Tralfamadore. These operators are connected as a DAG, where</text>
<text top="431" left="81" width="359" height="13" font="2">each operator consumes a stream of records from one or more up-</text>
<text top="446" left="81" width="358" height="13" font="2">stream operators and produces a stream of records for downstream</text>
<text top="461" left="81" width="359" height="13" font="2">operators. Data traverses the graph of operators, <i>ﬂowing </i>from the</text>
<text top="476" left="81" width="153" height="13" font="2">leaves to the root of the tree.</text>
<text top="491" left="99" width="341" height="13" font="2">Tralfamadore analyses execute by parsing the trace into a <i>stream</i></text>
<text top="506" left="81" width="359" height="13" font="2">of records called <i>annotations </i>corresponding to the execution of</text>
<text top="521" left="81" width="359" height="13" font="2">machine-level instructions and the occurrence of events such as</text>
<text top="536" left="81" width="359" height="13" font="2">interrupts or page faults. The stream is passed through an analysis-</text>
<text top="551" left="81" width="358" height="13" font="2">speciﬁc conﬁguration of operators that progressively augment</text>
<text top="566" left="81" width="359" height="13" font="2">the stream with semantically richer annotations corresponding to</text>
<text top="581" left="81" width="359" height="13" font="2">higher-level events such as function calls, lock uses, or heap alloca-</text>
<text top="596" left="81" width="359" height="13" font="2">tions. Analyses can be expressed succinctly in terms of higher level</text>
<text top="611" left="81" width="335" height="13" font="2">annotations instead of dealing directly with a CPU-level trace.</text>
<text top="625" left="99" width="341" height="13" font="2">The current implementation of the Tralfamadore analysis en-</text>
<text top="640" left="81" width="358" height="13" font="2">gine consists of approximately 5000 lines of C code and 12000</text>
<text top="655" left="81" width="359" height="13" font="2">lines of OCaml code. The C language is used to implement per-</text>
<text top="670" left="81" width="359" height="13" font="2">formance critical code such as the trace parser and the instruc-</text>
<text top="685" left="81" width="359" height="13" font="2">tion disassembler. All of the operators and analyses are written</text>
<text top="700" left="81" width="359" height="13" font="2">in OCaml. OCaml is a garbage-collected, statically typed func-</text>
<text top="715" left="81" width="359" height="13" font="2">tional language with imperative and object-oriented features. We</text>
<text top="730" left="81" width="359" height="13" font="2">choose OCaml because many of its features such as variant types</text>
<text top="745" left="81" width="359" height="13" font="2">and pattern matching map naturally to the tasks accomplished by</text>
<text top="760" left="81" width="129" height="13" font="2">Tralfamadore operators.</text>
<text top="785" left="81" width="17" height="12" font="4"><b>4.1</b></text>
<text top="785" left="111" width="59" height="12" font="4"><b>Primitives</b></text>
<text top="807" left="81" width="59" height="12" font="4"><b>Operators</b></text>
<text top="807" left="146" width="294" height="13" font="2">are the main functional abstraction in Tralfamadore.</text>
<text top="821" left="81" width="359" height="13" font="2">Each operator is designed to recognize speciﬁc patterns in the</text>
<text top="836" left="81" width="358" height="13" font="2">stream corresponding to the occurrence of events and produce</text>
<text top="851" left="81" width="359" height="13" font="2">annotations that describe these events. The type of an operator is</text>
<text top="866" left="81" width="358" height="13" font="2">solely deﬁned by the annotations it produces. This encapsulation</text>
<text top="881" left="81" width="359" height="13" font="2">makes it easy to replace the implementation of an operator with a</text>
<text top="896" left="81" width="72" height="13" font="2">different one.</text>
<text top="912" left="99" width="70" height="12" font="4"><b>Annotations</b></text>
<text top="911" left="174" width="265" height="13" font="2">are the basic unit of information in the system.</text>
<text top="926" left="81" width="359" height="13" font="2">They are typed and parameterized, and operators are able to deﬁne</text>
<text top="941" left="81" width="359" height="13" font="2">new annotations that they will produce for downstream operators.</text>
<text top="956" left="81" width="359" height="13" font="2">Annotations are logically timestamped to provide an ordering be-</text>
<text top="971" left="81" width="358" height="13" font="2">tween annotations which is needed when merging multiple annota-</text>
<text top="986" left="81" width="359" height="13" font="2">tion streams. The trace parser operator reads the raw trace on disk</text>
<text top="1001" left="81" width="359" height="13" font="2">and produces <i>basic block </i>and <i>event </i>annotations, which are the most</text>
<text top="1016" left="81" width="358" height="13" font="2">basic form of annotations used in the system. Section 5 describes</text>
<text top="1031" left="81" width="359" height="13" font="2">some of the current stream operators and the annotations that they</text>
<text top="1046" left="81" width="358" height="13" font="2">use. We are actively developing new operators in order to provide</text>
<text top="1061" left="81" width="359" height="13" font="2">support for other operating systems and the analysis of user-level</text>
<text top="1076" left="81" width="68" height="13" font="2">applications.</text>
<text top="110" left="493" width="341" height="13" font="2">A <b>stream</b>, then, is an interface across which operators may send</text>
<text top="125" left="476" width="359" height="13" font="2">and receive sequences of annotations. As mentioned above, the ﬂow</text>
<text top="140" left="476" width="359" height="13" font="2">of annotations in the system is driven by a “pull” from the sink</text>
<text top="155" left="476" width="359" height="13" font="2">operator in the DAG rather than a “push” from the trace itself. This</text>
<text top="170" left="476" width="359" height="13" font="2">allows operators to elect to work with speciﬁc, small regions of the</text>
<text top="185" left="476" width="359" height="13" font="2">trace. The programmatic idiom for streams in our system is that of</text>
<text top="200" left="476" width="344" height="13" font="2">an inﬁnite lazy list, whose contents are materialized on demand.</text>
<text top="226" left="476" width="17" height="12" font="4"><b>4.2</b></text>
<text top="226" left="506" width="45" height="12" font="4"><b>Tracing</b></text>
<text top="248" left="476" width="359" height="13" font="2">Almost all operators consume annotations from other operators in</text>
<text top="263" left="476" width="359" height="13" font="2">order to produce semantically richer annotations. The most impor-</text>
<text top="278" left="476" width="359" height="13" font="2">tant exception is the <i>trace operator</i>, which consumes the trace it-</text>
<text top="293" left="476" width="359" height="13" font="2">self to produce annotations representing changes to the state of the</text>
<text top="308" left="476" width="359" height="13" font="2">system at the (virtual) hardware level. The trace is captured by run-</text>
<text top="323" left="476" width="359" height="13" font="2">ning the target system on a modiﬁed version of QEMU [5]. QEMU</text>
<text top="338" left="476" width="359" height="13" font="2">is a fast whole-machine emulator that uses dynamic binary trans-</text>
<text top="353" left="476" width="358" height="13" font="2">lation to emulate a guest instruction set architecture on a (possibly</text>
<text top="368" left="476" width="359" height="13" font="2">different) host architecture. QEMU breaks guest instructions into</text>
<text top="383" left="476" width="358" height="13" font="2">a series of RISC-like micro-operations which are fed into a code</text>
<text top="398" left="476" width="359" height="13" font="2">generator to produce native code that executes directly on the host.</text>
<text top="413" left="476" width="359" height="13" font="2">We made straightforward additions to these micro-operations to log</text>
<text top="427" left="476" width="359" height="13" font="2">their changes to emulated guest state as they execute. The resulting</text>
<text top="442" left="476" width="359" height="13" font="2">log is a faithful recording of every change to guest state, detailed</text>
<text top="457" left="476" width="359" height="13" font="2">enough that the exact state of the machine at any point in its ex-</text>
<text top="472" left="476" width="358" height="13" font="2">ecution can be recreated later. The modiﬁcations we have made</text>
<text top="487" left="476" width="358" height="13" font="2">to support trace generation are based on QEMU version 0.9.1 and</text>
<text top="502" left="476" width="251" height="13" font="2">consist of approximately 2200 lines of C code.</text>
<text top="517" left="493" width="341" height="13" font="2">In order to support arbitrary analyses, the execution trace must</text>
<text top="532" left="476" width="359" height="13" font="2">record every change to the state of the machine as it runs. This in-</text>
<text top="547" left="476" width="359" height="13" font="2">cludes every instruction executed, every exception, every interrupt,</text>
<text top="562" left="476" width="359" height="13" font="2">and all changes to register and memory, whether due to instructions</text>
<text top="577" left="476" width="36" height="13" font="2">or I/O.</text>
<text top="601" left="476" width="57" height="8" font="13">c01373e8 sti</text>
<text top="601" left="599" width="56" height="8" font="13">EFL=00000206</text>
<text top="612" left="476" width="137" height="8" font="13">c01373e9 nop 0x0(%eax,%eax,1)</text>
<text top="623" left="476" width="89" height="8" font="13">E[20,0000,c01373f1]</text>
<text top="623" left="599" width="161" height="8" font="13">STL[cd903f74]=206 STL[cd903f70]=60</text>
<text top="634" left="599" width="180" height="8" font="13">STL[cd903f6c]=c01373f1 R[ESP]=cd903f6c</text>
<text top="646" left="599" width="175" height="8" font="13">S[CS]=0060,00000000,ffffffff,00cf9a00</text>
<text top="657" left="599" width="113" height="8" font="13">BR=c010859c EFL=00000006</text>
<text top="668" left="476" width="304" height="8" font="13">c010859c push $0xffffffff STL[cd903f68]=ffffffff R[ESP]=cd903f68</text>
<text top="679" left="476" width="109" height="8" font="13">c010859e jmp 0xc0108ddc</text>
<text top="679" left="599" width="52" height="8" font="13">BR=c0108ddc</text>
<text top="691" left="476" width="57" height="8" font="13">c0108ddc cld</text>
<text top="691" left="599" width="56" height="8" font="13">EFL=00000006</text>
<text top="702" left="476" width="81" height="8" font="13">c0108ddd push %fs</text>
<text top="702" left="599" width="180" height="8" font="13">STL[cd903f64]=000000d8 R[ESP]=cd903f64</text>
<text top="713" left="476" width="81" height="8" font="13">c0108ddf push %es</text>
<text top="713" left="599" width="180" height="8" font="13">STL[cd903f60]=0000007b R[ESP]=cd903f60</text>
<text top="724" left="476" width="81" height="8" font="13">c0108de0 push %ds</text>
<text top="724" left="599" width="180" height="8" font="13">STL[cd903f5c]=0000007b R[ESP]=cd903f5c</text>
<text top="735" left="476" width="85" height="8" font="13">c0108de1 push %eax</text>
<text top="735" left="599" width="180" height="8" font="13">STL[cd903f58]=00b77000 R[ESP]=cd903f58</text>
<text top="747" left="476" width="14" height="8" font="13">...</text>
<text top="758" left="476" width="85" height="8" font="13">c0108de7 push %ebx</text>
<text top="758" left="599" width="180" height="8" font="13">STL[cd903f40]=00000002 R[ESP]=cd903f40</text>
<text top="769" left="476" width="109" height="8" font="13">c0108de8 mov $0x7b,%edx</text>
<text top="769" left="599" width="70" height="8" font="13">R[EDX]=0000007b</text>
<text top="780" left="476" width="99" height="8" font="13">c0108ded mov %edx,%ds</text>
<text top="780" left="599" width="175" height="8" font="13">S[DS]=007b,00000000,ffffffff,00cff300</text>
<text top="810" left="588" width="51" height="12" font="4"><b>Figure 6.</b></text>
<text top="810" left="646" width="75" height="13" font="2">Trace sample.</text>
<text top="836" left="493" width="341" height="13" font="2">Figure 6 is a concrete example of the level of detail captured</text>
<text top="851" left="476" width="358" height="13" font="2">by our trace collector. At the start of the section, the CPU program</text>
<text top="866" left="476" width="359" height="13" font="2">counter is at 0xc01373e8, which contains the sti instruction that</text>
<text top="881" left="476" width="359" height="13" font="2">causes interrupt delivery to be enabled (setting bit 9 of the EFLAGS</text>
<text top="896" left="476" width="359" height="13" font="2">register). Upon execution of this instruction, an interrupt (0x20, the</text>
<text top="911" left="476" width="359" height="13" font="2">timer interrupt) is immediately delivered. As part of interrupt de-</text>
<text top="926" left="476" width="359" height="13" font="2">livery, the CPU saves essential state on the stack, disables interrupt</text>
<text top="941" left="476" width="359" height="13" font="2">delivery, and branches to an interrupt dispatch function. The dis-</text>
<text top="956" left="476" width="359" height="13" font="2">patcher saves register values on the stack to free the registers for</text>
<text top="971" left="476" width="244" height="13" font="2">use by the interrupt handler it is about to call.</text>
<text top="986" left="493" width="341" height="13" font="2">As is probably apparent from Figure 6, this approach produces</text>
<text top="1001" left="476" width="359" height="13" font="2">an enormous amount of trace data, and slows execution signiﬁ-</text>
<text top="1016" left="476" width="359" height="13" font="2">cantly (see Section 7 for details). For a system like ours, which</text>
<text top="1031" left="476" width="359" height="13" font="2">is designed as a developer tool and in which a single trace can be</text>
<text top="1046" left="476" width="359" height="13" font="2">reused for large numbers of analyses, the beneﬁts can be worth the</text>
<text top="1061" left="476" width="358" height="13" font="2">costs. For applications that demand less overhead during execu-</text>
<text top="1076" left="476" width="359" height="13" font="2">tion (e.g., debugging, security, or forensics), it is possible to re-</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="14" size="12" family="Times" color="#231f20"/>
	<fontspec id="15" size="10" family="Times" color="#231f20"/>
	<fontspec id="16" size="10" family="Times" color="#231f20"/>
	<fontspec id="17" size="7" family="Times" color="#0f0e0c"/>
	<fontspec id="18" size="7" family="Times" color="#0f0e0c"/>
	<fontspec id="19" size="4" family="Times" color="#0f0e0c"/>
	<fontspec id="20" size="6" family="Times" color="#0f0e0c"/>
<text top="112" left="291" width="92" height="13" font="14"><b>Analysis Target</b></text>
<text top="129" left="292" width="89" height="12" font="15">e.g. Linux System </text>
<text top="144" left="286" width="101" height="12" font="15">running a SPECWeb</text>
<text top="160" left="312" width="49" height="12" font="15">workload</text>
<text top="198" left="278" width="118" height="13" font="14"><b>Execution Recorder</b></text>
<text top="214" left="279" width="115" height="12" font="15">Writes execution trace </text>
<text top="230" left="319" width="36" height="12" font="15">to disk.</text>
<text top="212" left="433" width="192" height="12" font="16"><b>Analysis Engine</b> - Plans and executes </text>
<text top="227" left="453" width="152" height="12" font="15">analyses on trace and indices.</text>
<text top="292" left="311" width="60" height="13" font="14"><b>Execution</b></text>
<text top="309" left="325" width="32" height="13" font="14"><b>Trace</b></text>
<text top="292" left="395" width="56" height="13" font="14"><b>Operator</b></text>
<text top="309" left="406" width="34" height="13" font="14"><b>Index</b></text>
<text top="143" left="428" width="189" height="12" font="16"><b>Analysis</b> - A dataflow composition of</text>
<text top="158" left="428" width="98" height="12" font="15">analysis operators. </text>
<text top="292" left="459" width="56" height="13" font="14"><b>Operator</b></text>
<text top="309" left="469" width="34" height="13" font="14"><b>Index</b></text>
<text top="292" left="523" width="56" height="13" font="14"><b>Operator</b></text>
<text top="309" left="533" width="34" height="13" font="14"><b>Index</b></text>
<text top="112" left="721" width="28" height="13" font="14"><b>User</b></text>
<text top="128" left="675" width="120" height="12" font="15">“What are the common</text>
<text top="144" left="671" width="128" height="12" font="15">paths of packets through</text>
<text top="159" left="685" width="100" height="12" font="15">the network stack?”</text>
<text top="189" left="721" width="28" height="13" font="14"><b>User</b></text>
<text top="206" left="676" width="118" height="12" font="15">“What is the maximum</text>
<text top="221" left="690" width="90" height="12" font="15">stack size while in</text>
<text top="237" left="687" width="96" height="12" font="15">interrupt context?”</text>
<text top="264" left="721" width="28" height="13" font="14"><b>User</b></text>
<text top="280" left="685" width="101" height="12" font="15">“Assert: all writes to </text>
<text top="296" left="679" width="112" height="12" font="15">instances of struct foo</text>
<text top="311" left="693" width="83" height="12" font="15">hold mutex bar.”</text>
<text top="292" left="587" width="56" height="13" font="14"><b>Operator</b></text>
<text top="309" left="597" width="34" height="13" font="14"><b>Index</b></text>
<text top="112" left="416" width="82" height="13" font="14"><b>Tralfamadore</b></text>
<text top="112" left="116" width="117" height="13" font="14"><b>System Architecture</b></text>
<text top="128" left="116" width="145" height="12" font="15">Tralfamadore analyzes and </text>
<text top="144" left="116" width="114" height="12" font="15">rebuilds source-level </text>
<text top="159" left="116" width="147" height="12" font="15">semantics from instruction-</text>
<text top="175" left="116" width="143" height="12" font="15">level execution traces that </text>
<text top="190" left="116" width="139" height="12" font="15">have been stored to disk.  </text>
<text top="206" left="116" width="119" height="12" font="15">By providing a shared </text>
<text top="221" left="116" width="154" height="12" font="15">service for trace storage and </text>
<text top="236" left="116" width="141" height="12" font="15">analysis, developers amor-</text>
<text top="252" left="116" width="131" height="12" font="15">tize the costs associated </text>
<text top="267" left="116" width="141" height="12" font="15">with writing analysis tools </text>
<text top="283" left="116" width="137" height="12" font="15">and performing analysis.  </text>
<text top="298" left="116" width="144" height="12" font="15">The analysis engine allows </text>
<text top="314" left="116" width="152" height="12" font="15">developers to compose and </text>
<text top="329" left="116" width="140" height="12" font="15">refine their analysis, while </text>
<text top="345" left="116" width="118" height="12" font="15">providing immediate, </text>
<text top="360" left="116" width="97" height="12" font="15">interactive results.</text>
<text top="388" left="357" width="51" height="12" font="4"><b>Figure 5.</b></text>
<text top="388" left="415" width="143" height="13" font="2">Tralfamadore Architecture</text>
<text top="432" left="81" width="359" height="13" font="2">duce recording cost by separating it from trace generation, using</text>
<text top="447" left="81" width="359" height="13" font="2">deterministic virtual machine record and replay [11]. These logs</text>
<text top="462" left="81" width="358" height="13" font="2">are small, and recording them imposes only modest performance</text>
<text top="477" left="81" width="359" height="13" font="2">costs. As an event log, the recording contains very little information</text>
<text top="492" left="81" width="359" height="13" font="2">about execution, making it unsuitable for direct analysis. However,</text>
<text top="507" left="81" width="358" height="13" font="2">it provides enough information to regenerate the entire execution</text>
<text top="522" left="81" width="359" height="13" font="2">history in a subsequent, ofﬂine replay phase during which the full</text>
<text top="537" left="81" width="358" height="13" font="2">execution trace can be produced [38]. We are currently working</text>
<text top="552" left="81" width="359" height="13" font="2">on adding support for deterministic record/replay in QEMU and in</text>
<text top="567" left="81" width="359" height="13" font="2">Xen. Our goal is to be able to record execution in Xen and replay it</text>
<text top="582" left="81" width="313" height="13" font="2">in QEMU, similarily to Aftersight [10], to generate traces.</text>
<text top="605" left="81" width="17" height="12" font="4"><b>4.3</b></text>
<text top="605" left="111" width="85" height="12" font="4"><b>Trace Analysis</b></text>
<text top="627" left="81" width="358" height="13" font="2">Figure 7 illustrates how operators gradually reconstruct execution</text>
<text top="642" left="81" width="358" height="13" font="2">semantics when streaming a CPU-level trace through the conﬁgu-</text>
<text top="657" left="81" width="359" height="13" font="2">ration of operators shown in Figure 8. The left hand side of Figure 7</text>
<text top="672" left="81" width="358" height="13" font="2">shows an excerpt of raw trace containing basic block (BBlk) anno-</text>
<text top="687" left="81" width="359" height="13" font="2">tations. These annotations are generated by the <i>Trace Parser </i>opera-</text>
<text top="702" left="81" width="358" height="13" font="2">tor. The stream passes through the <i>Invoke </i>operator which augments</text>
<text top="717" left="81" width="359" height="13" font="2">the stream with <i>Invoke </i>and <i>Return </i>annotations corresponding to</text>
<text top="731" left="81" width="359" height="13" font="2">function calls and return statements. A third operator (<i>Alloc</i>), uses</text>
<text top="746" left="81" width="219" height="13" font="2">the <i>Invoke </i>annotations to identify calls to</text>
<text top="747" left="313" width="62" height="11" font="2">kmalloc()</text>
<text top="746" left="374" width="65" height="13" font="2">, and further</text>
<text top="761" left="81" width="359" height="13" font="2">augments the stream with heap allocation annotations. The <i>Alloc</i></text>
<text top="776" left="81" width="359" height="13" font="2">annotation shown on the right hand side indicates the allocation</text>
<text top="791" left="81" width="359" height="13" font="2">of a block of 1024 bytes at address 0xdfcc5800. Subsequent op-</text>
<text top="806" left="81" width="358" height="13" font="2">erators interested in heap allocations do not need to be concerned</text>
<text top="821" left="81" width="127" height="13" font="2">with identifying calls to</text>
<text top="822" left="221" width="62" height="11" font="2">kmalloc()</text>
<text top="821" left="283" width="157" height="13" font="2">, but can simply use the <i>Alloc</i></text>
<text top="836" left="81" width="316" height="13" font="2">annotation directly without knowing how it was generated.</text>
<text top="851" left="99" width="341" height="13" font="2">In addition to gradually bridging the semantic gap, the dataﬂow</text>
<text top="866" left="81" width="358" height="13" font="2">architecture encourages the design of analysis that are <i>composable</i></text>
<text top="881" left="81" width="359" height="13" font="2">and <i>reusable</i>. Composable means that analyses can be easily struc-</text>
<text top="896" left="81" width="359" height="13" font="2">tured as a combination of simple single-function operators. This</text>
<text top="911" left="81" width="359" height="13" font="2">design also makes it easy to reuse these operators across multiple</text>
<text top="926" left="81" width="359" height="13" font="2">analyses, saving developers from the burden of constantly having</text>
<text top="941" left="81" width="256" height="13" font="2">to re-understand low-level aspects of execution.</text>
<text top="964" left="81" width="17" height="12" font="4"><b>4.4</b></text>
<text top="964" left="111" width="127" height="12" font="4"><b>Caching and Indexing</b></text>
<text top="986" left="81" width="359" height="13" font="2">Many analyses only need to look at small portions of the trace to</text>
<text top="1001" left="81" width="359" height="13" font="2">extract the information they need. A good example is extracting</text>
<text top="1016" left="81" width="359" height="13" font="2">the value of an argument for all calls to a speciﬁc function. It is</text>
<text top="1031" left="81" width="359" height="13" font="2">sufﬁcient to revisit the trace at all call sites and inspect the register</text>
<text top="1046" left="81" width="359" height="13" font="2">or memory state to extract the argument values. Analyses could</text>
<text top="1061" left="81" width="359" height="13" font="2">execute much faster if they had the ability to only read the relevant</text>
<text top="1076" left="81" width="101" height="13" font="2">portions of a trace.</text>
<text top="432" left="476" width="39" height="8" font="17">BBlk(2):</text>
<text top="442" left="476" width="255" height="8" font="17">c01b0623: mov  $0x000000d0  -&gt; %edx : R[edx]=000000d0</text>
<text top="451" left="476" width="342" height="8" font="17">c01b0628: call 0xfffe7228 %esp -&gt; %esp (%esp) : ST32[f755bea4]=c01b062d</text>
<text top="461" left="476" width="179" height="8" font="17">          R[esp]=f755bea4 BR=c0197850</text>
<text top="475" left="476" width="39" height="8" font="17">BBlk(8):</text>
<text top="485" left="476" width="245" height="8" font="17">c0197850: sub  $0x1c %esp -&gt; %esp : R[esp]=f755be88</text>
<text top="494" left="476" width="154" height="8" font="17">c0197853: cmp  %eax $0x00000800:</text>
<text top="504" left="476" width="245" height="8" font="17">c0197858: mov  %ebx -&gt; 0xc(%esp): ST32[f755be94]=ff</text>
<text top="513" left="476" width="255" height="8" font="17">c019785c: mov  %esi -&gt; 0x10(%esp): ST32[f755be98]=100</text>
<text top="523" left="476" width="331" height="8" font="17">c0197860: mov  %edi -&gt; 0x14(%esp): ST32[f755be9c]=f755bf0cc0197864:  </text>
<text top="532" left="476" width="264" height="8" font="17">          mov %ebp-&gt;0x18(%esp): ST32[f755bea0]=dfda0600</text>
<text top="542" left="476" width="250" height="8" font="17">c0197868: mov  %edx -&gt; 0x8(%esp) : ST32[f755be90]=d0</text>
<text top="551" left="476" width="187" height="8" font="17">c019786c: jcc  0x00000099 : FL=00000287</text>
<text top="558" left="476" width="15" height="8" font="17">...</text>
<text top="569" left="476" width="39" height="8" font="17">BBlk(7):</text>
<text top="579" left="476" width="221" height="8" font="17">c01978ce: mov  %ebx  -&gt; %eax : R[eax]=dfcc5800</text>
<text top="588" left="476" width="327" height="8" font="17">c01978d0: mov  0xc(%esp) -&gt; %ebx : LD32[f755be94]=ff R[ebx]=000000ff</text>
<text top="597" left="476" width="337" height="8" font="17">c01978d4: mov  0x10(%esp) -&gt; %esi : LD32[f755be98]=100 R[esi]=00000100</text>
<text top="607" left="476" width="361" height="8" font="17">c01978d8: mov  0x14(%esp) -&gt; %edi : LD32[f755be9c]=f755bf0c R[edi]=f755bf0c</text>
<text top="617" left="476" width="361" height="8" font="17">c01978dc: mov  0x18(%esp) -&gt; %ebp : LD32[f755bea0]=dfda0600 R[ebp]=dfda0600</text>
<text top="626" left="476" width="245" height="8" font="17">c01978e0: add  $0x1c %esp -&gt; %esp : R[esp]=f755bea4</text>
<text top="636" left="476" width="366" height="8" font="17">c01978e3: ret  %esp (%esp) -&gt; %esp : LD32[f755bea4]=c01b062d R[esp]=f755bea8</text>
<text top="645" left="476" width="160" height="8" font="17">          BR=c01b062d FL=00000292</text>
<text top="472" left="625" width="141" height="9" font="18"><i><b>Invoke (__kmalloc, 0xf755bea4)</b></i></text>
<text top="655" left="623" width="93" height="9" font="18"><i><b>Return (0xf755bea4)</b></i></text>
<text top="666" left="714" width="110" height="9" font="18"><i><b>Alloc (0xdfcc5800, 1024)</b></i></text>
<text top="689" left="476" width="53" height="12" font="4"><b>Figure 7.</b></text>
<text top="689" left="536" width="298" height="13" font="2">Reconstruction of execution semantics using progres-</text>
<text top="704" left="476" width="168" height="13" font="2">sively higher-level annotations.</text>
<text top="812" left="694" width="21" height="5" font="19">Invoke</text>
<text top="814" left="828" width="16" height="5" font="19">trace</text>
<text top="807" left="774" width="17" height="5" font="19">Trace</text>
<text top="817" left="773" width="21" height="5" font="19">Parser</text>
<text top="812" left="598" width="16" height="5" font="19">Alloc</text>
<text top="812" left="489" width="14" height="5" font="19">Sink</text>
<text top="855" left="721" width="38" height="8" font="20">trace time</text>
<text top="758" left="686" width="69" height="6" font="19">Annotations inserted by</text>
<text top="766" left="692" width="57" height="6" font="19">the Invoke operator</text>
<text top="758" left="586" width="66" height="6" font="19">Annotation inserted by</text>
<text top="766" left="593" width="52" height="6" font="19">the Alloc operator</text>
<text top="891" left="563" width="51" height="12" font="4"><b>Figure 8.</b></text>
<text top="891" left="621" width="126" height="13" font="2">Operator conﬁguration.</text>
<text top="941" left="493" width="341" height="13" font="2">To efﬁciently support this sort of analysis, Tralfamadore opera-</text>
<text top="956" left="476" width="358" height="13" font="2">tors can be conﬁgured to create persistent caches of the annotations</text>
<text top="971" left="476" width="359" height="13" font="2">they generate. Subsequent analyses can use cached annotations as</text>
<text top="986" left="476" width="359" height="13" font="2">indices to map annotations or annotation attributes to interesting</text>
<text top="1001" left="476" width="359" height="13" font="2">positions in the trace. These positions can be used as starting points</text>
<text top="1016" left="476" width="359" height="13" font="2">to examine a trace, or used to identify interesting slices of a trace,</text>
<text top="1031" left="476" width="358" height="13" font="2">such as the range of a trace where a speciﬁc thread was running.</text>
<text top="1046" left="476" width="359" height="13" font="2">Operators that support this mechanism export a query interface that</text>
<text top="1061" left="476" width="359" height="13" font="2">lets analyses instantiate an operator that will produce the subset</text>
<text top="1076" left="476" width="359" height="13" font="2">of annotations matching the query. This is conceptually similar to</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="21" size="9" family="Times" color="#000000"/>
	<fontspec id="22" size="9" family="Times" color="#000000"/>
<text top="109" left="149" width="42" height="11" font="8">Operator</text>
<text top="109" left="226" width="55" height="11" font="8">Description</text>
<text top="123" left="149" width="59" height="11" font="8">Trace Parser</text>
<text top="123" left="226" width="116" height="11" font="8">Parses the raw trace ﬁle.</text>
<text top="137" left="226" width="418" height="11" font="8">Produces: <i><b>BBlk</b>(pc, instructions, side effects)</i>, <i><b>Event</b>(vector, error code, pc, side effects)</i></text>
<text top="151" left="149" width="37" height="11" font="8">Context</text>
<text top="151" left="226" width="310" height="11" font="8">Identiﬁes independent contexts of execution (threads, interrupts).</text>
<text top="164" left="226" width="448" height="11" font="8">Depends: <i><b>BBlk</b>(side effect = </i>store[TSS.esp0]|<i>mnemonic = </i>sysenter|iret|...<i>)</i>, <i><b>Event*</b></i></text>
<text top="178" left="226" width="288" height="11" font="8">Produces: <i><b>Context</b>(act id, stack addr, </i>Entry|Exit|Switch<i>)</i></text>
<text top="192" left="149" width="32" height="11" font="8">Invoke</text>
<text top="192" left="226" width="194" height="11" font="8">Identiﬁes function call and return points.</text>
<text top="205" left="226" width="289" height="11" font="8">Depends: <i><b>BBlk</b>(pc = function addr </i>| <i>instr.mnemonic = </i>ret<i>)</i></text>
<text top="219" left="226" width="280" height="11" font="8">Produces: <i><b>Invoke</b>(pc, stack pointer)</i>, <i><b>Return</b>(stack pointer)</i></text>
<text top="233" left="149" width="26" height="11" font="8">Alloc</text>
<text top="233" left="226" width="267" height="11" font="8">Tracks the allocation and release of objects on the heap.</text>
<text top="246" left="226" width="346" height="11" font="8">Depends: <i><b>Context*</b></i>, <i><b>Invoke*</b></i>, Produces: <i><b>Alloc</b>(ptr, size, pc)</i>, <i><b>Release</b>(ptr)</i></text>
<text top="260" left="149" width="52" height="11" font="8">MemTrace</text>
<text top="260" left="226" width="111" height="11" font="8">Tracks memory access.</text>
<text top="274" left="226" width="241" height="11" font="8">Depends: <i><b>BBlk</b>(side effect = </i>load[*]|store[*]<i>)</i></text>
<text top="287" left="226" width="248" height="11" font="8">Produces: <i><b>MemTrace</b>(pc, address, access size, </i>R|W<i>)</i></text>
<text top="301" left="149" width="52" height="11" font="8">HeapTrace</text>
<text top="301" left="226" width="232" height="11" font="8">Tracks accesses to objects allocated on the heap.</text>
<text top="315" left="226" width="145" height="11" font="8">Depends: <i><b>MemTrace*</b></i>, <i><b>Alloc*</b></i></text>
<text top="328" left="226" width="262" height="11" font="8">Produces: <i><b>HeapTrace</b>(pc, ptr, offsetm access size, </i>R|W<i>)</i></text>
<text top="354" left="224" width="45" height="12" font="4"><b>Table 1.</b></text>
<text top="353" left="276" width="414" height="13" font="2">Some of the current library of streaming operators available in Tralfamadore.</text>
<text top="398" left="81" width="359" height="13" font="2">a <i>select </i>operation in a relational database where a subset of the</text>
<text top="413" left="81" width="321" height="13" font="2">rows—those that match the selection criteria—are returned.</text>
<text top="439" left="81" width="12" height="15" font="6"><b>5.</b></text>
<text top="439" left="110" width="126" height="15" font="6"><b>Operator Library</b></text>
<text top="463" left="81" width="359" height="13" font="2">Whole-system analysis faces unique challenges in mapping CPU-</text>
<text top="478" left="81" width="359" height="13" font="2">level execution to source-level semantics. Our approach provides a</text>
<text top="493" left="81" width="359" height="13" font="2">framework in which new analyses can be composed from existing</text>
<text top="508" left="81" width="358" height="13" font="2">operators that reﬁne low level trace annotations into progressively</text>
<text top="523" left="81" width="359" height="13" font="2">higher-level semantics. While our focus with the system to date</text>
<text top="538" left="81" width="359" height="13" font="2">has been in studying the Linux operating system on x86 hardware,</text>
<text top="553" left="81" width="359" height="13" font="2">we have also begun work on Windows support, as well as user-</text>
<text top="568" left="81" width="359" height="13" font="2">level analysis. Extending the system in these directions is largely a</text>
<text top="583" left="81" width="359" height="13" font="2">matter of developing new operators. Tralfamadore currently hosts</text>
<text top="598" left="81" width="358" height="13" font="2">a library of about twenty operators, a subset of which are described</text>
<text top="612" left="81" width="57" height="13" font="2">in Table 1.</text>
<text top="627" left="99" width="341" height="13" font="2">Operators are intended to be standalone sections of code that</text>
<text top="642" left="81" width="359" height="13" font="2">embed a speciﬁc aspect of analysis. Lower-level operators include</text>
<text top="657" left="81" width="359" height="13" font="2">detailed knowledge about the hardware and how it is used by the</text>
<text top="672" left="81" width="359" height="13" font="2">OS, while higher-level operators encode details about how the OS</text>
<text top="687" left="81" width="359" height="13" font="2">behaves, for instance with regard to its heap management. The</text>
<text top="702" left="81" width="359" height="13" font="2">remainder of this section describes three of the more complex of</text>
<text top="717" left="81" width="248" height="13" font="2">the fundamental operators in additional detail.</text>
<text top="740" left="81" width="17" height="12" font="4"><b>5.1</b></text>
<text top="740" left="111" width="112" height="12" font="4"><b>Execution Contexts</b></text>
<text top="762" left="81" width="359" height="13" font="2">One of the primary responsibilities of an operating system is to</text>
<text top="777" left="81" width="359" height="13" font="2">schedule independent threads of execution onto shared physical</text>
<text top="792" left="81" width="359" height="13" font="2">CPUs. Since the trace is a record of instructions at the CPU level,</text>
<text top="807" left="81" width="359" height="13" font="2">these threads of control will appear to be arbitrarily interleaved. Yet</text>
<text top="821" left="81" width="359" height="13" font="2">many modes of analysis (the simplest is call ﬂow extraction) oper-</text>
<text top="836" left="81" width="359" height="13" font="2">ate on single execution ﬂows. Therefore, we provide a <i>Context </i>op-</text>
<text top="851" left="81" width="358" height="13" font="2">erator for demultiplexing the trace. Tracking contexts in operating</text>
<text top="866" left="81" width="359" height="13" font="2">systems kernels is challenging, due to the asynchronous, interrupt-</text>
<text top="881" left="81" width="359" height="13" font="2">driven environment in which they operate: a ﬂow of execution may</text>
<text top="896" left="81" width="359" height="13" font="2">be suspended and resumed for a number of reasons, including ex-</text>
<text top="911" left="81" width="359" height="13" font="2">plicit context switches, interrupts (which may be nested), and ex-</text>
<text top="926" left="81" width="359" height="13" font="2">ceptions. Identifying these transitions requires an understanding of</text>
<text top="941" left="81" width="359" height="13" font="2">both the physical architecture and how a given OS uses that ar-</text>
<text top="956" left="81" width="359" height="13" font="2">chitecture in its implementation. Speciﬁcally, the <i>Context </i>operator</text>
<text top="971" left="81" width="359" height="13" font="2">needs to track three things: the start and end of interrupt and fault</text>
<text top="986" left="81" width="359" height="13" font="2">handlers, system calls, and the occurrence of context switches from</text>
<text top="1001" left="81" width="116" height="13" font="2">one thread to another.</text>
<text top="1016" left="99" width="340" height="13" font="2">The execution of interrupt and exception handlers (including</text>
<text top="1031" left="81" width="359" height="13" font="2">system calls that use software interrupts to enter the kernel) can</text>
<text top="1046" left="81" width="359" height="13" font="2">be identiﬁed by Event annotations in the trace. At these points,</text>
<text top="1061" left="81" width="359" height="13" font="2">the current ﬂow of execution is suspended and control jumps to</text>
<text top="1076" left="81" width="358" height="13" font="2">an event handler. An <i>iret </i>instruction marks the end of handler</text>
<text top="398" left="476" width="359" height="13" font="2">execution and the resumption of the original execution context.</text>
<text top="413" left="476" width="359" height="13" font="2">System calls may also be invoked through fast entry instructions</text>
<text top="428" left="476" width="359" height="13" font="2">that do not generate events; their boundaries are identiﬁed as pairs</text>
<text top="443" left="476" width="301" height="13" font="2">of <i>sysenter/sysexit </i>Instruction annotations in the stream.</text>
<text top="458" left="493" width="341" height="13" font="2">There are multiple ways to identify software execution contexts,</text>
<text top="473" left="476" width="359" height="13" font="2">with different trade-offs. In order to pair a thread resumed by the</text>
<text top="488" left="476" width="358" height="13" font="2">operating system scheduler with its previously suspended execution</text>
<text top="503" left="476" width="359" height="13" font="2">the <i>Context </i>operator needs a mechanism to identify each thread</text>
<text top="518" left="476" width="359" height="13" font="2">in the system. One simple way to do this would be to track the</text>
<text top="533" left="476" width="359" height="13" font="2">invocation of the operating system stack switching routine such as</text>
<text top="548" left="484" width="60" height="11" font="2">switch to</text>
<text top="548" left="548" width="286" height="13" font="2">on Linux, using its argument to identify threads. We</text>
<text top="562" left="476" width="359" height="13" font="2">currently use a more generic approach (that works for both Linux</text>
<text top="577" left="476" width="359" height="13" font="2">and Windows) which is to track updates to the esp0 ﬁeld of the</text>
<text top="592" left="476" width="359" height="13" font="2">Task State Segment (TSS). This ﬁeld indicates the base address of</text>
<text top="607" left="476" width="358" height="13" font="2">the kernel stack for the task about to run. This address uniquely</text>
<text top="622" left="476" width="359" height="13" font="2">identiﬁes a thread over its lifetime and thus serves as a suitable</text>
<text top="637" left="476" width="94" height="13" font="2">context identiﬁer.</text>
<text top="652" left="493" width="341" height="13" font="2">The <i>Context </i>operator tags each ﬂow by emitting an annotation</text>
<text top="667" left="476" width="359" height="13" font="2">whenever a ﬂow of execution is suspended or resumed (whether</text>
<text top="682" left="476" width="359" height="13" font="2">due to a software context switch or a hardware interrupt). The</text>
<text top="697" left="476" width="358" height="13" font="2">ﬁrst attribute of the annotation is an activation ID that uniquely</text>
<text top="712" left="476" width="359" height="13" font="2">identiﬁes a ﬂow (such as the invocation of a system call or interrupt</text>
<text top="727" left="476" width="358" height="13" font="2">handler) over its lifetime. The second attribute is the base address</text>
<text top="742" left="476" width="359" height="13" font="2">of the kernel stack, which can be used to group all system calls</text>
<text top="757" left="476" width="155" height="13" font="2">executed by the same thread.</text>
<text top="772" left="493" width="341" height="13" font="2">To deal with nested interrupts, the operator maintains a stack</text>
<text top="787" left="476" width="359" height="13" font="2">of live activations for each thread it has seen. When an interrupt</text>
<text top="802" left="476" width="359" height="13" font="2">occurs, the operator emits an annotation with a new activation ID</text>
<text top="817" left="476" width="359" height="13" font="2">and pushes that ID on the stack. When the handler terminates,</text>
<text top="832" left="476" width="359" height="13" font="2">the operator pops its stack and emits an annotation with the ID</text>
<text top="846" left="476" width="359" height="13" font="2">of the resumed activation. Similarly, on a software context switch,</text>
<text top="861" left="476" width="359" height="13" font="2">the operator emits an annotation indicating the activation and stack</text>
<text top="876" left="476" width="164" height="13" font="2">address of the resumed thread.</text>
<text top="891" left="493" width="341" height="13" font="2">Analyses using annotations from the <i>Context </i>operator require</text>
<text top="906" left="476" width="359" height="13" font="2">no speciﬁc knowledge of Linux or the x86 architecture. They may</text>
<text top="921" left="476" width="359" height="13" font="2">simply use the annotations to identify the regions of trace that</text>
<text top="936" left="476" width="274" height="13" font="2">comprise a single activation or thread of execution.</text>
<text top="963" left="476" width="17" height="12" font="4"><b>5.2</b></text>
<text top="963" left="506" width="66" height="12" font="4"><b>Invocations</b></text>
<text top="986" left="476" width="359" height="13" font="2">The Invoke operator produces annotations that simplify the track-</text>
<text top="1001" left="476" width="358" height="13" font="2">ing of call ﬂow for downstream operators; compiler optimizations</text>
<text top="1016" left="476" width="358" height="13" font="2">such as tail call elimination can make this challenging. The operator</text>
<text top="1031" left="476" width="358" height="13" font="2">produces two annotations: <i>Invoke </i>and <i>Return</i>. The <i>Invoke </i>annota-</text>
<text top="1046" left="476" width="359" height="13" font="2">tion includes the function being called and the value of the stack</text>
<text top="1061" left="476" width="359" height="13" font="2">pointer at the time of the call. The <i>Return </i>annotation includes the</text>
<text top="1076" left="476" width="358" height="13" font="2">value of the stack pointer just before the return address is consumed</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1188" width="918">
<text top="110" left="81" width="359" height="13" font="2">by a ret instruction. The stack pointer can be used as a key to pair</text>
<text top="125" left="81" width="359" height="13" font="2">matching function calls and returns. In the case of tail call opti-</text>
<text top="140" left="81" width="359" height="13" font="2">mization where a single ret instruction will unwind multiple calls,</text>
<text top="155" left="81" width="349" height="13" font="2">a <i>Return </i>annotation will match more than one <i>Invoke </i>annotation.</text>
<text top="170" left="99" width="341" height="13" font="2">Inline functions cannot be tracked in this way, since they are</text>
<text top="185" left="81" width="359" height="13" font="2">not explicitly called. We do, however, provide limited support (re-</text>
<text top="200" left="81" width="358" height="13" font="2">stricted to control ﬂow) for inline functions based on debugging</text>
<text top="215" left="81" width="67" height="13" font="2">information.</text>
<text top="242" left="81" width="17" height="12" font="4"><b>5.3</b></text>
<text top="242" left="111" width="64" height="12" font="4"><b>Allocations</b></text>
<text top="264" left="81" width="359" height="13" font="2">The <i>Alloc </i>operator tracks the allocation of objects on the heap and</text>
<text top="279" left="81" width="359" height="13" font="2">issues annotations whenever an object is allocated or freed. It con-</text>
<text top="294" left="81" width="359" height="13" font="2">tains domain-speciﬁc knowledge of the allocation functions being</text>
<text top="309" left="81" width="359" height="13" font="2">used. The allocation annotation contains the address of the object,</text>
<text top="324" left="81" width="332" height="13" font="2">its size and the address of the caller to the allocation function.</text>
<text top="339" left="99" width="341" height="13" font="2">The biggest difﬁculty with tracking allocations is that with most</text>
<text top="354" left="81" width="359" height="13" font="2">allocators the parameters used to determine the size — either the</text>
<text top="369" left="81" width="359" height="13" font="2">size itself or a pointer to a memory pool — are passed on invoca-</text>
<text top="384" left="81" width="359" height="13" font="2">tion, but the pointer to the object is only available on return. The</text>
<text top="399" left="81" width="28" height="12" font="5"><i>Alloc</i></text>
<text top="399" left="114" width="326" height="13" font="2">operator takes advantage of the stack pointer matching pro-</text>
<text top="414" left="81" width="359" height="13" font="2">vided by the <i>Invoke </i>operator’s annotations to match the object with</text>
<text top="429" left="81" width="40" height="13" font="2">its size.</text>
<text top="455" left="81" width="17" height="12" font="4"><b>5.4</b></text>
<text top="455" left="111" width="191" height="12" font="4"><b>Putting It Together: Heap Slicing</b></text>
<text top="478" left="81" width="359" height="13" font="2">The ﬁgures in Section 3 were generated by extracting <i>heap slices</i></text>
<text top="493" left="81" width="359" height="13" font="2">from a trace of a virtual machine running the Apache web server</text>
<text top="508" left="81" width="359" height="13" font="2">on Linux. Heap slicing is a new analysis that extracts the set of</text>
<text top="523" left="81" width="359" height="13" font="2">statements that have touched a set of heap objects between their</text>
<text top="538" left="81" width="359" height="13" font="2">allocation and release. It produces a representation of where and</text>
<text top="553" left="81" width="282" height="13" font="2">how these objects are used throughout their lifetime.</text>
<text top="567" left="99" width="341" height="13" font="2">The goals of heap slicing are different than with program slic-</text>
<text top="582" left="81" width="358" height="13" font="2">ing [4, 36], a program analysis technique which extracts program</text>
<text top="597" left="81" width="359" height="13" font="2">statements that have affected the value of a variable at a speciﬁc</text>
<text top="612" left="81" width="359" height="13" font="2">point in a program. This set of statements, called a program slice,</text>
<text top="627" left="81" width="359" height="13" font="2">helps developers focus on the relevant portion of a program when</text>
<text top="642" left="81" width="359" height="13" font="2">trying to understand how and why a variable holds a certain value.</text>
<text top="657" left="81" width="359" height="13" font="2">The goal of heap slicing is more holistic as it is to provide a view</text>
<text top="672" left="81" width="321" height="13" font="2">of how an entire data-driven subsystem operates at runtime.</text>
<text top="687" left="99" width="341" height="13" font="2">The inputs to heap slicing are a function and one of its argu-</text>
<text top="702" left="81" width="359" height="13" font="2">ments which should be a pointer to a heap object. The analysis</text>
<text top="717" left="81" width="359" height="13" font="2">executes in two passes over a trace. In the ﬁrst pass, the value of</text>
<text top="732" left="81" width="359" height="13" font="2">the pointer is extracted at all points in time where the function is</text>
<text top="747" left="81" width="359" height="13" font="2">called. This pass uses the function index to only visit relevant call</text>
<text top="762" left="81" width="359" height="13" font="2">sites, skipping most of the trace. The (timestamp, pointer) tuples</text>
<text top="777" left="81" width="359" height="13" font="2">extracted in this ﬁrst pass are cross-referenced with a heap allo-</text>
<text top="792" left="81" width="359" height="13" font="2">cation index to determine the allocation and release time for each</text>
<text top="807" left="81" width="107" height="13" font="2">pointer/heap object.</text>
<text top="821" left="99" width="341" height="13" font="2">In the second pass, for every object, the analysis scans the</text>
<text top="836" left="81" width="359" height="13" font="2">trace from allocation to release to extract all accesses to the object</text>
<text top="851" left="81" width="359" height="13" font="2">throughout its lifetime. The result is an access trace for each object.</text>
<text top="866" left="81" width="359" height="13" font="2">The results are forwarded to the frontend where they are summa-</text>
<text top="881" left="81" width="359" height="13" font="2">rized in a tree, similar to the ones shown in Figure 3 and 4, where</text>
<text top="896" left="81" width="359" height="13" font="2">each access trace is inserted from the root down using longest preﬁx</text>
<text top="911" left="81" width="359" height="13" font="2">matching. The root of the tree corresponds to the allocation func-</text>
<text top="926" left="81" width="359" height="13" font="2">tion and the leaf nodes are deallocation functions. A given analysis</text>
<text top="941" left="81" width="359" height="13" font="2">can produce more than one graph if the objects were allocated by</text>
<text top="956" left="81" width="128" height="13" font="2">more than one function.</text>
<text top="971" left="99" width="341" height="13" font="2">This two pass approach is only possible with an ofﬂine frame-</text>
<text top="986" left="81" width="359" height="13" font="2">work such as Tralfamadore where multiple analyses or analysis</text>
<text top="1001" left="81" width="359" height="13" font="2">passes can execute over the same persisted execution. From an exe-</text>
<text top="1016" left="81" width="359" height="13" font="2">cution point of view, the analysis effectively goes back in time from</text>
<text top="1031" left="81" width="359" height="13" font="2">the point in time where the selected function is called to the point</text>
<text top="1046" left="81" width="358" height="13" font="2">where the object is allocated. Heap slicing could be implemented</text>
<text top="1061" left="81" width="359" height="13" font="2">in an online manner but such an implementation would be highly</text>
<text top="1076" left="81" width="359" height="13" font="2">inefﬁcient for two reasons. First, the analysis, unaware of where ob-</text>
<text top="110" left="476" width="359" height="13" font="2">jects are allocated and released, would need to examine the entire</text>
<text top="125" left="476" width="359" height="13" font="2">execution. Analysis built with Tralfamadore can leverage indices</text>
<text top="140" left="476" width="359" height="13" font="2">to only look at sections of trace containing live objects. Second,</text>
<text top="155" left="476" width="358" height="13" font="2">it would have to track memory accesses to all heap objects, and</text>
<text top="170" left="476" width="358" height="13" font="2">then discard objects that were never manipulated by the function</text>
<text top="185" left="476" width="359" height="13" font="2">of interest. Tralfamadore only needs to track accesses to the set of</text>
<text top="200" left="476" width="358" height="13" font="2">objects that will actually be part of the slice, reducing the overhead</text>
<text top="215" left="476" width="81" height="13" font="2">of the analysis.</text>
<text top="240" left="476" width="4" height="6" font="10">1</text>
<text top="240" left="487" width="68" height="6" font="10">module HeapTraceOp</text>
<text top="240" left="563" width="30" height="6" font="10">= struct</text>
<text top="249" left="476" width="4" height="6" font="10">2</text>
<text top="258" left="476" width="4" height="6" font="10">3</text>
<text top="258" left="491" width="129" height="6" font="10">(* This operator acts as a filter,</text>
<text top="267" left="476" width="4" height="6" font="10">4</text>
<text top="267" left="502" width="232" height="6" font="10">removing all annotations not part of an object heap trace. *)</text>
<text top="276" left="476" width="4" height="6" font="10">5</text>
<text top="285" left="476" width="4" height="6" font="10">6</text>
<text top="285" left="491" width="76" height="6" font="10">let rec next st () =</text>
<text top="294" left="476" width="4" height="6" font="10">7</text>
<text top="294" left="498" width="217" height="6" font="10">(* Pull the next annotation from the upstream operator *)</text>
<text top="303" left="476" width="4" height="6" font="10">8</text>
<text top="303" left="498" width="107" height="6" font="10">let a = st.m.M2Op.next () in</text>
<text top="312" left="476" width="4" height="6" font="10">9</text>
<text top="312" left="498" width="88" height="6" font="10">match a.Annot.attr with</text>
<text top="321" left="476" width="8" height="6" font="10">10</text>
<text top="321" left="498" width="72" height="6" font="10">| ‘Alloc alloc -&gt; (</text>
<text top="330" left="476" width="8" height="6" font="10">11</text>
<text top="330" left="506" width="187" height="6" font="10">st.live_obj &lt;- add_to_live_obj st.live_obj alloc;</text>
<text top="339" left="476" width="8" height="6" font="10">12</text>
<text top="339" left="506" width="4" height="6" font="10">a</text>
<text top="348" left="476" width="8" height="6" font="10">13</text>
<text top="348" left="498" width="4" height="6" font="10">)</text>
<text top="357" left="476" width="8" height="6" font="10">14</text>
<text top="357" left="498" width="72" height="6" font="10">| ‘Release rel -&gt; (</text>
<text top="366" left="476" width="8" height="6" font="10">15</text>
<text top="366" left="506" width="187" height="6" font="10">st.live_obj &lt;- del_from_live_obj st.live_obj rel;</text>
<text top="375" left="476" width="8" height="6" font="10">16</text>
<text top="375" left="506" width="149" height="6" font="10">if live_obj_is_empty st.live_obj then (</text>
<text top="384" left="476" width="8" height="6" font="10">17</text>
<text top="384" left="514" width="225" height="6" font="10">(* If there is no live obj, seek to the next allocation. *)</text>
<text top="393" left="476" width="8" height="6" font="10">18</text>
<text top="393" left="514" width="145" height="6" font="10">try st.m.M2Op.seek_1 () with EOF -&gt; ()</text>
<text top="402" left="476" width="8" height="6" font="10">19</text>
<text top="402" left="506" width="8" height="6" font="10">);</text>
<text top="411" left="476" width="8" height="6" font="10">20</text>
<text top="411" left="506" width="4" height="6" font="10">a</text>
<text top="420" left="476" width="8" height="6" font="10">21</text>
<text top="420" left="498" width="4" height="6" font="10">)</text>
<text top="429" left="476" width="8" height="6" font="10">22</text>
<text top="429" left="498" width="72" height="6" font="10">| ‘MemTrace mt -&gt; (</text>
<text top="438" left="476" width="8" height="6" font="10">23</text>
<text top="438" left="506" width="248" height="6" font="10">(* If this memtrace annotation corresponds to an access to a live</text>
<text top="447" left="476" width="8" height="6" font="10">24</text>
<text top="447" left="518" width="183" height="6" font="10">heap object, produce a heap trace annotation. *)</text>
<text top="456" left="476" width="8" height="6" font="10">25</text>
<text top="456" left="506" width="11" height="6" font="10">try</text>
<text top="465" left="476" width="8" height="6" font="10">26</text>
<text top="465" left="514" width="172" height="6" font="10">(* Find the allocation matching the access *)</text>
<text top="474" left="476" width="8" height="6" font="10">27</text>
<text top="474" left="514" width="229" height="6" font="10">let alloc = find_in_live_obj st.live_obj mt.MemTrace.addr in</text>
<text top="482" left="476" width="8" height="6" font="10">28</text>
<text top="482" left="514" width="175" height="6" font="10">let off = Guest32.sub addr alloc.Alloc.base in</text>
<text top="491" left="476" width="8" height="6" font="10">29</text>
<text top="491" left="514" width="183" height="6" font="10">‘HeapTrace { base = alloc.Alloc.base; off = off;</text>
<text top="500" left="476" width="8" height="6" font="10">30</text>
<text top="500" left="563" width="190" height="6" font="10">sz = mt.MemTrace.sz; access = mt.MemTrace.access }</text>
<text top="509" left="476" width="8" height="6" font="10">31</text>
<text top="509" left="506" width="107" height="6" font="10">with Not_found -&gt; next st ()</text>
<text top="518" left="476" width="8" height="6" font="10">32</text>
<text top="518" left="498" width="65" height="6" font="10">| _ -&gt; next st ()</text>
<text top="527" left="476" width="8" height="6" font="10">33</text>
<text top="536" left="476" width="8" height="6" font="10">34</text>
<text top="536" left="491" width="11" height="6" font="10">...</text>
<text top="545" left="476" width="8" height="6" font="10">35</text>
<text top="554" left="476" width="8" height="6" font="10">36</text>
<text top="554" left="491" width="11" height="6" font="10">end</text>
<text top="591" left="571" width="51" height="12" font="4"><b>Figure 9.</b></text>
<text top="591" left="629" width="109" height="13" font="2">HeapTrace operator.</text>
<text top="614" left="493" width="341" height="13" font="2">Figure 9 shows the core of the <i>HeapTrace </i>operator which ex-</text>
<text top="629" left="476" width="359" height="13" font="2">tracts the object access traces, skipping sections of trace without</text>
<text top="644" left="476" width="359" height="13" font="2">live objects. This example shows how an operator reuses existing</text>
<text top="659" left="476" width="359" height="13" font="2">operators to compose a new analysis. The operator writer needs not</text>
<text top="674" left="476" width="358" height="13" font="2">to be concerned with speciﬁc knowledge of the Linux kernel heap</text>
<text top="689" left="476" width="359" height="13" font="2">allocation functions or which x86 instruction touches memory. This</text>
<text top="704" left="476" width="359" height="13" font="2">knowledge is abstracted away by using the <i>Alloc </i>and <i>Release </i>an-</text>
<text top="719" left="476" width="359" height="13" font="2">notations (Line 10 and 14 respectively) produced by the <i>Alloc </i>op-</text>
<text top="734" left="476" width="359" height="13" font="2">erator, and the <i>Memtrace </i>annotations (Line 22) produced by the</text>
<text top="750" left="476" width="57" height="12" font="5"><i>MemTrace</i></text>
<text top="749" left="536" width="47" height="13" font="2">operator.</text>
<text top="778" left="476" width="12" height="15" font="6"><b>6.</b></text>
<text top="778" left="504" width="154" height="15" font="6"><b>Example Applications</b></text>
<text top="803" left="476" width="359" height="13" font="2">Tralfamadore preserves a complete execution as a data set in or-</text>
<text top="818" left="476" width="359" height="13" font="2">der to make it possible to explore it interactively in the same way</text>
<text top="833" left="476" width="359" height="13" font="2">that developers interrogate source repositories. To support this us-</text>
<text top="848" left="476" width="358" height="13" font="2">age, and to demonstrate the types of analyses that Tralfamadore</text>
<text top="863" left="476" width="359" height="13" font="2">facilitates, we have built several applications on the platform. In</text>
<text top="878" left="476" width="359" height="13" font="2">this section, we present our prototype execution browser, which in-</text>
<text top="893" left="476" width="358" height="13" font="2">tegrates interactive execution queries directly into a conventional</text>
<text top="908" left="476" width="359" height="13" font="2">source code browser using a simple and intuitive interface. We fol-</text>
<text top="922" left="476" width="358" height="13" font="2">low this with a series of more complex applications that highlight</text>
<text top="937" left="476" width="359" height="13" font="2">the development advantages of our data-driven processing archi-</text>
<text top="952" left="476" width="359" height="13" font="2">tecture, in which simple pipelines of reusable operators combine to</text>
<text top="967" left="476" width="147" height="13" font="2">produce powerful analyses.</text>
<text top="993" left="476" width="17" height="12" font="4"><b>6.1</b></text>
<text top="993" left="506" width="147" height="12" font="4"><b>Understanding Execution</b></text>
<text top="1016" left="476" width="359" height="13" font="2">Reasonably simple applications of static analysis are often used to</text>
<text top="1031" left="476" width="359" height="13" font="2">assist developers in navigating large bases of source code. Editors</text>
<text top="1046" left="476" width="358" height="13" font="2">have “tag” facilities, and often also allow developers to use a search</text>
<text top="1061" left="476" width="359" height="13" font="2">facility that is tied to a language-speciﬁc parser in order to ﬁnd</text>
<text top="1076" left="476" width="359" height="13" font="2">things like the declaration of a speciﬁc variable or the deﬁnition</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="23" size="4" family="Times" color="#656263"/>
	<fontspec id="24" size="5" family="Times" color="#656263"/>
	<fontspec id="25" size="5" family="Times" color="#231f20"/>
	<fontspec id="26" size="5" family="Times" color="#3b4ba7"/>
	<fontspec id="27" size="7" family="Times" color="#231f20"/>
	<fontspec id="28" size="8" family="Times" color="#3b4ba7"/>
	<fontspec id="29" size="7" family="Times" color="#3b4ba7"/>
	<fontspec id="30" size="7" family="Times" color="#3b4ba7"/>
	<fontspec id="31" size="4" family="Times" color="#231f20"/>
	<fontspec id="32" size="4" family="Times" color="#3b4ba7"/>
	<fontspec id="33" size="6" family="Times" color="#3b4ba7"/>
	<fontspec id="34" size="5" family="Times" color="#eeecf7"/>
	<fontspec id="35" size="5" family="Times" color="#efefef"/>
	<fontspec id="36" size="5" family="Times" color="#f4f4f4"/>
	<fontspec id="37" size="5" family="Times" color="#f3f3f3"/>
	<fontspec id="38" size="5" family="Times" color="#898788"/>
	<fontspec id="39" size="5" family="Times" color="#888687"/>
	<fontspec id="40" size="5" family="Times" color="#8e8b8c"/>
	<fontspec id="41" size="5" family="Times" color="#8d8b8b"/>
	<fontspec id="42" size="2" family="Times" color="#231f20"/>
<text top="111" left="107" width="15" height="6" font="23">2509</text>
<text top="110" left="123" width="23" height="7" font="24">     </text>
<text top="110" left="146" width="153" height="7" font="25">if (unlikely((flags &amp; SLUB_DMA)))</text>
<text top="120" left="107" width="15" height="6" font="23">2510</text>
<text top="119" left="123" width="222" height="7" font="24">         return dma_kmalloc_cache(index, flags);</text>
<text top="128" left="107" width="15" height="6" font="23">2511</text>
<text top="137" left="107" width="15" height="6" font="23">2512</text>
<text top="136" left="123" width="32" height="7" font="24"> #endif</text>
<text top="146" left="107" width="15" height="6" font="23">2513</text>
<text top="145" left="123" width="23" height="7" font="24">     </text>
<text top="145" left="146" width="139" height="7" font="25">return &amp;kmalloc_caches[index];</text>
<text top="156" left="107" width="15" height="6" font="23">2514</text>
<text top="155" left="123" width="5" height="7" font="24"> </text>
<text top="155" left="127" width="5" height="7" font="25">}</text>
<text top="163" left="107" width="15" height="6" font="23">2515</text>
<text top="173" left="107" width="15" height="6" font="23">2516</text>
<text top="172" left="123" width="5" height="7" font="24"> </text>
<text top="172" left="127" width="106" height="7" font="25">void *__kmalloc(size_t </text>
<text top="172" left="234" width="19" height="7" font="26"><b>size</b></text>
<text top="172" left="252" width="37" height="7" font="25">, gfp_t </text>
<text top="172" left="289" width="23" height="7" font="26"><b>flags</b></text>
<text top="172" left="312" width="5" height="7" font="25">)</text>
<text top="182" left="107" width="15" height="6" font="23">2517</text>
<text top="181" left="123" width="5" height="7" font="24"> </text>
<text top="181" left="127" width="5" height="7" font="25">{</text>
<text top="191" left="107" width="15" height="6" font="23">2518</text>
<text top="190" left="123" width="23" height="7" font="24">     </text>
<text top="190" left="146" width="88" height="7" font="25">struct kmem_cache *</text>
<text top="190" left="234" width="5" height="7" font="26"><b>s</b></text>
<text top="190" left="238" width="5" height="7" font="25">;</text>
<text top="199" left="107" width="15" height="6" font="23">2519</text>
<text top="208" left="107" width="15" height="6" font="23">2520</text>
<text top="207" left="123" width="23" height="7" font="24">     </text>
<text top="207" left="146" width="162" height="7" font="25">if (unlikely(size &gt; PAGE_SIZE / 2))</text>
<text top="217" left="107" width="15" height="6" font="23">2521</text>
<text top="217" left="123" width="278" height="7" font="24">         return (void *)__get_free_pages(flags | __GFP_COMP,</text>
<text top="227" left="107" width="15" height="6" font="23">2522</text>
<text top="226" left="123" width="324" height="7" font="24">                                                         get_order(siz</text>
<text top="234" left="107" width="15" height="6" font="23">2523</text>
<text top="244" left="107" width="15" height="6" font="23">2524</text>
<text top="243" left="123" width="23" height="7" font="24">     </text>
<text top="243" left="146" width="120" height="7" font="25">s = get_slab(size, flags);</text>
<text top="251" left="107" width="15" height="6" font="23">2525</text>
<text top="261" left="107" width="15" height="6" font="23">2526</text>
<text top="260" left="123" width="23" height="7" font="24">     </text>
<text top="260" left="146" width="157" height="7" font="25">if (unlikely(ZERO_OR_NULL_PTR(s)))</text>
<text top="270" left="107" width="15" height="6" font="23">2527</text>
<text top="269" left="123" width="83" height="7" font="24">         return s;</text>
<text top="278" left="107" width="15" height="6" font="23">2528</text>
<text top="287" left="107" width="15" height="6" font="23">2529</text>
<text top="286" left="123" width="23" height="7" font="24">     </text>
<text top="286" left="146" width="282" height="7" font="25">return slab_alloc(s, flags, -1, __builtin_return_address(0));</text>
<text top="296" left="107" width="15" height="6" font="23">2530</text>
<text top="295" left="123" width="5" height="7" font="24"> </text>
<text top="295" left="127" width="5" height="7" font="25">}</text>
<text top="305" left="107" width="15" height="6" font="23">2531</text>
<text top="305" left="123" width="5" height="7" font="24"> </text>
<text top="305" left="127" width="116" height="7" font="25">EXPORT_SYMBOL(__kmalloc);</text>
<text top="313" left="107" width="15" height="6" font="23">2532</text>
<text top="322" left="107" width="15" height="6" font="23">2533</text>
<text top="322" left="123" width="88" height="7" font="24"> #ifdef CONFIG_NUMA</text>
<text top="332" left="107" width="15" height="6" font="23">2534</text>
<text top="331" left="123" width="5" height="7" font="24"> </text>
<text top="331" left="127" width="259" height="7" font="25">void *__kmalloc_node(size_t size, gfp_t flags, int node)</text>
<text top="341" left="107" width="15" height="6" font="23">2535</text>
<text top="340" left="123" width="5" height="7" font="24"> </text>
<text top="340" left="127" width="5" height="7" font="25">{</text>
<text top="350" left="107" width="15" height="6" font="23">2536</text>
<text top="349" left="123" width="120" height="7" font="24">     struct kmem_cache *s;</text>
<text top="358" left="107" width="15" height="6" font="23">2537</text>
<text top="367" left="107" width="15" height="6" font="23">2538</text>
<text top="366" left="123" width="185" height="7" font="24">     if (unlikely(size &gt; PAGE_SIZE / 2))</text>
<text top="376" left="107" width="15" height="6" font="23">2539</text>
<text top="376" left="123" width="282" height="7" font="24">         return (void *)__get_free_pages(flags | __GFP_COMP, </text>
<text top="188" left="238" width="20" height="9" font="27">Get </text>
<text top="187" left="258" width="32" height="10" font="28">values</text>
<text top="188" left="291" width="7" height="9" font="29">  </text>
<text top="188" left="297" width="13" height="9" font="27">or </text>
<text top="187" left="311" width="47" height="10" font="28">data flow</text>
<text top="188" left="358" width="7" height="9" font="29">  </text>
<text top="188" left="364" width="58" height="9" font="27">for variable </text>
<text top="188" left="422" width="21" height="7" font="30"><b>size</b></text>
<text top="209" left="340" width="34" height="6" font="31">max rows:</text>
<text top="209" left="378" width="10" height="7" font="25">10</text>
<text top="209" left="242" width="32" height="7" font="31">sort  by  </text>
<text top="209" left="274" width="35" height="7" font="32">frequency</text>
<text top="209" left="309" width="3" height="7" font="31">|</text>
<text top="209" left="312" width="19" height="7" font="32">value</text>
<text top="224" left="245" width="37" height="8" font="33"><b>256:565</b></text>
<text top="237" left="245" width="32" height="8" font="33"><b>19:353</b></text>
<text top="250" left="244" width="37" height="8" font="33"><b>192:353</b></text>
<text top="264" left="244" width="32" height="8" font="33"><b>41:144</b></text>
<text top="278" left="245" width="37" height="8" font="33"><b>224:143</b></text>
<text top="290" left="245" width="32" height="8" font="33"><b>42:126</b></text>
<text top="304" left="244" width="32" height="8" font="33"><b>43:125</b></text>
<text top="318" left="244" width="32" height="8" font="33"><b>40:123</b></text>
<text top="330" left="244" width="32" height="8" font="33"><b>44:111</b></text>
<text top="344" left="245" width="27" height="8" font="33"><b>39:98</b></text>
<text top="111" left="108" width="15" height="6" font="23">2509</text>
<text top="110" left="123" width="23" height="7" font="24">     </text>
<text top="110" left="146" width="153" height="7" font="25">if (unlikely((flags &amp; SLUB_DMA)))</text>
<text top="120" left="108" width="15" height="6" font="23">2510</text>
<text top="119" left="123" width="222" height="7" font="24">         return dma_kmalloc_cache(index, flags);</text>
<text top="129" left="108" width="15" height="6" font="23">2511</text>
<text top="128" left="123" width="5" height="7" font="24"> </text>
<text top="139" left="108" width="15" height="6" font="23">2512</text>
<text top="138" left="123" width="32" height="7" font="24"> #endif</text>
<text top="148" left="108" width="15" height="6" font="23">2513</text>
<text top="147" left="123" width="23" height="7" font="24">     </text>
<text top="147" left="146" width="139" height="7" font="25">return &amp;kmalloc_caches[index];</text>
<text top="157" left="108" width="15" height="6" font="23">2514</text>
<text top="156" left="123" width="5" height="7" font="24"> </text>
<text top="156" left="128" width="5" height="7" font="25">}</text>
<text top="166" left="108" width="15" height="6" font="23">2515</text>
<text top="166" left="123" width="5" height="7" font="24"> </text>
<text top="176" left="108" width="15" height="6" font="23">2516</text>
<text top="175" left="123" width="5" height="7" font="24"> </text>
<text top="175" left="128" width="106" height="7" font="25">void *__kmalloc(size_t </text>
<text top="175" left="234" width="19" height="7" font="26"><b>size</b></text>
<text top="175" left="253" width="37" height="7" font="25">, gfp_t </text>
<text top="175" left="290" width="23" height="7" font="26"><b>flags</b></text>
<text top="175" left="313" width="5" height="7" font="25">)</text>
<text top="185" left="108" width="15" height="6" font="23">2517</text>
<text top="184" left="123" width="5" height="7" font="24"> </text>
<text top="184" left="128" width="5" height="7" font="25">{</text>
<text top="194" left="108" width="15" height="6" font="23">2518</text>
<text top="193" left="123" width="23" height="7" font="24">     </text>
<text top="193" left="146" width="88" height="7" font="25">struct kmem_cache *</text>
<text top="194" left="234" width="5" height="7" font="26"><b>s</b></text>
<text top="193" left="239" width="5" height="7" font="25">;</text>
<text top="203" left="108" width="15" height="6" font="23">2519</text>
<text top="203" left="123" width="5" height="7" font="24"> </text>
<text top="213" left="108" width="15" height="6" font="23">2520</text>
<text top="212" left="123" width="23" height="7" font="24">     </text>
<text top="212" left="146" width="162" height="7" font="25">if (unlikely(size &gt; PAGE_SIZE / 2))</text>
<text top="222" left="108" width="15" height="6" font="23">2521</text>
<text top="221" left="123" width="278" height="7" font="24">         return (void *)__get_free_pages(flags | __GFP_COMP,</text>
<text top="231" left="108" width="15" height="6" font="23">2522</text>
<text top="230" left="123" width="324" height="7" font="24">                                                         get_order(siz</text>
<text top="241" left="108" width="15" height="6" font="23">2523</text>
<text top="240" left="123" width="5" height="7" font="24"> </text>
<text top="250" left="108" width="15" height="6" font="23">2524</text>
<text top="249" left="123" width="23" height="7" font="24">     </text>
<text top="249" left="146" width="120" height="7" font="25">s = get_slab(size, flags);</text>
<text top="259" left="108" width="15" height="6" font="23">2525</text>
<text top="258" left="123" width="5" height="7" font="24"> </text>
<text top="268" left="108" width="15" height="6" font="23">2526</text>
<text top="267" left="123" width="23" height="7" font="24">     </text>
<text top="267" left="146" width="157" height="7" font="25">if (unlikely(ZERO_OR_NULL_PTR(s)))</text>
<text top="278" left="108" width="15" height="6" font="23">2527</text>
<text top="277" left="123" width="83" height="7" font="24">         return s;</text>
<text top="287" left="108" width="15" height="6" font="23">2528</text>
<text top="286" left="123" width="5" height="7" font="24"> </text>
<text top="296" left="108" width="15" height="6" font="23">2529</text>
<text top="295" left="123" width="23" height="7" font="24">     </text>
<text top="295" left="146" width="282" height="7" font="25">return slab_alloc(s, flags, -1, __builtin_return_address(0));</text>
<text top="305" left="108" width="15" height="6" font="23">2530</text>
<text top="305" left="123" width="5" height="7" font="24"> </text>
<text top="305" left="128" width="5" height="7" font="25">}</text>
<text top="315" left="108" width="15" height="6" font="23">2531</text>
<text top="314" left="123" width="5" height="7" font="24"> </text>
<text top="314" left="128" width="116" height="7" font="25">EXPORT_SYMBOL(__kmalloc);</text>
<text top="324" left="108" width="15" height="6" font="23">2532</text>
<text top="323" left="123" width="5" height="7" font="24"> </text>
<text top="333" left="108" width="15" height="6" font="23">2533</text>
<text top="332" left="123" width="88" height="7" font="24"> #ifdef CONFIG_NUMA</text>
<text top="342" left="108" width="15" height="6" font="23">2534</text>
<text top="342" left="123" width="5" height="7" font="24"> </text>
<text top="342" left="128" width="259" height="7" font="25">void *__kmalloc_node(size_t size, gfp_t flags, int node)</text>
<text top="352" left="108" width="15" height="6" font="23">2535</text>
<text top="351" left="123" width="5" height="7" font="24"> </text>
<text top="351" left="128" width="5" height="7" font="25">{</text>
<text top="361" left="108" width="15" height="6" font="23">2536</text>
<text top="360" left="123" width="120" height="7" font="24">     struct kmem_cache *s;</text>
<text top="370" left="108" width="15" height="6" font="23">2537</text>
<text top="369" left="123" width="5" height="7" font="24"> </text>
<text top="380" left="108" width="15" height="6" font="23">2538</text>
<text top="379" left="123" width="185" height="7" font="24">     if (unlikely(size &gt; PAGE_SIZE / 2))</text>
<text top="194" left="234" width="5" height="7" font="34"><b>s</b></text>
<text top="193" left="239" width="5" height="7" font="35">;</text>
<text top="212" left="230" width="79" height="7" font="35">&gt; PAGE_SIZE / 2))</text>
<text top="221" left="234" width="28" height="7" font="36">__get_</text>
<text top="221" left="281" width="19" height="7" font="36">_pag</text>
<text top="221" left="308" width="9" height="7" font="36">(f</text>
<text top="221" left="327" width="37" height="7" font="36">gs | __G</text>
<text top="221" left="373" width="9" height="7" font="36">_C</text>
<text top="221" left="392" width="9" height="7" font="36">P,</text>
<text top="221" left="123" width="278" height="7" font="37">         return (void *)__get_free_pages(flags | __GFP_COMP,</text>
<text top="230" left="234" width="213" height="7" font="36">                                 get_order(siz</text>
<text top="230" left="123" width="324" height="7" font="37">                                                         get_order(siz</text>
<text top="249" left="230" width="37" height="7" font="35"> flags);</text>
<text top="267" left="230" width="74" height="7" font="35">OR_NULL_PTR(s)))</text>
<text top="295" left="146" width="282" height="7" font="35">return slab_alloc(s, flags, -1, __builtin_return_address(0));</text>
<text top="314" left="128" width="116" height="7" font="35">EXPORT_SYMBOL(__kmalloc);</text>
<text top="342" left="230" width="157" height="7" font="35">ize_t size, gfp_t flags, int node)</text>
<text top="360" left="225" width="19" height="7" font="36"> *s;</text>
<text top="193" left="230" width="5" height="7" font="38">*</text>
<text top="193" left="146" width="88" height="7" font="39">struct kmem_cache *</text>
<text top="212" left="230" width="9" height="7" font="38">&gt; </text>
<text top="221" left="225" width="19" height="7" font="40">*)__</text>
<text top="221" left="123" width="278" height="7" font="41">         return (void *)__get_free_pages(flags | __GFP_COMP,</text>
<text top="230" left="438" width="9" height="7" font="40">iz</text>
<text top="230" left="123" width="324" height="7" font="41">                                                         get_order(siz</text>
<text top="230" left="234" width="9" height="7" font="40">  </text>
<text top="230" left="123" width="324" height="7" font="41">                                                         get_order(siz</text>
<text top="249" left="230" width="9" height="7" font="38"> f</text>
<text top="267" left="230" width="9" height="7" font="38">OR</text>
<text top="295" left="146" width="282" height="7" font="39">return slab_alloc(s, flags, -1, __builtin_return_address(0));</text>
<text top="314" left="128" width="116" height="7" font="39">EXPORT_SYMBOL(__kmalloc);</text>
<text top="342" left="230" width="9" height="7" font="38">iz</text>
<text top="360" left="225" width="9" height="7" font="40"> *</text>
<text top="190" left="239" width="20" height="9" font="27">Get </text>
<text top="190" left="259" width="36" height="10" font="28">values </text>
<text top="190" left="295" width="13" height="9" font="27">or </text>
<text top="190" left="308" width="51" height="10" font="28">heap slice</text>
<text top="190" left="359" width="3" height="9" font="29"> </text>
<text top="190" left="362" width="58" height="9" font="27">for variable </text>
<text top="190" left="420" width="21" height="7" font="30"><b>size</b></text>
<text top="209" left="341" width="34" height="6" font="31">max rows:</text>
<text top="209" left="378" width="10" height="7" font="25">10</text>
<text top="209" left="243" width="32" height="7" font="31">sort  by  </text>
<text top="209" left="275" width="35" height="7" font="32">frequency</text>
<text top="209" left="309" width="3" height="7" font="31">|</text>
<text top="209" left="313" width="19" height="7" font="32">value</text>
<text top="224" left="245" width="37" height="8" font="33"><b>256:565</b></text>
<text top="237" left="245" width="32" height="8" font="33"><b>19:353</b></text>
<text top="250" left="245" width="37" height="8" font="33"><b>192:353</b></text>
<text top="264" left="245" width="32" height="8" font="33"><b>41:144</b></text>
<text top="278" left="245" width="37" height="8" font="33"><b>224:143</b></text>
<text top="290" left="245" width="32" height="8" font="33"><b>42:126</b></text>
<text top="304" left="245" width="32" height="8" font="33"><b>43:125</b></text>
<text top="318" left="245" width="32" height="8" font="33"><b>40:123</b></text>
<text top="330" left="245" width="32" height="8" font="33"><b>44:111</b></text>
<text top="344" left="245" width="27" height="8" font="33"><b>39:98</b></text>
<text top="111" left="462" width="15" height="6" font="23">1753</text>
<text top="110" left="478" width="9" height="7" font="24"> *</text>
<text top="121" left="462" width="15" height="6" font="23">1754</text>
<text top="120" left="478" width="79" height="7" font="24"> * return values:</text>
<text top="130" left="462" width="15" height="6" font="23">1755</text>
<text top="129" left="478" width="153" height="7" font="24"> * NET_RX_SUCCESS (no congestion)</text>
<text top="139" left="462" width="15" height="6" font="23">1756</text>
<text top="138" left="478" width="162" height="7" font="24"> * NET_RX_DROP (packet was dropped)</text>
<text top="148" left="462" width="15" height="6" font="23">1757</text>
<text top="148" left="478" width="9" height="7" font="24"> *</text>
<text top="158" left="462" width="15" height="6" font="23">1758</text>
<text top="157" left="478" width="5" height="7" font="24"> </text>
<text top="157" left="482" width="9" height="7" font="25">*/</text>
<text top="167" left="462" width="15" height="6" font="23">1759</text>
<text top="166" left="478" width="5" height="7" font="24"> </text>
<text top="176" left="462" width="15" height="6" font="23">1760</text>
<text top="175" left="478" width="5" height="7" font="24"> </text>
<text top="175" left="482" width="134" height="7" font="25">int netif_rx(struct sk_buff *</text>
<text top="176" left="617" width="14" height="7" font="26"><b>skb</b></text>
<text top="175" left="631" width="5" height="7" font="25">)</text>
<text top="185" left="462" width="15" height="6" font="23">1761</text>
<text top="185" left="478" width="5" height="7" font="24"> </text>
<text top="185" left="482" width="5" height="7" font="25">{</text>
<text top="195" left="462" width="15" height="6" font="23">1762</text>
<text top="194" left="478" width="14" height="7" font="24">   </text>
<text top="194" left="492" width="97" height="7" font="25">struct softnet_data *</text>
<text top="194" left="589" width="23" height="7" font="26"><b>queue</b></text>
<text top="194" left="612" width="5" height="7" font="25">;</text>
<text top="204" left="462" width="15" height="6" font="23">1763</text>
<text top="203" left="478" width="14" height="7" font="24">   </text>
<text top="203" left="492" width="65" height="7" font="25">unsigned long </text>
<text top="203" left="557" width="23" height="7" font="26"><b>flags</b></text>
<text top="203" left="580" width="5" height="7" font="25">;</text>
<text top="213" left="462" width="15" height="6" font="23">1764</text>
<text top="212" left="478" width="5" height="7" font="24"> </text>
<text top="223" left="462" width="15" height="6" font="23">1765</text>
<text top="222" left="478" width="245" height="7" font="24">   /* if netpoll wants it, pretend we never saw it */</text>
<text top="232" left="462" width="15" height="6" font="23">1766</text>
<text top="231" left="478" width="111" height="7" font="24">   if (netpoll_rx(skb)) </text>
<text top="241" left="462" width="15" height="6" font="23">1767</text>
<text top="240" left="478" width="134" height="7" font="24">          return NET_RX_DROP;</text>
<text top="250" left="462" width="15" height="6" font="23">1768</text>
<text top="249" left="478" width="14" height="7" font="24">   </text>
<text top="260" left="462" width="15" height="6" font="23">1769</text>
<text top="259" left="478" width="14" height="7" font="24">   </text>
<text top="259" left="492" width="106" height="7" font="25">if (!skb-&gt;tstamp.tv64) </text>
<text top="269" left="462" width="15" height="6" font="23">1770</text>
<text top="268" left="478" width="134" height="7" font="24">          net_timestamp(skb);</text>
<text top="278" left="462" width="15" height="6" font="23">1771</text>
<text top="277" left="478" width="28" height="7" font="24">      </text>
<text top="287" left="462" width="15" height="6" font="23">1772</text>
<text top="287" left="478" width="23" height="7" font="24">   /*</text>
<text top="297" left="462" width="15" height="6" font="23">1773</text>
<text top="296" left="478" width="264" height="7" font="24">    * The code is rearranged so that the path is the most</text>
<text top="306" left="462" width="15" height="6" font="23">1774</text>
<text top="305" left="478" width="268" height="7" font="24">    * short when CPU is congested, but is still operating.</text>
<text top="315" left="462" width="15" height="6" font="23">1775</text>
<text top="314" left="478" width="28" height="7" font="24">    */</text>
<text top="324" left="462" width="15" height="6" font="23">1776</text>
<text top="324" left="478" width="116" height="7" font="24">   local_irq_save(flags);</text>
<text top="334" left="462" width="15" height="6" font="23">1777</text>
<text top="333" left="478" width="14" height="7" font="24">   </text>
<text top="333" left="492" width="171" height="7" font="25">queue = &amp;__get_cpu_var(softnet_data);</text>
<text top="343" left="462" width="15" height="6" font="23">1778</text>
<text top="342" left="478" width="9" height="7" font="24">  </text>
<text top="352" left="462" width="15" height="6" font="23">1779</text>
<text top="351" left="478" width="14" height="7" font="24">   </text>
<text top="351" left="492" width="176" height="7" font="25">__get_cpu_var(netdev_rx_stat).total++;</text>
<text top="362" left="462" width="15" height="6" font="23">1780</text>
<text top="361" left="478" width="14" height="7" font="24">   </text>
<text top="361" left="492" width="259" height="7" font="25">if (queue-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog) {</text>
<text top="371" left="462" width="15" height="6" font="23">1781</text>
<text top="370" left="478" width="46" height="7" font="24">          </text>
<text top="370" left="524" width="157" height="7" font="25">if (queue-&gt;input_pkt_queue.qlen) {</text>
<text top="380" left="462" width="15" height="6" font="23">1782</text>
<text top="379" left="478" width="5" height="7" font="24"> </text>
<text top="379" left="482" width="37" height="7" font="25">enqueue:</text>
<text top="194" left="575" width="14" height="7" font="35">a *</text>
<text top="194" left="492" width="97" height="7" font="35">struct softnet_data *</text>
<text top="194" left="589" width="23" height="7" font="34"><b>queue</b></text>
<text top="194" left="589" width="23" height="7" font="34"><b>queue</b></text>
<text top="194" left="612" width="5" height="7" font="35">;</text>
<text top="203" left="566" width="14" height="7" font="34"><b>ags</b></text>
<text top="203" left="557" width="23" height="7" font="34"><b>flags</b></text>
<text top="203" left="580" width="5" height="7" font="35">;</text>
<text top="222" left="478" width="245" height="7" font="37">   /* if netpoll wants it, pretend we never saw it */</text>
<text top="231" left="570" width="19" height="7" font="36">b)) </text>
<text top="231" left="478" width="111" height="7" font="37">   if (netpoll_rx(skb)) </text>
<text top="240" left="570" width="19" height="7" font="36">_RX_</text>
<text top="240" left="607" width="5" height="7" font="36">;</text>
<text top="240" left="478" width="134" height="7" font="37">          return NET_RX_DROP;</text>
<text top="259" left="492" width="106" height="7" font="35">if (!skb-&gt;tstamp.tv64) </text>
<text top="268" left="570" width="42" height="7" font="36">amp(skb);</text>
<text top="296" left="478" width="264" height="7" font="37">    * The code is rearranged so that the path is the most</text>
<text top="305" left="570" width="176" height="7" font="36"> is congested, but is still operating.</text>
<text top="324" left="570" width="23" height="7" font="36">ags);</text>
<text top="333" left="492" width="171" height="7" font="35">queue = &amp;__get_cpu_var(softnet_data);</text>
<text top="351" left="492" width="176" height="7" font="35">__get_cpu_var(netdev_rx_stat).total++;</text>
<text top="361" left="575" width="176" height="7" font="35">kt_queue.qlen &lt;= netdev_max_backlog) {</text>
<text top="370" left="524" width="157" height="7" font="35">if (queue-&gt;input_pkt_queue.qlen) {</text>
<text top="190" left="579" width="20" height="9" font="27">Get </text>
<text top="189" left="599" width="32" height="10" font="28">values</text>
<text top="190" left="631" width="3" height="9" font="29"> </text>
<text top="190" left="635" width="13" height="9" font="27">or </text>
<text top="189" left="648" width="51" height="10" font="28">heap slice</text>
<text top="190" left="699" width="3" height="9" font="29"> </text>
<text top="190" left="702" width="58" height="9" font="27">for variable </text>
<text top="190" left="760" width="19" height="7" font="30"><b>skb</b></text>
<text top="382" left="766" width="5" height="4" font="42"><b>11</b></text>
<text top="382" left="720" width="3" height="4" font="42"><b>1</b></text>
<text top="308" left="656" width="8" height="4" font="42"><b>113</b></text>
<text top="271" left="693" width="8" height="4" font="42"><b>124</b></text>
<text top="290" left="693" width="8" height="4" font="42"><b>124</b></text>
<text top="309" left="727" width="5" height="4" font="42"><b>11</b></text>
<text top="326" left="619" width="8" height="4" font="42"><b>113</b></text>
<text top="346" left="680" width="3" height="4" font="42"><b>1</b></text>
<text top="345" left="643" width="6" height="4" font="42"><b>26</b></text>
<text top="364" left="654" width="6" height="4" font="42"><b>26</b></text>
<text top="364" left="720" width="3" height="4" font="42"><b>1</b></text>
<text top="253" left="693" width="8" height="4" font="42"><b>124</b></text>
<text top="234" left="693" width="8" height="4" font="42"><b>124</b></text>
<text top="215" left="693" width="8" height="4" font="42"><b>124</b></text>
<text top="327" left="766" width="5" height="4" font="42"><b>11</b></text>
<text top="345" left="766" width="5" height="4" font="42"><b>11</b></text>
<text top="363" left="767" width="5" height="4" font="42"><b>11</b></text>
<text top="364" left="597" width="6" height="4" font="42"><b>86</b></text>
<text top="345" left="599" width="6" height="4" font="42"><b>86</b></text>
<text top="263" left="678" width="38" height="4" font="42"><b>eth_type_trans</b></text>
<text top="281" left="684" width="27" height="4" font="42"><b>ei_recieve</b></text>
<text top="299" left="687" width="22" height="4" font="42"><b>netif_rx</b></text>
<text top="317" left="603" width="41" height="4" font="42"><b>process_backlog</b></text>
<text top="318" left="750" width="41" height="4" font="42"><b>process_backlog</b></text>
<text top="336" left="747" width="46" height="4" font="42"><b>netif_receive_skb</b></text>
<text top="354" left="647" width="19" height="4" font="42"><b>arp_rcv</b></text>
<text top="354" left="763" width="16" height="4" font="42"><b>ip_rcv</b></text>
<text top="354" left="712" width="22" height="4" font="42"><b>ipv6_rcv</b></text>
<text top="207" left="682" width="30" height="4" font="42"><b>__alloc_skb</b></text>
<text top="226" left="683" width="27" height="4" font="42"><b>ei_recieve</b></text>
<text top="244" left="670" width="55" height="4" font="42"><b>ne2k_pci_block_input</b></text>
<text top="354" left="592" width="16" height="4" font="42"><b>ip_rcv</b></text>
<text top="336" left="601" width="46" height="4" font="42"><b>netif_receive_skb</b></text>
<text top="372" left="751" width="38" height="4" font="42"><b>ip_rcvp_finish</b></text>
<text top="373" left="704" width="41" height="4" font="42"><b>ip6_route_input</b></text>
<text top="373" left="582" width="36" height="4" font="42"><b>ip_rcv_finish</b></text>
<text top="382" left="608" width="3" height="4" font="42"><b>1</b></text>
<text top="382" left="595" width="6" height="4" font="42"><b>28</b></text>
<text top="382" left="583" width="6" height="4" font="42"><b>58</b></text>
<text top="382" left="660" width="3" height="4" font="42"><b>1</b></text>
<text top="382" left="647" width="6" height="4" font="42"><b>25</b></text>
<text top="373" left="643" width="30" height="4" font="42"><b>arp_process</b></text>
<text top="407" left="186" width="58" height="12" font="4"><b>Figure 10.</b></text>
<text top="407" left="251" width="478" height="13" font="2">Live data value and heap slice analyses from the source understanding tool. (Section 6.1)</text>
<text top="452" left="81" width="359" height="13" font="2">of some function. Dynamic techniques have also been applied to</text>
<text top="467" left="81" width="359" height="13" font="2">help developers understand how source behaves under execution by</text>
<text top="482" left="81" width="359" height="13" font="2">exposing details such as proﬁling and coverage information. With</text>
<text top="497" left="81" width="359" height="13" font="2">Tralfamadore, we felt that a signiﬁcantly more powerful tool could</text>
<text top="512" left="81" width="359" height="13" font="2">be provided for understanding program execution. We have devel-</text>
<text top="526" left="81" width="359" height="13" font="2">oped a web-based source navigator that maps interactive analysis</text>
<text top="541" left="81" width="188" height="13" font="2">tools directly onto the source code.</text>
<text top="556" left="99" width="341" height="13" font="2">In a previous paper [18], we described an early prototype of this</text>
<text top="571" left="81" width="359" height="13" font="2">source navigator that maps binary trace information into source-</text>
<text top="586" left="81" width="359" height="13" font="2">level call and control ﬂow graphs. With this initial support, a func-</text>
<text top="601" left="81" width="359" height="13" font="2">tion in source can be annotated with a graph that shows the speciﬁc</text>
<text top="616" left="81" width="359" height="13" font="2">unique control ﬂow paths that travel through it, and allows devel-</text>
<text top="631" left="81" width="359" height="13" font="2">opers to choose between focusing on the common case, outliers, or</text>
<text top="646" left="81" width="243" height="13" font="2">unexecuted code, depending on their interest.</text>
<text top="661" left="99" width="341" height="13" font="2">Figure 10 shows the interface provided by our source under-</text>
<text top="676" left="81" width="359" height="13" font="2">standing tool for two new data-oriented analyses. From the source</text>
<text top="691" left="81" width="359" height="13" font="2">browser, a developer may select a function parameter and request</text>
<text top="706" left="81" width="359" height="13" font="2">a histogram of the values of that parameter across all calls to the</text>
<text top="721" left="81" width="359" height="13" font="2">function, or, in the case of pointers to heap objects, they may gen-</text>
<text top="736" left="81" width="359" height="13" font="2">erate a data ﬂow graph that summarizes all accesses to the set of</text>
<text top="751" left="81" width="359" height="13" font="2">objects passed to that function. Partial results are streamed into the</text>
<text top="765" left="81" width="359" height="13" font="2">browser over AJAX as soon as they become available, and the result</text>
<text top="780" left="81" width="286" height="13" font="2">set is continuously updated as the query is processed.</text>
<text top="802" left="81" width="27" height="12" font="4"><b>6.1.1</b></text>
<text top="802" left="121" width="164" height="12" font="4"><b>Argument value distribution</b></text>
<text top="823" left="81" width="359" height="13" font="2">The left-hand side of Figure 10 shows an online query in which a</text>
<text top="838" left="81" width="200" height="13" font="2">user browsing the source to the Linux</text>
<text top="839" left="294" width="48" height="11" font="2">kmalloc</text>
<text top="838" left="345" width="95" height="13" font="2">memory allocator</text>
<text top="853" left="81" width="358" height="13" font="2">has become curious about the size of allocation requests observed</text>
<text top="868" left="81" width="359" height="13" font="2">during a trace. She clicks on the size argument to the function and</text>
<text top="883" left="81" width="359" height="13" font="2">is presented with a pop-up window in which she can select from one</text>
<text top="898" left="81" width="359" height="13" font="2">of two variable queries. In this case, she chooses the <i>values </i>option.</text>
<text top="913" left="81" width="359" height="13" font="2">Immediately, a histogram appears showing the sizes observed in the</text>
<text top="928" left="81" width="359" height="13" font="2">trace. At the point seen in the ﬁgure, the query has been running for</text>
<text top="943" left="81" width="359" height="13" font="2">1 second and shows that the most commonly requested object size</text>
<text top="958" left="81" width="101" height="13" font="2">so far is 256 bytes.</text>
<text top="980" left="81" width="27" height="12" font="4"><b>6.1.2</b></text>
<text top="980" left="121" width="73" height="12" font="4"><b>Heap Slicing</b></text>
<text top="1001" left="81" width="359" height="13" font="2">On the right of Figure 10 is a screen capture of a heap slicing</text>
<text top="1016" left="81" width="359" height="13" font="2">query in progress (ﬁgures in Section 3 were generated by this tool</text>
<text top="1031" left="81" width="358" height="13" font="2">and adjusted for presentation). In this case, the user has clicked</text>
<text top="1046" left="81" width="359" height="13" font="2">on the skb parameter of the netif rx function and chosen the</text>
<text top="1061" left="81" width="66" height="12" font="5"><i>heap slicing</i></text>
<text top="1061" left="151" width="288" height="13" font="2">option. The heap slice of all packets passing through</text>
<text top="1076" left="81" width="53" height="11" font="2">netif rx</text>
<text top="1076" left="137" width="260" height="13" font="2">begins to form, stabilizing within a few seconds.</text>
<text top="452" left="493" width="341" height="13" font="2">This example extends recent work in visualizing data ﬂow in</text>
<text top="467" left="476" width="359" height="13" font="2">systems code [23], by allowing the dynamic and <i>interactive </i>map-</text>
<text top="482" left="476" width="359" height="13" font="2">ping of arbitrary objects in source to a graph illustrating the use</text>
<text top="497" left="476" width="359" height="13" font="2">of all instances of that object in actual execution. In the future, we</text>
<text top="512" left="476" width="359" height="13" font="2">hope to extend this tool to allow users to navigate execution by it-</text>
<text top="526" left="476" width="358" height="13" font="2">eratively following this sort of graph across both control ﬂow and</text>
<text top="541" left="476" width="207" height="13" font="2">data ﬂow representations of execution.</text>
<text top="563" left="476" width="17" height="12" font="4"><b>6.2</b></text>
<text top="563" left="506" width="129" height="12" font="4"><b>Retroactive Assertions</b></text>
<text top="584" left="476" width="359" height="13" font="2">The use of assertions is common practice when attempting to de-</text>
<text top="599" left="476" width="359" height="13" font="2">bug, understand, or otherwise validate assumptions about the way</text>
<text top="614" left="476" width="359" height="13" font="2">that a system is behaving. Unfortunately, they typically must be</text>
<text top="629" left="476" width="358" height="13" font="2">made <i>a priori</i>, either by compiling assert statements into source</text>
<text top="644" left="476" width="359" height="13" font="2">or inserting dynamic probes prior to running a system. VAssert [2]</text>
<text top="659" left="476" width="358" height="13" font="2">partly solves this problem by allowing assertions on applications</text>
<text top="674" left="476" width="359" height="13" font="2">running in a virtual machine to be validated during replay, but while</text>
<text top="689" left="476" width="359" height="13" font="2">they allow the evaluations of assertions to be deferred, the asser-</text>
<text top="704" left="476" width="359" height="13" font="2">tions themselves are no more powerful. We now consider the use of</text>
<text top="719" left="476" width="359" height="13" font="2">Tralfamadore to validate <i>retroactive assertions </i>that would be very</text>
<text top="734" left="476" width="211" height="13" font="2">difﬁcult to write in the traditional style.</text>
<text top="756" left="476" width="27" height="12" font="4"><b>6.2.1</b></text>
<text top="756" left="516" width="119" height="12" font="4"><b>Ownership Violation</b></text>
<text top="777" left="476" width="359" height="13" font="2">For simplicity and scalability, applications desire to use as little</text>
<text top="792" left="476" width="358" height="13" font="2">locking as possible. In Linux, for example, many functions assume</text>
<text top="807" left="476" width="359" height="13" font="2">that their objects are never accessed in interrupt context. They may</text>
<text top="822" left="476" width="121" height="13" font="2">use runtime assertions</text>
<text top="819" left="596" width="5" height="10" font="7">3</text>
<text top="822" left="606" width="228" height="13" font="2">to catch some violations, but it is difﬁcult</text>
<text top="837" left="476" width="314" height="13" font="2">to be assured that all possible accesses have been guarded.</text>
<text top="852" left="493" width="341" height="13" font="2">Tralfamadore makes it straightforward to validate whether such</text>
<text top="867" left="476" width="359" height="13" font="2">an assumption holds throughout the duration of a trace, and can</text>
<text top="882" left="476" width="359" height="13" font="2">additionally produce a detailed report about the violation. Here</text>
<text top="897" left="476" width="358" height="13" font="2">we present a simple <i>ownership </i>assertion that detects whenever</text>
<text top="912" left="476" width="359" height="13" font="2">an object is accessed by contexts other than the one in which it</text>
<text top="927" left="476" width="359" height="13" font="2">was allocated, which may be checked against all instances of a</text>
<text top="942" left="476" width="359" height="13" font="2">given object type within the trace. The algorithm is a reﬁnement</text>
<text top="957" left="476" width="359" height="13" font="2">of the heap slicing algorithm presented in Section 6.1.2: Each</text>
<text top="972" left="476" width="359" height="13" font="2">object’s lifetime is looked up from the allocation index, and the</text>
<text top="987" left="476" width="358" height="13" font="2">moment of allocation is then cross-referenced with the context</text>
<text top="1002" left="476" width="359" height="13" font="2">index to identify the <i>allocation context</i>. The trace can then be</text>
<text top="1017" left="476" width="359" height="13" font="2">scanned linearly from the time of allocation to the point where</text>
<text top="1032" left="476" width="358" height="13" font="2">the object is freed. Whenever the object is touched, the <i>accessor</i></text>
<text top="1047" left="476" width="38" height="12" font="5"><i>context</i></text>
<text top="1046" left="517" width="317" height="13" font="2">is recorded. If the set of accessor contexts contains multiple</text>
<text top="1075" left="476" width="4" height="8" font="9">3</text>
<text top="1077" left="482" width="120" height="11" font="8">BUG ON(in interrupt());</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="43" size="6" family="Times" color="#000000"/>
<text top="110" left="81" width="359" height="13" font="2">elements, then an ownership violation has occurred. If a violation is</text>
<text top="125" left="81" width="359" height="13" font="2">detected, a subsequent query can retrieve the necessary information</text>
<text top="140" left="81" width="359" height="13" font="2">to produce a graph showing the exact sequence of accesses that</text>
<text top="155" left="81" width="359" height="13" font="2">produced the violation overlayed with the control ﬂow of both</text>
<text top="170" left="81" width="359" height="13" font="2">the <i>owner </i>and <i>violator</i>. Figure 11 shows a portion of the report</text>
<text top="185" left="81" width="359" height="13" font="2">produced by a test case we created, in which an <i>owner </i>thread</text>
<text top="200" left="81" width="358" height="13" font="2">creates an object, and a <i>violator </i>running as a timer interrupt handler</text>
<text top="215" left="81" width="359" height="13" font="2">accesses it. The sequence on the left is an abridged call trace of</text>
<text top="230" left="81" width="359" height="13" font="2">the owner context, and the one on the right is the call trace of the</text>
<text top="245" left="81" width="359" height="13" font="2">violator context. The chain of arrows between the two represents</text>
<text top="260" left="81" width="302" height="13" font="2">the sequence of accesses, including the violating access.</text>
<text top="579" left="149" width="58" height="12" font="4"><b>Figure 11.</b></text>
<text top="579" left="213" width="159" height="13" font="2">Ownership violation example</text>
<text top="641" left="81" width="27" height="12" font="4"><b>6.2.2</b></text>
<text top="641" left="121" width="70" height="12" font="4"><b>Stack Usage</b></text>
<text top="672" left="81" width="359" height="13" font="2">Stack space in the kernel is at a premium: each thread of each pro-</text>
<text top="687" left="81" width="359" height="13" font="2">cess needs its own stack, and the address space is small. For this</text>
<text top="702" left="81" width="359" height="13" font="2">reason, Linux includes a compilation option to use 4K stacks in-</text>
<text top="717" left="81" width="359" height="13" font="2">stead of the default 8K. Unfortunately, stack usage is a highly dy-</text>
<text top="732" left="81" width="359" height="13" font="2">namic property, depending on a combination of control and data</text>
<text top="747" left="81" width="359" height="13" font="2">(for example, a recursive function’s stack usage can vary wildly</text>
<text top="762" left="81" width="359" height="13" font="2">depending on input). And so while the developers believe that 4K</text>
<text top="777" left="81" width="359" height="13" font="2">should sufﬁce, and that it would allow many more threads, the de-</text>
<text top="792" left="81" width="358" height="13" font="2">fault remains at 8K. The kernel developers are washing their hands</text>
<text top="807" left="81" width="359" height="13" font="2">of the problem, leaving it to the end user to decide whether to take</text>
<text top="821" left="81" width="359" height="13" font="2">the chance of stack corruption in exchange for better scalability,</text>
<text top="836" left="81" width="328" height="13" font="2">with no good idea of even how likely that corruption may be.</text>
<text top="851" left="99" width="341" height="13" font="2">If the target workload is run under Tralfamadore, the actual</text>
<text top="866" left="81" width="359" height="13" font="2">amount of stack used can be easily measured. We constructed a</text>
<text top="881" left="81" width="359" height="13" font="2">simple query that measures the amount of stack in use whenever it</text>
<text top="896" left="81" width="359" height="13" font="2">changes. Running it on the kernel workload described in Section</text>
<text top="911" left="81" width="359" height="13" font="2">7 produces the usage distribution shown in Figure 12. This reveals</text>
<text top="926" left="81" width="359" height="13" font="2">the exact moment at which the stack reaches its largest point (in</text>
<text top="941" left="81" width="359" height="13" font="2">this case, the maximum size of 2960 bytes was reached 14 times).</text>
<text top="956" left="81" width="359" height="13" font="2">A query for the call stack at that point returns the stack shown in</text>
<text top="971" left="81" width="359" height="13" font="2">Figure 13, showing that the cause of the high stack usage was a</text>
<text top="986" left="81" width="359" height="13" font="2">network interrupt being handled while the kernel was deep in the</text>
<text top="1001" left="81" width="358" height="13" font="2">processing of a <i>sys write </i>system call. Further inspection revealed</text>
<text top="1016" left="81" width="359" height="13" font="2">that all 14 occurrences were at this location, due to the interrupt</text>
<text top="1031" left="81" width="359" height="13" font="2">handler repeatedly processing a backlog of packets. This easily</text>
<text top="1046" left="81" width="359" height="13" font="2">reveals the motivation for the decision of the Linux developers to</text>
<text top="1061" left="81" width="359" height="13" font="2">enable a separate interrupt stack frame when the 4K stack option is</text>
<text top="1076" left="81" width="45" height="13" font="2">enabled.</text>
<text top="349" left="640" width="66" height="8" font="9">stack usage (bytes)</text>
<text top="326" left="537" width="4" height="7" font="10">0</text>
<text top="326" left="578" width="11" height="7" font="10">500</text>
<text top="326" left="621" width="15" height="7" font="10">1000</text>
<text top="326" left="665" width="15" height="7" font="10">1500</text>
<text top="326" left="709" width="15" height="7" font="10">2000</text>
<text top="326" left="754" width="15" height="7" font="10">2500</text>
<text top="326" left="798" width="15" height="7" font="10">3000</text>
<text top="231" left="504" width="0" height="8" font="43">frequency</text>
<text top="309" left="529" width="4" height="7" font="10">1</text>
<text top="290" left="525" width="7" height="7" font="10">10</text>
<text top="265" left="522" width="11" height="7" font="10">100</text>
<text top="239" left="524" width="9" height="7" font="10">1K</text>
<text top="214" left="520" width="13" height="7" font="10">10K</text>
<text top="188" left="516" width="16" height="7" font="10">100K</text>
<text top="162" left="522" width="10" height="7" font="10">1M</text>
<text top="136" left="519" width="14" height="7" font="10">10M</text>
<text top="377" left="553" width="58" height="12" font="4"><b>Figure 12.</b></text>
<text top="376" left="617" width="140" height="13" font="2">Distribution of stack sizes</text>
<text top="417" left="476" width="197" height="6" font="10">sysenter_past_esp/sys_write/vfs_write/do_sync_write/</text>
<text top="426" left="476" width="147" height="6" font="10">ext3_file_write/generic_file_aio_write/</text>
<text top="435" left="476" width="228" height="6" font="10">__generic_file_aio_write_nolock/generic_file_buffered_write/</text>
<text top="444" left="476" width="216" height="6" font="10">ext3_write_begin/block_write_begin/__block_prepare_write/</text>
<text top="453" left="476" width="205" height="6" font="10">ext3_get_block/ext3_get_blocks_handle/ext3_new_blocks/</text>
<text top="462" left="476" width="216" height="6" font="10">__ext3_journal_get_write_access/journal_get_write_access/</text>
<text top="471" left="476" width="193" height="6" font="10">do_get_write_access/__get_free_pages/__alloc_pages/</text>
<text top="480" left="476" width="212" height="6" font="10">get_page_from_freelist/common_interrupt/do_IRQ/irq_exit/</text>
<text top="488" left="476" width="205" height="6" font="10">do_softirq/__do_softirq/net_rx_action/process_backlog/</text>
<text top="497" left="476" width="212" height="6" font="10">netif_receive_skb/ip_rcv/ip_rcv_finish/ip_local_deliver/</text>
<text top="506" left="476" width="186" height="6" font="10">ip_local_deliver_finish/tcp_v4_rcv/tcp_v4_do_rcv/</text>
<text top="515" left="476" width="239" height="6" font="10">tcp_rcv_established/__tcp_push_pending_frames/tcp_transmit_skb/</text>
<text top="524" left="476" width="212" height="6" font="10">ip_queue_xmit/ip_output/ip_finish_output/dev_queue_xmit/</text>
<text top="533" left="476" width="113" height="6" font="10">__qdisc_run/pfifo_fast_dequeue</text>
<text top="562" left="501" width="58" height="12" font="4"><b>Figure 13.</b></text>
<text top="562" left="566" width="243" height="13" font="2">Maximum stack depth seen (kernel compile).</text>
<text top="605" left="476" width="12" height="15" font="6"><b>7.</b></text>
<text top="605" left="504" width="77" height="15" font="6"><b>Evaluation</b></text>
<text top="629" left="476" width="359" height="13" font="2">Tralfamadore approaches dynamic analysis in a manner that is dra-</text>
<text top="644" left="476" width="359" height="13" font="2">matically different from previous systems and in which tools may</text>
<text top="659" left="476" width="359" height="13" font="2">access any point in execution history at any time. This comes with</text>
<text top="674" left="476" width="359" height="13" font="2">a cost: large amounts of ﬁne-grained trace data must be collected,</text>
<text top="689" left="476" width="359" height="13" font="2">stored, and processed. In this section, we evaluate the practicality of</text>
<text top="704" left="476" width="359" height="13" font="2">this approach. First, we measure the overhead of taking and storing</text>
<text top="719" left="476" width="359" height="13" font="2">raw trace data. We then evaluate the cost of generating and storing</text>
<text top="733" left="476" width="359" height="13" font="2">trace indices used to speed up queries, and the degree to which they</text>
<text top="748" left="476" width="358" height="13" font="2">improve the speed and efﬁciency of various queries. We conclude</text>
<text top="763" left="476" width="359" height="13" font="2">with a consideration of the class of analyses for which Tralfama-</text>
<text top="778" left="476" width="359" height="13" font="2">dore is currently suited and discuss how it might be evolved to serve</text>
<text top="793" left="476" width="139" height="13" font="2">a broader set of use cases.</text>
<text top="815" left="476" width="17" height="12" font="4"><b>7.1</b></text>
<text top="815" left="506" width="236" height="12" font="4"><b>Overheads of Trace Capture and Storage</b></text>
<text top="836" left="476" width="359" height="13" font="2">Table 2 shows the overheads of trace collection for four different</text>
<text top="851" left="476" width="358" height="13" font="2">example workloads. <i>Kernel </i>is a minimal build of the Linux kernel</text>
<text top="866" left="476" width="358" height="13" font="2">which balances CPU and I/O, and exercises a variety of kernel</text>
<text top="881" left="476" width="359" height="13" font="2">services. <i>OS Boot </i>traces a virtual machine as it boots. <i>Postmark</i></text>
<text top="896" left="476" width="359" height="13" font="2">is a standard ﬁle system benchmark. Finally, <i>apache </i>is a trace of</text>
<text top="911" left="476" width="358" height="13" font="2">30 minutes of activity totalling 7981 requests on our departmental</text>
<text top="926" left="476" width="61" height="13" font="2">web server.</text>
<text top="941" left="493" width="341" height="13" font="2">Each workload was run natively, then under virtualization using</text>
<text top="956" left="476" width="359" height="13" font="2">QEMU 0.9.1 and VMware Workstation 7.0, with and without trac-</text>
<text top="971" left="476" width="359" height="13" font="2">ing activated. The host was a 2.5GHz quad-core Xeon server with</text>
<text top="986" left="476" width="359" height="13" font="2">16GB of RAM and a 1 TB 7200rpm SATA2 hard drive. Table 2</text>
<text top="1001" left="476" width="358" height="13" font="2">shows the effects of virtualization and tracing on total workload</text>
<text top="1016" left="476" width="358" height="13" font="2">execution time, as well as the sizes of the traces produced (<i>Apache</i></text>
<text top="1031" left="476" width="358" height="13" font="2">measures request latency rather than total time, since the workload</text>
<text top="1046" left="476" width="359" height="13" font="2">is bursty). QEMU traces are generated using the modiﬁcations de-</text>
<text top="1061" left="476" width="359" height="13" font="2">scribed in Section 4.2, whereas VMware traces are event logs cre-</text>
<text top="1076" left="476" width="359" height="13" font="2">ated using its deterministic logging feature. We include both the</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1188" width="918">
<text top="109" left="226" width="35" height="13" font="2">Native</text>
<text top="109" left="294" width="33" height="13" font="2">Qemu</text>
<text top="109" left="365" width="33" height="13" font="2">Qemu</text>
<text top="109" left="427" width="48" height="13" font="2">Log Size</text>
<text top="109" left="510" width="48" height="13" font="2">Log Size</text>
<text top="109" left="579" width="48" height="13" font="2">VMware</text>
<text top="109" left="645" width="48" height="13" font="2">VMware</text>
<text top="109" left="715" width="48" height="13" font="2">Log Size</text>
<text top="124" left="230" width="32" height="13" font="2">Linux</text>
<text top="124" left="301" width="26" height="13" font="2">Base</text>
<text top="124" left="356" width="41" height="13" font="2">Tracing</text>
<text top="124" left="429" width="45" height="13" font="2">(Kernel)</text>
<text top="124" left="532" width="26" height="13" font="2">(All)</text>
<text top="124" left="601" width="26" height="13" font="2">Base</text>
<text top="124" left="651" width="41" height="13" font="2">Tracing</text>
<text top="124" left="737" width="26" height="13" font="2">(All)</text>
<text top="140" left="152" width="36" height="13" font="2">Kernel</text>
<text top="140" left="228" width="34" height="13" font="2">89 sec</text>
<text top="140" left="280" width="47" height="13" font="2">1569 sec</text>
<text top="140" left="350" width="47" height="13" font="2">7459 sec</text>
<text top="140" left="416" width="59" height="13" font="2">101.64 GB</text>
<text top="140" left="493" width="66" height="13" font="2">1991.01 GB</text>
<text top="140" left="593" width="34" height="13" font="2">87 sec</text>
<text top="140" left="659" width="34" height="13" font="2">88 sec</text>
<text top="140" left="710" width="52" height="13" font="2">0.002 GB</text>
<text top="155" left="152" width="47" height="13" font="2">OS Boot</text>
<text top="155" left="228" width="34" height="13" font="2">38 sec</text>
<text top="155" left="286" width="41" height="13" font="2">153 sec</text>
<text top="155" left="357" width="41" height="13" font="2">549 sec</text>
<text top="155" left="422" width="52" height="13" font="2">66.43 GB</text>
<text top="155" left="499" width="59" height="13" font="2">128.31 GB</text>
<text top="155" left="593" width="34" height="13" font="2">25 sec</text>
<text top="155" left="659" width="34" height="13" font="2">31 sec</text>
<text top="155" left="710" width="52" height="13" font="2">0.022 GB</text>
<text top="170" left="152" width="51" height="13" font="2">Postmark</text>
<text top="170" left="221" width="41" height="13" font="2">152 sec</text>
<text top="170" left="286" width="41" height="13" font="2">332 sec</text>
<text top="170" left="357" width="41" height="13" font="2">523 sec</text>
<text top="170" left="416" width="59" height="13" font="2">274.54 GB</text>
<text top="170" left="499" width="59" height="13" font="2">297.40 GB</text>
<text top="170" left="586" width="41" height="13" font="2">237 sec</text>
<text top="170" left="652" width="41" height="13" font="2">310 sec</text>
<text top="170" left="710" width="52" height="13" font="2">0.014 GB</text>
<text top="185" left="152" width="41" height="13" font="2">Apache</text>
<text top="185" left="222" width="39" height="13" font="2">6.17ms</text>
<text top="185" left="281" width="46" height="13" font="2">49.98ms</text>
<text top="185" left="345" width="52" height="13" font="2">144.34ms</text>
<text top="185" left="422" width="52" height="13" font="2">74.63 GB</text>
<text top="185" left="506" width="52" height="13" font="2">80.06 GB</text>
<text top="185" left="581" width="46" height="13" font="2">10.55ms</text>
<text top="185" left="647" width="46" height="13" font="2">26.41ms</text>
<text top="185" left="717" width="46" height="13" font="2">0.18 GB</text>
<text top="212" left="320" width="45" height="12" font="4"><b>Table 2.</b></text>
<text top="212" left="372" width="223" height="13" font="2">Tracing overheads for various workloads.</text>
<text top="257" left="81" width="359" height="13" font="2">full size of the trace and the portion of it which represents kernel</text>
<text top="272" left="81" width="358" height="13" font="2">activity; the analyses we evaluate operate on the kernel component</text>
<text top="287" left="81" width="96" height="13" font="2">of the trace alone.</text>
<text top="302" left="99" width="340" height="13" font="2">The storage requirements and workload performance overhead</text>
<text top="317" left="81" width="359" height="13" font="2">of direct tracing are high. However, both could be mitigated by us-</text>
<text top="332" left="81" width="358" height="13" font="2">ing deterministic record-replay to capture execution, and expanding</text>
<text top="346" left="81" width="359" height="13" font="2">the log into a trace on demand [38]. The VMware columns in Ta-</text>
<text top="361" left="81" width="359" height="13" font="2">ble 2 show the considerable degree by which recording costs could</text>
<text top="376" left="81" width="128" height="13" font="2">be realistically reduced.</text>
<text top="399" left="188" width="21" height="13" font="2">File</text>
<text top="399" left="284" width="23" height="13" font="2">Size</text>
<text top="399" left="330" width="29" height="13" font="2">Ratio</text>
<text top="415" left="174" width="50" height="13" font="2">raw trace</text>
<text top="415" left="255" width="52" height="13" font="2">101.6 GB</text>
<text top="415" left="328" width="31" height="13" font="2">100%</text>
<text top="430" left="164" width="69" height="13" font="2">Invoke index</text>
<text top="430" left="268" width="39" height="13" font="2">2.2 GB</text>
<text top="430" left="325" width="35" height="13" font="2">2.20%</text>
<text top="445" left="161" width="75" height="13" font="2">Context index</text>
<text top="445" left="262" width="44" height="13" font="2">324 MB</text>
<text top="445" left="325" width="35" height="13" font="2">0.32%</text>
<text top="460" left="167" width="63" height="13" font="2">Alloc index</text>
<text top="460" left="269" width="38" height="13" font="2">12 MB</text>
<text top="460" left="325" width="35" height="13" font="2">0.01%</text>
<text top="487" left="127" width="45" height="12" font="4"><b>Table 3.</b></text>
<text top="486" left="179" width="215" height="13" font="2">Index size relative to trace size (kernel).</text>
<text top="518" left="131" width="53" height="13" font="2">Workload</text>
<text top="518" left="220" width="34" height="13" font="2">Query</text>
<text top="518" left="290" width="41" height="13" font="2">% trace</text>
<text top="518" left="348" width="41" height="13" font="2">% trace</text>
<text top="533" left="295" width="36" height="13" font="2">(large)</text>
<text top="533" left="351" width="38" height="13" font="2">(small)</text>
<text top="548" left="132" width="51" height="13" font="2">Postmark</text>
<text top="548" left="202" width="70" height="13" font="2">Heap Slicing</text>
<text top="548" left="296" width="35" height="13" font="2">0.01%</text>
<text top="548" left="354" width="35" height="13" font="2">0.00%</text>
<text top="563" left="207" width="59" height="13" font="2">Arguments</text>
<text top="563" left="296" width="35" height="13" font="2">0.23%</text>
<text top="563" left="354" width="35" height="13" font="2">0.00%</text>
<text top="579" left="140" width="36" height="13" font="2">Kernel</text>
<text top="579" left="202" width="70" height="13" font="2">Heap Slicing</text>
<text top="579" left="296" width="35" height="13" font="2">1.25%</text>
<text top="579" left="354" width="35" height="13" font="2">0.02%</text>
<text top="594" left="207" width="59" height="13" font="2">Arguments</text>
<text top="594" left="296" width="35" height="13" font="2">0.17%</text>
<text top="594" left="354" width="35" height="13" font="2">0.06%</text>
<text top="609" left="137" width="41" height="13" font="2">Apache</text>
<text top="609" left="202" width="70" height="13" font="2">Heap Slicing</text>
<text top="609" left="296" width="35" height="13" font="2">37.5%</text>
<text top="609" left="354" width="35" height="13" font="2">0.01%</text>
<text top="624" left="207" width="59" height="13" font="2">Arguments</text>
<text top="624" left="296" width="35" height="13" font="2">0.25%</text>
<text top="624" left="354" width="35" height="13" font="2">0.00%</text>
<text top="651" left="122" width="45" height="12" font="4"><b>Table 4.</b></text>
<text top="651" left="174" width="224" height="13" font="2">Amount of trace read when using indices.</text>
<text top="693" left="81" width="27" height="12" font="4"><b>7.1.1</b></text>
<text top="693" left="121" width="128" height="12" font="4"><b>Indexing Performance</b></text>
<text top="717" left="81" width="359" height="13" font="2">As shown in Table 2, the full trace grows very rapidly, to the point</text>
<text top="732" left="81" width="359" height="13" font="2">that scanning it directly can take considerable time. Fortunately,</text>
<text top="747" left="81" width="359" height="13" font="2">many trace operators only need to see a small amount of the trace,</text>
<text top="762" left="81" width="359" height="13" font="2">and can make use of indices to read only the relevant sections.</text>
<text top="777" left="81" width="359" height="13" font="2">Table 3 shows the relative size of the index to the trace for the most</text>
<text top="792" left="81" width="359" height="13" font="2">used operators in our operator library. As this table demonstrates,</text>
<text top="807" left="81" width="359" height="13" font="2">the size of the index is generally inversely proportional to the</text>
<text top="821" left="81" width="359" height="13" font="2">degree of semantic information it provides. This results from the</text>
<text top="836" left="81" width="359" height="13" font="2">fact that higher-level operators consume ﬁltered information from</text>
<text top="851" left="81" width="139" height="13" font="2">the operators below them.</text>
<text top="866" left="99" width="341" height="13" font="2">The cost of analysis is determined largely by the amount of</text>
<text top="881" left="81" width="359" height="13" font="2">physical trace that must be read. Table 4 measures the beneﬁt of</text>
<text top="896" left="81" width="359" height="13" font="2">using indices in terms of the percentage of trace that an analysis</text>
<text top="911" left="81" width="359" height="13" font="2">must examine when the relevant indices are available (without in-</text>
<text top="926" left="81" width="359" height="13" font="2">dices, it would be necessary to read the entire trace). For each of</text>
<text top="941" left="81" width="359" height="13" font="2">the workloads described at the start of this section, we ran two</text>
<text top="956" left="81" width="359" height="13" font="2">heap slicing analyses and two argument value extraction queries.</text>
<text top="971" left="81" width="359" height="13" font="2">The large heap slicing analysis examines every TCP packet pass-</text>
<text top="986" left="81" width="359" height="13" font="2">ing through the tcp v4 rcv function, while the small only exam-</text>
<text top="1001" left="81" width="359" height="13" font="2">ines (relatively infrequent) ARP packets passing through arp rcv.</text>
<text top="1016" left="81" width="359" height="13" font="2">Similarly, the two functions chosen for argument value extraction</text>
<text top="1031" left="81" width="359" height="13" font="2">were the common kmem cache alloc, which is involved in most</text>
<text top="1046" left="81" width="359" height="13" font="2">object allocations, and the relatively rare mmap region. Because</text>
<text top="1061" left="81" width="359" height="13" font="2">the heap slicing analysis must scan the physical trace from the time</text>
<text top="1076" left="81" width="359" height="13" font="2">an object of interest is allocated until it is freed, and because in</text>
<text top="257" left="476" width="359" height="13" font="2">the Apache workload there is almost always a live TCP packet, the</text>
<text top="272" left="476" width="358" height="13" font="2">heap slicing query consumed a large amount of physical trace even</text>
<text top="287" left="476" width="359" height="13" font="2">when indexed. Every other query consumed a tiny fraction of the</text>
<text top="302" left="476" width="167" height="13" font="2">total trace, completing quickly.</text>
<text top="327" left="476" width="27" height="12" font="4"><b>7.1.2</b></text>
<text top="327" left="516" width="123" height="12" font="4"><b>Evaluation Summary</b></text>
<text top="350" left="476" width="359" height="13" font="2">In our current prototype, there is no denying that traces are large</text>
<text top="365" left="476" width="358" height="13" font="2">and slow to generate. But the premise of Tralfamadore is to decou-</text>
<text top="380" left="476" width="358" height="13" font="2">ple trace generation from analysis, and we ﬁnd that having done</text>
<text top="395" left="476" width="359" height="13" font="2">so, analysis itself performs well. Because Tralfamadore can ag-</text>
<text top="409" left="476" width="359" height="13" font="2">gressively reuse trace data, we are relatively unconcerned with the</text>
<text top="424" left="476" width="359" height="13" font="2">space required to store it. We also believe that trace-based analy-</text>
<text top="439" left="476" width="359" height="13" font="2">sis makes it much easier to develop new analyses, since they can</text>
<text top="454" left="476" width="359" height="13" font="2">be written in the author’s choice of language and with a full com-</text>
<text top="469" left="476" width="359" height="13" font="2">plement of libraries, and that being able to freely seek within a</text>
<text top="484" left="476" width="359" height="13" font="2">trace allows a more natural style of query expression. Furthermore,</text>
<text top="499" left="476" width="359" height="13" font="2">persistent traces allow users to break the expensive and delicate cy-</text>
<text top="514" left="476" width="359" height="13" font="2">cle of hypothesis, instrumentation, execution, and analysis which is</text>
<text top="529" left="476" width="195" height="13" font="2">generally used for query reﬁnement.</text>
<text top="544" left="493" width="341" height="13" font="2">However, it is clear that the ability to collect and analyze traces</text>
<text top="559" left="476" width="358" height="13" font="2">more easily and with lower overhead would make the techniques</text>
<text top="574" left="476" width="359" height="13" font="2">described in this paper apply to a broader range of problems. As</text>
<text top="589" left="476" width="359" height="13" font="2">discussed in Section 4.2, a natural optimization would be to use</text>
<text top="604" left="476" width="358" height="13" font="2">deterministic logging during the recording phase. The full log could</text>
<text top="619" left="476" width="358" height="13" font="2">then be treated as a cache that could be regenerated when necessary</text>
<text top="634" left="476" width="358" height="13" font="2">using replay. We believe that this approach would allow operators</text>
<text top="648" left="476" width="359" height="13" font="2">to rapidly create the data needed to populate their indices. From this</text>
<text top="663" left="476" width="359" height="13" font="2">point, some analyses could proceed largely based on the contents of</text>
<text top="679" left="476" width="358" height="13" font="2">their indices, and use replay to materialize only the relevant regions</text>
<text top="693" left="476" width="359" height="13" font="2">of the complete trace, on demand. Such an approach could facilitate</text>
<text top="708" left="476" width="256" height="13" font="2">the processing of much larger amounts of trace.</text>
<text top="737" left="476" width="12" height="15" font="6"><b>8.</b></text>
<text top="737" left="504" width="98" height="15" font="6"><b>Related Work</b></text>
<text top="762" left="476" width="358" height="13" font="2">As described in Section 2.2, the traces recorded with Tralfamadore</text>
<text top="777" left="476" width="359" height="13" font="2">are complete, meaning that analyses based on these traces have ac-</text>
<text top="792" left="476" width="358" height="13" font="2">cess to the register and memory state on every instruction bound-</text>
<text top="807" left="476" width="358" height="13" font="2">ary. This section compares Tralfamadore with other frameworks</text>
<text top="821" left="476" width="358" height="13" font="2">that provide access to the same level of information. This includes</text>
<text top="836" left="476" width="358" height="13" font="2">traditional dynamic binary instrumentation (DBI) frameworks such</text>
<text top="851" left="476" width="352" height="13" font="2">as Pin [20], and replay based frameworks such as Aftersight [10].</text>
<text top="866" left="493" width="341" height="13" font="2">Aftersight [10] proposes to decouple dynamic analysis from</text>
<text top="881" left="476" width="358" height="13" font="2">execution by using deterministic record-replay to efﬁciently record</text>
<text top="896" left="476" width="359" height="13" font="2">the execution of virtual machine and replay this execution in an</text>
<text top="911" left="476" width="359" height="13" font="2">whole-system emulator (QEMU). Like Tralfamadore, Aftersight</text>
<text top="926" left="476" width="358" height="13" font="2">supports whole-system or kernel-level ofﬂine analyses, but does</text>
<text top="941" left="476" width="358" height="13" font="2">not provide an instrumentation API, forcing users to directly embed</text>
<text top="956" left="476" width="357" height="13" font="2">their instrumentation and analysis into QEMU’s micro-operations.</text>
<text top="971" left="493" width="341" height="13" font="2">SimOS [32] explores the idea of using a machine simulator</text>
<text top="986" left="476" width="358" height="13" font="2">to study the execution of entire systems. Similar to Tralfamadore,</text>
<text top="1001" left="476" width="358" height="13" font="2">SimOS proposes the use of annotations to capture events at a higher</text>
<text top="1016" left="476" width="358" height="13" font="2">semantic level. As with Tralfamadore, annotations can be recursive</text>
<text top="1031" left="476" width="266" height="13" font="2">(annotations can be built from other annotations).</text>
<text top="1046" left="493" width="341" height="13" font="2">SimOS can operate in two modes: emulation mode which uses</text>
<text top="1061" left="476" width="359" height="13" font="2">dynamic binary translation and accurate mode which executes the</text>
<text top="1076" left="476" width="359" height="13" font="2">system under a cycle-accurate simulator. Analyses performed in</text>
</page>
<page number="11" position="absolute" top="0" left="0" height="1188" width="918">
<text top="110" left="81" width="359" height="13" font="2">emulation mode execute in an online manner, and do not pro-</text>
<text top="125" left="81" width="359" height="13" font="2">vide the beneﬁts of ofﬂine analysis. Analyses performed in accu-</text>
<text top="140" left="81" width="359" height="13" font="2">rate mode may be repeatable if the simulation is deterministic but</text>
<text top="155" left="81" width="359" height="13" font="2">the overheads in this mode are much higher than with Tralfama-</text>
<text top="170" left="81" width="359" height="13" font="2">dore, ranging between 180 and 6400× for a uniprocessor simula-</text>
<text top="185" left="81" width="50" height="13" font="2">tion [31].</text>
<text top="200" left="99" width="341" height="13" font="2">Although analyses built with SimOS are composable, SimOS</text>
<text top="215" left="81" width="359" height="13" font="2">does not address the issue of reusability. Also, SimOS does not</text>
<text top="230" left="81" width="359" height="13" font="2">support indices to efﬁciently navigate execution, and therefore does</text>
<text top="245" left="81" width="359" height="13" font="2">not provide mechanisms such as annotation caching to deal with</text>
<text top="260" left="81" width="242" height="13" font="2">stateful analyses, as described in Section 4.4.</text>
<text top="275" left="99" width="340" height="13" font="2">Traditional binary instrumentation frameworks are fundamen-</text>
<text top="290" left="81" width="359" height="13" font="2">tally different than Tralfamadore. These are online tools and are</text>
<text top="305" left="81" width="359" height="13" font="2">“stuck in time.” They are limited to analyzing a program as it</text>
<text top="319" left="81" width="359" height="13" font="2">executes instead of analyzing an execution. Dynamic binary in-</text>
<text top="334" left="81" width="359" height="13" font="2">strumentation frameworks such as Pin [20] and Valgrind [24] use</text>
<text top="349" left="81" width="359" height="13" font="2">process-level dynamic binary translation to add instrumentation to</text>
<text top="364" left="81" width="359" height="13" font="2">a program as it executes. Because both the analysis and the target</text>
<text top="379" left="81" width="359" height="13" font="2">program execute in the same address space, analysis writers are</text>
<text top="394" left="81" width="359" height="13" font="2">forced to use clever techniques to avoid clashing with the target</text>
<text top="409" left="81" width="359" height="13" font="2">program. This technique does not require explicit modiﬁcations to</text>
<text top="424" left="81" width="359" height="13" font="2">the program being analyzed but it is not completely transparent be-</text>
<text top="439" left="81" width="359" height="13" font="2">cause it may cause memory conﬂicts between the program being</text>
<text top="454" left="81" width="140" height="13" font="2">analyzed and the analysis.</text>
<text top="469" left="99" width="340" height="13" font="2">These tools are unable to instrument and analyze the execution</text>
<text top="484" left="81" width="359" height="13" font="2">of operating system code. PinOS [7] addresses this issue by ex-</text>
<text top="499" left="81" width="359" height="13" font="2">tending Pin with the ability to do whole-system analysis. Because</text>
<text top="514" left="81" width="359" height="13" font="2">it uses virtualization, most of the instrumentation framework sits</text>
<text top="529" left="81" width="358" height="13" font="2">outside of the system being analyzed but the instrumentation code</text>
<text top="544" left="81" width="359" height="13" font="2">and data still need to be embedded within the system, potentially</text>
<text top="558" left="81" width="270" height="13" font="2">causing memory clashes as with Pin and Valgrind.</text>
<text top="573" left="99" width="341" height="13" font="2">JIFL [25] proposes to embed a DBI within the Linux kernel.</text>
<text top="588" left="81" width="359" height="13" font="2">This approach allows adding arbitrary dynamic instrumentation to</text>
<text top="603" left="81" width="359" height="13" font="2">the Linux kernel but requires the operating system to be explicitly</text>
<text top="618" left="81" width="276" height="13" font="2">modiﬁed to add support for a just-in-time compiler.</text>
<text top="633" left="99" width="340" height="13" font="2">Nirvana [6] is a user-level ofﬂine dynamic analysis framework</text>
<text top="648" left="81" width="359" height="13" font="2">based on a variant of record-replay. Instead of explicitly logging all</text>
<text top="663" left="81" width="359" height="13" font="2">the external inputs and non-deterministic events, Nirvana captures</text>
<text top="678" left="81" width="359" height="13" font="2">this information implicitly by logging the complete register state</text>
<text top="693" left="81" width="359" height="13" font="2">after kernel-to-user transitions and non-deterministic instructions</text>
<text top="708" left="81" width="359" height="13" font="2">such as rdtsc, and logging all values read from memory by the</text>
<text top="723" left="81" width="143" height="13" font="2">processor while executing.</text>
<text top="738" left="99" width="341" height="13" font="2">Nirvana provides an instrumentation API but, unlike Tralfama-</text>
<text top="753" left="81" width="359" height="13" font="2">dore, it does not support capturing and analyzing the execution of</text>
<text top="768" left="81" width="358" height="13" font="2">operating system code. Nirvana can record and analyze unmodi-</text>
<text top="783" left="81" width="359" height="13" font="2">ﬁed programs, but it is not completely transparent. Like Pin and</text>
<text top="798" left="81" width="359" height="13" font="2">Valgrind, the Nirvana execution recorder is embedded in the ad-</text>
<text top="812" left="81" width="359" height="13" font="2">dress space of the program being recorded, which can cause mem-</text>
<text top="827" left="81" width="359" height="13" font="2">ory conﬂicts. PinPlay [27] extends Pin to support replay-based of-</text>
<text top="842" left="81" width="359" height="13" font="2">ﬂine analysis in a manner similar to Nirvana, and uses a software-</text>
<text top="857" left="81" width="359" height="13" font="2">simulated cache coherency protocol to deterministically replay the</text>
<text top="872" left="81" width="359" height="13" font="2">execution of a process on a multi-processor machine. PinPlay pro-</text>
<text top="887" left="81" width="234" height="13" font="2">vides the same level of transparency as Pin.</text>
<text top="902" left="99" width="341" height="13" font="2">Bitblaze [33] is an online whole-system binary analysis frame-</text>
<text top="917" left="81" width="359" height="13" font="2">work based on QEMU. Like Tralfamadore and Aftersight, Bitblaze</text>
<text top="932" left="81" width="359" height="13" font="2">analyzes execution at the processor level which provides a transpar-</text>
<text top="947" left="81" width="359" height="13" font="2">ent approach to dynamic analysis, and support for the analysis of</text>
<text top="962" left="81" width="359" height="13" font="2">operating system code. Because Bitblaze is an online framework,</text>
<text top="977" left="81" width="359" height="13" font="2">it is also “stuck in time” and can only analyze programs as they</text>
<text top="992" left="81" width="44" height="13" font="2">execute.</text>
<text top="1007" left="99" width="341" height="13" font="2">Time-travelling virtual machines [15] use deterministic replay</text>
<text top="1022" left="81" width="358" height="13" font="2">to allow a debugger attached to a Linux kernel to step execution</text>
<text top="1037" left="81" width="358" height="13" font="2">backwards as well as forwards. VMware Workstation now includes</text>
<text top="1052" left="81" width="359" height="13" font="2">a record-replay facility [38] that can be used for replay debug-</text>
<text top="1067" left="81" width="358" height="13" font="2">ging [3] of recorded software. Time-travelling virtual machines</text>
<text top="110" left="476" width="359" height="13" font="2">support the ofﬂine analysis of operating systems but the interface</text>
<text top="125" left="476" width="358" height="13" font="2">provided to analyze execution is limited to debugging contexts</text>
<text top="140" left="476" width="195" height="13" font="2">(e.g., breakpoints, watchpoints, etc.)</text>
<text top="155" left="493" width="341" height="13" font="2">Omniscient debugging [1, 8, 19, 29] is an approach to debug-</text>
<text top="170" left="476" width="358" height="13" font="2">ging where the execution of a program is stored and indexed using</text>
<text top="185" left="476" width="358" height="13" font="2">techniques borrowed from program slicing [36], allowing debug-</text>
<text top="200" left="476" width="359" height="13" font="2">ging to work “backwards in time.” All existing implementations of</text>
<text top="215" left="476" width="359" height="13" font="2">omniscient debugging are limited to user-space programs and pro-</text>
<text top="230" left="476" width="208" height="13" font="2">vide an interface limited to debugging.</text>
<text top="245" left="493" width="341" height="13" font="2">Whole Execution Traces (WET) [39] is a generic trace for-</text>
<text top="260" left="476" width="359" height="13" font="2">mat with the same completeness properties as traces collected with</text>
<text top="275" left="476" width="359" height="13" font="2">Tralfamadore. WET traces embed control and data ﬂow informa-</text>
<text top="290" left="476" width="359" height="13" font="2">tion in the trace to provide efﬁcient backward navigation. This in-</text>
<text top="305" left="476" width="359" height="13" font="2">formation could be added to the Tralfamadore trace format to sim-</text>
<text top="319" left="476" width="326" height="13" font="2">plify going backward to get register and memory deﬁnitions.</text>
<text top="341" left="476" width="17" height="12" font="4"><b>8.1</b></text>
<text top="341" left="506" width="168" height="12" font="4"><b>Deterministic Record-Replay</b></text>
<text top="362" left="476" width="359" height="13" font="2">As discussed in Section 4.2, it is possible to use deterministic vir-</text>
<text top="377" left="476" width="359" height="13" font="2">tual machine record-replay to capture a lightweight event log of a</text>
<text top="392" left="476" width="359" height="13" font="2">running system, which can be reconstituted into a full trace dur-</text>
<text top="407" left="476" width="359" height="13" font="2">ing a later replay phase [38]. Tralfamadore could use this compli-</text>
<text top="422" left="476" width="358" height="13" font="2">mentary technique to reduce the overhead on execution incurred</text>
<text top="437" left="476" width="359" height="13" font="2">by the trace collection facility. The overhead of this approach are</text>
<text top="452" left="476" width="359" height="13" font="2">very low for single core systems. Recording multicore execution is</text>
<text top="467" left="476" width="358" height="13" font="2">substantially more challenging due to the need to capture memory</text>
<text top="482" left="476" width="359" height="13" font="2">races. The overhead can be substantial for workloads that exhibit</text>
<text top="497" left="476" width="359" height="13" font="2">a large amount of shared memory communication. Fortunately, de-</text>
<text top="512" left="476" width="358" height="13" font="2">terministic record-replay for multicore is an active area of research</text>
<text top="527" left="476" width="359" height="13" font="2">and recent work both at the software [26, 34], and at the hard-</text>
<text top="542" left="476" width="359" height="13" font="2">ware [13, 22, 37] level aim to address this issue. Just as in the single</text>
<text top="557" left="476" width="359" height="13" font="2">processor case, these emerging techniques will be usable to gener-</text>
<text top="571" left="476" width="228" height="13" font="2">ate detailed traces of multicore workloads.</text>
<text top="593" left="476" width="17" height="12" font="4"><b>8.2</b></text>
<text top="593" left="506" width="205" height="12" font="4"><b>Ofﬂine and Whole-System Analyses</b></text>
<text top="614" left="476" width="359" height="13" font="2">TaintBochs [9] uses a mix of online taint tracking and ofﬂine trace-</text>
<text top="629" left="476" width="358" height="13" font="2">based analysis to study the lifetime of sensitive information such</text>
<text top="644" left="476" width="359" height="13" font="2">as passwords. TaintBochs uses a modiﬁed version of the Bochs</text>
<text top="659" left="476" width="358" height="13" font="2">emulator [17] to record traces that contain all writes to memory</text>
<text top="674" left="476" width="359" height="13" font="2">and all updates to a speciﬁc subset of registers. One could use</text>
<text top="689" left="476" width="358" height="13" font="2">Tralfamadore to also implement the taint propagation ofﬂine, using</text>
<text top="704" left="476" width="358" height="13" font="2">a recorded execution to experiment with different taint propagation</text>
<text top="719" left="476" width="45" height="13" font="2">policies.</text>
<text top="734" left="493" width="341" height="13" font="2">Dataﬂow tomography [23] proposes the use of whole-system</text>
<text top="749" left="476" width="359" height="13" font="2">taint tracking as a tool to understand complex computer sys-</text>
<text top="764" left="476" width="358" height="13" font="2">tems. This project is complementary to Tralfamadore, meaning</text>
<text top="779" left="476" width="359" height="13" font="2">that Tralfamadore could be used to implement the various taint</text>
<text top="794" left="476" width="359" height="13" font="2">policies described in the paper. Using Tralfamadore would have</text>
<text top="809" left="476" width="359" height="13" font="2">provided the authors with the beneﬁts of deterministic analysis, in</text>
<text top="823" left="476" width="359" height="13" font="2">addition to using a high-level language instead of dealing directly</text>
<text top="838" left="476" width="266" height="13" font="2">with QEMU’s dynamic binary translation engine.</text>
<text top="853" left="493" width="341" height="13" font="2">Introvirt [14] proposes to use virtual machine deterministic re-</text>
<text top="868" left="476" width="359" height="13" font="2">play to retroactively detect the presence of an intrusion. Introvirt is</text>
<text top="883" left="476" width="359" height="13" font="2">the original source of inspiration for the idea of retroactive asser-</text>
<text top="898" left="476" width="358" height="13" font="2">tions described in Section 6.2. While Introvirt checks are expressed</text>
<text top="913" left="476" width="359" height="13" font="2">at the source level, Tralfamadore retroactive assertions are written</text>
<text top="928" left="476" width="359" height="13" font="2">as binary analyses and can validate assertions difﬁcult to express at</text>
<text top="943" left="476" width="272" height="13" font="2">the source level such as detecting a stack overﬂow.</text>
<text top="965" left="476" width="17" height="12" font="4"><b>8.3</b></text>
<text top="965" left="506" width="115" height="12" font="4"><b>Querying Execution</b></text>
<text top="986" left="476" width="359" height="13" font="2">Several projects have explored the notion of querying program ex-</text>
<text top="1001" left="476" width="358" height="13" font="2">ecution, either by providing an explicit query interface to the end</text>
<text top="1016" left="476" width="359" height="13" font="2">user or using machine learning to discover execution patterns. Two</text>
<text top="1031" left="476" width="359" height="13" font="2">recent projects from the programming languages community, re-</text>
<text top="1046" left="476" width="358" height="13" font="2">lational queries over program traces [12], and the program query</text>
<text top="1061" left="476" width="359" height="13" font="2">language PQL [21], have proposed query interfaces to allow de-</text>
<text top="1076" left="476" width="359" height="13" font="2">velopers to search for interesting aspects of program behavior. The</text>
</page>
<page number="12" position="absolute" top="0" left="0" height="1188" width="918">
<text top="110" left="81" width="359" height="13" font="2">scalable omniscient debugging project [29] also explored query in-</text>
<text top="125" left="81" width="359" height="13" font="2">terfaces to assist in navigation. A suitable query interface would be</text>
<text top="140" left="81" width="358" height="13" font="2">an excellent tool for interacting with traced execution. These query</text>
<text top="155" left="81" width="359" height="13" font="2">languages are designed around speciﬁc language runtimes and are</text>
<text top="170" left="81" width="359" height="13" font="2">not designed to query operating system execution. They operate at</text>
<text top="185" left="81" width="359" height="13" font="2">a higher level and rely on runtime information provided by the op-</text>
<text top="200" left="81" width="359" height="13" font="2">erating system or the language runtime. Tralfamadore analyses ex-</text>
<text top="215" left="81" width="358" height="13" font="2">ecution at the hardware level below the operating system and needs</text>
<text top="230" left="81" width="220" height="13" font="2">to explicitly reconstruct this information.</text>
<text top="255" left="81" width="12" height="15" font="6"><b>9.</b></text>
<text top="255" left="110" width="212" height="15" font="6"><b>Conclusions and Future Work</b></text>
<text top="279" left="81" width="358" height="13" font="2">We believe that developers (especially kernel developers) would</text>
<text top="294" left="81" width="359" height="13" font="2">beneﬁt greatly from being able to explore actual program execu-</text>
<text top="309" left="81" width="359" height="13" font="2">tion as easily as they can navigate source. To that end, we have</text>
<text top="324" left="81" width="359" height="13" font="2">built a platform for recording execution of an entire machine as a</text>
<text top="339" left="81" width="359" height="13" font="2">persistent object, and facilities for easily constructing complex and</text>
<text top="354" left="81" width="359" height="13" font="2">powerful dynamic analyses from a library of simple, reusable com-</text>
<text top="369" left="81" width="359" height="13" font="2">ponents. We have demonstrated several applications of this system,</text>
<text top="384" left="81" width="359" height="13" font="2">including an interactive source-level execution browser with inter-</text>
<text top="399" left="81" width="359" height="13" font="2">faces for both control and data ﬂow, and a variety of retroactive</text>
<text top="414" left="81" width="294" height="13" font="2">assertions against the behavior of an executing system.</text>
<text top="429" left="99" width="341" height="13" font="2">The overheads associated with our approach seem high com-</text>
<text top="443" left="81" width="359" height="13" font="2">pared to traditional dynamic analysis, but they can be amortized</text>
<text top="458" left="81" width="359" height="13" font="2">over large numbers of queries. Additionally, trace-based analysis</text>
<text top="473" left="81" width="359" height="13" font="2">avoids the difﬁculties of reproducing machine state when perform-</text>
<text top="488" left="81" width="358" height="13" font="2">ing cyclical analysis, and provides a much richer and more conve-</text>
<text top="503" left="81" width="359" height="13" font="2">nient environment for writing interactive dynamic analysis tools.</text>
<text top="518" left="81" width="359" height="13" font="2">Our evaluation has demonstrated that it is practical to capture and</text>
<text top="533" left="81" width="359" height="13" font="2">analyze complete traces of kernel activity for reasonable periods</text>
<text top="548" left="81" width="359" height="13" font="2">of time, including workloads such as kernel compilation, OS boots,</text>
<text top="563" left="81" width="359" height="13" font="2">and samples of server workloads. Further, once recorded, it is possi-</text>
<text top="578" left="81" width="359" height="13" font="2">ble to perform highly interactive analyses of these workloads, often</text>
<text top="593" left="81" width="359" height="13" font="2">receiving complex answers about a control and data ﬂow within a</text>
<text top="608" left="81" width="98" height="13" font="2">matter of seconds.</text>
<text top="623" left="99" width="341" height="13" font="2">Tralfamadore is still in its infancy. While the system already</text>
<text top="638" left="81" width="359" height="13" font="2">represents a considerable effort, spanning four years and contribu-</text>
<text top="653" left="81" width="359" height="13" font="2">tions from a group of six graduate students, many challenges re-</text>
<text top="668" left="81" width="359" height="13" font="2">main. We are in the process of releasing a hosted version of the</text>
<text top="683" left="81" width="359" height="13" font="2">system that allows developers to analyze current and historical ver-</text>
<text top="697" left="81" width="359" height="13" font="2">sions of the Linux kernel. To address performance challenges and</text>
<text top="712" left="81" width="359" height="13" font="2">scale, the system is being extended to parallelize and dispatch anal-</text>
<text top="727" left="81" width="359" height="13" font="2">ysis to a cluster of physical hosts. Once this framework is in place,</text>
<text top="742" left="81" width="359" height="13" font="2">we hope to explore how Tralfamadore can be used to compare exe-</text>
<text top="757" left="81" width="359" height="13" font="2">cution across multiple versions of software, which we hope will aid</text>
<text top="772" left="81" width="358" height="13" font="2">in identifying and diagnosing performance challenges and helping</text>
<text top="787" left="81" width="359" height="13" font="2">developers to reproduce and identify root-causes for software fail-</text>
<text top="802" left="81" width="26" height="13" font="2">ures.</text>
<text top="827" left="81" width="129" height="15" font="6"><b>Acknowledgments</b></text>
<text top="851" left="81" width="359" height="13" font="2">We thank the VEE reviewers for their insightful feedback and for</text>
<text top="866" left="81" width="359" height="13" font="2">accepting the paper for publication. We also thank many of our</text>
<text top="881" left="81" width="359" height="13" font="2">peers, including Paul Barham, Herbert Bos, Steve Gribble, Steven</text>
<text top="896" left="81" width="358" height="13" font="2">Hand, Rebecca Isaacs, and Timothy Roscoe, for being supportive</text>
<text top="911" left="81" width="358" height="13" font="2">and encouraging over the course of this work. We acknowledge</text>
<text top="926" left="81" width="359" height="13" font="2">the graduate students in CS538W 2010 (“Execution Mining”) for</text>
<text top="941" left="81" width="359" height="13" font="2">suffering through project assignments on an early version of the</text>
<text top="956" left="81" width="214" height="13" font="2">system and helping to ﬁnd and ﬁx bugs.</text>
<text top="971" left="99" width="340" height="13" font="2">As some previous reviewers have pointed out, the Tralfamadore</text>
<text top="986" left="81" width="359" height="13" font="2">project has involved quite a bit of <i>engineering</i>: while many of the</text>
<text top="1001" left="81" width="359" height="13" font="2">techniques used by “Tralf” are well understood, tying together the</text>
<text top="1016" left="81" width="359" height="13" font="2">necessary pieces to perform trace collection, parsing, instruction</text>
<text top="1031" left="81" width="359" height="13" font="2">analysis, as well as source-level interactions through DWARF and</text>
<text top="1046" left="81" width="359" height="13" font="2">symbol ﬁles involved a lot more effort than we imagined at the</text>
<text top="1061" left="81" width="359" height="13" font="2">beginning of the project, despite considerable experience in under-</text>
<text top="1076" left="81" width="125" height="13" font="2">estimating such things!</text>
<text top="110" left="476" width="77" height="15" font="6"><b>References</b></text>
<text top="135" left="482" width="352" height="11" font="8">[1] C/C++ trace-based debugger based on chronicle and eclipse.</text>
<text top="148" left="501" width="196" height="11" font="8">http://code.google.com/p/chronomancer/.</text>
<text top="167" left="482" width="154" height="11" font="8">[2] Vassert programming guide.</text>
<text top="180" left="501" width="295" height="11" font="8">http://www.vmware.com/pdf/ws65 vassert programming.pdf.</text>
<text top="199" left="482" width="151" height="11" font="8">[3] Replay debugging on linux.</text>
<text top="212" left="501" width="290" height="11" font="8">http://www.vmware.com/pdf/ws7 replay linux technote.pdf.</text>
<text top="231" left="482" width="353" height="11" font="8">[4] H. Agrawal and J. R. Horgan. Dynamic program slicing. In <i>PLDI ’90</i>.</text>
<text top="249" left="482" width="353" height="11" font="8">[5] F. Bellard. QEMU, a fast and portable dynamic translator. In <i>USENIX</i></text>
<text top="263" left="501" width="141" height="11" font="22"><i>Annual Technical Conference</i></text>
<text top="263" left="641" width="33" height="11" font="8">, 2005.</text>
<text top="281" left="482" width="353" height="11" font="8">[6] S. Bhansali, W.-K. Chen, S. de Jong, A. Edwards, R. Murray,</text>
<text top="295" left="501" width="333" height="11" font="8">M. Drini´c, D. Mihoˇcka, and J. Chau. Framework for instruction-level</text>
<text top="308" left="501" width="269" height="11" font="8">tracing and analysis of program executions. In <i>VEE ’06</i>.</text>
<text top="327" left="481" width="353" height="11" font="8">[7] P. P. Bungale and C.-K. Luk. Pinos: a programmable framework for</text>
<text top="340" left="501" width="333" height="11" font="8">whole-system dynamic instrumentation. In <i>Virtual execution environ-</i></text>
<text top="354" left="501" width="28" height="11" font="22"><i>ments</i></text>
<text top="354" left="528" width="164" height="11" font="8">, 2007. ISBN 978-1-59593-630-1.</text>
<text top="372" left="481" width="352" height="11" font="8">[8] J.-D. Choi, B. P. Miller, and R. H. B. Netzer. Techniques for debugging</text>
<text top="386" left="501" width="210" height="11" font="8">parallel programs with ﬂowback analysis.</text>
<text top="386" left="724" width="110" height="11" font="22"><i>ACM Transactions on</i></text>
<text top="400" left="501" width="183" height="11" font="22"><i>Programming Languages and Systems</i></text>
<text top="399" left="684" width="150" height="11" font="8">, 13, 1991. URL http://doi.</text>
<text top="413" left="501" width="177" height="10" font="8">acm.org/10.1145/115372.115324</text>
<text top="413" left="678" width="3" height="11" font="8">.</text>
<text top="431" left="482" width="352" height="11" font="8">[9] J. Chow, B. Pfaff, T. Garﬁnkel, K. Christopher, and M. Rosen-</text>
<text top="445" left="501" width="334" height="11" font="8">blum. Understanding data lifetime via whole system simulation. In</text>
<text top="459" left="501" width="146" height="11" font="22"><i>USENIX Security Symposium</i></text>
<text top="458" left="646" width="36" height="11" font="8">, 2004.</text>
<text top="458" left="695" width="140" height="11" font="8">URL http://portal.acm.</text>
<text top="472" left="501" width="214" height="10" font="8">org/citation.cfm?id=1251375.1251397</text>
<text top="472" left="715" width="3" height="11" font="8">.</text>
<text top="490" left="476" width="358" height="11" font="8">[10] J. Chow, T. Garﬁnkel, and P. M. Chen. Decoupling dynamic program</text>
<text top="504" left="501" width="333" height="11" font="8">analysis from execution in virtual environments. In <i>USENIX Annual</i></text>
<text top="518" left="501" width="103" height="11" font="22"><i>Technical Conference</i></text>
<text top="517" left="604" width="33" height="11" font="8">, 2008.</text>
<text top="536" left="476" width="358" height="11" font="8">[11] G. W. Dunlap, S. T. King, S. Cinar, M. A. Basrai, and P. M. Chen.</text>
<text top="549" left="501" width="333" height="11" font="8">Revirt: enabling intrusion analysis through virtual-machine logging</text>
<text top="563" left="501" width="328" height="11" font="8">and replay. In <i>Operating Systems Design and Implementation</i>, 2002.</text>
<text top="581" left="476" width="358" height="11" font="8">[12] S. Goldsmith, R. O’Callahan, and A. Aiken. Relational queries over</text>
<text top="595" left="501" width="77" height="11" font="8">program traces.</text>
<text top="595" left="591" width="244" height="11" font="8">In <i>Object-Oriented Programming, Systems, Lan-</i></text>
<text top="609" left="501" width="121" height="11" font="22"><i>guages, and Applications</i></text>
<text top="608" left="621" width="33" height="11" font="8">, 2005.</text>
<text top="627" left="476" width="184" height="11" font="8">[13] D. R. Hower and M. D. Hill.</text>
<text top="627" left="676" width="158" height="11" font="8">Rerun: Exploiting episodes for</text>
<text top="640" left="501" width="334" height="11" font="8">lightweight memory race recording. In <i>International Symposium on</i></text>
<text top="654" left="501" width="110" height="11" font="22"><i>Computer Architecture</i></text>
<text top="654" left="610" width="225" height="11" font="8">, 2008. URL http://dx.doi.org/10.1109/</text>
<text top="668" left="501" width="73" height="10" font="8">ISCA.2008.26</text>
<text top="667" left="574" width="3" height="11" font="8">.</text>
<text top="686" left="476" width="300" height="11" font="8">[14] A. Joshi, S. T. King, G. W. Dunlap, and P. M. Chen.</text>
<text top="686" left="788" width="46" height="11" font="8">Detecting</text>
<text top="699" left="501" width="333" height="11" font="8">past and present intrusions through vulnerability-speciﬁc predicates.</text>
<text top="713" left="501" width="334" height="11" font="8">In <i>Symposium on Operating Systems Principles</i>, 2005. URL http:</text>
<text top="727" left="501" width="226" height="10" font="8">//doi.acm.org/10.1145/1095810.1095820</text>
<text top="726" left="727" width="3" height="11" font="8">.</text>
<text top="745" left="476" width="358" height="11" font="8">[15] S. T. King, G. W. Dunlap, and P. M. Chen. Debugging operating</text>
<text top="758" left="501" width="226" height="11" font="8">systems with time-traveling virtual machines.</text>
<text top="758" left="738" width="96" height="11" font="8">In <i>USENIX Annual</i></text>
<text top="772" left="501" width="103" height="11" font="22"><i>Technical Conference</i></text>
<text top="772" left="604" width="33" height="11" font="8">, 2005.</text>
<text top="790" left="476" width="359" height="11" font="8">[16] E. Kohler, R. Morris, B. Chen, J. Jannotti, and F. M. Kaashoek. The</text>
<text top="804" left="501" width="333" height="11" font="8">Click modular router. <i>ACM Transactions on Computer Systems</i>, 2000.</text>
<text top="822" left="476" width="358" height="11" font="8">[17] K. P. Lawton. Bochs: A portable PC emulator for unix/x. <i>Linux</i></text>
<text top="836" left="501" width="37" height="11" font="22"><i>Journal</i></text>
<text top="836" left="537" width="91" height="11" font="8">. ISSN 1075-3583.</text>
<text top="854" left="476" width="358" height="11" font="8">[18] G. Lefebvre, B. Cully, M. J. Feeley, N. C. Hutchinson, and A. Warﬁeld.</text>
<text top="868" left="501" width="333" height="11" font="8">Tralfamadore: Unifying source code and execution experience (short</text>
<text top="881" left="501" width="123" height="11" font="8">paper). In <i>EuroSys</i>, 2009.</text>
<text top="900" left="476" width="358" height="11" font="8">[19] B. Lewis. Debugging backwards in time. In <i>Workshop on Automated</i></text>
<text top="914" left="501" width="52" height="11" font="22"><i>Debugging</i></text>
<text top="913" left="553" width="33" height="11" font="8">, 2003.</text>
<text top="932" left="476" width="359" height="11" font="8">[20] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wal-</text>
<text top="945" left="501" width="334" height="11" font="8">lace, V. J. Reddi, and K. Hazelwood. Pin: building customized pro-</text>
<text top="959" left="501" width="333" height="11" font="8">gram analysis tools with dynamic instrumentation. In <i>Programming</i></text>
<text top="973" left="501" width="183" height="11" font="22"><i>Language Design and Implementation</i></text>
<text top="972" left="683" width="34" height="11" font="8">, 2005.</text>
<text top="991" left="476" width="358" height="11" font="8">[21] M. Martin, B. Livshits, and M. S. Lam. Finding application errors</text>
<text top="1004" left="501" width="333" height="11" font="8">and security ﬂaws using pql: a program query language. In <i>Object-</i></text>
<text top="1018" left="501" width="300" height="11" font="22"><i>Oriented Programming, Systems, Languages, and Applications</i></text>
<text top="1018" left="801" width="33" height="11" font="8">, 2005.</text>
<text top="1036" left="476" width="358" height="11" font="8">[22] P. Montesinos, L. Ceze, and J. Torrellas. DeLorean: Recording and</text>
<text top="1050" left="501" width="333" height="11" font="8">deterministically replaying shared-memory multiprocessor execution</text>
<text top="1063" left="501" width="333" height="11" font="8">efﬁciently. In <i>International Symposium on Computer Architecture</i>,</text>
<text top="1077" left="501" width="294" height="11" font="8">2008. URL http://dx.doi.org/10.1109/ISCA.2008.36.</text>
</page>
<page number="13" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="81" width="358" height="11" font="8">[23] S. Mysore, B. Mazloom, B. Agrawal, and T. Sherwood. Understand-</text>
<text top="125" left="106" width="333" height="11" font="8">ing and visualizing full systems with data ﬂow tomography. In <i>Archi-</i></text>
<text top="139" left="106" width="330" height="11" font="22"><i>tectural Support for Programming Languages and Operating Systems</i></text>
<text top="138" left="437" width="3" height="11" font="8">,</text>
<text top="152" left="106" width="27" height="11" font="8">2008.</text>
<text top="170" left="81" width="358" height="11" font="8">[24] N. Nethercote and J. Seward. Valgrind: a framework for heavyweight</text>
<text top="183" left="106" width="333" height="11" font="8">dynamic binary instrumentation. In <i>Programming Language Design</i></text>
<text top="197" left="106" width="95" height="11" font="22"><i>and Implementation</i></text>
<text top="197" left="201" width="33" height="11" font="8">, 2007.</text>
<text top="214" left="81" width="359" height="11" font="8">[25] M. Olszewski, K. Mierle, A. Czajkowski, and A. D. Brown. JIT in-</text>
<text top="228" left="106" width="333" height="11" font="8">strumentation: a novel approach to dynamically instrument operating</text>
<text top="241" left="106" width="334" height="11" font="8">systems. In <i>EuroSys</i>, 2007. URL http://doi.acm.org/10.1145/</text>
<text top="255" left="106" width="92" height="10" font="8">1272996.1273000</text>
<text top="255" left="198" width="3" height="11" font="8">.</text>
<text top="273" left="81" width="359" height="11" font="8">[26] S. Park, Y. Zhou, W. Xiong, Z. Yin, R. Kaushik, K. H. Lee, and S. Lu.</text>
<text top="286" left="106" width="333" height="11" font="8">PRES: probabilistic replay with execution sketching on multiproces-</text>
<text top="299" left="106" width="333" height="11" font="8">sors. In <i>Proceedings of the ACM SIGOPS 22nd symposium on Oper-</i></text>
<text top="313" left="106" width="116" height="11" font="22"><i>ating systems principles</i></text>
<text top="313" left="222" width="217" height="11" font="8">, SOSP ’09, pages 177–192, New York, NY,</text>
<text top="326" left="106" width="333" height="11" font="8">USA, 2009. ACM. ISBN 978-1-60558-752-3. doi: http://doi.acm.org/</text>
<text top="340" left="106" width="334" height="11" font="8">10.1145/1629575.1629593. URL http://doi.acm.org/10.1145/</text>
<text top="354" left="106" width="92" height="10" font="8">1629575.1629593</text>
<text top="353" left="198" width="3" height="11" font="8">.</text>
<text top="371" left="81" width="358" height="11" font="8">[27] H. Patil, C. Pereira, M. Stallcup, G. Lueck, and J. Cownie. PinPlay:</text>
<text top="385" left="106" width="333" height="11" font="8">a framework for deterministic replay and reproducible analysis of</text>
<text top="398" left="106" width="333" height="11" font="8">parallel programs. In <i>Code Generation and Optimization</i>, 2010. URL</text>
<text top="412" left="106" width="257" height="10" font="8">http://doi.acm.org/10.1145/1772954.1772958</text>
<text top="412" left="363" width="3" height="11" font="8">.</text>
<text top="430" left="81" width="358" height="11" font="8">[28] V. Paxson. Bro: a system for detecting network intruders in real-time.</text>
<text top="444" left="106" width="96" height="11" font="22"><i>Computer Networks</i></text>
<text top="443" left="202" width="89" height="11" font="8">, 31(23–24), 1999.</text>
<text top="461" left="81" width="358" height="11" font="8">[29] G. Pothier, E. Tanter, and J. Piquer. Scalable omniscient debugging.</text>
<text top="474" left="106" width="333" height="11" font="8">In <i>Object-Oriented Programming, Systems, Languages, and Applica-</i></text>
<text top="488" left="106" width="23" height="11" font="22"><i>tions</i></text>
<text top="488" left="129" width="33" height="11" font="8">, 2007.</text>
<text top="506" left="81" width="358" height="11" font="8">[30] F. Reiss, K. Stockinger, K. Wu, A. Shoshani, and J. M. Hellerstein.</text>
<text top="519" left="106" width="333" height="11" font="8">Enabling real-time querying of live and historical stream data. In</text>
<text top="533" left="106" width="229" height="11" font="22"><i>Scientiﬁc and Statistical Database Management</i></text>
<text top="533" left="335" width="33" height="11" font="8">, 2007.</text>
<text top="551" left="81" width="358" height="11" font="8">[31] M. Rosenblum, S. A. Herrod, E. Witchel, and A. Gupta. Complete</text>
<text top="564" left="106" width="333" height="11" font="8">computer system simulation: The SimOS approach. <i>IEEE Parallel</i></text>
<text top="578" left="106" width="131" height="11" font="22"><i>and Distributed Technology</i></text>
<text top="578" left="237" width="203" height="11" font="8">, 3, 1995. URL http://dx.doi.org/10.</text>
<text top="592" left="106" width="86" height="10" font="8">1109/88.473612</text>
<text top="591" left="192" width="3" height="11" font="8">.</text>
<text top="609" left="81" width="358" height="11" font="8">[32] M. Rosenblum, E. Bugnion, S. Devine, and S. A. Herrod. Using the</text>
<text top="622" left="106" width="333" height="11" font="8">SimOS machine simulator to study complex computer systems. <i>ACM</i></text>
<text top="636" left="106" width="256" height="11" font="22"><i>Transactions on Modeling and Computer Simulation</i></text>
<text top="636" left="362" width="78" height="11" font="8">, 7, 1997. URL</text>
<text top="650" left="106" width="245" height="10" font="8">http://doi.acm.org/10.1145/244804.244807</text>
<text top="649" left="351" width="3" height="11" font="8">.</text>
<text top="667" left="81" width="358" height="11" font="8">[33] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager, M. G. Kang,</text>
<text top="681" left="106" width="333" height="11" font="8">Z. Liang, N. James, P. Poosankam, and P. Saxena. BitBlaze: A new</text>
<text top="694" left="106" width="333" height="11" font="8">approach to computer security via binary analysis. In <i>International</i></text>
<text top="708" left="106" width="212" height="11" font="22"><i>Conference on Information Systems Security</i></text>
<text top="708" left="318" width="121" height="11" font="8">, 2008. doi: http://dx.doi.</text>
<text top="721" left="106" width="334" height="11" font="8">org/10.1007/978-3-540-89862-7 1. URL http://dx.doi.org/10.</text>
<text top="735" left="106" width="150" height="10" font="8">1007/978-3-540-89862-7_1</text>
<text top="734" left="256" width="3" height="11" font="8">.</text>
<text top="752" left="81" width="358" height="11" font="8">[34] K. Veeraraghavan, D. Lee, B. Wester, J. Ouyang, P. M. Chen, J. Flinn,</text>
<text top="766" left="106" width="333" height="11" font="8">and S. Narayanasamy. DoublePlay: parallelizing sequential logging</text>
<text top="779" left="106" width="333" height="11" font="8">and replay. In <i>Proceedings of the sixteenth international conference</i></text>
<text top="793" left="106" width="333" height="11" font="22"><i>on Architectural support for programming languages and operating</i></text>
<text top="807" left="106" width="36" height="11" font="22"><i>systems</i></text>
<text top="806" left="143" width="297" height="11" font="8">, ASPLOS ’11, pages 15–26, New York, NY, USA, 2011.</text>
<text top="820" left="106" width="333" height="11" font="8">ACM. ISBN 978-1-4503-0266-1. doi: http://doi.acm.org/10.1145/</text>
<text top="833" left="106" width="334" height="11" font="8">1950365.1950370. URL http://doi.acm.org/10.1145/1950365.</text>
<text top="847" left="106" width="43" height="10" font="8">1950370</text>
<text top="846" left="149" width="3" height="11" font="8">.</text>
<text top="864" left="81" width="358" height="11" font="8">[35] K. Vonnegut. <i>Slaughterhouse Five</i>. Delacorte, 1969. ISBN 0-385-</text>
<text top="878" left="106" width="43" height="11" font="8">31208-3.</text>
<text top="896" left="81" width="358" height="11" font="8">[36] M. Weiser. Program slicing. In <i>International Conference on Software</i></text>
<text top="910" left="106" width="59" height="11" font="22"><i>Engineering</i></text>
<text top="909" left="165" width="33" height="11" font="8">, 1981.</text>
<text top="927" left="81" width="358" height="11" font="8">[37] M. Xu, R. Bodik, and M. D. Hill. A “ﬂight data recorder” for enabling</text>
<text top="941" left="106" width="333" height="11" font="8">full-system multiprocessor deterministic replay. In <i>International Sym-</i></text>
<text top="955" left="106" width="162" height="11" font="22"><i>posium on Computer Architecture</i></text>
<text top="954" left="268" width="33" height="11" font="8">, 2003.</text>
<text top="972" left="81" width="359" height="11" font="8">[38] M. Xu, V. Malyugin, J. Sheldon, G. Venkitachalam, and B. Weissman.</text>
<text top="985" left="106" width="333" height="11" font="8">Retrace: Collecting execution trace with virtual machine deterministic</text>
<text top="999" left="106" width="279" height="11" font="8">replay. In <i>Modeling, Benchmarking and Simulation</i>, 2007.</text>
<text top="1017" left="81" width="358" height="11" font="8">[39] X. Zhang and R. Gupta. Whole execution traces and their applications.</text>
<text top="1031" left="106" width="286" height="11" font="22"><i>ACM Transactions on Architecture and Code Optimization</i></text>
<text top="1030" left="392" width="47" height="11" font="8">, 2, 2005.</text>
<text top="1044" left="106" width="287" height="11" font="8">URL http://doi.acm.org/10.1145/1089008.1089012.</text>
</page>
</pdf2xml>
