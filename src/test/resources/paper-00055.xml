<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="24" family="Times" color="#000000"/>
	<fontspec id="1" size="14" family="Times" color="#000000"/>
	<fontspec id="2" size="11" family="Times" color="#000000"/>
	<fontspec id="3" size="8" family="Times" color="#000000"/>
	<fontspec id="4" size="6" family="Times" color="#000000"/>
	<fontspec id="5" size="9" family="Times" color="#000000"/>
<text top="118" left="121" width="682" height="24" font="0">Path-Exploration Lifting: Hi-Fi Tests for Lo-Fi Emulators</text>
<text top="180" left="131" width="133" height="15" font="1">Lorenzo Martignoni</text>
<text top="204" left="162" width="70" height="12" font="2">UC Berkeley</text>
<text top="222" left="132" width="131" height="12" font="2">martignlo@gmail.com</text>
<text top="180" left="393" width="130" height="15" font="1">Stephen McCamant</text>
<text top="204" left="422" width="70" height="12" font="2">UC Berkeley</text>
<text top="222" left="389" width="137" height="12" font="2">smcc@cs.berkeley.edu</text>
<text top="180" left="651" width="133" height="15" font="1">Pongsin Poosankam</text>
<text top="204" left="659" width="118" height="12" font="2">CMU &amp; UC Berkeley</text>
<text top="222" left="656" width="123" height="12" font="2">ppoosank@cmu.edu</text>
<text top="266" left="240" width="77" height="15" font="1">Dawn Song</text>
<text top="290" left="243" width="70" height="12" font="2">UC Berkeley</text>
<text top="305" left="225" width="106" height="12" font="2">Berkeley, CA, USA</text>
<text top="322" left="195" width="167" height="12" font="2">dawnsong@cs.berkeley.edu</text>
<text top="266" left="586" width="103" height="15" font="1">Petros Maniatis</text>
<text top="290" left="610" width="54" height="12" font="2">Intel Labs</text>
<text top="305" left="584" width="106" height="12" font="2">Berkeley, CA, USA</text>
<text top="322" left="558" width="158" height="12" font="2">petros.maniatis@intel.com</text>
<text top="407" left="81" width="61" height="15" font="1">Abstract</text>
<text top="431" left="81" width="359" height="12" font="2">Processor emulators are widely used to provide isolation and instru-</text>
<text top="445" left="81" width="359" height="12" font="2">mentation of binary software. However they have proved difﬁcult</text>
<text top="460" left="81" width="359" height="12" font="2">to implement correctly: processor speciﬁcations have many corner</text>
<text top="475" left="81" width="359" height="12" font="2">cases that are not exercised by common workloads. It is untenable</text>
<text top="490" left="81" width="359" height="12" font="2">to base other system security properties on the correctness of em-</text>
<text top="505" left="81" width="359" height="12" font="2">ulators that have received only ad-hoc testing. To obtain emulators</text>
<text top="520" left="81" width="359" height="12" font="2">that are worthy of the required trust, we propose a technique to ex-</text>
<text top="535" left="81" width="359" height="12" font="2">plore a high-ﬁdelity emulator with symbolic execution, and then lift</text>
<text top="550" left="81" width="359" height="12" font="2">those test cases to test a lower-ﬁdelity emulator. The high-ﬁdelity</text>
<text top="565" left="81" width="359" height="12" font="2">emulator serves as a proxy for the hardware speciﬁcation, but we</text>
<text top="580" left="81" width="359" height="12" font="2">can also further validate by running the tests on real hardware. We</text>
<text top="595" left="81" width="359" height="12" font="2">implement our approach and apply it to generate about 610,000 test</text>
<text top="610" left="81" width="359" height="12" font="2">cases; for about 95% of the instructions we achieve complete path</text>
<text top="625" left="81" width="359" height="12" font="2">coverage. The tests reveal thousands of individual differences; we</text>
<text top="640" left="81" width="359" height="12" font="2">analyze those differences to shed light on a number of root causes,</text>
<text top="655" left="81" width="313" height="12" font="2">such as atomicity violations and missing security features.</text>
<text top="679" left="81" width="198" height="12" font="2">Categories and Subject Descriptors</text>
<text top="679" left="293" width="147" height="12" font="2">D.2.5 [Testing and Debug-</text>
<text top="694" left="81" width="24" height="12" font="2">ging</text>
<text top="694" left="105" width="81" height="12" font="2">]: Testing tools</text>
<text top="719" left="81" width="82" height="12" font="2">General Terms</text>
<text top="719" left="177" width="176" height="12" font="2">Reliability, Security, Veriﬁcation</text>
<text top="744" left="81" width="53" height="12" font="2">Keywords</text>
<text top="744" left="148" width="292" height="12" font="2">Symbolic binary execution, CPU emulators, cross-</text>
<text top="759" left="81" width="53" height="12" font="2">validation</text>
<text top="792" left="81" width="12" height="15" font="1">1.</text>
<text top="792" left="110" width="89" height="15" font="1">Introduction</text>
<text top="815" left="81" width="359" height="12" font="2">Processor emulators are widely used in systems, to provide pri-</text>
<text top="830" left="81" width="359" height="12" font="2">vacy [29], integrity [17], instrumentation, replay, sandboxing [9],</text>
<text top="845" left="81" width="359" height="12" font="2">and program analysis [3, 27]. In principle, any component meant to</text>
<text top="860" left="81" width="119" height="12" font="2">mediate transparently</text>
<text top="860" left="204" width="236" height="12" font="2">between an operating system and the hard-</text>
<text top="875" left="81" width="359" height="12" font="2">ware needs to emulate the hardware to some degree; consequently,</text>
<text top="890" left="81" width="359" height="12" font="2">processor emulators have been linchpin components for a large</text>
<text top="905" left="81" width="153" height="12" font="2">class of critical applications.</text>
<text top="920" left="99" width="341" height="12" font="2">Unfortunately, our critical reliance on emulators has not been</text>
<text top="935" left="81" width="359" height="12" font="2">met by a commensurate assurance of their correctness. Emulators</text>
<text top="1025" left="81" width="359" height="9" font="3">This is the authors’ version of the work. It is made available by permission of the ACM</text>
<text top="1037" left="81" width="359" height="9" font="3">for your personal use to ensure timely dissemination of scholarly and technical work,</text>
<text top="1049" left="81" width="121" height="9" font="3">rather than for redistribution.</text>
<text top="1064" left="81" width="56" height="9" font="3">ASPLOS’12,</text>
<text top="1064" left="147" width="173" height="9" font="3">March 3–7, 2012, London, England, UK.</text>
<text top="1076" left="81" width="259" height="9" font="3">Copyright c 2012 ACM 978-1-4503-0759-8/12/03. . . $10.00</text>
<text top="410" left="476" width="359" height="12" font="2">are just too hard to implement correctly, for several reasons. First,</text>
<text top="425" left="476" width="359" height="12" font="2">emulators are large, complex pieces of software meant to mirror</text>
<text top="439" left="476" width="359" height="12" font="2">complex emulated layers such processors. Second, as components</text>
<text top="454" left="476" width="359" height="12" font="2">that often appear in the critical path of applications, emulators must</text>
<text top="469" left="476" width="359" height="12" font="2">be optimized aggressively, often using pervasive, brittle optimiza-</text>
<text top="484" left="476" width="359" height="12" font="2">tions involving self-modifying code and multiple intermediate rep-</text>
<text top="499" left="476" width="359" height="12" font="2">resentations. Third, typical emulated systems exhibit great variance</text>
<text top="514" left="476" width="359" height="12" font="2">in how their different features are exercised, which leads to emu-</text>
<text top="529" left="476" width="359" height="12" font="2">lators with many corner cases that are infrequently exercised by</text>
<text top="544" left="476" width="110" height="12" font="2">common workloads.</text>
<text top="559" left="493" width="341" height="12" font="2">In this paper, we tackle the problem of increasing the assur-</text>
<text top="574" left="476" width="359" height="12" font="2">ance of processor emulators, hoping to generalize what we learn to</text>
<text top="589" left="476" width="359" height="12" font="2">broader emulation assurance. Speciﬁcally, we present PokeEMU,</text>
<text top="604" left="476" width="359" height="12" font="2">a systematic framework for high-coverage testing and cross-</text>
<text top="619" left="476" width="274" height="12" font="2">validation of processor emulators such as Bochs</text>
<text top="617" left="750" width="4" height="8" font="4">1</text>
<text top="619" left="761" width="65" height="12" font="2">and QEMU</text>
<text top="617" left="826" width="4" height="8" font="4">2</text>
<text top="619" left="831" width="3" height="12" font="2">.</text>
<text top="634" left="476" width="359" height="12" font="2">Our work is inspired by two observations. First, there are sev-</text>
<text top="649" left="476" width="359" height="12" font="2">eral emulators for common processor architectures such as IA-32,</text>
<text top="664" left="476" width="359" height="12" font="2">each of which achieves a different point in the complexity-ﬁdelity</text>
<text top="679" left="476" width="359" height="12" font="2">spectrum. For example, the Bochs interpreter is a faithful but rela-</text>
<text top="694" left="476" width="359" height="12" font="2">tively slow implementation of the processor (a “Hi-Fi” emulator),</text>
<text top="709" left="476" width="359" height="12" font="2">whereas QEMU, a dynamic binary translator, is faster but much</text>
<text top="724" left="476" width="283" height="12" font="2">more complex, buggier, and less complete (“Lo-Fi”)</text>
<text top="722" left="758" width="4" height="8" font="4">3</text>
<text top="724" left="764" width="71" height="12" font="2">. Second, ex-</text>
<text top="739" left="476" width="359" height="12" font="2">ploration based on symbolic execution has matured signiﬁcantly</text>
<text top="754" left="476" width="359" height="12" font="2">in recent years, allowing us to leverage such techniques to enable</text>
<text top="769" left="476" width="303" height="12" font="2">high-coverage path exploration and test-case generation.</text>
<text top="784" left="493" width="341" height="12" font="2">We capitalize on these observations by exploiting the following</text>
<text top="799" left="476" width="359" height="12" font="2">insight: one can use symbolic execution on a Hi-Fi emulator to</text>
<text top="814" left="476" width="359" height="12" font="2">generate high-quality test cases for a Lo-Fi emulator. Analysis of</text>
<text top="829" left="476" width="359" height="12" font="2">the Hi-Fi emulator extracts all the distinct behaviors and corner</text>
<text top="844" left="476" width="359" height="12" font="2">cases it implements; those are useful because we assume the Hi-</text>
<text top="859" left="476" width="359" height="12" font="2">Fi emulator’s behavior is closer to the ideal processor speciﬁcation</text>
<text top="874" left="476" width="359" height="12" font="2">than the behaviors implemented by the Lo-Fi emulator. Using then</text>
<text top="889" left="476" width="359" height="12" font="2">the Hi-Fi emulator’s behaviors to generate automatically a test suite</text>
<text top="904" left="476" width="359" height="12" font="2">for the Lo-Fi emulator, one can detect and ﬁx deviations of the Lo-</text>
<text top="919" left="476" width="359" height="12" font="2">Fi emulator from the behavior of the (presumed “more correct”)</text>
<text top="934" left="476" width="359" height="12" font="2">Hi-Fi emulator or the emulated hardware. We call this methodology</text>
<text top="949" left="476" width="126" height="12" font="2">path-exploration lifting</text>
<text top="949" left="601" width="233" height="12" font="2">, since it automatically “lifts” deﬁnitions of</text>
<text top="964" left="476" width="359" height="12" font="2">program behaviors—as captured by distinct code paths—from one</text>
<text top="979" left="476" width="108" height="12" font="2">emulator to another.</text>
<text top="1013" left="476" width="4" height="8" font="4">1</text>
<text top="1016" left="482" width="208" height="9" font="5">http://bochs.sourceforge.net/</text>
<text top="1015" left="690" width="3" height="11" font="5">.</text>
<text top="1031" left="476" width="4" height="8" font="4">2</text>
<text top="1033" left="482" width="143" height="9" font="5">http://www.qemu.com/</text>
<text top="1033" left="626" width="3" height="11" font="5">.</text>
<text top="1048" left="476" width="4" height="8" font="4">3</text>
<text top="1050" left="482" width="352" height="11" font="5">We use ﬁdelity loosely to denote how closely an emulator approximates</text>
<text top="1064" left="476" width="359" height="11" font="5">the target architecture; a buggier, less complete emulator has lower ﬁdelity</text>
<text top="1077" left="476" width="218" height="11" font="5">than a more correct, more complete emulator.</text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="6" size="9" family="Times" color="#000000"/>
<text top="111" left="99" width="341" height="12" font="2">Interestingly, although in this paper we use path-exploration lift-</text>
<text top="126" left="81" width="359" height="12" font="2">ing from a Hi-Fi emulator to a Lo-Fi emulator, hoping to “rub off”</text>
<text top="141" left="81" width="359" height="12" font="2">some of the higher ﬁdelity of the Hi-Fi emulator to the Lo-Fi one,</text>
<text top="156" left="81" width="359" height="12" font="2">the technique is more general. It can be used in the opposite di-</text>
<text top="171" left="81" width="359" height="12" font="2">rection, from Lo-Fi to Hi-Fi, to see how the Hi-Fi emulator would</text>
<text top="186" left="81" width="359" height="12" font="2">behave for the distinct cases implemented by the Lo-Fi emulator</text>
<text top="201" left="81" width="359" height="12" font="2">developers. Beyond emulation, for any two implementations of the</text>
<text top="215" left="81" width="359" height="12" font="2">same precise speciﬁcation (e.g., SQL query engines, SSL imple-</text>
<text top="230" left="81" width="359" height="12" font="2">mentations, etc.), it makes sense to analyze one implementation to</text>
<text top="245" left="81" width="340" height="12" font="2">generate test cases for comparison to the other implementation.</text>
<text top="260" left="99" width="341" height="12" font="2">Certainly neither cross-validation nor path exploration via sym-</text>
<text top="275" left="81" width="359" height="12" font="2">bolic execution are new. However, path exploration on an arti-</text>
<text top="290" left="81" width="359" height="12" font="2">fact to test that same artifact can at best trigger its own corner</text>
<text top="305" left="81" width="359" height="12" font="2">cases, but not capture those unimplemented in it, which our ap-</text>
<text top="320" left="81" width="359" height="12" font="2">proach can achieve. More importantly, cross-validation alone can,</text>
<text top="335" left="81" width="359" height="12" font="2">at best, do random directed testing (“fuzzing”) without capitalizing</text>
<text top="350" left="81" width="359" height="12" font="2">on the fundamental differences between the different tested arti-</text>
<text top="365" left="81" width="359" height="12" font="2">facts. In contrast, applying systematic program analysis for path</text>
<text top="380" left="81" width="359" height="12" font="2">exploration, such as symbolic execution, to amplify the beneﬁts</text>
<text top="395" left="81" width="359" height="12" font="2">of cross-validation is novel to our knowledge. Ideally, one would</text>
<text top="410" left="81" width="359" height="12" font="2">want to apply path-exploration lifting to a hardware speciﬁcation</text>
<text top="425" left="81" width="359" height="12" font="2">(e.g., the register-transfer language speciﬁcation of a circuit); un-</text>
<text top="440" left="81" width="359" height="12" font="2">fortunately, such speciﬁcations for commodity hardware are pro-</text>
<text top="455" left="81" width="359" height="12" font="2">prietary and extremely well guarded. By applying the methodology</text>
<text top="469" left="81" width="359" height="12" font="2">to a Hi-Fi emulator, we capture corner cases from the next best</text>
<text top="484" left="81" width="359" height="12" font="2">thing. Conveniently, the Hi-Fi emulator need not be perfect, only</text>
<text top="499" left="81" width="359" height="12" font="2">complete: we use the actual hardware to test our emulators against,</text>
<text top="514" left="81" width="359" height="12" font="2">so correctness bugs in the Hi-Fi emulator do not impact our results,</text>
<text top="529" left="81" width="320" height="12" font="2">and can be discovered through our approach as side effects.</text>
<text top="544" left="99" width="341" height="12" font="2">Although path-exploration lifting is a general concept, its im-</text>
<text top="559" left="81" width="359" height="12" font="2">plementation is challenging, often losing generality. In this paper</text>
<text top="574" left="81" width="359" height="12" font="2">we apply and customize the technique for Bochs and QEMU, deal-</text>
<text top="589" left="81" width="359" height="12" font="2">ing with several fundamental challenges. While in the past others</text>
<text top="604" left="81" width="359" height="12" font="2">have used symbolic execution to generate high-coverage test cases</text>
<text top="619" left="81" width="359" height="12" font="2">for programs, those programs were applications with scalar or other</text>
<text top="634" left="81" width="359" height="12" font="2">simple input types. In contrast, PokeEMU must generate test cases</text>
<text top="649" left="81" width="359" height="12" font="2">for emulators, whose input is a starting machine state and a test in-</text>
<text top="664" left="81" width="359" height="12" font="2">struction, a staggeringly large state space to explore. Furthermore,</text>
<text top="679" left="81" width="359" height="12" font="2">even after PokeEMU makes sense out of the state space and gener-</text>
<text top="694" left="81" width="359" height="12" font="2">ates some test cases with starting states for a given test instruction,</text>
<text top="709" left="81" width="359" height="12" font="2">we must ﬁgure out how to lead the emulated system to the desired</text>
<text top="724" left="81" width="359" height="12" font="2">start state: how to get it to set its registers, conﬁguration, program</text>
<text top="738" left="81" width="359" height="12" font="2">counter, and execution mode to the values required, which is not</text>
<text top="753" left="81" width="359" height="12" font="2">straightforward since certain parts of the machine state cannot be</text>
<text top="768" left="81" width="359" height="12" font="2">set directly and most instructions have multiple side effects that</text>
<text top="783" left="81" width="359" height="12" font="2">may undo prior state setup. Finally, it may not always be possible</text>
<text top="798" left="81" width="359" height="12" font="2">to analyze the source code of an emulator due to intellectual prop-</text>
<text top="813" left="81" width="359" height="12" font="2">erty restrictions and, even without such restrictions, the emulator</text>
<text top="828" left="81" width="359" height="12" font="2">may manipulate system state through multiple intermediate repre-</text>
<text top="843" left="81" width="359" height="12" font="2">sentations, via just-in-time compilers, etc.; operating on the binary</text>
<text top="858" left="81" width="343" height="12" font="2">executable may be the only option for testing system emulators.</text>
<text top="887" left="81" width="78" height="12" font="2">Contributions.</text>
<text top="886" left="163" width="277" height="12" font="2">This paper proposes path-exploration lifting, a new</text>
<text top="901" left="81" width="359" height="12" font="2">methodology for exhaustively exploiting the correctness of one ar-</text>
<text top="916" left="81" width="359" height="12" font="2">tifact to improve the correctness of another. The paper presents the</text>
<text top="931" left="81" width="359" height="12" font="2">design, implementation, and evaluation of the methodology in the</text>
<text top="946" left="81" width="359" height="12" font="2">PokeEMU system for processor emulators. PokeEMU consists of</text>
<text top="961" left="81" width="359" height="12" font="2">several key components. First, the paper presents a symbolic execu-</text>
<text top="976" left="81" width="359" height="12" font="2">tion engine for x86 binaries, FuzzBALL, used to explore paths from</text>
<text top="991" left="81" width="359" height="12" font="2">binaries, as opposed to source code. Second, it describes a novel ex-</text>
<text top="1006" left="81" width="359" height="12" font="2">ploration strategy for processor emulators, which starts with the in-</text>
<text top="1021" left="81" width="359" height="12" font="2">struction decoders, generating instructions to iterate over, and then</text>
<text top="1036" left="81" width="359" height="12" font="2">explores the instruction emulator to identify paths per instruction,</text>
<text top="1051" left="81" width="359" height="12" font="2">with optimizations to reduce the state space. Third, it details an</text>
<text top="1066" left="81" width="359" height="12" font="2">essential tool for processor testing: an input-state generator that,</text>
<text top="227" left="520" width="89" height="12" font="5">(1) Instruction set </text>
<text top="241" left="535" width="56" height="12" font="5">exploration</text>
<text top="227" left="676" width="98" height="12" font="5">(2) CPU state-space </text>
<text top="241" left="696" width="56" height="12" font="5">exploration</text>
<text top="403" left="708" width="84" height="12" font="5">(3) Test program </text>
<text top="417" left="722" width="53" height="12" font="5">generation</text>
<text top="403" left="595" width="39" height="12" font="5">(4) Test </text>
<text top="417" left="590" width="48" height="12" font="5">execution</text>
<text top="403" left="513" width="16" height="12" font="5">(5) </text>
<text top="417" left="500" width="39" height="12" font="5">Analysis</text>
<text top="157" left="518" width="25" height="12" font="6"><i>Hi-Fi </i></text>
<text top="171" left="507" width="45" height="12" font="6"><i>emulator</i></text>
<text top="188" left="510" width="42" height="9" font="4">Instruction </text>
<text top="199" left="514" width="31" height="9" font="4">Decoder</text>
<text top="157" left="697" width="25" height="12" font="6"><i>Hi-Fi </i></text>
<text top="171" left="686" width="45" height="12" font="6"><i>emulator</i></text>
<text top="188" left="688" width="42" height="9" font="4">Instruction </text>
<text top="199" left="691" width="34" height="9" font="4">Emulator</text>
<text top="126" left="516" width="94" height="12" font="5">Symbolic Execution</text>
<text top="175" left="582" width="49" height="10" font="3">Instruction </text>
<text top="187" left="587" width="37" height="10" font="3">Opcodes</text>
<text top="126" left="695" width="94" height="12" font="5">Symbolic Execution</text>
<text top="175" left="778" width="22" height="10" font="3">Path </text>
<text top="187" left="763" width="49" height="10" font="3">Constraints</text>
<text top="300" left="706" width="91" height="12" font="5">State Initialization </text>
<text top="314" left="725" width="50" height="12" font="5">Generator</text>
<text top="336" left="514" width="10" height="10" font="3">=?</text>
<text top="327" left="603" width="25" height="12" font="6"><i>Hi-Fi </i></text>
<text top="342" left="591" width="45" height="12" font="6"><i>emulator</i></text>
<text top="361" left="602" width="26" height="12" font="6"><i>Lo-Fi </i></text>
<text top="376" left="591" width="45" height="12" font="6"><i>emulator</i></text>
<text top="301" left="590" width="49" height="12" font="6"><i>Hardware</i></text>
<text top="345" left="712" width="77" height="10" font="3">Baseline Initializer</text>
<text top="358" left="748" width="5" height="10" font="3">+</text>
<text top="371" left="708" width="84" height="10" font="3">Test State Initializer</text>
<text top="456" left="600" width="111" height="12" font="2">Figure 1. Overview</text>
<text top="499" left="476" width="359" height="12" font="2">given an input state for a test case, automatically creates a program</text>
<text top="514" left="476" width="359" height="12" font="2">to bring an emulator or physical system to that state, so that the</text>
<text top="529" left="476" width="359" height="12" font="2">test can take place. Finally, it conducts the ﬁrst systematic study of</text>
<text top="544" left="476" width="359" height="12" font="2">the approach using symbolic execution, assessing QEMU’s emula-</text>
<text top="558" left="476" width="359" height="12" font="2">tion ﬁdelity using test cases lifted from Bochs and comparing it to</text>
<text top="573" left="476" width="359" height="12" font="2">both Bochs and real hardware, identifying several deviations from</text>
<text top="588" left="476" width="100" height="12" font="2">expected behavior.</text>
<text top="603" left="493" width="341" height="12" font="2">Our evaluation establishes four key points. First, for more than</text>
<text top="618" left="476" width="359" height="12" font="2">95% of the instructions, PokeEMU achieved complete path cover-</text>
<text top="633" left="476" width="359" height="12" font="2">age. Second, PokeEMU found a large number of deviations among</text>
<text top="648" left="476" width="359" height="12" font="2">the emulators tested and real hardware: out of about 610,000 pro-</text>
<text top="663" left="476" width="359" height="12" font="2">grams, more than 72,000 triggered differences, and we have iden-</text>
<text top="678" left="476" width="359" height="12" font="2">tiﬁed a number of root causes, some of which affect many instruc-</text>
<text top="693" left="476" width="359" height="12" font="2">tions. Third, many of the deviations found could not have been</text>
<text top="708" left="476" width="359" height="12" font="2">found by prior emulator-testing approaches, such as random test-</text>
<text top="723" left="476" width="359" height="12" font="2">ing. Finally, at least two of the deviations found could lead to sig-</text>
<text top="738" left="476" width="359" height="12" font="2">niﬁcant security problems, when those emulators are used as the</text>
<text top="753" left="476" width="129" height="12" font="2">basis for a security tool.</text>
<text top="786" left="476" width="12" height="15" font="1">2.</text>
<text top="786" left="504" width="67" height="15" font="1">Overview</text>
<text top="809" left="476" width="359" height="12" font="2">A CPU or instruction-set emulator is a program that runs on one</text>
<text top="824" left="476" width="359" height="12" font="2">architecture (host), but whose functionality is to simulate the pro-</text>
<text top="839" left="476" width="359" height="12" font="2">cessor of a potentially different architecture (guest). Our goal in</text>
<text top="854" left="476" width="359" height="12" font="2">this work is to discover differences between the behavior of a CPU</text>
<text top="868" left="476" width="359" height="12" font="2">emulator, and the behavior of another emulator or real hardware:</text>
<text top="883" left="476" width="291" height="12" font="2">such a difference enables us to ﬁnd bugs in emulators.</text>
<text top="898" left="493" width="341" height="12" font="2">To be precise, we deﬁne the (machine) state of a CPU emulator</text>
<text top="913" left="476" width="359" height="12" font="2">or hardware system to be all the values, such as in general pur-</text>
<text top="928" left="476" width="359" height="12" font="2">pose registers, control registers, ﬂags, or memory, that can affect</text>
<text top="943" left="476" width="359" height="12" font="2">the execution of a future instruction. We say that systems show a</text>
<text top="958" left="476" width="359" height="12" font="2">behavioral difference if we start them in the same machine state</text>
<text top="973" left="476" width="359" height="12" font="2">(called the test state), and they execute the same instruction (called</text>
<text top="988" left="476" width="359" height="12" font="2">the test instruction), but after the instruction executes they are in</text>
<text top="1003" left="476" width="359" height="12" font="2">different machine states (called the ﬁnal states). Example differ-</text>
<text top="1018" left="476" width="359" height="12" font="2">ences include having a different value in a register, or not raising</text>
<text top="1033" left="476" width="214" height="12" font="2">an exception when the hardware would.</text>
<text top="1061" left="476" width="56" height="12" font="2">Approach.</text>
<text top="1061" left="535" width="299" height="12" font="2">At a high level, our approach is to discover differences</text>
<text top="1076" left="476" width="359" height="12" font="2">by constructing high-coverage tests that trigger them, using the</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="7" size="5" family="Times" color="#000000"/>
<text top="111" left="81" width="359" height="12" font="2">methodology of path-exploration lifting. Furthermore, unlike tra-</text>
<text top="126" left="81" width="359" height="12" font="2">ditional program testing where the tests are simply scalar test input</text>
<text top="141" left="81" width="359" height="12" font="2">values, a test for the emulator would specify a test state and a test</text>
<text top="156" left="81" width="359" height="12" font="2">instruction. And in practice, we generate test programs: stand-alone</text>
<text top="171" left="81" width="359" height="12" font="2">programs that can run on an emulator to set up the test states and</text>
<text top="186" left="81" width="179" height="12" font="2">then execute the test instructions.</text>
<text top="201" left="99" width="341" height="12" font="2">Our design goals are (1) to maximize the coverage of our test-</text>
<text top="215" left="81" width="359" height="12" font="2">ing, subject to the constraints of (2) producing a practical number</text>
<text top="230" left="81" width="359" height="12" font="2">of tests, while (3) requiring relatively little human guidance in mod-</text>
<text top="245" left="81" width="359" height="12" font="2">ifying the emulators or conﬁguring the tests. Next we discuss how</text>
<text top="260" left="81" width="308" height="12" font="2">we apply these principles to the key technical challenges.</text>
<text top="289" left="81" width="149" height="12" font="2">Challenges and Techniques.</text>
<text top="289" left="233" width="206" height="12" font="2">First, the space of possible instructions</text>
<text top="304" left="81" width="359" height="12" font="2">and machine states is astronomically large, so it would not be prac-</text>
<text top="319" left="81" width="359" height="12" font="2">tical to individually test every possible instruction and initial state.</text>
<text top="334" left="81" width="359" height="12" font="2">However this space also has complex structure, so choosing instruc-</text>
<text top="348" left="81" width="359" height="12" font="2">tions and states at random, or based on typical usage, would miss</text>
<text top="363" left="81" width="359" height="12" font="2">differences that occur in corner cases. We address this challenge</text>
<text top="378" left="81" width="359" height="12" font="2">by using symbolic execution to explore the space based on how</text>
<text top="393" left="81" width="359" height="12" font="2">components of the state are used by a tested emulator. First, we</text>
<text top="408" left="81" width="359" height="12" font="2">apply symbolic execution on the instruction decoder of an emu-</text>
<text top="423" left="81" width="359" height="12" font="2">lator to select test instructions. Then for each test instruction, we</text>
<text top="438" left="81" width="359" height="12" font="2">apply symbolic execution to the emulator’s implementation of that</text>
<text top="453" left="81" width="359" height="12" font="2">instruction. Speciﬁcally, we choose a subset of the machine state</text>
<text top="468" left="81" width="359" height="12" font="2">as relevant (this choice is discussed in detail in Section 3.3.1 and</text>
<text top="483" left="81" width="359" height="12" font="2">Figure 3). Symbolic execution determines a test state for each ex-</text>
<text top="498" left="81" width="359" height="12" font="2">ecution path through the implementation that can be triggered by</text>
<text top="513" left="81" width="324" height="12" font="2">some assignment of values to the selected state components.</text>
<text top="528" left="99" width="341" height="12" font="2">A second challenge is that CPU architectures do not provide</text>
<text top="543" left="81" width="359" height="12" font="2">a uniform interface to initialize all the components of their state.</text>
<text top="558" left="81" width="359" height="12" font="2">For instance control registers must be initialized using specialized</text>
<text top="573" left="81" width="359" height="12" font="2">instructions, and some kinds of initialization are either prerequisites</text>
<text top="588" left="81" width="359" height="12" font="2">for or conﬂict with other kinds. To address these challenges, we</text>
<text top="602" left="81" width="359" height="12" font="2">write a ﬁxed piece of code to initialize a machine to a baseline</text>
<text top="617" left="81" width="359" height="12" font="2">state. Then our tool automatically instantiates a sequence of test</text>
<text top="633" left="81" width="86" height="12" font="2">state initializers</text>
<text top="632" left="170" width="270" height="12" font="2">to set the remaining parts of the state. Thus the test</text>
<text top="647" left="81" width="359" height="12" font="2">program consists of the baseline state initializer, then the test state</text>
<text top="662" left="81" width="193" height="12" font="2">initializers, then the test instruction.</text>
<text top="677" left="99" width="341" height="12" font="2">A third challenge is that many emulators use inline assembly</text>
<text top="692" left="81" width="359" height="12" font="2">code or perform just-in-time (JIT) compilation, so they cannot</text>
<text top="707" left="81" width="359" height="12" font="2">be properly analyzed at the source code level. We address this</text>
<text top="722" left="81" width="359" height="12" font="2">challenge by using binary-level symbolic execution, which applies</text>
<text top="737" left="81" width="359" height="12" font="2">uniformly to an interpreter compiled from source code and the</text>
<text top="752" left="81" width="359" height="12" font="2">machine code created by a just-in-time compiler. Although we</text>
<text top="767" left="81" width="359" height="12" font="2">did have source code for the emulators we studied, we took on</text>
<text top="782" left="81" width="359" height="12" font="2">this challenge so as to prepare for also studying closed-source,</text>
<text top="797" left="81" width="188" height="12" font="2">commercial emulators and VMMs.</text>
<text top="825" left="81" width="110" height="12" font="2">System Architecture.</text>
<text top="825" left="195" width="245" height="12" font="2">Our approach has four steps: exploration, test</text>
<text top="840" left="81" width="359" height="12" font="2">program generation, test program execution, and difference analy-</text>
<text top="855" left="81" width="75" height="12" font="2">sis (Figure 1).</text>
<text top="870" left="99" width="341" height="12" font="2">In the ﬁrst step, exploration, we use symbolic execution to ex-</text>
<text top="885" left="81" width="359" height="12" font="2">plore an emulator. To efﬁciently partition the space of possible in-</text>
<text top="900" left="81" width="359" height="12" font="2">struction executions, we do the exploration in two steps: we ﬁrst</text>
<text top="915" left="81" width="359" height="12" font="2">explore to generate legal instructions (Figure 1(1)), and then ex-</text>
<text top="930" left="81" width="359" height="12" font="2">plore the execution of each instruction separately (Figure 1(2)). We</text>
<text top="945" left="81" width="359" height="12" font="2">progressively explore all the execution paths of an instruction im-</text>
<text top="960" left="81" width="359" height="12" font="2">plementation, given a selected set of symbolic state components,</text>
<text top="975" left="81" width="359" height="12" font="2">and generate one test for each path. Thus the output of this step is</text>
<text top="990" left="81" width="359" height="12" font="2">a set of pairs of test instructions and test states. The symbolic ex-</text>
<text top="1004" left="81" width="359" height="12" font="2">ecution is implemented using our tool FuzzBALL, which we have</text>
<text top="1019" left="81" width="359" height="12" font="2">extended with optimizations for this problem domain. The second</text>
<text top="1034" left="81" width="359" height="12" font="2">step, test program generation, constructs complete test programs</text>
<text top="1049" left="81" width="359" height="12" font="2">from the results of exploration. For each input pair of a test instruc-</text>
<text top="1064" left="81" width="359" height="12" font="2">tion and an test state found in the exploration phase, we construct</text>
<text top="111" left="476" width="359" height="12" font="2">as output a test program consisting of the baseline initializer, the</text>
<text top="126" left="476" width="359" height="12" font="2">test state initializer for the test state, and the test instruction (Fig-</text>
<text top="141" left="476" width="359" height="12" font="2">ure 1(3)). In the third step, test program execution, we take the test</text>
<text top="156" left="476" width="359" height="12" font="2">programs as input and run them on emulators and real hardware</text>
<text top="171" left="476" width="359" height="12" font="2">(Figure 1(4)). We instrument the emulators and a hardware-based</text>
<text top="186" left="476" width="359" height="12" font="2">virtual machine to save as output the machine state after execut-</text>
<text top="201" left="476" width="359" height="12" font="2">ing the test program (the ﬁnal state). In the fourth step, difference</text>
<text top="215" left="476" width="359" height="12" font="2">analysis, we compare the ﬁnal states from the different executions</text>
<text top="230" left="476" width="359" height="12" font="2">of a test (Figure 1(5)). If the results differ between emulators or</text>
<text top="245" left="476" width="359" height="12" font="2">between an emulator and the real hardware, we have triggered a</text>
<text top="260" left="476" width="108" height="12" font="2">behavior difference.</text>
<text top="275" left="493" width="341" height="12" font="2">For our evaluation, we have selected two emulators that support</text>
<text top="290" left="476" width="359" height="12" font="2">x86 guest code: Bochs is an interpreter, and QEMU is a JIT com-</text>
<text top="305" left="476" width="359" height="12" font="2">piler. We compile the emulators for the Linux/x86 host platform.</text>
<text top="320" left="476" width="359" height="12" font="2">In our experiments, we apply symbolic execution to Bochs, and</text>
<text top="335" left="476" width="359" height="12" font="2">then use the generated tests for a three-way behavior comparison</text>
<text top="350" left="476" width="169" height="12" font="2">of Bochs, QEMU, and an Intel</text>
<text top="354" left="647" width="5" height="7" font="7">R</text>
<text top="350" left="659" width="26" height="12" font="2">Core</text>
<text top="351" left="685" width="11" height="7" font="7">TM</text>
<text top="350" left="702" width="10" height="12" font="2">i5</text>
<text top="347" left="716" width="6" height="8" font="4">∗</text>
<text top="350" left="727" width="107" height="12" font="2">workstation virtual-</text>
<text top="365" left="476" width="330" height="12" font="2">ized by KVM. We test the processor’s 32-bit protected mode.</text>
<text top="396" left="476" width="12" height="15" font="1">3.</text>
<text top="396" left="504" width="175" height="15" font="1">Path-Exploration Lifting</text>
<text top="419" left="476" width="359" height="12" font="2">In this section we describe the main technical aspects of how our</text>
<text top="434" left="476" width="359" height="12" font="2">system explores the space of possible instruction executions in an</text>
<text top="449" left="476" width="359" height="12" font="2">emulator. We start by describing our core technology of lightweight</text>
<text top="464" left="476" width="359" height="12" font="2">binary-level symbolic execution (Section 3.1). Then we describe</text>
<text top="479" left="476" width="359" height="12" font="2">the two ways we apply it: ﬁrst, to discover possible instructions</text>
<text top="494" left="476" width="359" height="12" font="2">(Section 3.2), and then to ﬁnd machine states that trigger various</text>
<text top="509" left="476" width="359" height="12" font="2">behaviors in an emulated instruction (Section 3.3). Finally, we de-</text>
<text top="524" left="476" width="359" height="12" font="2">scribe a difference-minimization technique that we use to simplify</text>
<text top="539" left="476" width="359" height="12" font="2">the machine states discovered by symbolic execution (Section 3.4).</text>
<text top="565" left="476" width="17" height="12" font="2">3.1</text>
<text top="565" left="506" width="187" height="12" font="2">Lightweight Symbolic Execution</text>
<text top="586" left="476" width="359" height="12" font="2">The core of our system’s state-space exploration is a lightweight</text>
<text top="601" left="476" width="359" height="12" font="2">engine for binary-level symbolic execution, named FuzzBALL.</text>
<text top="615" left="476" width="359" height="12" font="2">We start our description with a review of the key concepts of</text>
<text top="630" left="476" width="359" height="12" font="2">symbolic execution in general, then describe the online approach</text>
<text top="645" left="476" width="359" height="12" font="2">our tool takes, and some of the particular challenges that arise</text>
<text top="660" left="476" width="359" height="12" font="2">when operating on binaries. At a high level, FuzzBALL implements</text>
<text top="675" left="476" width="359" height="12" font="2">similar functionality to previous symbolic execution systems such</text>
<text top="690" left="476" width="359" height="12" font="2">as KLEE [6]. But in contrast, it takes a simpler approach in some</text>
<text top="705" left="476" width="359" height="12" font="2">areas that can be performance or code complexity challenges in</text>
<text top="720" left="476" width="359" height="12" font="2">other systems, and it is designed for a binary-level, rather than a</text>
<text top="735" left="476" width="200" height="12" font="2">source-level, program representation.</text>
<text top="761" left="476" width="27" height="12" font="2">3.1.1</text>
<text top="761" left="516" width="193" height="12" font="2">Background: Symbolic Execution</text>
<text top="782" left="476" width="359" height="12" font="2">The basic principle of symbolic execution is to replace certain</text>
<text top="797" left="476" width="46" height="12" font="2">concrete</text>
<text top="797" left="526" width="308" height="12" font="2">values in a program’s state with symbolic variables. As</text>
<text top="812" left="476" width="359" height="12" font="2">these symbolic values are used in later computations, they produce</text>
<text top="827" left="476" width="359" height="12" font="2">more complex symbolic expressions. These symbolic expressions</text>
<text top="842" left="476" width="359" height="12" font="2">are valuable because they can summarize the effect of many con-</text>
<text top="857" left="476" width="90" height="12" font="2">crete executions.</text>
<text top="872" left="493" width="341" height="12" font="2">When a symbolic expression is used in a control-ﬂow instruc-</text>
<text top="886" left="476" width="359" height="12" font="2">tion, we call the formula that controls the target a branch condition.</text>
<text top="901" left="476" width="359" height="12" font="2">On a complete program run, the conjunction of the conditions for</text>
<text top="916" left="476" width="359" height="12" font="2">all the symbolic branches is the path condition. Thus the values for</text>
<text top="931" left="476" width="359" height="12" font="2">the symbolic variables that satisfy a path condition are ones that</text>
<text top="946" left="476" width="359" height="12" font="2">would cause the program to execute the same control-ﬂow path as</text>
<text top="961" left="476" width="359" height="12" font="2">the one executed symbolically. Similarly, by taking a preﬁx of the</text>
<text top="976" left="476" width="359" height="12" font="2">path condition with the ﬁnal branch condition negated, we obtain</text>
<text top="991" left="476" width="359" height="12" font="2">a condition corresponding to a different control-ﬂow path. Solving</text>
<text top="1006" left="476" width="359" height="12" font="2">such a path condition lets us obtain a new set of concrete values</text>
<text top="1021" left="476" width="301" height="12" font="2">that would cause the corresponding path to be executed.</text>
<text top="1047" left="476" width="6" height="8" font="4">∗</text>
<text top="1050" left="483" width="22" height="11" font="5">Intel</text>
<text top="1053" left="508" width="5" height="7" font="7">R</text>
<text top="1050" left="519" width="23" height="11" font="5">Core</text>
<text top="1050" left="543" width="11" height="7" font="7">TM</text>
<text top="1050" left="559" width="276" height="11" font="5">i5 is a trademark of Intel Corporation in the U.S. and/or</text>
<text top="1064" left="476" width="359" height="11" font="5">other countries. Other names and brands may be claimed as the property of</text>
<text top="1077" left="476" width="32" height="11" font="5">others.</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
<text top="397" left="81" width="753" height="12" font="2">Figure 2. An overview of some of the key components of our symbolic execution engine FuzzBALL. The interior components are described</text>
<text top="413" left="81" width="376" height="12" font="2">in Section 3.1; the gray-shaded components are off-the-shelf libraries.</text>
<text top="457" left="81" width="27" height="12" font="2">3.1.2</text>
<text top="457" left="121" width="175" height="12" font="2">Lightweight, Online Approach</text>
<text top="478" left="81" width="359" height="12" font="2">At its core, FuzzBALL is an interpreter for x86 instructions, but</text>
<text top="493" left="81" width="359" height="12" font="2">one in which the values in registers and memory can be sym-</text>
<text top="508" left="81" width="359" height="12" font="2">bolic expressions rather than just concrete bit patterns. A graphi-</text>
<text top="523" left="81" width="359" height="12" font="2">cal overview of FuzzBALL’s architecture is shown in Figure 2. As</text>
<text top="538" left="81" width="359" height="12" font="2">it executes an x86 binary program, FuzzBALL translates each in-</text>
<text top="553" left="81" width="359" height="12" font="2">struction into a streamlined intermediate representation (IR), then</text>
<text top="568" left="81" width="359" height="12" font="2">performs each action speciﬁed by this IR on a symbolic state repre-</text>
<text top="583" left="81" width="359" height="12" font="2">sentation. For instance, suppose that %eax has the symbolic value</text>
<text top="598" left="81" width="359" height="12" font="2">a − 20, and the location pointed to by %ebx has the value 5. Then</text>
<text top="613" left="81" width="359" height="12" font="2">after FuzzBALL interprets the instruction add (%ebx),%eax,</text>
<text top="628" left="81" width="237" height="12" font="2">the symbolic value of %eax will be a − 15.</text>
<text top="643" left="99" width="341" height="12" font="2">Suppose that the following instruction is jz a04, a conditional</text>
<text top="658" left="81" width="359" height="12" font="2">branch that checks whether %eax is zero. The branch condition</text>
<text top="672" left="81" width="359" height="12" font="2">a − 15 = 0 depends on the symbolic variable a, so to decide which</text>
<text top="687" left="81" width="359" height="12" font="2">instruction to execute next, FuzzBALL checks whether either of</text>
<text top="702" left="81" width="359" height="12" font="2">the formulas a − 15 = 0 or a − 15 = 0 is satisﬁable, using a</text>
<text top="717" left="81" width="359" height="12" font="2">decision procedure. In this case both are, so FuzzBALL can choose</text>
<text top="732" left="81" width="359" height="12" font="2">freely. Suppose it chooses to take the true case (a − 15 = 0);</text>
<text top="747" left="81" width="359" height="12" font="2">then it will record that the false case is available to explore later,</text>
<text top="762" left="81" width="359" height="12" font="2">and go on to the instruction at address 0xa04. As it encounters</text>
<text top="777" left="81" width="359" height="12" font="2">other symbolic branches, it makes similar choices and records</text>
<text top="792" left="81" width="359" height="12" font="2">them. When it reaches the end of the program or another speciﬁed</text>
<text top="807" left="81" width="359" height="12" font="2">stopping point, FuzzBALL will mark that state as explored, and</text>
<text top="822" left="81" width="359" height="12" font="2">start again from the beginning of the program or a speciﬁed starting</text>
<text top="837" left="81" width="359" height="12" font="2">point. On the next run, FuzzBALL uses recorded decisions to</text>
<text top="852" left="81" width="359" height="12" font="2">ensure that the path it executes is different from those explored</text>
<text top="867" left="81" width="359" height="12" font="2">before. FuzzBALL continues in a loop, executing new paths, until</text>
<text top="882" left="81" width="359" height="12" font="2">all the possible paths have been executed. The choice of which</text>
<text top="897" left="81" width="359" height="12" font="2">program values are marked symbolic (typically the inputs to some</text>
<text top="912" left="81" width="359" height="12" font="2">computation) controls how many paths FuzzBALL explores: more</text>
<text top="927" left="81" width="241" height="12" font="2">symbolic values mean more execution paths.</text>
<text top="942" left="99" width="341" height="12" font="2">Many uses of symbolic execution start by running a program</text>
<text top="956" left="81" width="359" height="12" font="2">with a pre-existing concrete input. In such applications, a simpliﬁ-</text>
<text top="971" left="81" width="359" height="12" font="2">cation is to have the symbolic execution run in parallel with, but not</text>
<text top="986" left="81" width="359" height="12" font="2">modify, a concrete execution, so that the path condition describes</text>
<text top="1001" left="81" width="359" height="12" font="2">the path the concrete execution took. In our context, by contrast,</text>
<text top="1016" left="81" width="359" height="12" font="2">we wish to completely explore an execution space, so it does not</text>
<text top="1031" left="81" width="359" height="12" font="2">matter which path we execute ﬁrst. On the other hand, it is useful to</text>
<text top="1046" left="81" width="359" height="12" font="2">have more ﬂexibility in choosing which paths to symbolically ex-</text>
<text top="1061" left="81" width="359" height="12" font="2">ecute. Therefore our system performs online symbolic execution.</text>
<text top="1076" left="81" width="359" height="12" font="2">During execution we start with no commitment to a concrete value</text>
<text top="457" left="476" width="359" height="12" font="2">for any symbolic variable; when the value at a memory location</text>
<text top="472" left="476" width="359" height="12" font="2">has a symbolic expression, this is instead of, rather than in addition</text>
<text top="487" left="476" width="359" height="12" font="2">to, a concrete value. This gives the system the ﬂexibility to choose</text>
<text top="502" left="476" width="348" height="12" font="2">either direction for a symbolic branch, subject only to feasibility.</text>
<text top="517" left="493" width="341" height="12" font="2">Thus FuzzBALL is an interpreter for machine instructions,</text>
<text top="532" left="476" width="359" height="12" font="2">where registers and memory contain symbolic formulas. The rep-</text>
<text top="547" left="476" width="359" height="12" font="2">resentation of memory uses a two-level data structure similar to a</text>
<text top="562" left="476" width="359" height="12" font="2">page table, in which each page of memory is an array of formulas</text>
<text top="577" left="476" width="169" height="12" font="2">rather than an array of integers.</text>
<text top="605" left="476" width="135" height="12" font="2">Online Decision Making.</text>
<text top="605" left="614" width="220" height="12" font="2">When a branch condition is symbolic, an</text>
<text top="620" left="476" width="359" height="12" font="2">online symbolic execution tool can execute either the true or false</text>
<text top="635" left="476" width="359" height="12" font="2">side of the branch, but to make this decision it must reason about</text>
<text top="650" left="476" width="359" height="12" font="2">the path condition before execution can proceed. Our symbolic ex-</text>
<text top="665" left="476" width="359" height="12" font="2">ecution engine can choose directions subject to two constraints: the</text>
<text top="680" left="476" width="359" height="12" font="2">branch direction must be feasible, and it should lead to a path that</text>
<text top="695" left="476" width="359" height="12" font="2">has not been explored before. A branch direction is feasible if it</text>
<text top="710" left="476" width="359" height="12" font="2">is logically consistent with the previous branches in the path. For</text>
<text top="725" left="476" width="359" height="12" font="2">instance, in if (x&gt;y) x=y; if (x&gt;y) abort();, there is</text>
<text top="740" left="476" width="359" height="12" font="2">no feasible path in which both if conditions are true. FuzzBALL</text>
<text top="755" left="476" width="359" height="12" font="2">checks feasibility by giving the path condition to a decision proce-</text>
<text top="770" left="476" width="359" height="12" font="2">dure, which determines whether the condition is satisﬁable, and if</text>
<text top="785" left="476" width="195" height="12" font="2">so, supplies a satisfying assignment.</text>
<text top="800" left="493" width="341" height="12" font="2">Speciﬁcally, FuzzBALL interfaces with the decision procedures</text>
<text top="814" left="476" width="359" height="12" font="2">STP [13] and Z3 [12]. After simplifying symbolic expression, it</text>
<text top="829" left="476" width="359" height="12" font="2">translates them into STP or Z3’s syntax for quantiﬁer-free formulas</text>
<text top="844" left="476" width="359" height="12" font="2">over ﬁxed-sized bit-vectors (representing bounded machine arith-</text>
<text top="859" left="476" width="359" height="12" font="2">metic). STP and Z3 are well tuned for applications like FuzzBALL:</text>
<text top="874" left="476" width="359" height="12" font="2">their results are precise but produced quickly, with most queries</text>
<text top="889" left="476" width="359" height="12" font="2">completing in a fraction of a second. When using Z3, FuzzBALL</text>
<text top="904" left="476" width="359" height="12" font="2">can also solve path conditions incrementally: i.e., if it previously</text>
<text top="919" left="476" width="44" height="12" font="2">solved b</text>
<text top="923" left="520" width="5" height="8" font="4">1</text>
<text top="918" left="529" width="18" height="13" font="2">∧ b</text>
<text top="923" left="547" width="5" height="8" font="4">2</text>
<text top="919" left="553" width="281" height="12" font="2">, Z3 can reuse information from that solving process</text>
<text top="934" left="476" width="81" height="12" font="2">when solving b</text>
<text top="938" left="557" width="5" height="8" font="4">1</text>
<text top="933" left="566" width="18" height="13" font="2">∧ b</text>
<text top="938" left="584" width="5" height="8" font="4">2</text>
<text top="933" left="594" width="18" height="13" font="2">∧ b</text>
<text top="938" left="612" width="5" height="8" font="4">3</text>
<text top="934" left="618" width="3" height="12" font="2">.</text>
<text top="963" left="476" width="82" height="12" font="2">Decision Tree.</text>
<text top="962" left="565" width="270" height="12" font="2">To avoid exploring the same paths repeatedly,</text>
<text top="977" left="476" width="359" height="12" font="2">FuzzBALL uses a decision tree. The decision tree is a binary tree in</text>
<text top="992" left="476" width="359" height="12" font="2">which each node represents the occurrence of a symbolic branch on</text>
<text top="1007" left="476" width="359" height="12" font="2">a particular execution path, and a node has children labeled “false”</text>
<text top="1022" left="476" width="359" height="12" font="2">and “true” representing the next symbolic branch that will occur</text>
<text top="1037" left="476" width="359" height="12" font="2">in either case. Each tree node records whether the false and true</text>
<text top="1052" left="476" width="359" height="12" font="2">branches have been checked for feasibility, as well as whether any</text>
<text top="1067" left="476" width="357" height="12" font="2">additional unexplored branches appear below this node in the tree.</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="99" width="341" height="12" font="2">On each execution, FuzzBALL examines the decision tree to</text>
<text top="126" left="81" width="359" height="12" font="2">choose a random path within the part of the tree that has not been</text>
<text top="141" left="81" width="359" height="12" font="2">completely explored, then adds on to the tree for the part of the path</text>
<text top="156" left="81" width="359" height="12" font="2">being explored that is new. When creating a new node, FuzzBALL</text>
<text top="171" left="81" width="359" height="12" font="2">checks whether both the false and true branch directions are fea-</text>
<text top="186" left="81" width="359" height="12" font="2">sible, and if so, it can choose arbitrarily (either randomly or ac-</text>
<text top="201" left="81" width="359" height="12" font="2">cording to a supplied heuristic). After reaching the end of the path,</text>
<text top="215" left="81" width="359" height="12" font="2">FuzzBALL propagates the bit indicating that a subtree has been</text>
<text top="230" left="81" width="359" height="12" font="2">fully explored back up the tree until it reaches a node with an unex-</text>
<text top="245" left="81" width="359" height="12" font="2">plored branch. The decision tree grows as more paths are explored,</text>
<text top="260" left="81" width="359" height="12" font="2">so FuzzBALL uses a compact in-memory representation and can</text>
<text top="275" left="81" width="359" height="12" font="2">optionally store it on disk instead, but this is not needed for runs of</text>
<text top="290" left="81" width="162" height="12" font="2">the length used in this project.</text>
<text top="305" left="99" width="341" height="12" font="2">Branches that come from if statements and branches for loop</text>
<text top="320" left="81" width="359" height="12" font="2">exit conditions are treated uniformly, since at the instruction level</text>
<text top="335" left="81" width="359" height="12" font="2">they look the same. Thus FuzzBALL considers a different num-</text>
<text top="350" left="81" width="359" height="12" font="2">ber of executions of a loop as distinguishing a different execu-</text>
<text top="365" left="81" width="359" height="12" font="2">tion path. In other applications, this can lead to a signiﬁcant state-</text>
<text top="380" left="81" width="359" height="12" font="2">space explosion to manage, but it is not a major obstacle to Po-</text>
<text top="395" left="81" width="359" height="12" font="2">keEMU because instructions usually do not contain unbounded</text>
<text top="410" left="81" width="123" height="12" font="2">input-dependent loops.</text>
<text top="425" left="99" width="341" height="12" font="2">Thus the decision tree ensures that each path FuzzBALL ex-</text>
<text top="440" left="81" width="359" height="12" font="2">plores is different, and that exploration stops if no further paths</text>
<text top="455" left="81" width="359" height="12" font="2">are possible. Similarly to systems that duplicate execution state at</text>
<text top="469" left="81" width="359" height="12" font="2">a symbolic branch [6, 8], the decision tree saves (expensive) in-</text>
<text top="484" left="81" width="359" height="12" font="2">vocations of the decision procedure when the tool already knows</text>
<text top="499" left="81" width="359" height="12" font="2">which branch direction is feasible. As a tradeoff, our approach re-</text>
<text top="514" left="81" width="359" height="12" font="2">peats (relatively inexpensive) concrete and symbolic execution on</text>
<text top="529" left="81" width="359" height="12" font="2">the repeated path, to avoid keeping multiple states at once, which</text>
<text top="544" left="81" width="340" height="12" font="2">would increase memory usage and implementation complexity.</text>
<text top="573" left="81" width="176" height="12" font="2">Extension to Word-sized Values.</text>
<text top="573" left="262" width="177" height="12" font="2">When execution requires a con-</text>
<text top="588" left="81" width="359" height="12" font="2">crete value for a word-sized expression, like a switch statement</text>
<text top="602" left="81" width="359" height="12" font="2">argument or an array index, FuzzBALL applies the same mecha-</text>
<text top="617" left="81" width="359" height="12" font="2">nisms described above for two-way branches, once for each bit in</text>
<text top="632" left="81" width="359" height="12" font="2">the word, most-signiﬁcant ﬁrst. This reduction carries over the key</text>
<text top="647" left="81" width="359" height="12" font="2">properties from two-way branches: FuzzBALL chooses only feasi-</text>
<text top="662" left="81" width="268" height="12" font="2">ble values, and eventually tries all feasible values.</text>
<text top="695" left="81" width="27" height="12" font="2">3.1.3</text>
<text top="695" left="121" width="172" height="12" font="2">Operating at the Binary Level</text>
<text top="716" left="81" width="359" height="12" font="2">Since FuzzBALL targets binaries rather than source, it must ad-</text>
<text top="731" left="81" width="359" height="12" font="2">dress challenges including instruction-set complexity and variable-</text>
<text top="746" left="81" width="128" height="12" font="2">sized memory accesses.</text>
<text top="761" left="99" width="341" height="12" font="2">To factor out instruction-set complexity, FuzzBALL uses the</text>
<text top="776" left="81" width="47" height="12" font="2">BitBlaze</text>
<text top="773" left="128" width="4" height="8" font="4">4</text>
<text top="776" left="136" width="304" height="12" font="2">Vine library [27], which in turn builds on the VEX library</text>
<text top="791" left="81" width="359" height="12" font="2">which is also used by the Valgrind debugging tool [25]. First VEX</text>
<text top="806" left="81" width="359" height="12" font="2">translates an x86 instruction into the VEX intermediate representa-</text>
<text top="821" left="81" width="359" height="12" font="2">tion, and then Vine translates from this into its own language which</text>
<text top="836" left="81" width="359" height="12" font="2">is even simpler; these translations are cached for efﬁciency. To han-</text>
<text top="851" left="81" width="359" height="12" font="2">dle memory accesses of different operand sizes (bytes, words, etc.),</text>
<text top="866" left="81" width="359" height="12" font="2">FuzzBALL tries when possible to represent values in their natural</text>
<text top="881" left="81" width="359" height="12" font="2">size, so that splitting and reassembly are required only when the</text>
<text top="896" left="81" width="359" height="12" font="2">program itself accesses memory in an inconsistent way. To achieve</text>
<text top="911" left="81" width="359" height="12" font="2">this, FuzzBALL’s representation of memory can contain symbolic</text>
<text top="926" left="81" width="359" height="12" font="2">values of differing sizes. We describe some additional implementa-</text>
<text top="940" left="81" width="359" height="12" font="2">tion challenges that, in particular, are inspired by use with emula-</text>
<text top="955" left="81" width="111" height="12" font="2">tors in Section 3.3.2.</text>
<text top="988" left="81" width="27" height="12" font="2">3.1.4</text>
<text top="988" left="121" width="204" height="12" font="2">Impact of FuzzBALL’s Correctness</text>
<text top="1009" left="81" width="359" height="12" font="2">At this point, one might worry about seemingly circular reasoning</text>
<text top="1024" left="81" width="359" height="12" font="2">in our approach. Our goal is to check the correctness of one x86</text>
<text top="1039" left="81" width="359" height="12" font="2">interpreter (that in an emulator), but our technique relies on another</text>
<text top="1075" left="81" width="4" height="8" font="4">4</text>
<text top="1078" left="88" width="230" height="9" font="5">http://bitblaze.cs.berkeley.edu/</text>
<text top="111" left="476" width="359" height="12" font="2">x86 interpreter (that inside FuzzBALL). What if FuzzBALL has</text>
<text top="126" left="476" width="325" height="12" font="2">bugs similar to those we ﬁnd (Section 6) in other emulators?</text>
<text top="141" left="493" width="341" height="12" font="2">In fact there are several reasons why our approach is still ef-</text>
<text top="156" left="476" width="359" height="12" font="2">fective. First, any such bugs in FuzzBALL would be unlikely to</text>
<text top="171" left="476" width="359" height="12" font="2">signiﬁcantly affect our results, because emulators use in their own</text>
<text top="186" left="476" width="359" height="12" font="2">implementation a much smaller and better-exercised subset of pro-</text>
<text top="201" left="476" width="359" height="12" font="2">cessor functionality than they emulate. Second, the differences we</text>
<text top="215" left="476" width="359" height="12" font="2">discover are real, independent of the test generation process. We</text>
<text top="230" left="476" width="359" height="12" font="2">use symbolic execution to improve coverage, but the behavior dif-</text>
<text top="245" left="476" width="359" height="12" font="2">ferences are validated by test cases that run on their own. Third,</text>
<text top="260" left="476" width="359" height="12" font="2">FuzzBALL can be used to validate many emulators, so efforts</text>
<text top="275" left="476" width="359" height="12" font="2">towards strengthening or verifying the correctness of FuzzBALL</text>
<text top="290" left="476" width="334" height="12" font="2">would be ampliﬁed through its use in a tool such a PokeEMU.</text>
<text top="337" left="476" width="17" height="12" font="2">3.2</text>
<text top="337" left="506" width="158" height="12" font="2">Instruction Set Exploration</text>
<text top="358" left="476" width="359" height="12" font="2">The x86 instruction set is complex enough that even just enumer-</text>
<text top="373" left="476" width="359" height="12" font="2">ating all the possible instructions is non-trivial. But we would like</text>
<text top="388" left="476" width="359" height="12" font="2">exactly such an enumeration, in order to partition the later explo-</text>
<text top="403" left="476" width="359" height="12" font="2">ration so that we consider each instruction separately and exactly</text>
<text top="418" left="476" width="359" height="12" font="2">once. Therefore our ﬁrst, and relatively simpler, application of sym-</text>
<text top="433" left="476" width="359" height="12" font="2">bolic execution is to discover a set of byte sequences representing</text>
<text top="448" left="476" width="102" height="12" font="2">instructions to test.</text>
<text top="463" left="493" width="341" height="12" font="2">We observe that emulators contain instruction-decoding func-</text>
<text top="478" left="476" width="45" height="12" font="2">tionality</text>
<text top="478" left="525" width="309" height="12" font="2">to parse a byte sequence, check whether the sequence is</text>
<text top="493" left="476" width="359" height="12" font="2">a legal instruction, and if so, decide which code in the emulator</text>
<text top="508" left="476" width="359" height="12" font="2">will process it. This later code might be the implementation itself</text>
<text top="523" left="476" width="359" height="12" font="2">in an interpreter, or a code-generation routine in an IR-based or JIT-</text>
<text top="538" left="476" width="359" height="12" font="2">compiler emulator; we will refer to it as per-instruction code. By</text>
<text top="553" left="476" width="359" height="12" font="2">exploring the instruction decoder with symbolic execution, we can</text>
<text top="568" left="476" width="359" height="12" font="2">discover which byte sequences the emulator considers to be instruc-</text>
<text top="583" left="476" width="359" height="12" font="2">tions, and group byte sequences that are the “same” instruction in</text>
<text top="598" left="476" width="359" height="12" font="2">the sense that they have common per-instruction code in the emu-</text>
<text top="613" left="476" width="359" height="12" font="2">lator. In particular, we start symbolic execution at the entry point of</text>
<text top="627" left="476" width="359" height="12" font="2">the emulator’s instruction parser, mark the bytes that are the input</text>
<text top="642" left="476" width="359" height="12" font="2">to this parser as symbolic, and explore execution paths up to the</text>
<text top="657" left="476" width="197" height="12" font="2">selection of the per-instruction code.</text>
<text top="672" left="493" width="341" height="12" font="2">An x86 instruction is between 1 and 15 bytes, consisting of op-</text>
<text top="687" left="476" width="359" height="12" font="2">tional preﬁx bytes, an opcode that is usually 1 or 2 bytes, and trail-</text>
<text top="702" left="476" width="359" height="12" font="2">ing ﬁelds. Those trailing ﬁelds can specify a sub-opcode, register</text>
<text top="717" left="476" width="359" height="12" font="2">operands, addressing modes, and immediate values. The total num-</text>
<text top="732" left="476" width="359" height="12" font="2">ber of possible instruction byte sequences is astronomical (though</text>
<text top="747" left="476" width="61" height="12" font="2">less than 2</text>
<text top="744" left="536" width="20" height="8" font="4">8·15</text>
<text top="746" left="564" width="63" height="13" font="2">≈ 1.3 · 10</text>
<text top="744" left="627" width="11" height="8" font="4">36</text>
<text top="747" left="639" width="195" height="12" font="2">, because not all instructions allow</text>
<text top="762" left="476" width="359" height="12" font="2">all possible preﬁxes and operands). To select a more manageable</text>
<text top="777" left="476" width="359" height="12" font="2">number of byte sequences, we conceptually partition the byte se-</text>
<text top="792" left="476" width="359" height="12" font="2">quences according to which per-instruction code they trigger, and</text>
<text top="807" left="476" width="359" height="12" font="2">select a bounded number of byte sequences (currently 1) from each</text>
<text top="822" left="476" width="359" height="12" font="2">cell of the partition. Intuitively, we select one byte sequence per in-</text>
<text top="837" left="476" width="359" height="12" font="2">struction, for the deﬁnition of “instruction” given by the emulator’s</text>
<text top="852" left="476" width="359" height="12" font="2">per-instruction code. Selecting more byte sequences per instruction</text>
<text top="867" left="476" width="359" height="12" font="2">would slightly improve our coverage of functionality selected by</text>
<text top="882" left="476" width="359" height="12" font="2">ﬂags within the instruction, such as different addressing modes, but</text>
<text top="897" left="476" width="346" height="12" font="2">we estimate that the incremental beneﬁt would be relatively low.</text>
<text top="912" left="493" width="341" height="12" font="2">The instructions deﬁned by emulator implementations are not</text>
<text top="927" left="476" width="359" height="12" font="2">in one-to-one correspondence with the 1-2 byte instruction opcode</text>
<text top="942" left="476" width="359" height="12" font="2">ﬁeld: some opcode values correspond to multiple implementations</text>
<text top="956" left="476" width="359" height="12" font="2">depending on preﬁxes or an extra sub-opcode ﬁeld, and some dis-</text>
<text top="971" left="476" width="359" height="12" font="2">tinct opcodes share a single implementation. But we observe that</text>
<text top="986" left="476" width="359" height="12" font="2">generally at most either a single preﬁx byte or the sub-opcode</text>
<text top="1001" left="476" width="359" height="12" font="2">within the next byte after the opcode is also relevant, and any other</text>
<text top="1016" left="476" width="359" height="12" font="2">preﬁx bytes are optional, so every implementation has a unique rep-</text>
<text top="1031" left="476" width="359" height="12" font="2">resentative based on the ﬁrst three bytes of an instruction byte se-</text>
<text top="1046" left="476" width="359" height="12" font="2">quence. As shown in the results of Section 6, this approach allows</text>
<text top="1061" left="476" width="207" height="12" font="2">us to cut down an original space of 2</text>
<text top="1058" left="683" width="11" height="8" font="4">24</text>
<text top="1061" left="699" width="135" height="12" font="2">(16.8 million) three-byte</text>
<text top="1076" left="476" width="269" height="12" font="2">sequences into less than 1000 unique instructions.</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="81" width="17" height="12" font="2">3.3</text>
<text top="111" left="111" width="193" height="12" font="2">Machine State-Space Exploration</text>
<text top="132" left="81" width="359" height="12" font="2">Our system’s more critical (and more complex) use of symbolic ex-</text>
<text top="147" left="81" width="359" height="12" font="2">ecution is to explore how the state of the emulated machine before</text>
<text top="162" left="81" width="359" height="12" font="2">execution of an instruction (the input state) affects the instruction</text>
<text top="177" left="81" width="359" height="12" font="2">execution of the Hi-Fi emulator, and the state after its execution</text>
<text top="192" left="81" width="359" height="12" font="2">(the output state). At a high level, we mark the input state as sym-</text>
<text top="206" left="81" width="359" height="12" font="2">bolic, symbolically execute the instruction implementation, and for</text>
<text top="221" left="81" width="359" height="12" font="2">each execution path record the behavior and output state. Speciﬁ-</text>
<text top="236" left="81" width="359" height="12" font="2">cally, each execution path starts at the beginning of the code imple-</text>
<text top="251" left="81" width="359" height="12" font="2">menting an instruction and ends when the Hi-Fi emulator is about</text>
<text top="266" left="81" width="359" height="12" font="2">to raise an exception or execute the next instruction. Here we dis-</text>
<text top="281" left="81" width="359" height="12" font="2">cuss how we select and mark machine state as symbolic, and some</text>
<text top="296" left="81" width="284" height="12" font="2">optimizations that make this state space manageable.</text>
<text top="321" left="81" width="27" height="12" font="2">3.3.1</text>
<text top="321" left="121" width="83" height="12" font="2">Machine State</text>
<text top="342" left="81" width="359" height="12" font="2">Our key control over the exploration performed by symbolic exe-</text>
<text top="357" left="81" width="359" height="12" font="2">cution is the choice of which parts of the machine state we treat as</text>
<text top="372" left="81" width="359" height="12" font="2">symbolic. Symbolic execution will explore all of the code paths that</text>
<text top="387" left="81" width="359" height="12" font="2">can be reached for some assignment of values to the symbolic parts</text>
<text top="402" left="81" width="359" height="12" font="2">of the input state. On the other hand, those parts of the machine</text>
<text top="417" left="81" width="359" height="12" font="2">state that are left concrete will be treated as ﬁxed in exploration.</text>
<text top="432" left="81" width="359" height="12" font="2">Thus the more state we mark as symbolic, the larger a state space</text>
<text top="447" left="81" width="359" height="12" font="2">we will explore. We would generally like to explore as large a state</text>
<text top="462" left="81" width="359" height="12" font="2">space as possible, except that we would like to avoid repeatedly ex-</text>
<text top="477" left="81" width="359" height="12" font="2">ploring large numbers of executions that are effectively identical.</text>
<text top="492" left="81" width="211" height="12" font="2">For instance the page table can have 2</text>
<text top="489" left="292" width="11" height="8" font="4">20</text>
<text top="492" left="308" width="131" height="12" font="2">possible base addresses,</text>
<text top="507" left="81" width="359" height="12" font="2">but while the contents of the page table are signiﬁcant, its location</text>
<text top="522" left="81" width="359" height="12" font="2">is not, so it is enough to use only one such position for exploration.</text>
<text top="537" left="99" width="341" height="12" font="2">The state of the guest machine is represented by data structures</text>
<text top="552" left="81" width="359" height="12" font="2">in the memory of the host program, so it is with respect to these data</text>
<text top="567" left="81" width="359" height="12" font="2">structures that we specify symbolic locations. FuzzBALL supports</text>
<text top="582" left="81" width="359" height="12" font="2">a mode in which the entire state of the host machine is symbolic,</text>
<text top="597" left="81" width="359" height="12" font="2">and we also considered inferring this data layout from execution.</text>
<text top="612" left="81" width="359" height="12" font="2">However, neither of those approaches has proved necessary so far:</text>
<text top="627" left="81" width="359" height="12" font="2">in our observation the data structures that represent the machine</text>
<text top="641" left="81" width="305" height="12" font="2">state have a straightforward layout in the Hi-Fi emulator.</text>
<text top="656" left="99" width="341" height="12" font="2">Symbolic values are speciﬁed to FuzzBALL by giving their</text>
<text top="671" left="81" width="359" height="12" font="2">address, so we write C test code to print the locations of the</text>
<text top="686" left="81" width="359" height="12" font="2">ﬁelds that we make symbolic. For uniformity, all of the symbolic</text>
<text top="701" left="81" width="359" height="12" font="2">locations are speciﬁed as bytes, but specifying 4 consecutive bytes</text>
<text top="716" left="81" width="359" height="12" font="2">as symbolic is equivalent to specifying a single symbolic word.</text>
<text top="731" left="81" width="359" height="12" font="2">Conversely, we can make a subset of the bits in a byte symbolic</text>
<text top="746" left="81" width="359" height="12" font="2">by marking the entire byte as symbolic, and then adding a side</text>
<text top="761" left="81" width="200" height="12" font="2">constraint that ﬁxes the concrete bits.</text>
<text top="776" left="99" width="341" height="12" font="2">Overall, our strategy has been to mark as much of the machine</text>
<text top="791" left="81" width="359" height="12" font="2">state as symbolic as possible, except for locations that have many</text>
<text top="806" left="81" width="359" height="12" font="2">effectively equivalent values. Thus we make most of the machine</text>
<text top="821" left="81" width="359" height="12" font="2">registers and tables such as the page table and the global descrip-</text>
<text top="836" left="81" width="359" height="12" font="2">tor table (used for segment accesses) symbolic. A graphical pre-</text>
<text top="851" left="81" width="359" height="12" font="2">sentation of the registers we mark symbolic is shown in Figure 3.</text>
<text top="866" left="81" width="359" height="12" font="2">However, we keep concrete values for parts of registers that are ef-</text>
<text top="881" left="81" width="359" height="12" font="2">fectively just pointers to other data in memory, such as the portion</text>
<text top="895" left="81" width="359" height="12" font="2">of the CR3 register that is a pointer to the page table, as described</text>
<text top="910" left="81" width="359" height="12" font="2">above. We also leave concrete the ﬂags that specify the CPU is</text>
<text top="925" left="81" width="359" height="12" font="2">operating in 32-bit protected mode, since that is the target of our</text>
<text top="940" left="81" width="359" height="12" font="2">testing. And of course the instruction pointer (EIP in x86 terminol-</text>
<text top="955" left="81" width="359" height="12" font="2">ogy) needs to be concrete along with the bytes of the instruction</text>
<text top="970" left="81" width="359" height="12" font="2">to be executed. In total, our symbolic machine state consists of ap-</text>
<text top="985" left="81" width="359" height="12" font="2">proximately 400 bytes in registers and tables, along with all of the</text>
<text top="1000" left="81" width="182" height="12" font="2">unused bytes in physical memory.</text>
<text top="1025" left="81" width="27" height="12" font="2">3.3.2</text>
<text top="1025" left="121" width="174" height="12" font="2">Optimizations for Exploration</text>
<text top="1046" left="81" width="359" height="12" font="2">Even after restricting to a single instruction and carefully selecting</text>
<text top="1061" left="81" width="359" height="12" font="2">which machine state should be symbolic, the space of possible</text>
<text top="1076" left="81" width="359" height="12" font="2">executions is still quite large. Here we discuss two classes of further</text>
<text top="111" left="476" width="359" height="12" font="2">optimizations that make our symbolic execution more effective by</text>
<text top="126" left="476" width="250" height="12" font="2">avoiding repeated exploration of similar paths.</text>
<text top="154" left="476" width="210" height="12" font="2">Summarizing Common Computations.</text>
<text top="154" left="691" width="143" height="12" font="2">Some parts of instruction</text>
<text top="169" left="476" width="359" height="12" font="2">execution involve multiple execution paths, but are consistent over</text>
<text top="184" left="476" width="359" height="12" font="2">a large number of instructions. We would like to avoid repeated</text>
<text top="199" left="476" width="359" height="12" font="2">execution of these code regions, particularly since each such multi-</text>
<text top="214" left="476" width="359" height="12" font="2">path region has a multiplicative effect on the total number of paths.</text>
<text top="229" left="476" width="359" height="12" font="2">To avoid path explosion, we take a divide and conquer approach: we</text>
<text top="244" left="476" width="359" height="12" font="2">identify the common code region, perform symbolic execution on</text>
<text top="259" left="476" width="359" height="12" font="2">it separately to build a precise summary, and then use that summary</text>
<text top="274" left="476" width="159" height="12" font="2">in place of the common code.</text>
<text top="289" left="493" width="341" height="12" font="2">Using a preliminary run of symbolic execution, we explore all</text>
<text top="304" left="476" width="359" height="12" font="2">the paths of a computation and record the outputs as a function</text>
<text top="319" left="476" width="359" height="12" font="2">of the inputs. Next, we combine the symbolic expressions for the</text>
<text top="334" left="476" width="359" height="12" font="2">path conditions and the output values for a value into a single</text>
<text top="348" left="476" width="359" height="12" font="2">large formula: for instance, if such a computation had an output</text>
<text top="363" left="476" width="7" height="12" font="2">v</text>
<text top="368" left="482" width="4" height="8" font="4">i</text>
<text top="363" left="493" width="192" height="12" font="2">on the path with path condition p</text>
<text top="368" left="685" width="4" height="8" font="4">i</text>
<text top="363" left="690" width="144" height="12" font="2">, the summary formula is</text>
<text top="379" left="476" width="202" height="10" font="2">p1 ? v1 : (p2 ? v2 : ...)</text>
<text top="378" left="677" width="157" height="12" font="2">. Then, in the main symbolic</text>
<text top="393" left="476" width="359" height="12" font="2">execution runs, we skip execution of the computation and instead</text>
<text top="408" left="476" width="291" height="12" font="2">add the pre-computed constraint to the path condition.</text>
<text top="423" left="493" width="341" height="12" font="2">For instance, we use this treatment for code in Bochs that com-</text>
<text top="438" left="476" width="359" height="12" font="2">putes a cached copy of a segment descriptor. An x86 processor al-</text>
<text top="453" left="476" width="359" height="12" font="2">lows the speciﬁcation of six memory regions, called segments, each</text>
<text top="468" left="476" width="359" height="12" font="2">with a chosen base address and size (these were once used for mem-</text>
<text top="483" left="476" width="359" height="12" font="2">ory management, and are still used for thread-local memory regions</text>
<text top="498" left="476" width="359" height="12" font="2">and some security applications). The locations and other attributes</text>
<text top="513" left="476" width="359" height="12" font="2">of each segment are stored in a packed data structure called the seg-</text>
<text top="528" left="476" width="85" height="12" font="2">ment descriptor</text>
<text top="528" left="560" width="274" height="12" font="2">, but since this descriptor rarely changes, emulators</text>
<text top="543" left="476" width="359" height="12" font="2">often cache its information in a data structure with their own choice</text>
<text top="558" left="476" width="359" height="12" font="2">of layout. The layout of the cache is emulator-speciﬁc, so we mark</text>
<text top="573" left="476" width="359" height="12" font="2">the state symbolic in the emulator-independent descriptor structure</text>
<text top="588" left="476" width="359" height="12" font="2">and let the emulator recompute its cache. However the code that</text>
<text top="602" left="476" width="359" height="12" font="2">updates the cache has 23 paths, so executing all the possible paths</text>
<text top="617" left="476" width="359" height="12" font="2">through all of the possible cache updates would increase the search</text>
<text top="633" left="476" width="130" height="12" font="2">space by a factor of 23</text>
<text top="630" left="606" width="5" height="8" font="4">6</text>
<text top="632" left="619" width="215" height="12" font="2">= 148035889. Instead, we summarize</text>
<text top="648" left="476" width="359" height="12" font="2">the cache-update computation with a single set of symbolic expres-</text>
<text top="662" left="476" width="359" height="12" font="2">sions, automatically computed from an exploration, in advance, of</text>
<text top="677" left="476" width="165" height="12" font="2">just the cache-update function.</text>
<text top="706" left="476" width="160" height="12" font="2">Indexing Memory and Tables.</text>
<text top="706" left="638" width="196" height="12" font="2">As described in Section 3.1.2 above,</text>
<text top="721" left="476" width="359" height="12" font="2">FuzzBALL’s default behavior, when a symbolic value is used as</text>
<text top="736" left="476" width="359" height="12" font="2">an index, is to exhaustively explore each index value. While this</text>
<text top="751" left="476" width="359" height="12" font="2">would be suitable for a small table in which each entry is different,</text>
<text top="766" left="476" width="359" height="12" font="2">it is impractical for large arrays such as the page table or the guest</text>
<text top="781" left="476" width="359" height="12" font="2">memory (which is generally represented as a single or multi-level</text>
<text top="795" left="476" width="359" height="12" font="2">table in the host). For these arrays, we instead direct FuzzBALL</text>
<text top="810" left="476" width="359" height="12" font="2">to select a single index value at random, and not explore any other</text>
<text top="825" left="476" width="359" height="12" font="2">values. Like making a pointer in the initial state concrete rather than</text>
<text top="840" left="476" width="359" height="12" font="2">symbolic, this on-the-ﬂy concretization narrows the search space</text>
<text top="855" left="476" width="359" height="12" font="2">that FuzzBALL explores, but it is justiﬁed by the observation that</text>
<text top="870" left="476" width="127" height="12" font="2">for most purposes, all 2</text>
<text top="868" left="602" width="11" height="8" font="4">32</text>
<text top="870" left="617" width="192" height="12" font="2">locations in memory are equivalent.</text>
<text top="885" left="493" width="341" height="12" font="2">Another important consideration for large tables in the machine</text>
<text top="900" left="476" width="359" height="12" font="2">state is how they are initialized for symbolic execution. For the</text>
<text top="915" left="476" width="359" height="12" font="2">page table, we concretely initialize the parts of the table that are</text>
<text top="930" left="476" width="359" height="12" font="2">pointers to sub-tables or page frames, but make all of the ﬂag bits</text>
<text top="945" left="476" width="359" height="12" font="2">symbolic. For main memory, we treat each byte as a separate sym-</text>
<text top="960" left="476" width="359" height="12" font="2">bolic variable, but we modify FuzzBALL to create those variables</text>
<text top="975" left="476" width="241" height="12" font="2">on demand only when a location is accessed.</text>
<text top="1010" left="476" width="17" height="12" font="2">3.4</text>
<text top="1010" left="506" width="173" height="12" font="2">State Difference Minimization</text>
<text top="1031" left="476" width="359" height="12" font="2">For each path explored in symbolic execution, the decision proce-</text>
<text top="1046" left="476" width="359" height="12" font="2">dure computes an assignment of bits to the symbolic variables that</text>
<text top="1061" left="476" width="359" height="12" font="2">would cause the emulator to execute that path: this assignment is</text>
<text top="1076" left="476" width="359" height="12" font="2">then the basis for constructing a test state. If any bits are symbolic,</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1188" width="918">
<text top="126" left="169" width="0" height="7" font="7">PG</text>
<text top="125" left="177" width="0" height="7" font="7">CD</text>
<text top="124" left="186" width="0" height="7" font="7">NW</text>
<text top="124" left="274" width="0" height="7" font="7">AM</text>
<text top="125" left="291" width="0" height="7" font="7">WP</text>
<text top="126" left="379" width="0" height="7" font="7">NE</text>
<text top="126" left="387" width="0" height="7" font="7">ET</text>
<text top="126" left="395" width="0" height="7" font="7">TS</text>
<text top="125" left="403" width="0" height="7" font="7">EM</text>
<text top="125" left="412" width="0" height="7" font="7">MP</text>
<text top="126" left="420" width="0" height="7" font="7">PE</text>
<text top="113" left="420" width="4" height="7" font="7">0</text>
<text top="113" left="356" width="4" height="7" font="7">8</text>
<text top="113" left="289" width="7" height="7" font="7">16</text>
<text top="113" left="225" width="7" height="7" font="7">24</text>
<text top="113" left="168" width="7" height="7" font="7">31</text>
<text top="165" left="387" width="0" height="7" font="7">PCW</text>
<text top="165" left="395" width="0" height="7" font="7">PWT</text>
<text top="175" left="215" width="59" height="7" font="7">Page-directory base</text>
<text top="211" left="276" width="0" height="10" font="7">..</text>
<text top="217" left="276" width="0" height="7" font="7">.</text>
<text top="205" left="307" width="0" height="7" font="7">SMXE</text>
<text top="205" left="315" width="0" height="7" font="7">VMXE</text>
<text top="214" left="323" width="0" height="7" font="7">0</text>
<text top="214" left="331" width="0" height="7" font="7">0</text>
<text top="211" left="341" width="0" height="10" font="7">..</text>
<text top="217" left="341" width="0" height="7" font="7">.</text>
<text top="211" left="349" width="0" height="10" font="7">..</text>
<text top="217" left="349" width="0" height="7" font="7">.</text>
<text top="209" left="355" width="0" height="7" font="7">PCE</text>
<text top="208" left="363" width="0" height="7" font="7">PGE</text>
<text top="207" left="371" width="0" height="7" font="7">MCE</text>
<text top="209" left="379" width="0" height="7" font="7">P</text>
<text top="212" left="379" width="0" height="7" font="7">AE</text>
<text top="209" left="387" width="0" height="7" font="7">PSE</text>
<text top="211" left="395" width="0" height="7" font="7">DE</text>
<text top="208" left="403" width="0" height="7" font="7">TSD</text>
<text top="210" left="412" width="0" height="7" font="7">PVI</text>
<text top="207" left="420" width="0" height="7" font="7">VME</text>
<text top="218" left="206" width="28" height="7" font="7">Reserved</text>
<text top="254" left="250" width="0" height="7" font="7">ID</text>
<text top="252" left="258" width="0" height="7" font="7">VIP</text>
<text top="252" left="266" width="0" height="7" font="7">VIF</text>
<text top="253" left="274" width="0" height="7" font="7">A</text>
<text top="258" left="274" width="0" height="7" font="7">C</text>
<text top="252" left="282" width="0" height="7" font="7">VM</text>
<text top="253" left="290" width="0" height="7" font="7">RF</text>
<text top="256" left="299" width="0" height="7" font="7">0</text>
<text top="253" left="307" width="0" height="7" font="7">NT</text>
<text top="253" left="331" width="0" height="7" font="7">OF</text>
<text top="253" left="339" width="0" height="7" font="7">DF</text>
<text top="255" left="347" width="0" height="7" font="7">IF</text>
<text top="254" left="355" width="0" height="7" font="7">TF</text>
<text top="254" left="363" width="0" height="7" font="7">SF</text>
<text top="254" left="371" width="0" height="7" font="7">ZF</text>
<text top="256" left="379" width="0" height="7" font="7">0</text>
<text top="253" left="387" width="0" height="7" font="7">AF</text>
<text top="256" left="395" width="0" height="7" font="7">0</text>
<text top="254" left="403" width="0" height="7" font="7">PF</text>
<text top="256" left="411" width="0" height="7" font="7">1</text>
<text top="253" left="420" width="0" height="7" font="7">CF</text>
<text top="250" left="319" width="0" height="7" font="7">IOPL</text>
<text top="261" left="198" width="28" height="7" font="7">Reserved</text>
<text top="131" left="141" width="22" height="11" font="5">CR0</text>
<text top="174" left="141" width="22" height="11" font="5">CR3</text>
<text top="216" left="141" width="22" height="11" font="5">CR4</text>
<text top="259" left="118" width="45" height="11" font="5">EFLAGS</text>
<text top="301" left="100" width="63" height="11" font="5">EAX . . . ESP</text>
<text top="127" left="570" width="0" height="7" font="7">G</text>
<text top="124" left="578" width="0" height="7" font="7">D/B</text>
<text top="128" left="587" width="0" height="7" font="7">L</text>
<text top="123" left="595" width="0" height="7" font="7">A</text>
<text top="127" left="595" width="0" height="7" font="7">VL</text>
<text top="128" left="635" width="0" height="7" font="7">P</text>
<text top="128" left="659" width="0" height="7" font="7">S</text>
<text top="113" left="757" width="4" height="7" font="7">0</text>
<text top="113" left="692" width="4" height="7" font="7">8</text>
<text top="113" left="626" width="7" height="7" font="7">16</text>
<text top="113" left="561" width="7" height="7" font="7">24</text>
<text top="113" left="505" width="7" height="7" font="7">31</text>
<text top="133" left="727" width="15" height="7" font="7">Base</text>
<text top="133" left="525" width="15" height="7" font="7">Base</text>
<text top="133" left="610" width="17" height="7" font="7">Limit</text>
<text top="132" left="674" width="15" height="7" font="7">Type</text>
<text top="123" left="647" width="0" height="7" font="7">DPL</text>
<text top="167" left="694" width="17" height="7" font="7">Limit</text>
<text top="167" left="558" width="15" height="7" font="7">Base</text>
<text top="140" left="770" width="25" height="11" font="5">GDT</text>
<text top="154" left="770" width="32" height="11" font="5">entries</text>
<text top="211" left="708" width="0" height="7" font="7">PS</text>
<text top="213" left="716" width="0" height="7" font="7">A</text>
<text top="208" left="724" width="0" height="7" font="7">PCD</text>
<text top="207" left="732" width="0" height="7" font="7">PWT</text>
<text top="209" left="740" width="0" height="7" font="7">U/S</text>
<text top="208" left="748" width="0" height="7" font="7">R/W</text>
<text top="213" left="756" width="0" height="7" font="7">P</text>
<text top="217" left="569" width="56" height="7" font="7">Page-table address</text>
<text top="208" left="770" width="15" height="11" font="5">PD</text>
<text top="222" left="770" width="32" height="11" font="5">entries</text>
<text top="255" left="691" width="0" height="7" font="7">G</text>
<text top="251" left="700" width="0" height="7" font="7">P</text>
<text top="255" left="700" width="0" height="7" font="7">A</text>
<text top="259" left="700" width="0" height="7" font="7">T</text>
<text top="255" left="708" width="0" height="7" font="7">D</text>
<text top="255" left="716" width="0" height="7" font="7">A</text>
<text top="250" left="724" width="0" height="7" font="7">PCD</text>
<text top="250" left="732" width="0" height="7" font="7">PWT</text>
<text top="252" left="740" width="0" height="7" font="7">U/S</text>
<text top="251" left="748" width="0" height="7" font="7">R/W</text>
<text top="256" left="756" width="0" height="7" font="7">P</text>
<text top="251" left="770" width="14" height="11" font="5">PT</text>
<text top="264" left="770" width="32" height="11" font="5">entries</text>
<text top="259" left="572" width="50" height="7" font="7">Physical address</text>
<text top="297" left="740" width="0" height="7" font="7">TI</text>
<text top="323" left="757" width="4" height="7" font="7">0</text>
<text top="323" left="692" width="4" height="7" font="7">8</text>
<text top="323" left="634" width="7" height="7" font="7">15</text>
<text top="293" left="752" width="0" height="7" font="7">RPL</text>
<text top="303" left="677" width="17" height="7" font="7">Index</text>
<text top="301" left="768" width="47" height="11" font="5">CS . . . GS</text>
<text top="345" left="202" width="512" height="12" font="2">Figure 3. Symbolic machine state (grayed bits are symbolic, the remaining ones are concrete).</text>
<text top="390" left="81" width="359" height="12" font="2">but not constrained by checks on the explored path, the decision</text>
<text top="405" left="81" width="359" height="12" font="2">procedure will choose values for them arbitrarily. However, this</text>
<text top="420" left="81" width="359" height="12" font="2">ﬂexibility is inconvenient for two reasons. First, it makes the gen-</text>
<text top="435" left="81" width="359" height="12" font="2">erated tests harder to understand, because they contain extra state</text>
<text top="450" left="81" width="359" height="12" font="2">differences that are irrelevant to the execution of the emulator, and</text>
<text top="465" left="81" width="359" height="12" font="2">caused only by the decision procedure’s arbitrary choices. Second,</text>
<text top="480" left="81" width="359" height="12" font="2">these irrelevant differences can cause test execution to fail when</text>
<text top="495" left="81" width="359" height="12" font="2">they affect state that is checked in the test execution but not during</text>
<text top="509" left="81" width="359" height="12" font="2">the symbolic execution. As an example, we start symbolic execu-</text>
<text top="524" left="81" width="359" height="12" font="2">tion in Bochs after it has fetched and decoded an instruction, so</text>
<text top="539" left="81" width="359" height="12" font="2">the permissions on the code segment CS are not relevant for most</text>
<text top="554" left="81" width="359" height="12" font="2">instructions. But in a real execution, the test instruction must be</text>
<text top="569" left="81" width="359" height="12" font="2">fetched using CS, so a change that makes that segment inaccessible</text>
<text top="584" left="81" width="308" height="12" font="2">will cause the test to fail before executing the instruction.</text>
<text top="599" left="99" width="341" height="12" font="2">To avoid these problems, we wish to base test states not on an as-</text>
<text top="614" left="81" width="359" height="12" font="2">signment where unconstrained bits are arbitrary, but on one where</text>
<text top="629" left="81" width="359" height="12" font="2">unconstrained bits are left the same as in a baseline machine state</text>
<text top="644" left="81" width="359" height="12" font="2">that “just works.” In other words we want to ﬁnd an assignment that</text>
<text top="659" left="81" width="359" height="12" font="2">is minimally different from the baseline state. We implement this</text>
<text top="674" left="81" width="359" height="12" font="2">minimization using a simple and efﬁcient greedy approach. Start-</text>
<text top="689" left="81" width="359" height="12" font="2">ing with a working assignment equal to the one produced by the</text>
<text top="704" left="81" width="359" height="12" font="2">decision procedure, we iterate over each of the bits that are differ-</text>
<text top="719" left="81" width="359" height="12" font="2">ent from the baseline state. For each bit that is different, we check</text>
<text top="734" left="81" width="359" height="12" font="2">whether setting it to its value in the baseline state still satisﬁes the</text>
<text top="749" left="81" width="359" height="12" font="2">path condition; if so, we make the change in the working assign-</text>
<text top="764" left="81" width="359" height="12" font="2">ment. Potentially making multiple passes could further reduce the</text>
<text top="778" left="81" width="359" height="12" font="2">size of the difference, but a single pass is sufﬁcient for the problem</text>
<text top="793" left="81" width="309" height="12" font="2">of unconstrained variables, which is our main motivation.</text>
<text top="808" left="99" width="341" height="12" font="2">We also explored implementing this minimization by exclud-</text>
<text top="823" left="81" width="359" height="12" font="2">ing variables from the assignment that do not appear in the path</text>
<text top="838" left="81" width="359" height="12" font="2">condition. However, particularly in the presence of bitwise oper-</text>
<text top="853" left="81" width="359" height="12" font="2">ations, FuzzBALL’s symbolic expressions sometimes retain irrele-</text>
<text top="868" left="81" width="359" height="12" font="2">vant variables. It would have required a complex additional analysis</text>
<text top="883" left="81" width="359" height="12" font="2">to reliably remove such variables. By comparison our current ap-</text>
<text top="898" left="81" width="359" height="12" font="2">proach based on evaluation was simple to implement and requires</text>
<text top="913" left="81" width="99" height="12" font="2">no approximation.</text>
<text top="948" left="81" width="12" height="15" font="1">4.</text>
<text top="948" left="110" width="185" height="15" font="1">Generating Test Programs</text>
<text top="972" left="81" width="359" height="12" font="2">Figure 4 shows the execution of a test program, which is a stan-</text>
<text top="987" left="81" width="359" height="12" font="2">dalone disk image that boots an emulator, initializes a test state,</text>
<text top="1001" left="81" width="359" height="12" font="2">executes a test instruction, and either halts normally or raises an</text>
<text top="1016" left="81" width="359" height="12" font="2">exception. To simplify the process of constructing code to set up</text>
<text top="1031" left="81" width="359" height="12" font="2">the test state, we divide it into two steps. First we write a baseline</text>
<text top="1046" left="81" width="82" height="12" font="2">state initializer</text>
<text top="1046" left="163" width="276" height="12" font="2">, code that sets up a single baseline state that is a</text>
<text top="1061" left="81" width="359" height="12" font="2">starting point for any state in a given processor mode. Then we use</text>
<text top="1076" left="81" width="359" height="12" font="2">an automated code generation process to construct, for each spe-</text>
<text top="420" left="511" width="27" height="11" font="5">Boot-</text>
<text top="440" left="513" width="23" height="11" font="5">strap</text>
<text top="420" left="578" width="41" height="11" font="5">Baseline</text>
<text top="440" left="577" width="44" height="11" font="5">state init.</text>
<text top="420" left="653" width="20" height="11" font="5">Test</text>
<text top="440" left="653" width="19" height="11" font="5">init.</text>
<text top="420" left="695" width="20" height="11" font="5">Test</text>
<text top="440" left="694" width="23" height="11" font="5">insn.</text>
<text top="404" left="762" width="19" height="11" font="5">Halt</text>
<text top="452" left="746" width="44" height="11" font="5">Exception</text>
<text top="398" left="578" width="63" height="11" font="5">Test program</text>
<text top="501" left="476" width="359" height="12" font="2">Figure 4. Execution of a test (the black circles denote when we</text>
<text top="516" left="476" width="359" height="12" font="2">take a snapshot of the CPU state and of the physical memory; the</text>
<text top="531" left="476" width="195" height="12" font="2">rectangle delimits the test program).</text>
<text top="578" left="476" width="359" height="12" font="2">ciﬁc test state, the additional initializations needed to reach the test</text>
<text top="592" left="476" width="359" height="12" font="2">state from the baseline state: we call these the test state initializers.</text>
<text top="607" left="476" width="359" height="12" font="2">The advantage of this two-step approach is that because the test</text>
<text top="622" left="476" width="359" height="12" font="2">states are similar to the baseline state, we require relatively little</text>
<text top="637" left="476" width="163" height="12" font="2">new code speciﬁc to each test.</text>
<text top="652" left="493" width="341" height="12" font="2">We choose a bootable disk image as the easiest way to load and</text>
<text top="667" left="476" width="359" height="12" font="2">run code in an emulator. So in summary, a test consists of a bootable</text>
<text top="682" left="476" width="359" height="12" font="2">disk image containing an off-the-shelf boot loader, the ﬁxed base-</text>
<text top="697" left="476" width="359" height="12" font="2">line state initializer, the test state initializers for a particular test</text>
<text top="712" left="476" width="157" height="12" font="2">state, and the test instruction.</text>
<text top="727" left="493" width="341" height="12" font="2">Next we describe in detail baseline-state initialization and test-</text>
<text top="742" left="476" width="143" height="12" font="2">state initializer generation.</text>
<text top="771" left="476" width="17" height="12" font="2">4.1</text>
<text top="771" left="506" width="158" height="12" font="2">Baseline State Initialization</text>
<text top="792" left="476" width="359" height="12" font="2">The baseline state is a minimalist execution environment necessary</text>
<text top="807" left="476" width="359" height="12" font="2">for successfully running all possible tests in a speciﬁc operating</text>
<text top="822" left="476" width="359" height="12" font="2">mode. This baseline state corresponds to the concrete state used</text>
<text top="837" left="476" width="359" height="12" font="2">during the exploration stage (described in Section 3.3). We now</text>
<text top="852" left="476" width="359" height="12" font="2">describe speciﬁcally the baseline initializer we use for 32-bit pro-</text>
<text top="867" left="476" width="359" height="12" font="2">tected mode with paging enabled, the most common mode for x86</text>
<text top="882" left="476" width="359" height="12" font="2">processors and the one used in our evaluation. We could construct</text>
<text top="897" left="476" width="237" height="12" font="2">similar baseline initializers for other modes.</text>
<text top="912" left="493" width="341" height="12" font="2">The off-the-shelf boot loader we use happens to already con-</text>
<text top="927" left="476" width="359" height="12" font="2">ﬁgure the machine in 32-bit protected mode. The remainder of the</text>
<text top="942" left="476" width="359" height="12" font="2">initialization consists of populating the global descriptor table, the</text>
<text top="957" left="476" width="359" height="12" font="2">page table, the interrupt descriptor table, and enabling paging and</text>
<text top="972" left="476" width="359" height="12" font="2">interrupts. More precisely we initialize the global descriptor ta-</text>
<text top="987" left="476" width="359" height="12" font="2">ble to use a ﬂat segmentation model. That is, the code, data, and</text>
<text top="1001" left="476" width="359" height="12" font="2">stack segments have a zero base and a 4-GByte limit. We conﬁgure</text>
<text top="1016" left="476" width="359" height="12" font="2">the page table to map the 4-GByte virtual address space linearly</text>
<text top="1031" left="476" width="359" height="12" font="2">to a 4-MByte physical memory, repeating every 4-MBytes so that</text>
<text top="1046" left="476" width="359" height="12" font="2">each physical page backs 1024 virtual pages. All pages are initially</text>
<text top="1061" left="476" width="359" height="12" font="2">marked as readable and writable and accessible to both user and</text>
<text top="1076" left="476" width="359" height="12" font="2">kernel mode. This conﬁguration ensures that, unless the global de-</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="81" width="359" height="12" font="2">scriptor table or the page table are modiﬁed later during the exe-</text>
<text top="126" left="81" width="359" height="12" font="2">cution, any access to the memory will succeed. The interrupt de-</text>
<text top="141" left="81" width="359" height="12" font="2">scriptor table is conﬁgured to dispatch exceptions to handlers that</text>
<text top="156" left="81" width="359" height="12" font="2">halt the CPU, and interrupts to handlers that effectively ignore the</text>
<text top="171" left="81" width="245" height="12" font="2">interrupt by resuming execution immediately.</text>
<text top="203" left="81" width="17" height="12" font="2">4.2</text>
<text top="203" left="111" width="136" height="12" font="2">Building Test Programs</text>
<text top="224" left="81" width="359" height="12" font="2">Each output of the exploration phase is a test instruction and a test</text>
<text top="239" left="81" width="359" height="12" font="2">state: a precise conﬁguration for a subset of the CPU state and of</text>
<text top="254" left="81" width="359" height="12" font="2">the physical memory, necessary to trigger a speciﬁc path during</text>
<text top="269" left="81" width="359" height="12" font="2">the emulation of the test instruction. In order to exercise the same</text>
<text top="284" left="81" width="359" height="12" font="2">behavior at run-time, we need to run the test instruction starting</text>
<text top="299" left="81" width="359" height="12" font="2">from the same machine state discovered during the exploration. To</text>
<text top="314" left="81" width="359" height="12" font="2">do so, we need to generate code that, starting from the baseline</text>
<text top="329" left="81" width="359" height="12" font="2">state described in the previous section, sets up the machine state</text>
<text top="344" left="81" width="359" height="12" font="2">for running the test instruction. This code, the test state initializer,</text>
<text top="359" left="81" width="359" height="12" font="2">will be executed immediately after the baseline state has been</text>
<text top="374" left="81" width="359" height="12" font="2">initialized. The test program then executes the test instruction. If</text>
<text top="389" left="81" width="359" height="12" font="2">the test program is executed successfully the CPU halts; otherwise</text>
<text top="404" left="81" width="119" height="12" font="2">an exception is raised.</text>
<text top="419" left="99" width="341" height="12" font="2">To organize the process of constructing the test state initializer,</text>
<text top="434" left="81" width="359" height="12" font="2">we divide it according to the various parts of the machine state we</text>
<text top="449" left="81" width="359" height="12" font="2">initialize. For each part of the state that must be initialized, we de-</text>
<text top="464" left="81" width="359" height="12" font="2">sign a gadget, a short code snippet, that encapsulates how to initial-</text>
<text top="478" left="81" width="359" height="12" font="2">ize the state component. Then we have an algorithm that automat-</text>
<text top="493" left="81" width="359" height="12" font="2">ically selects and instantiates appropriate gadgets and assembles</text>
<text top="508" left="81" width="221" height="12" font="2">them into a complete test state initializer.</text>
<text top="523" left="99" width="341" height="12" font="2">In more detail, each gadget consists of an assembly-language</text>
<text top="538" left="81" width="359" height="12" font="2">instruction sequence that initializes a speciﬁc state component,</text>
<text top="553" left="81" width="359" height="12" font="2">plus additional constraints specifying its prerequisites and side</text>
<text top="568" left="81" width="359" height="12" font="2">effects. The prerequisites specify that one gadget must execute</text>
<text top="583" left="81" width="359" height="12" font="2">before another. The side effects specify that in addition to the</text>
<text top="598" left="81" width="359" height="12" font="2">intended initialization, a gadget has other effects such as modifying</text>
<text top="613" left="81" width="359" height="12" font="2">scratch registers or causing a cache to become out of date. We</text>
<text top="628" left="81" width="359" height="12" font="2">have built gadgets to initialize general purpose registers, segment</text>
<text top="643" left="81" width="269" height="12" font="2">registers, control registers, and memory locations.</text>
<text top="658" left="99" width="341" height="12" font="2">Then, our algorithm to generate the test state initializer operates</text>
<text top="673" left="81" width="359" height="12" font="2">as follows. First we instantiate a gadget for each component of the</text>
<text top="688" left="81" width="359" height="12" font="2">test state. Next, for each side effect of this ﬁrst set of gadgets,</text>
<text top="703" left="81" width="359" height="12" font="2">we instantiate an additional gadget to correct the side effect, and</text>
<text top="718" left="81" width="359" height="12" font="2">we continue this process until there are no more outstanding side</text>
<text top="733" left="81" width="359" height="12" font="2">effects. Then, based on the prerequisite structure between all of</text>
<text top="747" left="81" width="359" height="12" font="2">these gadgets, we construct a dependency graph, and topologically</text>
<text top="762" left="81" width="359" height="12" font="2">sort the gadgets to respect the dependencies among them. Finally</text>
<text top="777" left="81" width="359" height="12" font="2">we append to this initializer sequence the test instruction itself and</text>
<text top="792" left="81" width="359" height="12" font="2">a halt instruction, and assemble the whole sequence to a binary.</text>
<text top="807" left="81" width="359" height="12" font="2">If our mechanism fails to ﬁnd an initializer (e.g., because of a</text>
<text top="822" left="81" width="359" height="12" font="2">cyclic dependency or a side effect for which no gadget exists),</text>
<text top="837" left="81" width="359" height="12" font="2">we abort and ask for user assistance. A beneﬁt of state-difference</text>
<text top="852" left="81" width="359" height="12" font="2">minimization (Section 3.4) is that none of the test cases generated</text>
<text top="867" left="81" width="283" height="12" font="2">by our system caused the initializer generator to fail.</text>
<text top="882" left="99" width="341" height="12" font="2">Figure 5 shows a sample test program (without the baseline ini-</text>
<text top="897" left="81" width="359" height="12" font="2">tializer) generated by our system for the instruction push %eax.</text>
<text top="912" left="81" width="359" height="12" font="2">The left hand side (Figure 5(a)) shows the output of the machine</text>
<text top="927" left="81" width="359" height="12" font="2">state space exploration. The system returned an assignment for the</text>
<text top="942" left="81" width="359" height="12" font="2">stack pointer and for two bytes of the physical memory, corre-</text>
<text top="957" left="81" width="359" height="12" font="2">sponding respectively to the ﬁfth and sixth byte of the tenth entry</text>
<text top="972" left="81" width="359" height="12" font="2">in the global descriptor table. This descriptor is used for the stack</text>
<text top="987" left="81" width="359" height="12" font="2">segment, thus the purpose of the test is to exercise checks on the</text>
<text top="1001" left="81" width="359" height="12" font="2">type and on the limit of the stack segment. The right hand side of</text>
<text top="1016" left="81" width="359" height="12" font="2">the ﬁgure (Figure 5(b)) shows the code generated by our system</text>
<text top="1031" left="81" width="359" height="12" font="2">to initialize the state, to execute the push instruction, and to mark</text>
<text top="1046" left="81" width="359" height="12" font="2">the end of the execution. Line 1 initializes the stack pointer. Lines</text>
<text top="1061" left="81" width="359" height="12" font="2">2 and 3 overwrite the type and the default operand size attributes</text>
<text top="1076" left="81" width="359" height="12" font="2">of the tenth segment descriptor in the global descriptor table. Lines</text>
<text top="111" left="476" width="359" height="12" font="2">4 and 5 force the CPU to reload the descriptor of the stack seg-</text>
<text top="126" left="476" width="359" height="12" font="2">ment (the tenth descriptor). Line 6 restores the original value of the</text>
<text top="141" left="476" width="32" height="10" font="2">%eax</text>
<text top="141" left="512" width="323" height="12" font="2">register, used by the previous instructions. Line 7 is the test</text>
<text top="156" left="476" width="359" height="12" font="2">instruction and line 8 halts the CPU. Our sequence generation al-</text>
<text top="171" left="476" width="359" height="12" font="2">gorithm automatically determines that lines 2 and 3 require lines 4</text>
<text top="186" left="476" width="229" height="12" font="2">and 5, and that lines 4 and 5 require line 6.</text>
<text top="221" left="476" width="12" height="15" font="1">5.</text>
<text top="221" left="504" width="176" height="15" font="1">Executing Test Programs</text>
<text top="244" left="476" width="359" height="12" font="2">In the test program execution step, we take as input a test program</text>
<text top="259" left="476" width="359" height="12" font="2">as constructed in the previous step, and execute it on either an</text>
<text top="274" left="476" width="359" height="12" font="2">emulator or the real hardware. We monitor its execution to catch</text>
<text top="289" left="476" width="359" height="12" font="2">any exceptions raised by the test instruction, and to record the ﬁnal</text>
<text top="304" left="476" width="359" height="12" font="2">state; these are the outputs that we will then compare. We now</text>
<text top="319" left="476" width="359" height="12" font="2">explain how we implement this execution step for emulators and</text>
<text top="334" left="476" width="96" height="12" font="2">for real hardware.</text>
<text top="363" left="476" width="17" height="12" font="2">5.1</text>
<text top="363" left="506" width="116" height="12" font="2">Emulator Execution</text>
<text top="384" left="476" width="359" height="12" font="2">To run a test on a given emulator, we boot the emulator using</text>
<text top="399" left="476" width="359" height="12" font="2">the virtual disk image created for the test. After booting, the test</text>
<text top="414" left="476" width="359" height="12" font="2">runs automatically. The execution of the test can terminate in two</text>
<text top="429" left="476" width="359" height="12" font="2">different ways: the CPU either halts or throws an exception. To</text>
<text top="443" left="476" width="359" height="12" font="2">detect the termination of a test, we intercept those events; when</text>
<text top="458" left="476" width="359" height="12" font="2">one occurs, we generate a snapshot of the state of the CPU and of</text>
<text top="473" left="476" width="359" height="12" font="2">the physical memory. We achieve this by instrumenting the main</text>
<text top="488" left="476" width="359" height="12" font="2">execution loop of the emulator, enabling the interception after the</text>
<text top="503" left="476" width="199" height="12" font="2">baseline initialization has completed.</text>
<text top="518" left="493" width="341" height="12" font="2">The test state initialization might modify critical portions of the</text>
<text top="533" left="476" width="359" height="12" font="2">CPU state (e.g., the page table or the global descriptor table). If any</text>
<text top="548" left="476" width="359" height="12" font="2">hardware interrupt is delivered during this stage of the initializa-</text>
<text top="563" left="476" width="359" height="12" font="2">tion, the CPU might be unable to execute the interrupt handler suc-</text>
<text top="578" left="476" width="359" height="12" font="2">cessfully and will throw an exception. Different emulators simulate</text>
<text top="593" left="476" width="359" height="12" font="2">different devices and adopt different strategies to deliver hardware</text>
<text top="608" left="476" width="359" height="12" font="2">interrupts. Therefore, to prevent a spurious difference in the state,</text>
<text top="623" left="476" width="359" height="12" font="2">we ignore all interrupts after the baseline state has been initialized,</text>
<text top="638" left="476" width="345" height="12" font="2">again by instrumenting the main execution loop of the emulator.</text>
<text top="653" left="493" width="341" height="12" font="2">We have had to implement very little instrumentation to inter-</text>
<text top="668" left="476" width="359" height="12" font="2">cept hardware interrupts, exceptions, and halt requests. Bochs al-</text>
<text top="683" left="476" width="359" height="12" font="2">ready offers an API to instrument various types of events. QEMU</text>
<text top="697" left="476" width="359" height="12" font="2">does not provide an API, but we only needed to write a 10-line</text>
<text top="712" left="476" width="154" height="12" font="2">patch to intercept the events.</text>
<text top="727" left="493" width="341" height="12" font="2">We create snapshots of the CPU state and of the physical mem-</text>
<text top="742" left="476" width="359" height="12" font="2">ory with instrumentation code in the emulator that uses the emula-</text>
<text top="757" left="476" width="359" height="12" font="2">tor’s APIs for memory access. The advantage of this approach, as</text>
<text top="772" left="476" width="359" height="12" font="2">opposed to attempting to create the snapshot as part of the test pro-</text>
<text top="787" left="476" width="359" height="12" font="2">gram, is that it is effective even if the emulated CPU is in an invalid</text>
<text top="802" left="476" width="359" height="12" font="2">state. Bochs and QEMU have similar built-in snapshot capabilities,</text>
<text top="817" left="476" width="336" height="12" font="2">but we implement our own ﬁle format to simplify comparison.</text>
<text top="846" left="476" width="17" height="12" font="2">5.2</text>
<text top="846" left="506" width="119" height="12" font="2">Hardware Execution</text>
<text top="867" left="476" width="359" height="12" font="2">As with the emulator, we would like to record the state of the CPU</text>
<text top="882" left="476" width="359" height="12" font="2">and of the physical memory obtained at the end of the test program</text>
<text top="897" left="476" width="359" height="12" font="2">on real hardware Unfortunately, this is not easy to do because the</text>
<text top="912" left="476" width="359" height="12" font="2">execution environment would require special support for creating</text>
<text top="927" left="476" width="359" height="12" font="2">snapshots of the state at the end of the execution and because each</text>
<text top="942" left="476" width="203" height="12" font="2">test would have to reset the hardware.</text>
<text top="957" left="493" width="341" height="12" font="2">Our strategy to overcome this problem is to leverage the closest</text>
<text top="972" left="476" width="359" height="12" font="2">approximation of the real hardware available: a hardware assisted</text>
<text top="987" left="476" width="359" height="12" font="2">virtual machine. With a hardware assisted virtual machine, based</text>
<text top="1001" left="476" width="41" height="12" font="2">on Intel</text>
<text top="1005" left="519" width="5" height="7" font="7">R</text>
<text top="1001" left="529" width="94" height="12" font="2">VT-x, or AMD-V</text>
<text top="998" left="623" width="6" height="8" font="4">∗</text>
<text top="1001" left="632" width="202" height="12" font="2">[1, 24], we can execute tests in a guest</text>
<text top="1016" left="476" width="359" height="12" font="2">virtual machine and supervise the execution of the guest from the</text>
<text top="1031" left="476" width="359" height="12" font="2">virtual machine monitor. The majority of the instructions (including</text>
<text top="1046" left="476" width="359" height="12" font="2">most privileged ones) can be executed directly on the hardware</text>
<text top="1061" left="476" width="359" height="12" font="2">from the guest. The mediation of the virtual machine monitor is</text>
<text top="1076" left="476" width="359" height="12" font="2">required only for a small subset of the instructions and events,</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1188" width="918">
<text top="142" left="105" width="29" height="9" font="5">%esp</text>
<text top="142" left="162" width="86" height="9" font="5">: 0x002007dc</text>
<text top="155" left="105" width="100" height="9" font="5">00208055: 0x13</text>
<text top="155" left="219" width="57" height="9" font="5">(gdt 10)</text>
<text top="169" left="105" width="100" height="9" font="5">00208056: 0xcf</text>
<text top="169" left="219" width="57" height="9" font="5">(gdt 10)</text>
<text top="192" left="192" width="13" height="11" font="5">(a)</text>
<text top="111" left="337" width="4" height="7" font="7">1</text>
<text top="108" left="359" width="151" height="9" font="5">movl $0x002007dc,%esp</text>
<text top="124" left="337" width="4" height="7" font="7">2</text>
<text top="122" left="359" width="151" height="9" font="5">movb $0x13,0x00208055</text>
<text top="122" left="531" width="187" height="9" font="5">// modify segment type and</text>
<text top="138" left="337" width="4" height="7" font="7">3</text>
<text top="135" left="359" width="151" height="9" font="5">movb $0xcf,0x00208056</text>
<text top="135" left="531" width="14" height="9" font="5">//</text>
<text top="135" left="567" width="222" height="9" font="5">default operation size (gdt 10)</text>
<text top="151" left="337" width="4" height="7" font="7">4</text>
<text top="149" left="359" width="115" height="9" font="5">movw $0x0050,%ax</text>
<text top="149" left="531" width="230" height="9" font="5">// force reload of stack segment</text>
<text top="165" left="337" width="4" height="7" font="7">5</text>
<text top="162" left="359" width="86" height="9" font="5">movw %ax,%ss</text>
<text top="178" left="337" width="4" height="7" font="7">6</text>
<text top="176" left="359" width="151" height="9" font="5">movl $0x00000000,%eax</text>
<text top="176" left="531" width="158" height="9" font="5">// restore killed %eax</text>
<text top="192" left="337" width="4" height="7" font="7">7</text>
<text top="189" left="359" width="108" height="9" font="5">.byte 0xff,0xf0</text>
<text top="189" left="531" width="86" height="9" font="5">// push %eax</text>
<text top="205" left="337" width="4" height="7" font="7">8</text>
<text top="203" left="359" width="22" height="9" font="5">hlt</text>
<text top="203" left="531" width="72" height="9" font="5">// the end</text>
<text top="226" left="578" width="14" height="11" font="5">(b)</text>
<text top="249" left="81" width="753" height="12" font="2">Figure 5. Sample test-case generated by FuzzBALL (a) and corresponding x86 code of the test program (b), for the instruction push %eax.</text>
<text top="293" left="81" width="359" height="12" font="2">and is triggered by traps. Hardware interrupts, exceptions, and</text>
<text top="308" left="81" width="359" height="12" font="2">halt requests that occur while executing guest code directly on the</text>
<text top="323" left="81" width="359" height="12" font="2">hardware can be intercepted by conﬁguring the CPU to trap into the</text>
<text top="338" left="81" width="359" height="12" font="2">virtual machine monitor whenever they occur. When a trap occurs,</text>
<text top="353" left="81" width="359" height="12" font="2">the virtual machine monitor, having complete visibility to the state</text>
<text top="368" left="81" width="359" height="12" font="2">of the guest virtual machine, can create a snapshot of the state of the</text>
<text top="383" left="81" width="359" height="12" font="2">CPU and of the physical memory. Finally, the hardware guarantees</text>
<text top="398" left="81" width="359" height="12" font="2">a separation of the guest from the virtual machine monitor. Thus,</text>
<text top="413" left="81" width="359" height="12" font="2">the virtual machine monitor is always able to regain control of the</text>
<text top="428" left="81" width="359" height="12" font="2">execution, it can reset the state of the guest, and multiple tests can</text>
<text top="443" left="81" width="291" height="12" font="2">be run without having to reset the machine physically.</text>
<text top="458" left="99" width="341" height="12" font="2">All the guest instructions in the test program that can be directly</text>
<text top="473" left="81" width="359" height="12" font="2">executed on the hardware are guaranteed to be correct. In other</text>
<text top="488" left="81" width="359" height="12" font="2">words, the state at the end of their execution corresponds to the</text>
<text top="503" left="81" width="359" height="12" font="2">state we would obtain if we executed the same instructions without</text>
<text top="518" left="81" width="359" height="12" font="2">the virtualization layer. On the other hand, for the instructions that</text>
<text top="533" left="81" width="359" height="12" font="2">require the mediation of the virtual machine monitor we do not</text>
<text top="548" left="81" width="359" height="12" font="2">have the same guarantee. However the number of such instructions</text>
<text top="562" left="81" width="359" height="12" font="2">is very small (just those that load and store a few privileged control</text>
<text top="577" left="81" width="359" height="12" font="2">registers), and their semantics simple, so we have checked by hand</text>
<text top="592" left="81" width="359" height="12" font="2">that the code in the virtual machine monitor responsible for the</text>
<text top="607" left="81" width="236" height="12" font="2">mediation complies with the real semantics.</text>
<text top="622" left="99" width="341" height="12" font="2">Our implementation is based on KVM [19] (Kernel-based Vir-</text>
<text top="637" left="81" width="359" height="12" font="2">tual Machine), a virtual machine monitor for GNU/Linux. Only a</text>
<text top="652" left="81" width="359" height="12" font="2">few modiﬁcations were necessary to the original KVM codebase</text>
<text top="667" left="81" width="359" height="12" font="2">in order to intercept all traps that occur after the baseline state has</text>
<text top="682" left="81" width="359" height="12" font="2">been initialized. We handle different types of traps differently. If the</text>
<text top="697" left="81" width="359" height="12" font="2">trap originates from an exception or a halt request, we take a snap-</text>
<text top="712" left="81" width="359" height="12" font="2">shot of the guest CPU state and physical memory and terminate the</text>
<text top="727" left="81" width="359" height="12" font="2">guest. If the trap originates from a hardware interrupt, we ignore the</text>
<text top="742" left="81" width="359" height="12" font="2">trap and resume the execution of the guest. Another class of traps</text>
<text top="757" left="81" width="359" height="12" font="2">are used to simulate exceptions: these occur when an instruction</text>
<text top="772" left="81" width="359" height="12" font="2">that would normally cause an exception (in the absence of the vir-</text>
<text top="787" left="81" width="359" height="12" font="2">tualization layer), instead generates a virtualization trap. Thus for</text>
<text top="802" left="81" width="359" height="12" font="2">all other types of trap, we let the virtual machine monitor handle</text>
<text top="816" left="81" width="359" height="12" font="2">the trap, but, before resuming the execution of the guest, we check</text>
<text top="831" left="81" width="359" height="12" font="2">whether an exception will be injected into the guest at the next re-</text>
<text top="846" left="81" width="359" height="12" font="2">sume. If so, this indicates that the trap was simulating an exception,</text>
<text top="861" left="81" width="329" height="12" font="2">so we take a snapshot and terminate as for a direct exception.</text>
<text top="919" left="81" width="12" height="15" font="1">6.</text>
<text top="919" left="110" width="77" height="15" font="1">Evaluation</text>
<text top="942" left="81" width="359" height="12" font="2">We evaluated PokeEMU by comparing the behaviors of the latest</text>
<text top="957" left="81" width="359" height="12" font="2">versions of QEMU (0.14.0) and Bochs (2.4.6), with the behavior of</text>
<text top="972" left="81" width="41" height="12" font="2">an Intel</text>
<text top="975" left="125" width="5" height="7" font="7">R</text>
<text top="972" left="136" width="26" height="12" font="2">Core</text>
<text top="973" left="162" width="11" height="7" font="7">TM</text>
<text top="972" left="178" width="262" height="12" font="2">i5 processor. On the latter we used a customized</text>
<text top="987" left="81" width="359" height="12" font="2">version of KVM (2.6.37) to automate the execution of the exper-</text>
<text top="1001" left="81" width="359" height="12" font="2">iments. Since the i5 processor has hardware support for memory</text>
<text top="1016" left="81" width="359" height="12" font="2">virtualization (extended, or nested, page tables), the vast majority</text>
<text top="1031" left="81" width="359" height="12" font="2">of the instructions could be executed natively by the hardware with-</text>
<text top="1046" left="81" width="195" height="12" font="2">out the need for software emulation.</text>
<text top="1061" left="99" width="341" height="12" font="2">As the Hi-Fi emulator we used a slightly earlier version of</text>
<text top="1076" left="81" width="359" height="12" font="2">Bochs (2.4.5), the latest available at the time we started working on</text>
<text top="293" left="476" width="359" height="12" font="2">this project. We slightly customized this emulator to ease symbolic</text>
<text top="308" left="476" width="339" height="12" font="2">execution (e.g., we disabled the devices and the user interface).</text>
<text top="323" left="493" width="341" height="12" font="2">We generated test cases using virtual machines running on</text>
<text top="338" left="476" width="359" height="12" font="2">Amazon EC2. We then used the same virtual machines to run the</text>
<text top="353" left="476" width="359" height="12" font="2">test cases in QEMU and Bochs and to compare their behaviors.</text>
<text top="368" left="476" width="359" height="12" font="2">The generation of the test cases required 545.4 CPU hours on 3</text>
<text top="383" left="476" width="359" height="12" font="2">8-core instances on EC2 (total cost was about 135 US dollars in</text>
<text top="398" left="476" width="359" height="12" font="2">Amazon EC2 charges during the summer of 2011). Generation is</text>
<text top="413" left="476" width="359" height="12" font="2">highly parallelizable, since the bulk of its execution cost lies in the</text>
<text top="428" left="476" width="359" height="12" font="2">invocations of the solver, and multiple paths can be explored at</text>
<text top="443" left="476" width="359" height="12" font="2">the same time. We estimate that, with proper scheduling, test-case</text>
<text top="458" left="476" width="296" height="12" font="2">generation would take about 33.0 hours on 3 instances.</text>
<text top="473" left="493" width="341" height="12" font="2">Test-case execution took totals of 198.7, 391.9, and 48.5 CPU</text>
<text top="488" left="476" width="359" height="12" font="2">hours on QEMU, Bochs, and the real hardware, respectively, and</text>
<text top="503" left="476" width="359" height="12" font="2">results comparison took 175.9 CPU hours. Test execution is also</text>
<text top="518" left="476" width="359" height="12" font="2">highly parallel, but our real-hardware testing approach is incom-</text>
<text top="533" left="476" width="359" height="12" font="2">patible with EC2’s para-virtualization; for the present results we</text>
<text top="548" left="476" width="359" height="12" font="2">used a local workstation. By combining 13 EC2 instances and 3</text>
<text top="562" left="476" width="359" height="12" font="2">bare-metal instances from another provider, and accounting for the</text>
<text top="577" left="476" width="359" height="12" font="2">network transfer between them, we estimate that a complete set of</text>
<text top="592" left="476" width="359" height="12" font="2">test executions and the comparison of their results would take 7.8</text>
<text top="607" left="476" width="359" height="12" font="2">hours and $100.19. This is already fast enough to use for nightly re-</text>
<text top="622" left="476" width="359" height="12" font="2">gression testing, so we believe that execution time is not a limiting</text>
<text top="637" left="476" width="277" height="12" font="2">factor for our approach or the PokeEMU prototype.</text>
<text top="652" left="493" width="341" height="12" font="2">Our system was able to identify several differences in the behav-</text>
<text top="667" left="476" width="359" height="12" font="2">iors of the emulators, some of which were not known before. We</text>
<text top="682" left="476" width="359" height="12" font="2">argue that our system can successfully be used in the future to val-</text>
<text top="697" left="476" width="359" height="12" font="2">idate the implementation of the currently missing security features</text>
<text top="712" left="476" width="359" height="12" font="2">in QEMU (i.e., the enforcement of segments’ limits and rights) and</text>
<text top="727" left="476" width="359" height="12" font="2">the other issues (such as those caused by the lack of atomicity dur-</text>
<text top="742" left="476" width="136" height="12" font="2">ing emulation) we found.</text>
<text top="771" left="476" width="17" height="12" font="2">6.1</text>
<text top="771" left="506" width="160" height="12" font="2">Completeness of the Testing</text>
<text top="792" left="476" width="359" height="12" font="2">To generate test instructions we explored the instruction set using</text>
<text top="807" left="476" width="359" height="12" font="2">a 15 byte input buffer. The ﬁrst three bytes of this buffer were</text>
<text top="822" left="476" width="359" height="12" font="2">made symbolic (for the reasons explained in Section 3.2) and the</text>
<text top="837" left="476" width="359" height="12" font="2">remaining ones were set to zero. We identiﬁed 68,977 candidate</text>
<text top="852" left="476" width="359" height="12" font="2">byte sequences encoding valid instructions and then selected 880</text>
<text top="867" left="476" width="359" height="12" font="2">unique instructions. This set of instructions covered all the unique</text>
<text top="882" left="476" width="359" height="12" font="2">instructions supported by the emulator, with the exception of a</text>
<text top="897" left="476" width="359" height="12" font="2">few SIMD instructions whose opcodes are longer than three bytes;</text>
<text top="912" left="476" width="359" height="12" font="2">we also excluded ﬂoating point instructions since our symbolic</text>
<text top="927" left="476" width="217" height="12" font="2">execution engine does not support them.</text>
<text top="924" left="693" width="4" height="8" font="4">5</text>
<text top="942" left="493" width="341" height="12" font="2">We used each of these instructions to explore the machine state-</text>
<text top="957" left="476" width="359" height="12" font="2">space and to generate test programs. For the exploration we treated</text>
<text top="972" left="476" width="359" height="12" font="2">the entire machine state as symbolic, with the exception of the</text>
<text top="987" left="476" width="359" height="12" font="2">bytes in memory representing pointers (as shown in Figure 3), the</text>
<text top="1002" left="476" width="359" height="12" font="2">FPU state, the MMX registers, and the contents of the interrupt</text>
<text top="1017" left="476" width="359" height="12" font="2">descriptor table. As concrete inputs we used a snapshot of the</text>
<text top="1048" left="476" width="4" height="8" font="4">5</text>
<text top="1050" left="482" width="352" height="11" font="5">Some of the techniques used for ﬂoating-point equivalence checking by</text>
<text top="1064" left="476" width="359" height="11" font="5">Collingbourne et al. [11] might help us remove the ﬂoating-point restriction</text>
<text top="1077" left="476" width="170" height="11" font="5">from PokeEMU in our future work.</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="81" width="359" height="12" font="2">baseline machine state. For each test instruction we executed the</text>
<text top="126" left="81" width="359" height="12" font="2">emulator until we explored all paths or we reached a limit on the</text>
<text top="141" left="81" width="240" height="12" font="2">maximum number of paths (currently 8192).</text>
<text top="156" left="99" width="341" height="12" font="2">In this setting, our system explored 610,516 different paths. We</text>
<text top="171" left="81" width="359" height="12" font="2">observed that the number of explored paths per instruction mainly</text>
<text top="186" left="81" width="359" height="12" font="2">depends on the type of instructions and on the type of operands</text>
<text top="201" left="81" width="359" height="12" font="2">(e.g., whether the operand represents a register or a memory loca-</text>
<text top="215" left="81" width="359" height="12" font="2">tion). We exhaustively explored the machine state-space for about</text>
<text top="230" left="81" width="359" height="12" font="2">95% of the instructions. The remaining 5% of the test instructions</text>
<text top="245" left="81" width="359" height="12" font="2">were not exhaustively explored because we either hit the limit on</text>
<text top="260" left="81" width="359" height="12" font="2">the maximum number of paths or because of a limitation of our</text>
<text top="275" left="81" width="359" height="12" font="2">current concretization strategy. Thus, for the exhaustively explored</text>
<text top="290" left="81" width="359" height="12" font="2">instructions, our system generated test programs that covered all</text>
<text top="305" left="81" width="122" height="12" font="2">the possible behaviors</text>
<text top="305" left="207" width="233" height="12" font="2">of the Hi-Fi emulator that can be triggered</text>
<text top="320" left="81" width="359" height="12" font="2">by varying the symbolic machine state. (It does not follow that our</text>
<text top="335" left="81" width="359" height="12" font="2">tests achieved 100% block or branch coverage of all of the code</text>
<text top="350" left="81" width="359" height="12" font="2">within the exhaustively-explored instructions, because for instance</text>
<text top="365" left="81" width="359" height="12" font="2">code that would only execute outside of protected mode was not in-</text>
<text top="380" left="81" width="359" height="12" font="2">cluded in the exploration. But in the cases we examined manually</text>
<text top="395" left="81" width="214" height="12" font="2">the static coverage appeared very high.)</text>
<text top="427" left="81" width="17" height="12" font="2">6.2</text>
<text top="427" left="111" width="131" height="12" font="2">Analysis of Differences</text>
<text top="449" left="81" width="359" height="12" font="2">Overall, we observed quite a high number of differences: out of</text>
<text top="464" left="81" width="359" height="12" font="2">the 610,516 test programs generated by our system, 60,770 of</text>
<text top="478" left="81" width="359" height="12" font="2">these programs produced distinguishable behaviors in QEMU and</text>
<text top="493" left="81" width="330" height="12" font="2">15,219 of them produced distinguishable behaviors in Bochs.</text>
<text top="508" left="99" width="341" height="12" font="2">Not all discovered differences represent a distinct bug. Some</text>
<text top="523" left="81" width="359" height="12" font="2">are caused by undeﬁned CPU behaviors; since those behaviors are</text>
<text top="538" left="81" width="359" height="12" font="2">undocumented, there may be no single correct behavior (and even</text>
<text top="553" left="81" width="359" height="12" font="2">different physical CPUs may produce different results). Among the</text>
<text top="568" left="81" width="359" height="12" font="2">remaining differences, many are imputable to the same root cause.</text>
<text top="583" left="81" width="359" height="12" font="2">We used scripts to ﬁlter out differences due to undeﬁned behaviors</text>
<text top="598" left="81" width="359" height="12" font="2">(we reused ﬁlters from our prior work [20, 21]). We then clustered</text>
<text top="613" left="81" width="359" height="12" font="2">the differences according to root cause; this clustering identiﬁed</text>
<text top="628" left="81" width="359" height="12" font="2">different executed paths that triggered the same behavior differ-</text>
<text top="643" left="81" width="359" height="12" font="2">ence. We then examined representative tests to understand each root</text>
<text top="658" left="81" width="359" height="12" font="2">cause. In the remainder of this section we brieﬂy summarize some</text>
<text top="673" left="81" width="356" height="12" font="2">of the root causes we identiﬁed, and we discuss their implications.</text>
<text top="688" left="99" width="341" height="12" font="2">Hardware CPUs execute instructions atomically. On the other</text>
<text top="703" left="81" width="359" height="12" font="2">hand, in a software emulated CPU, the execution of an instruction</text>
<text top="718" left="81" width="359" height="12" font="2">requires executing multiple instructions on the real hardware. Thus,</text>
<text top="733" left="81" width="359" height="12" font="2">to emulate the execution of an instruction atomically, special care</text>
<text top="747" left="81" width="359" height="12" font="2">is needed to ensure that the original state is preserved (or restored)</text>
<text top="762" left="81" width="359" height="12" font="2">when the execution of an instruction is interrupted by an exception.</text>
<text top="777" left="81" width="359" height="12" font="2">Non-atomic execution of instruction can produce incorrect program</text>
<text top="792" left="81" width="359" height="12" font="2">behaviors and open opportunities for attacks. The test programs</text>
<text top="807" left="81" width="359" height="12" font="2">generated by our system conﬁrmed that both emulators execute the</text>
<text top="822" left="81" width="359" height="12" font="2">majority of the instructions atomically. However, our system iden-</text>
<text top="837" left="81" width="359" height="12" font="2">tiﬁed instructions for which the atomicity property is not guaran-</text>
<text top="852" left="81" width="359" height="12" font="2">teed in QEMU. More precisely, our system found that this prob-</text>
<text top="867" left="81" width="359" height="12" font="2">lem occurs with the instructions leave (high level procedure exit)</text>
<text top="882" left="81" width="359" height="12" font="2">and cmpxchgw (compare and exchange). The former corrupts the</text>
<text top="897" left="81" width="359" height="12" font="2">stack pointer when the page containing the top of the stack is not</text>
<text top="912" left="81" width="359" height="12" font="2">accessible. The latter corrupts the source operand when the destina-</text>
<text top="927" left="81" width="359" height="12" font="2">tion operand represents a memory location and this memory loca-</text>
<text top="942" left="81" width="359" height="12" font="2">tion is read-only. Indeed, the lack of write permissions is detected</text>
<text top="957" left="81" width="359" height="12" font="2">only after the source operand has been updated, and the original</text>
<text top="972" left="81" width="359" height="12" font="2">value of the source operand is not checkpointed. We speculate that</text>
<text top="987" left="81" width="359" height="12" font="2">such issues, although not easy to trigger, might lead to serious se-</text>
<text top="1001" left="81" width="112" height="12" font="2">curity consequences.</text>
<text top="1016" left="99" width="341" height="12" font="2">Paging and segmentation are the two main security mechanisms</text>
<text top="1031" left="81" width="359" height="12" font="2">provided by the CPU; an emulator has to support these mechanisms</text>
<text top="1046" left="81" width="359" height="12" font="2">to be considered trustworthy. Our system identiﬁed that QEMU</text>
<text top="1061" left="81" width="359" height="12" font="2">does not implement segmentation properly because it does not en-</text>
<text top="1076" left="81" width="359" height="12" font="2">force segment limits and rights with the majority of instructions,</text>
<text top="111" left="476" width="359" height="12" font="2">which can have serious security implications. The lack of segmen-</text>
<text top="126" left="476" width="359" height="12" font="2">tation support renders security mechanisms that rely on this fea-</text>
<text top="141" left="476" width="359" height="12" font="2">ture [28] completely useless. This problem is known to QEMU’s</text>
<text top="156" left="476" width="359" height="12" font="2">developers and was previously, in part, found by applying random</text>
<text top="171" left="476" width="359" height="12" font="2">fuzzing to manually written test programs [21]. However, our sys-</text>
<text top="186" left="476" width="359" height="12" font="2">tem was able to generate test programs to exercise all the checks</text>
<text top="201" left="476" width="359" height="12" font="2">the CPU could possibly do and to identify all the cases in which</text>
<text top="215" left="476" width="359" height="12" font="2">limits and rights are not properly enforced. Thus, the test programs</text>
<text top="230" left="476" width="359" height="12" font="2">we have generated can be used again in the future to validate the</text>
<text top="245" left="476" width="345" height="12" font="2">implementation when this currently missing feature is available.</text>
<text top="260" left="493" width="341" height="12" font="2">We also found other less dangerous discrepancies in the behav-</text>
<text top="275" left="476" width="359" height="12" font="2">iors of the tested emulators. For example our system generated test</text>
<text top="290" left="476" width="359" height="12" font="2">programs showing that QEMU does not raise a general protection</text>
<text top="305" left="476" width="359" height="12" font="2">fault exception when the rmsr (read machine speciﬁc register)</text>
<text top="320" left="476" width="359" height="12" font="2">instruction is used to read the value of an invalid machine status</text>
<text top="335" left="476" width="359" height="12" font="2">register. Moreover, our system found that QEMU, Bochs, and the</text>
<text top="350" left="476" width="359" height="12" font="2">hardware fetch data from memory in different orders. For example,</text>
<text top="365" left="476" width="359" height="12" font="2">the order in which the emulators pop items from the stack while</text>
<text top="380" left="476" width="359" height="12" font="2">emulating the iret (interrupt return) instruction differs (QEMU</text>
<text top="395" left="476" width="359" height="12" font="2">accesses stack items from the outermost to the innermost, Bochs</text>
<text top="410" left="476" width="359" height="12" font="2">and the hardware in the opposite order). Similarly, for the lfs in-</text>
<text top="425" left="476" width="359" height="12" font="2">struction (load far pointer), Bochs fetches the two operands from</text>
<text top="440" left="476" width="359" height="12" font="2">the memory in the opposite order as QEMU and the hardware. This</text>
<text top="455" left="476" width="359" height="12" font="2">difference could cause different exceptions. Again, we found that</text>
<text top="469" left="476" width="359" height="12" font="2">QEMU does not consider valid certain instruction encodings and</text>
<text top="484" left="476" width="359" height="12" font="2">that it does not properly update the segments’ “accessed” ﬂag. Fi-</text>
<text top="499" left="476" width="359" height="12" font="2">nally, both in QEMU and Bochs, some arithmetic and logical in-</text>
<text top="514" left="476" width="359" height="12" font="2">structions differently update some status ﬂags (documented as un-</text>
<text top="529" left="476" width="359" height="12" font="2">deﬁned). Since emulators are widely used to dynamically analyze</text>
<text top="544" left="476" width="359" height="12" font="2">malicious software, malicious developers could embed into their</text>
<text top="559" left="476" width="359" height="12" font="2">software anti-emulation tricks that ﬁngerprint emulators by exploit-</text>
<text top="574" left="476" width="247" height="12" font="2">ing these subtle differences in their behaviors.</text>
<text top="589" left="493" width="341" height="12" font="2">Many of these differences would have been difﬁcult to ﬁnd</text>
<text top="604" left="476" width="359" height="12" font="2">using purely random testing, and were in fact not found by a</text>
<text top="619" left="476" width="359" height="12" font="2">previous such study [20]. For instance, the difference in iret</text>
<text top="634" left="476" width="359" height="12" font="2">read ordering can be signiﬁcant only if the values read lie on</text>
<text top="649" left="476" width="359" height="12" font="2">different pages or across a segment boundary, either of which</text>
<text top="664" left="476" width="359" height="12" font="2">would have a very low probability if the address and segment limit</text>
<text top="679" left="476" width="359" height="12" font="2">were chosen uniformly at random. Random testing can generate</text>
<text top="694" left="476" width="359" height="12" font="2">tests more quickly than PokeEMU, but this would leave the cost</text>
<text top="709" left="476" width="229" height="12" font="2">dominated by the time to execute the tests.</text>
<text top="757" left="476" width="12" height="15" font="1">7.</text>
<text top="757" left="504" width="208" height="15" font="1">Limitations and Future Work</text>
<text top="780" left="476" width="359" height="12" font="2">By necessity, our work reduced the size of the problem by narrow-</text>
<text top="795" left="476" width="359" height="12" font="2">ing its scope. We examine the resulting limitations and the direction</text>
<text top="810" left="476" width="129" height="12" font="2">of our future work next.</text>
<text top="839" left="476" width="302" height="12" font="2">Other operating modes and extended instruction sets.</text>
<text top="839" left="783" width="51" height="12" font="2">Although</text>
<text top="854" left="476" width="359" height="12" font="2">x86 CPUs support multiple operating modes, we focus on testing</text>
<text top="868" left="476" width="359" height="12" font="2">only the 32-bit protected mode with paging enabled. Other oper-</text>
<text top="883" left="476" width="359" height="12" font="2">ating modes (e.g. real and virtual 8086) are more prone to buggy</text>
<text top="898" left="476" width="359" height="12" font="2">behavior, since they are less commonly used. Our system could be</text>
<text top="913" left="476" width="359" height="12" font="2">easily extended for testing these operating modes as well. We plan</text>
<text top="928" left="476" width="359" height="12" font="2">to do that in the future. We also plan to extend our system to support</text>
<text top="943" left="476" width="236" height="12" font="2">ﬂoating-point, MMX, and SSE instructions.</text>
<text top="972" left="476" width="173" height="12" font="2">Multiple-Instruction Sequences.</text>
<text top="972" left="652" width="182" height="12" font="2">We focus on testing each instruc-</text>
<text top="987" left="476" width="359" height="12" font="2">tion separately, rather than sequences of several instructions to-</text>
<text top="1001" left="476" width="359" height="12" font="2">gether. In principle, doing so is completely sufﬁcient if we can</text>
<text top="1016" left="476" width="359" height="12" font="2">construct an initializer for every possible machine state, and the</text>
<text top="1031" left="476" width="359" height="12" font="2">execution of every instruction is independent, properties that have</text>
<text top="1046" left="476" width="359" height="12" font="2">held in our experiments so far. Under these observations, any dif-</text>
<text top="1061" left="476" width="359" height="12" font="2">ference caused by a multi-instruction sequence can be divided into</text>
<text top="1076" left="476" width="229" height="12" font="2">one or more single-instruction differences.</text>
</page>
<page number="11" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="99" width="341" height="12" font="2">In practice, however, emulators may themselves compose in-</text>
<text top="126" left="81" width="359" height="12" font="2">dividual instructions incorrectly, especially in the case of QEMU,</text>
<text top="141" left="81" width="359" height="12" font="2">which performs dynamic binary translation for multi-instruction</text>
<text top="156" left="81" width="359" height="12" font="2">sequences. In our future work, we plan on studying how multi-</text>
<text top="171" left="81" width="252" height="12" font="2">instruction sequences are treated by emulators.</text>
<text top="199" left="81" width="359" height="12" font="2">Symbolic Execution of JIT Compilers and Hardware Speciﬁcations.</text>
<text top="214" left="81" width="359" height="12" font="2">We have based our system on binary-level symbolic execution so</text>
<text top="229" left="81" width="359" height="12" font="2">that in the future we can apply it to emulators based on just-</text>
<text top="244" left="81" width="359" height="12" font="2">in-time compilation, such as QEMU. For example, it would be</text>
<text top="259" left="81" width="359" height="12" font="2">interesting to perform the converse of the comparison in Section 6</text>
<text top="274" left="81" width="359" height="12" font="2">by generating tests from QEMU and using them to evaluate Bochs.</text>
<text top="289" left="81" width="359" height="12" font="2">Since Bochs is generally more complete, our expectation is that</text>
<text top="304" left="81" width="359" height="12" font="2">this would produce only a few more differences than our current</text>
<text top="319" left="81" width="359" height="12" font="2">experiments, but it is important if there are cases where QEMU</text>
<text top="334" left="81" width="210" height="12" font="2">implements a check and Bochs fails to.</text>
<text top="348" left="99" width="341" height="12" font="2">In the limit, it may be possible to apply our path-exploration lift-</text>
<text top="363" left="81" width="359" height="12" font="2">ing methodology to the highest-Fi emulator there is: the hardware</text>
<text top="378" left="81" width="359" height="12" font="2">speciﬁcation itself. Although we have no hope of obtaining (and</text>
<text top="393" left="81" width="359" height="12" font="2">publishing about) speciﬁcations of commercial hardware, it might</text>
<text top="408" left="81" width="359" height="12" font="2">be possible to apply this methodology to open-source hardware ar-</text>
<text top="423" left="81" width="238" height="12" font="2">chitectures, like the SPARC Leon processor.</text>
<text top="438" left="99" width="341" height="12" font="2">Before we reach that desirable remote limit, we hope to study</text>
<text top="453" left="81" width="359" height="12" font="2">higher-level interpreters, e.g., for high-level languages such as Java.</text>
<text top="482" left="81" width="134" height="12" font="2">Other Virtual Machines.</text>
<text top="481" left="221" width="219" height="12" font="2">We currently make some use of source</text>
<text top="496" left="81" width="359" height="12" font="2">code to simplify the workﬂow of our study, but our binary approach</text>
<text top="511" left="81" width="359" height="12" font="2">allows us to tackle emulators for which we have no source code</text>
<text top="526" left="81" width="359" height="12" font="2">at all, e.g., commercial virtual machine monitors that incorporate</text>
<text top="541" left="81" width="359" height="12" font="2">emulation in one or more execution modes. To facilitate this, we</text>
<text top="556" left="81" width="359" height="12" font="2">would like to further automate the process of determining which</text>
<text top="571" left="81" width="359" height="12" font="2">host locations hold guest machine state. For instance the location</text>
<text top="586" left="81" width="359" height="12" font="2">of %eax is the one where the emulator writes 42 when executing</text>
<text top="601" left="81" width="189" height="12" font="2">the instruction mov $42, %eax.</text>
<text top="630" left="81" width="123" height="12" font="2">Equivalence Checking.</text>
<text top="629" left="207" width="232" height="12" font="2">Despite its promise, our approach only pro-</text>
<text top="644" left="81" width="359" height="12" font="2">vides tests, not proofs of correctness. A further direction to improve</text>
<text top="659" left="81" width="359" height="12" font="2">the completeness of our emulator checking would be to perform a</text>
<text top="674" left="81" width="359" height="12" font="2">complete equivalence check between our set of symbolic execu-</text>
<text top="689" left="81" width="359" height="12" font="2">tion results. Starting with a single Hi-Fi emulator path, we could</text>
<text top="704" left="81" width="359" height="12" font="2">identify all paths in the Lo-Fi emulator exercised by the same in-</text>
<text top="719" left="81" width="359" height="12" font="2">put states. Then we could symbolically combine the results for all</text>
<text top="734" left="81" width="359" height="12" font="2">Lo-Fi paths into a single large formula (as in the summary-building</text>
<text top="749" left="81" width="359" height="12" font="2">technique described in Section 3.3.2). Then we would check with</text>
<text top="764" left="81" width="359" height="12" font="2">a decision procedure whether the formula for the single Hi-Fi path</text>
<text top="779" left="81" width="359" height="12" font="2">is equivalent to the formula for the few Lo-Fi paths on all possible</text>
<text top="794" left="81" width="359" height="12" font="2">inputs. It may be difﬁcult to make such an approach scale to all</text>
<text top="809" left="81" width="359" height="12" font="2">instructions, but when it works it provides a very strong statement</text>
<text top="824" left="81" width="359" height="12" font="2">about the absence of differences. This has been tried successfully</text>
<text top="839" left="81" width="333" height="12" font="2">for smaller, restricted programs, like processor microcode [2].</text>
<text top="875" left="81" width="12" height="15" font="1">8.</text>
<text top="875" left="110" width="98" height="15" font="1">Related Work</text>
<text top="898" left="81" width="359" height="12" font="2">Next we discuss two classes of previous research that are related to</text>
<text top="913" left="81" width="359" height="12" font="2">our work here: ﬁrst, other projects that have searched for bugs in</text>
<text top="928" left="81" width="313" height="12" font="2">emulators, and then other systems for symbolic execution.</text>
<text top="957" left="81" width="117" height="12" font="2">Testing of Emulators.</text>
<text top="957" left="203" width="237" height="12" font="2">Emulator authors presumably perform test-</text>
<text top="972" left="81" width="359" height="12" font="2">ing internally, but there has been relatively little research on tech-</text>
<text top="987" left="81" width="359" height="12" font="2">niques to make that testing more automated and effective. A series</text>
<text top="1001" left="81" width="359" height="12" font="2">of two recent papers by Martignoni et al. show the practical value of</text>
<text top="1016" left="81" width="359" height="12" font="2">third-party comparative testing of emulators. They ﬁrst tested CPU</text>
<text top="1031" left="81" width="359" height="12" font="2">emulators speciﬁcally, with randomly generated instructions [20].</text>
<text top="1046" left="81" width="359" height="12" font="2">Later they tested whole-system virtual machines (based on emula-</text>
<text top="1061" left="81" width="359" height="12" font="2">tion and other technologies) using hand-written templates that were</text>
<text top="1076" left="81" width="359" height="12" font="2">then automatically expanded to create a larger number of instruc-</text>
<text top="111" left="476" width="359" height="12" font="2">tion sequences [21]. To generate a set of legal instruction byte se-</text>
<text top="126" left="476" width="359" height="12" font="2">quences (the same challenge we face in Section 3.2), they perform</text>
<text top="141" left="476" width="359" height="12" font="2">a concrete exploration using the CPU as a black-box correctness</text>
<text top="156" left="476" width="359" height="12" font="2">oracle. They also execute tests using techniques similar to the ones</text>
<text top="171" left="476" width="359" height="12" font="2">we describe in Section 4: either with a user-space program [20] or</text>
<text top="186" left="476" width="359" height="12" font="2">a custom-written kernel [21]. However, random testing on its own</text>
<text top="201" left="476" width="359" height="12" font="2">does not provide the same kind of coverage guarantees that sym-</text>
<text top="215" left="476" width="359" height="12" font="2">bolic execution does. First, PokeEMU completed test generation</text>
<text top="230" left="476" width="359" height="12" font="2">with measurable path coverage: complete path coverage for 95% of</text>
<text top="245" left="476" width="359" height="12" font="2">the tested instructions, a precise quantitative measure of coverage,</text>
<text top="260" left="476" width="359" height="12" font="2">which random-testing methods cannot provide. Second, as shown</text>
<text top="275" left="476" width="359" height="12" font="2">by the comparison of Section 6, our approach revealed some bugs</text>
<text top="290" left="476" width="359" height="12" font="2">that these previously state-of-the-art studies based on random test-</text>
<text top="305" left="476" width="359" height="12" font="2">ing did not ﬁnd. Therefore, we consider PokeEMU a demonstrated</text>
<text top="320" left="476" width="201" height="12" font="2">improvement over the state of the art.</text>
<text top="349" left="476" width="111" height="12" font="2">Symbolic Execution.</text>
<text top="348" left="591" width="243" height="12" font="2">Though our primary motivation in this work</text>
<text top="363" left="476" width="359" height="12" font="2">is the practical problem of trustworthy emulation, our results there</text>
<text top="378" left="476" width="359" height="12" font="2">are made possible in part by improvements in the underlying tech-</text>
<text top="393" left="476" width="163" height="12" font="2">nology of symbolic execution.</text>
<text top="408" left="493" width="341" height="12" font="2">Symbolic execution was ﬁrst proposed in the 1970s [18]. It has</text>
<text top="423" left="476" width="359" height="12" font="2">been the subject of renewed interest in the last decade thanks to a</text>
<text top="438" left="476" width="359" height="12" font="2">new generation of approaches [7, 15] and advances in constraint</text>
<text top="453" left="476" width="359" height="12" font="2">solving and increased computing power that have allowed it to be</text>
<text top="468" left="476" width="359" height="12" font="2">more widely applied. We can classify symbolic execution systems</text>
<text top="483" left="476" width="359" height="12" font="2">according to the relationship between concrete and symbolic ex-</text>
<text top="498" left="476" width="359" height="12" font="2">ecution. In systems that are called trace-based, dynamic, or con-</text>
<text top="513" left="476" width="359" height="12" font="2">colic [26], the program chooses branch directions based on a con-</text>
<text top="528" left="476" width="359" height="12" font="2">crete input, but records a path so that it can generate an different</text>
<text top="543" left="476" width="359" height="12" font="2">input later. By contrast online systems, of which FuzzBALL is an</text>
<text top="558" left="476" width="359" height="12" font="2">example, maintain symbolic values without a corresponding con-</text>
<text top="573" left="476" width="359" height="12" font="2">crete value, and so can be free to choose either direction at a branch.</text>
<text top="588" left="493" width="341" height="12" font="2">Another online symbolic execution tool is KLEE [6], which</text>
<text top="602" left="476" width="359" height="12" font="2">generates test cases for C programs using a symbolic interpreter</text>
<text top="617" left="476" width="359" height="12" font="2">for LLVM byte code. KLEE is similar to FuzzBALL in many ways,</text>
<text top="632" left="476" width="359" height="12" font="2">but has two key design differences. First, KLEE “forks” and main-</text>
<text top="647" left="476" width="359" height="12" font="2">tains multiple execution states at once when both sides of a branch</text>
<text top="662" left="476" width="359" height="12" font="2">are feasible, whereas FuzzBALL executes just one path to com-</text>
<text top="677" left="476" width="359" height="12" font="2">pletion and returns to other paths later. Second, KLEE’s symbolic</text>
<text top="692" left="476" width="359" height="12" font="2">constraints can contain array expressions, while FuzzBALL avoids</text>
<text top="707" left="476" width="359" height="12" font="2">them by choosing concrete values for indexes. KLEE’s approach</text>
<text top="722" left="476" width="359" height="12" font="2">produces fewer execution paths, but it requires additional knowl-</text>
<text top="737" left="476" width="359" height="12" font="2">edge and assumptions about the way a program manages memory.</text>
<text top="752" left="476" width="359" height="12" font="2">Also, decision procedure queries that contain large arrays can be</text>
<text top="767" left="476" width="359" height="12" font="2">signiﬁcantly difﬁcult to solve. Though a more symbolic approach</text>
<text top="782" left="476" width="359" height="12" font="2">could be added to FuzzBALL, our current approach works sufﬁ-</text>
<text top="797" left="476" width="329" height="12" font="2">ciently well for many applications, including the present one.</text>
<text top="812" left="493" width="341" height="12" font="2">Particularly for security applications, it is important to be able</text>
<text top="827" left="476" width="359" height="12" font="2">to perform symbolic execution at the binary level, as we do. SAGE</text>
<text top="842" left="476" width="359" height="12" font="2">[16] is a trace-based symbolic execution system for x86 that is</text>
<text top="857" left="476" width="359" height="12" font="2">used for extensive testing within Microsoft, but is not publicly</text>
<text top="871" left="476" width="359" height="12" font="2">available; SmartFuzz [22] is open-source and based on Valgrind.</text>
<text top="886" left="476" width="359" height="12" font="2">However trace-based systems tend to be geared to exploring just</text>
<text top="901" left="476" width="359" height="12" font="2">a few paths in a program, rather than the exhaustive exploration</text>
<text top="916" left="476" width="359" height="12" font="2">we perform. Another capability that is important in some security</text>
<text top="931" left="476" width="359" height="12" font="2">applications is to be able to symbolically execute a program in</text>
<text top="946" left="476" width="359" height="12" font="2">the context of a complete operating system. In a trace-based tool</text>
<text top="961" left="476" width="359" height="12" font="2">one can collect traces with a whole system emulator, but maintain</text>
<text top="976" left="476" width="359" height="12" font="2">symbolic information for a single process, as in the BitFuzz [5]</text>
<text top="991" left="476" width="243" height="12" font="2">system, based on QEMU. Most recently, S</text>
<text top="988" left="719" width="5" height="8" font="4">2</text>
<text top="991" left="725" width="109" height="12" font="2">E [10] is an online</text>
<text top="1006" left="476" width="359" height="12" font="2">system that integrates KLEE with QEMU, allowing more ﬂexible</text>
<text top="1021" left="476" width="359" height="12" font="2">combination of symbolic and concrete execution across multiple</text>
<text top="1036" left="476" width="359" height="12" font="2">components. However, our emulators do not make signiﬁcant use</text>
<text top="1051" left="476" width="359" height="12" font="2">of the operating system when executing instructions, so a lighter-</text>
<text top="1066" left="476" width="296" height="12" font="2">weight single-process approach was appropriate for us.</text>
</page>
<page number="12" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="99" width="341" height="12" font="2">Some of the optimizations we perform are also related to previ-</text>
<text top="126" left="81" width="359" height="12" font="2">ous approaches in symbolic execution. For instance, the technique</text>
<text top="141" left="81" width="359" height="12" font="2">of summary construction described in Section 3.3.2 is similar in</text>
<text top="156" left="81" width="319" height="12" font="2">spirit to compositional symbolic execution techniques [14].</text>
<text top="171" left="99" width="341" height="12" font="2">It is important to distinguish our work on validating processor</text>
<text top="186" left="81" width="359" height="12" font="2">emulators (using symbolic execution) from work on using proces-</text>
<text top="201" left="81" width="359" height="12" font="2">sor emulators (possibly to implement symbolic execution). For ex-</text>
<text top="215" left="81" width="359" height="12" font="2">ample, Anubis [3] uses a CPU emulator (based on QEMU) to ana-</text>
<text top="230" left="81" width="359" height="12" font="2">lyze malware and can perform symbolic path exploration [23]. Sim-</text>
<text top="245" left="81" width="359" height="12" font="2">ilarly, Minesweeper [4] uses an emulator to discover trigger-based</text>
<text top="260" left="81" width="359" height="12" font="2">behaviors in malware. Although our work concerns itself with secu-</text>
<text top="275" left="81" width="359" height="12" font="2">rity, emulators, and symbolic execution, it aims instead to provide</text>
<text top="290" left="81" width="359" height="12" font="2">assurances that the emulator itself is correct. The challenges of ex-</text>
<text top="305" left="81" width="359" height="12" font="2">ecuting an emulator symbolically may have some similarities to</text>
<text top="320" left="81" width="359" height="12" font="2">executing malware symbolically. However, we have two additional</text>
<text top="335" left="81" width="359" height="12" font="2">problems to address: mapping a CPU state identiﬁed by symbolic</text>
<text top="350" left="81" width="359" height="12" font="2">execution to a sequence of instructions that allow to reach the state,</text>
<text top="365" left="81" width="283" height="12" font="2">and identifying anomalous behaviors in an emulator.</text>
<text top="395" left="81" width="12" height="15" font="1">9.</text>
<text top="395" left="110" width="79" height="15" font="1">Conclusion</text>
<text top="418" left="81" width="359" height="12" font="2">We perform high-coverage testing of emulators by using binary-</text>
<text top="433" left="81" width="359" height="12" font="2">level symbolic execution to explore the space of legal instructions</text>
<text top="448" left="81" width="359" height="12" font="2">and machine state that could inﬂuence their execution in a high-</text>
<text top="463" left="81" width="359" height="12" font="2">ﬁdelity emulator (Bochs). The system generates a test, in the form</text>
<text top="478" left="81" width="359" height="12" font="2">of a bootable disk image, for each of the 610,516 explored paths.</text>
<text top="493" left="81" width="359" height="12" font="2">We can use these tests to lift the exploration to test a low-ﬁdelity</text>
<text top="508" left="81" width="359" height="12" font="2">emulator (QEMU), and to cross-validate with a hardware processor.</text>
<text top="523" left="81" width="359" height="12" font="2">In analyzing the differences, we see that many reveal systematic</text>
<text top="538" left="81" width="359" height="12" font="2">implementation oversights, such as atomicity violations in QEMU:</text>
<text top="553" left="81" width="359" height="12" font="2">the tests will be valuable both for understanding the failures and</text>
<text top="568" left="81" width="359" height="12" font="2">verifying that the problems have been ﬁxed. Though this is only</text>
<text top="583" left="81" width="359" height="12" font="2">the ﬁrst application, it demonstrates a practical and powerful tool</text>
<text top="598" left="81" width="198" height="12" font="2">to make emulators more trustworthy.</text>
<text top="612" left="99" width="341" height="12" font="2">Acknowledgments: We thank the anonymous reviewers, as</text>
<text top="628" left="81" width="359" height="12" font="2">well as our shepherd, Jim Larus, for their comments and helpful</text>
<text top="643" left="81" width="359" height="12" font="2">suggestions. We are grateful to Jim Grundy for his detailed feed-</text>
<text top="657" left="81" width="359" height="12" font="2">back on our drafts. This work was in part supported by a gift from</text>
<text top="672" left="81" width="359" height="12" font="2">Intel Corporation, by the Air Force Ofﬁce of Scientiﬁc Research</text>
<text top="687" left="81" width="359" height="12" font="2">(AFOSR) under MURI award FA9550-09-1-0539, by the Air Force</text>
<text top="702" left="81" width="359" height="12" font="2">Research Laboratory under grant no. P010071555, by DARPA un-</text>
<text top="717" left="81" width="359" height="12" font="2">der award HR0011-12-2-005, and by the National Science Foun-</text>
<text top="732" left="81" width="359" height="12" font="2">dation under grants CCF-0424422 and 0842695. Our use of Ama-</text>
<text top="747" left="81" width="359" height="12" font="2">zon EC2 was supported by the Amazon Web Services in Education</text>
<text top="762" left="81" width="359" height="12" font="2">research grant program. Any opinions, ﬁndings, and recommenda-</text>
<text top="777" left="81" width="359" height="12" font="2">tions expressed herein are those of the authors and do not necessar-</text>
<text top="792" left="81" width="276" height="12" font="2">ily reﬂect the views of Intel or the US Government.</text>
<text top="822" left="81" width="76" height="15" font="1">References</text>
<text top="845" left="87" width="353" height="11" font="5">[1] Advanced Micro Devices. AMD64 virtualization: Secure virtual ma-</text>
<text top="858" left="106" width="334" height="11" font="5">chine architecture reference manual. AMD Publication no. 33047 rev.</text>
<text top="872" left="106" width="54" height="11" font="5">3.01, 2005.</text>
<text top="890" left="87" width="353" height="11" font="5">[2] T. Arons, E. Elster, L. Fix, S. Mador-Haim, M. Mishaeli, J. Shalev,</text>
<text top="903" left="106" width="334" height="11" font="5">E. Singerman, A. Tiemeyer, M. Vardi, and L. Zuck. Formal Veriﬁ-</text>
<text top="917" left="106" width="334" height="11" font="5">cation of Backward Compatibility of Microcode. In Computer Aided</text>
<text top="930" left="106" width="87" height="10" font="5">Veriﬁcation (CAV)</text>
<text top="930" left="194" width="33" height="11" font="5">, 2005.</text>
<text top="948" left="87" width="353" height="11" font="5">[3] U. Bayer, C. Kruegel, and E. Kirda. TTAnalyze: A Tool for Analyzing</text>
<text top="961" left="106" width="45" height="11" font="5">Malware.</text>
<text top="961" left="163" width="277" height="11" font="5">In European Institute for Computer Antivirus Research</text>
<text top="975" left="106" width="42" height="10" font="5">(EICAR)</text>
<text top="975" left="148" width="33" height="11" font="5">, 2006.</text>
<text top="992" left="87" width="353" height="11" font="5">[4] D. Brumley, C. Hartwig, Z. Liang, J. Newsome, D. Song, and H. Yin.</text>
<text top="1006" left="106" width="309" height="11" font="5">Automatically identifying trigger-based behavior in malware.</text>
<text top="1006" left="430" width="10" height="11" font="5">In</text>
<text top="1019" left="106" width="334" height="11" font="5">W. Lee, C. Wang, and D. Dagon, editors, Botnet Detection, volume 36</text>
<text top="1033" left="106" width="253" height="11" font="5">of Advances in Information Security. Springer, 2008.</text>
<text top="1050" left="87" width="353" height="11" font="5">[5] J. Caballero, P. Poosankam, S. McCamant, D. Babic, and D. Song.</text>
<text top="1064" left="106" width="334" height="11" font="5">Input generation via decomposition and re-stitching: Finding bugs in</text>
<text top="1077" left="106" width="116" height="11" font="5">malware. In CCS, 2010.</text>
<text top="112" left="481" width="353" height="11" font="5">[6] C. Cadar, D. Dunbar, and D. Engler. KLEE: Unassisted and automatic</text>
<text top="125" left="501" width="334" height="11" font="5">generation of high-coverage tests for complex systems programs. In</text>
<text top="139" left="501" width="27" height="10" font="5">OSDI</text>
<text top="139" left="528" width="33" height="11" font="5">, 2008.</text>
<text top="157" left="481" width="143" height="11" font="5">[7] C. Cadar and D. Engler.</text>
<text top="157" left="636" width="198" height="11" font="5">Execution generated test cases: How to</text>
<text top="170" left="501" width="334" height="11" font="5">make systems code crash itself. In Model Checking Software (SPIN</text>
<text top="184" left="501" width="51" height="10" font="5">Workshop)</text>
<text top="184" left="552" width="33" height="11" font="5">, 2005.</text>
<text top="202" left="481" width="353" height="11" font="5">[8] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. Engler. EXE:</text>
<text top="215" left="501" width="268" height="11" font="5">automatically generating inputs of death. In CCS, 2006.</text>
<text top="233" left="481" width="353" height="11" font="5">[9] X. Chen, T. Garﬁnkel, E. C. Lewis, P. Subrahmanyam, C. A. Wald-</text>
<text top="246" left="501" width="334" height="11" font="5">spurger, D. Boneh, J. Dwoskin, and D. R. K. Ports. Overshadow: A</text>
<text top="260" left="501" width="334" height="11" font="5">Virtualization-Based Approach to Retroﬁtting Protection in Commod-</text>
<text top="273" left="501" width="201" height="11" font="5">ity Operating Systems. In ASPLOS, 2008.</text>
<text top="291" left="476" width="359" height="11" font="5">[10] V. Chipounov, V. Kuznetsov, and G. Candea. S2E: A platform for</text>
<text top="305" left="501" width="321" height="11" font="5">in-vivo multi-path analysis of software systems. In ASPLOS, 2011.</text>
<text top="323" left="476" width="359" height="11" font="5">[11] P. Collingbourne, C. Cadar, and P. H. J. Kelly. Symbolic Crosscheck-</text>
<text top="336" left="501" width="274" height="11" font="5">ing of Floating-Point and SIMD Code. In EuroSys, 2011.</text>
<text top="354" left="476" width="359" height="11" font="5">[12] L. de Moura and N. Bjørner. Z3: An efﬁcient SMT solver. In Tools</text>
<text top="368" left="501" width="331" height="10" font="5">and Algorithms for the Construction and Analysis of Systems (TACAS)</text>
<text top="367" left="831" width="3" height="11" font="5">,</text>
<text top="381" left="501" width="27" height="11" font="5">2008.</text>
<text top="399" left="476" width="359" height="11" font="5">[13] V. Ganesh and D. L. Dill. A decision procedure for bit-vectors and</text>
<text top="412" left="501" width="251" height="11" font="5">arrays. In Computer Aided Veriﬁcation (CAV), 2007.</text>
<text top="430" left="476" width="359" height="11" font="5">[14] P. Godefroid. Compositional dynamic test generation. In POPL, 2007.</text>
<text top="448" left="476" width="359" height="11" font="5">[15] P. Godefroid, N. Klarlund, and K. Sen. DART: directed automated</text>
<text top="462" left="501" width="151" height="11" font="5">random testing. In PLDI, 2005.</text>
<text top="479" left="476" width="359" height="11" font="5">[16] P. Godefroid, M. Y. Levin, and D. A. Molnar. Automated whitebox</text>
<text top="493" left="501" width="334" height="11" font="5">fuzz testing. In Network and Distributed System Security (NDSS),</text>
<text top="506" left="501" width="27" height="11" font="5">2008.</text>
<text top="524" left="476" width="359" height="11" font="5">[17] A. Ho, M. Fetterman, C. Clark, A. Warﬁeld, and S. Hand. Practical</text>
<text top="538" left="501" width="327" height="11" font="5">Taint-Based Protection using Demand Emulation. In EuroSys, 2006.</text>
<text top="556" left="476" width="359" height="11" font="5">[18] J. C. King. Symbolic execution and program testing. Communications</text>
<text top="569" left="501" width="55" height="10" font="5">of the ACM</text>
<text top="569" left="555" width="65" height="11" font="5">, 19(7), 1976.</text>
<text top="587" left="476" width="221" height="11" font="5">[19] Kernel-based Virtual Machine (KVM).</text>
<text top="588" left="711" width="123" height="9" font="5">http://linux-kvm.</text>
<text top="601" left="501" width="29" height="9" font="5">org/</text>
<text top="601" left="529" width="3" height="11" font="5">.</text>
<text top="618" left="476" width="312" height="11" font="5">[20] L. Martignoni, R. Paleari, G. F. Roglia, and D. Bruschi.</text>
<text top="618" left="799" width="35" height="11" font="5">Testing</text>
<text top="632" left="501" width="334" height="11" font="5">CPU emulators. In International Symposium on Software Testing and</text>
<text top="645" left="501" width="81" height="10" font="5">Analysis (ISSTA)</text>
<text top="645" left="581" width="33" height="11" font="5">, 2009.</text>
<text top="663" left="476" width="359" height="11" font="5">[21] L. Martignoni, R. Paleari, G. F. Roglia, and D. Bruschi. Testing system</text>
<text top="677" left="501" width="334" height="11" font="5">virtual machines. In International Symposium on Software Testing and</text>
<text top="690" left="501" width="81" height="10" font="5">Analysis (ISSTA)</text>
<text top="690" left="581" width="33" height="11" font="5">, 2010.</text>
<text top="708" left="476" width="359" height="11" font="5">[22] D. Molnar, X. C. Li, and D. A. Wagner. Dynamic test generation to</text>
<text top="722" left="501" width="334" height="11" font="5">ﬁnd integer bugs in x86 binary Linux programs. In USENIX Security</text>
<text top="735" left="501" width="54" height="10" font="5">Symposium</text>
<text top="735" left="555" width="33" height="11" font="5">, 2009.</text>
<text top="753" left="476" width="359" height="11" font="5">[23] A. Moser, C. Kruegel, and E. Kirda. Exploring Multiple Execution</text>
<text top="766" left="501" width="334" height="11" font="5">Paths for Malware Analysis. In IEEE Symposium on Security and</text>
<text top="780" left="501" width="89" height="10" font="5">Privacy (Oakland)</text>
<text top="780" left="590" width="33" height="11" font="5">, 2007.</text>
<text top="798" left="476" width="359" height="11" font="5">[24] G. Neiger, A. Santoni, F. Leung, D. Rodgers, and R. Uhlig. Intel</text>
<text top="811" left="501" width="334" height="11" font="5">Virtualization Technology: Hardware support for efﬁcient processor</text>
<text top="825" left="501" width="255" height="11" font="5">virtualization. Intel Technology Journal, 10(3), 2006.</text>
<text top="843" left="476" width="359" height="11" font="5">[25] N. Nethercote and J. Seward. Valgrind: a framework for heavyweight</text>
<text top="856" left="501" width="232" height="11" font="5">dynamic binary instrumentation. In PLDI, 2007.</text>
<text top="874" left="476" width="359" height="11" font="5">[26] K. Sen, D. Marinov, and G. Agha. CUTE: A concolic unit testing</text>
<text top="887" left="501" width="334" height="11" font="5">engine for C. In European Software Engineering Conference / Foun-</text>
<text top="901" left="501" width="218" height="10" font="5">dations of Software Engineering (ESEC/FSE)</text>
<text top="901" left="719" width="33" height="11" font="5">, 2005.</text>
<text top="919" left="476" width="359" height="11" font="5">[27] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager, M. G. Kang,</text>
<text top="932" left="501" width="334" height="11" font="5">Z. Liang, J. Newsome, P. Poosankam, and P. Saxena. BitBlaze: A new</text>
<text top="946" left="501" width="334" height="11" font="5">approach to computer security via binary analysis. In International</text>
<text top="959" left="501" width="223" height="10" font="5">Conf. on Information Systems Security (ICISS)</text>
<text top="959" left="724" width="80" height="11" font="5">, 2008. Keynote.</text>
<text top="977" left="476" width="359" height="11" font="5">[28] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy,</text>
<text top="991" left="501" width="334" height="11" font="5">S. Okasaka, N. Narula, and N. Fullagar. Native client: A sandbox for</text>
<text top="1004" left="501" width="334" height="11" font="5">portable, untrusted x86 native code. In IEEE Symposium on Security</text>
<text top="1018" left="501" width="110" height="10" font="5">and Privacy (Oakland)</text>
<text top="1017" left="611" width="33" height="11" font="5">, 2009.</text>
<text top="1035" left="476" width="359" height="11" font="5">[29] Q. Zhang, J. McCullough, J. Ma, N. Schear, M. Vrable, A. Vahdat,</text>
<text top="1049" left="501" width="334" height="11" font="5">A. C. Snoeren, G. M. Voelker, and S. Savage. Neon: system support for</text>
<text top="1062" left="501" width="334" height="11" font="5">derived data management. In Virtual Execution Environments (VEE),</text>
<text top="1076" left="501" width="27" height="11" font="5">2010.</text>
</page>
</pdf2xml>
