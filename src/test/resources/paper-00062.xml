<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pdf2xml SYSTEM "pdf2xml.dtd">

<pdf2xml>
<page number="1" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="0" size="23" family="Times" color="#000000"/>
	<fontspec id="1" size="14" family="Times" color="#000000"/>
	<fontspec id="2" size="9" family="Times" color="#000000"/>
	<fontspec id="3" size="11" family="Times" color="#000000"/>
	<fontspec id="4" size="6" family="Times" color="#000000"/>
	<fontspec id="5" size="8" family="Times" color="#000000"/>
<text top="118" left="236" width="442" height="23" font="0">A Case for Unlimited Watchpoints</text>
<text top="179" left="193" width="155" height="15" font="1">Joseph L. Greathouse</text>
<text top="175" left="349" width="6" height="11" font="2">†</text>
<text top="179" left="373" width="82" height="15" font="1">Hongyi Xin</text>
<text top="175" left="455" width="15" height="11" font="2">‡ ∗</text>
<text top="179" left="503" width="72" height="15" font="1">Yixin Luo</text>
<text top="175" left="575" width="11" height="11" font="2">†§</text>
<text top="179" left="622" width="91" height="15" font="1">Todd Austin</text>
<text top="175" left="712" width="6" height="11" font="2">†</text>
<text top="200" left="218" width="112" height="12" font="3"><a href="mailto:jlgreath@umich.edu">jlgreath@umich.edu</a></text>
<text top="200" left="374" width="97" height="12" font="3"><a href="mailto:hxin@cs.cmu.edu">hxin@cs.cmu.edu</a></text>
<text top="200" left="490" width="112" height="12" font="3"><a href="mailto:luoyixin@umich.edu">luoyixin@umich.edu</a></text>
<text top="200" left="619" width="103" height="12" font="3"><a href="mailto:austin@umich.edu">austin@umich.edu</a></text>
<text top="219" left="123" width="5" height="8" font="4">†</text>
<text top="223" left="128" width="277" height="12" font="3">Advanced Computer Architecture Laboratory</text>
<text top="219" left="427" width="5" height="8" font="4">‡</text>
<text top="223" left="433" width="152" height="12" font="3">SAFARI Research Group</text>
<text top="219" left="619" width="5" height="8" font="4">§</text>
<text top="223" left="625" width="154" height="12" font="3">UM-SJTU Joint Institute</text>
<text top="237" left="195" width="138" height="12" font="3">University of Michigan</text>
<text top="237" left="423" width="165" height="12" font="3">Carnegie Mellon University</text>
<text top="237" left="606" width="186" height="12" font="3">Shanghai Jiao Tong University</text>
<text top="252" left="199" width="129" height="12" font="3">Ann Arbor, MI, USA</text>
<text top="252" left="442" width="129" height="12" font="3">Pittsburgh, PA, USA</text>
<text top="252" left="650" width="100" height="12" font="3">Shanghai, China</text>
<text top="298" left="81" width="72" height="15" font="1">Abstract</text>
<text top="321" left="81" width="359" height="12" font="3">Numerous tools have been proposed to help developers ﬁx</text>
<text top="336" left="81" width="359" height="12" font="3">software errors and ineﬃciencies. Widely-used techniques</text>
<text top="351" left="81" width="359" height="12" font="3">such as memory checking suﬀer from overheads that limit</text>
<text top="366" left="81" width="359" height="12" font="3">their use to pre-deployment testing, while more advanced</text>
<text top="381" left="81" width="359" height="12" font="3">systems have such severe performance impacts that they</text>
<text top="396" left="81" width="359" height="12" font="3">may require special-purpose hardware. Previous works have</text>
<text top="411" left="81" width="359" height="12" font="3">described hardware that can accelerate individual analyses,</text>
<text top="426" left="81" width="359" height="12" font="3">but such specialization stymies adoption; generalized mech-</text>
<text top="441" left="81" width="359" height="12" font="3">anisms are more likely to be added to commercial processors.</text>
<text top="456" left="99" width="341" height="12" font="3">This paper demonstrates that the ability to set an unlim-</text>
<text top="470" left="81" width="359" height="12" font="3">ited number of ﬁne-grain data watchpoints can reduce the</text>
<text top="485" left="81" width="359" height="12" font="3">runtime overheads of numerous dynamic software analysis</text>
<text top="500" left="81" width="359" height="12" font="3">techniques. We detail the watchpoint capabilities required</text>
<text top="515" left="81" width="359" height="12" font="3">to accelerate these analyses while remaining general enough</text>
<text top="530" left="81" width="359" height="12" font="3">to be useful in the future. We describe a hardware design</text>
<text top="545" left="81" width="359" height="12" font="3">that stores watchpoints in main memory and utilizes two</text>
<text top="560" left="81" width="359" height="12" font="3">diﬀerent on-chip caches to accelerate performance. The ﬁrst</text>
<text top="575" left="81" width="359" height="12" font="3">is a bitmap lookaside buﬀer that stores ﬁne-grained watch-</text>
<text top="590" left="81" width="359" height="12" font="3">points, while the second is a range cache that can eﬃciently</text>
<text top="605" left="81" width="359" height="12" font="3">hold large contiguous regions of watchpoints. As an example</text>
<text top="620" left="81" width="359" height="12" font="3">of the power of such a system, it is possible to use watch-</text>
<text top="635" left="81" width="359" height="12" font="3">points to accelerate read/write set checks in a software data</text>
<text top="650" left="81" width="166" height="12" font="3">race detector by nearly 9×.</text>
<text top="673" left="81" width="251" height="12" font="3">Categories and Subject Descriptors</text>
<text top="673" left="346" width="93" height="12" font="3">B.3.2 [Memory</text>
<text top="688" left="81" width="359" height="12" font="3">Structures]: Design Styles—cache memories; C.0 [General ]:</text>
<text top="703" left="81" width="359" height="12" font="3">hardware/software interfaces; D.2.0 [Software Engineer-</text>
<text top="718" left="81" width="359" height="12" font="3">ing ]: General—protection mechanisms; D.2.5 [Software En-</text>
<text top="733" left="81" width="359" height="12" font="3">gineering]: Testing and Debugging—debugging aids, testing</text>
<text top="748" left="81" width="29" height="12" font="3">tools</text>
<text top="771" left="81" width="101" height="12" font="3">General Terms</text>
<text top="771" left="197" width="125" height="12" font="3">Design, Performance</text>
<text top="794" left="81" width="65" height="12" font="3">Keywords</text>
<text top="794" left="161" width="278" height="12" font="3">Watchpoints, Data Race Detection, Determin-</text>
<text top="809" left="81" width="359" height="12" font="3">istic Concurrent Execution, Taint Analysis, Demand-Driven</text>
<text top="824" left="81" width="51" height="12" font="3">Analysis</text>
<text top="856" left="81" width="15" height="15" font="1">1.</text>
<text top="856" left="114" width="104" height="15" font="1">Introduction</text>
<text top="879" left="81" width="359" height="12" font="3">Billions of dollars and millions of man-hours are spent each</text>
<text top="894" left="81" width="359" height="12" font="3">year attempting to build correct programs. As Bessey et al.</text>
<text top="920" left="81" width="6" height="8" font="4">∗</text>
<text top="923" left="89" width="351" height="11" font="2">Author was at the University of Michigan and Shanghai Jiao</text>
<text top="936" left="81" width="260" height="11" font="2">Tong University while working on this project.</text>
<text top="989" left="81" width="359" height="9" font="5">Permission to make digital or hard copies of all or part of this work for</text>
<text top="1001" left="81" width="359" height="9" font="5">personal or classroom use is granted without fee provided that copies</text>
<text top="1013" left="81" width="359" height="9" font="5">are not made or distributed for proﬁt or commercial advantage and</text>
<text top="1025" left="81" width="359" height="9" font="5">that copies bear this notice and the full citation on the ﬁrst page. To</text>
<text top="1037" left="81" width="359" height="9" font="5">copy otherwise, to republish, to post on servers or to redistribute to</text>
<text top="1049" left="81" width="271" height="9" font="5">lists, requires prior speciﬁc permission and/or a fee.</text>
<text top="1064" left="81" width="61" height="9" font="5">ASPLOS’12,</text>
<text top="1064" left="154" width="212" height="9" font="5">March 3–7, 2012, London, England, UK.</text>
<text top="1075" left="81" width="310" height="9" font="5">Copyright c 2012 ACM 978-1-4503-0759-8/12/03. . . $10.00</text>
<text top="300" left="476" width="359" height="12" font="3">stated, “Assuming you have a reasonable [software analysis]</text>
<text top="315" left="476" width="359" height="12" font="3">tool, if you run it over a large, previously unchecked system,</text>
<text top="330" left="476" width="359" height="12" font="3">you will always ﬁnd bugs” <a href="pdfxml.html#12">[7]. </a>The fact that developers</text>
<text top="345" left="476" width="359" height="12" font="3">looking to increase performance on multiprocessors must</text>
<text top="360" left="476" width="338" height="12" font="3">explicitly utilize concurrency only adds to this problem.</text>
<text top="375" left="493" width="341" height="12" font="3">Numerous tools exist to help developers make more ro-</text>
<text top="390" left="476" width="359" height="12" font="3">bust software. Valgrind’s MemCheck, for instance, checks</text>
<text top="405" left="476" width="359" height="12" font="3">dynamic memory operations for errors such as memory leaks</text>
<text top="420" left="476" width="359" height="12" font="3"><a href="pdfxml.html#13">[37]. </a>While such dynamic tools are powerful, they suﬀer from</text>
<text top="435" left="476" width="359" height="12" font="3">large computational overheads that limit their adoption to</text>
<text top="450" left="476" width="359" height="12" font="3">small groups of developers and dedicated testers. MemCheck</text>
<text top="464" left="476" width="359" height="12" font="3">can cause the original program to run 30× slower, while</text>
<text top="479" left="476" width="359" height="12" font="3">more heavyweight tools, such as Larson and Austin’s sym-</text>
<text top="494" left="476" width="359" height="12" font="3">bolic execution engine, see slowdowns of over 200× <a href="pdfxml.html#13">[24].</a></text>
<text top="509" left="476" width="359" height="12" font="3">More insidiously, because dynamic analyses can only observe</text>
<text top="524" left="476" width="359" height="12" font="3">bugs on executed paths, the power of these tools is further</text>
<text top="539" left="476" width="359" height="12" font="3">limited by slowdowns that reduce the number of situations</text>
<text top="554" left="476" width="259" height="12" font="3">observable in a reasonable amount of time.</text>
<text top="569" left="493" width="341" height="12" font="3">Application-speciﬁc hardware is one way of solving this</text>
<text top="584" left="476" width="359" height="12" font="3">problem. Such mechanisms are custom-designed to accel-</text>
<text top="599" left="476" width="359" height="12" font="3">erate individual analyses, but none oﬀers a comprehensive</text>
<text top="614" left="476" width="359" height="12" font="3">way of accelerating many tools. As such, they are unlikely</text>
<text top="629" left="476" width="359" height="12" font="3">to meet the stringent requirements needed to be integrated</text>
<text top="644" left="476" width="359" height="12" font="3">into a modern commercial microprocessor; their beneﬁts are</text>
<text top="659" left="476" width="359" height="12" font="3">too narrowly deﬁned compared to their high area, design,</text>
<text top="674" left="476" width="132" height="12" font="3">and veriﬁcation costs.</text>
<text top="689" left="493" width="341" height="12" font="3">Commercial processors tend to favor generic solutions,</text>
<text top="704" left="476" width="359" height="12" font="3">where costs can be amortized across multiple uses. As an ex-</text>
<text top="719" left="476" width="359" height="12" font="3">ample, the performance counters available on modern micro-</text>
<text top="733" left="476" width="359" height="12" font="3">processors are used to ﬁnd performance-degrading hotspots</text>
<text top="748" left="476" width="359" height="12" font="3">in software <a href="pdfxml.html#13">[39], </a>but they are also used during hardware</text>
<text top="763" left="476" width="359" height="12" font="3">bring-up to identify correctness issues <a href="pdfxml.html#13">[48]. </a>Similarly, while</text>
<text top="778" left="476" width="359" height="12" font="3">Sun added hardware into their prototype Rock processor in</text>
<text top="793" left="476" width="359" height="12" font="3">order to support transactional memory <a href="pdfxml.html#12">[10], </a>the same mech-</text>
<text top="808" left="476" width="359" height="12" font="3">anisms were also used to support runahead execution and</text>
<text top="823" left="476" width="158" height="12" font="3">speculative execution <a href="pdfxml.html#12">[11].</a></text>
<text top="876" left="476" width="20" height="12" font="3">1.1</text>
<text top="876" left="512" width="197" height="12" font="3">Contributions of This Paper</text>
<text top="897" left="476" width="359" height="12" font="3">We theorize that a general acceleration mechanism should</text>
<text top="912" left="476" width="359" height="12" font="3">alert programmers when speciﬁed locations in memory are</text>
<text top="927" left="476" width="359" height="12" font="3">being accessed. In other words, having the ability to set a</text>
<text top="942" left="476" width="359" height="12" font="3">large number of data watchpoints (WPs) would beneﬁt a</text>
<text top="956" left="476" width="139" height="12" font="3">wide range of analyses.</text>
<text top="971" left="493" width="341" height="12" font="3">As the original program executes, many runtime anal-</text>
<text top="986" left="476" width="359" height="12" font="3">ysis systems also perform actions on shadow values. In</text>
<text top="1001" left="476" width="359" height="12" font="3">taint analysis, for example, each location in memory has a</text>
<text top="1016" left="476" width="359" height="12" font="3">shadow value that marks it as trusted or untrusted. Check-</text>
<text top="1031" left="476" width="359" height="12" font="3">ing this meta-data, in order to decide if analyses should oc-</text>
<text top="1046" left="476" width="359" height="12" font="3">cur, is slow. As an example, we previously demonstrated</text>
<text top="1061" left="476" width="359" height="12" font="3">that checking read/write sets using software routines was</text>
<text top="1076" left="476" width="331" height="12" font="3">3-10× slower than using hardware to do the same <a href="pdfxml.html#13">[19].</a></text>
</page>
<page number="2" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="6" size="8" family="Times" color="#000000"/>
	<fontspec id="7" size="8" family="Times" color="#000000"/>
	<fontspec id="8" size="5" family="Times" color="#000000"/>
<text top="227" left="210" width="112" height="10" font="5">Number of Watchpoints</text>
<text top="221" left="194" width="0" height="10" font="6">W</text>
<text top="211" left="194" width="0" height="10" font="6">a</text>
<text top="205" left="194" width="0" height="10" font="6">tc</text>
<text top="197" left="194" width="0" height="10" font="6">h</text>
<text top="191" left="194" width="0" height="10" font="6">p</text>
<text top="185" left="194" width="0" height="10" font="6">o</text>
<text top="179" left="194" width="0" height="10" font="6">in</text>
<text top="170" left="194" width="0" height="10" font="6">t </text>
<text top="165" left="194" width="0" height="10" font="6">G</text>
<text top="156" left="194" width="0" height="10" font="6">ra</text>
<text top="147" left="194" width="0" height="10" font="6">n</text>
<text top="141" left="194" width="0" height="10" font="6">u</text>
<text top="135" left="194" width="0" height="10" font="6">la</text>
<text top="126" left="194" width="0" height="10" font="6">ri</text>
<text top="120" left="194" width="0" height="10" font="6">ty</text>
<text top="198" left="265" width="50" height="8" font="4">Fine-grained</text>
<text top="209" left="258" width="63" height="8" font="4">Mem Protection</text>
<text top="140" left="210" width="45" height="8" font="4">Mondriaan </text>
<text top="151" left="224" width="16" height="8" font="4">like </text>
<text top="161" left="214" width="34" height="8" font="4">Systems</text>
<text top="109" left="239" width="68" height="10" font="7"><b>Our Proposal</b></text>
<text top="178" left="212" width="112" height="8" font="4">Virtual Memory Watchpoints</text>
<text top="202" left="223" width="26" height="8" font="4">Debug</text>
<text top="212" left="223" width="21" height="8" font="4">Regs</text>
<text top="245" left="81" width="359" height="11" font="2">Figure 1: Existing Watchpoint Systems Are Inadequate.</text>
<text top="258" left="81" width="359" height="11" font="2">WP registers are too few in number. VM’s granularity is too</text>
<text top="271" left="81" width="359" height="11" font="2">coarse. Mondriaan-like systems cannot quickly change many</text>
<text top="285" left="81" width="352" height="11" font="2">WPs, and other systems are often only useful for small regions.</text>
<text top="343" left="99" width="341" height="12" font="3">This paper makes a case for the hardware-supported abil-</text>
<text top="358" left="81" width="359" height="12" font="3">ity to set a virtually unlimited number of ﬁne-grained data</text>
<text top="373" left="81" width="359" height="12" font="3">watchpoints. We will show that this mechanism can accel-</text>
<text top="388" left="81" width="359" height="12" font="3">erate numerous software tools and is more general than the</text>
<text top="403" left="81" width="358" height="12" font="3">application-speciﬁc hardware often touted in the literature.</text>
<text top="418" left="99" width="341" height="12" font="3">This is an improvement over existing memory-watching</text>
<text top="433" left="81" width="359" height="12" font="3">mechanisms, as qualitatively illustrated in Figure <a href="pdfxml.html#2">1. </a>Hard-</text>
<text top="448" left="81" width="359" height="12" font="3">ware watchpoint registers are too limited in number for</text>
<text top="463" left="81" width="359" height="12" font="3">the advanced systems we wish to accelerate. Virtual mem-</text>
<text top="478" left="81" width="359" height="12" font="3">ory watchpoints, which are not constrained by hardware re-</text>
<text top="493" left="81" width="359" height="12" font="3">sources, are limited by the coarse granularity of pages. Fi-</text>
<text top="508" left="81" width="359" height="12" font="3">nally, a number of proposals for ﬁne-grained hardware mem-</text>
<text top="523" left="81" width="359" height="12" font="3">ory protection and tagged memory systems exist in the lit-</text>
<text top="538" left="81" width="274" height="12" font="3">erature, but they too are not general enough.</text>
<text top="553" left="99" width="341" height="12" font="3">We present a mechanism that avoids these limitations.</text>
<text top="568" left="81" width="359" height="12" font="3">Our hardware/software hybrid watchpoint system stores</text>
<text top="583" left="81" width="359" height="12" font="3">per-thread virtual address watchpoints in main memory,</text>
<text top="597" left="81" width="359" height="12" font="3">avoiding hardware limitations on the total number of watch-</text>
<text top="612" left="81" width="359" height="12" font="3">points. It makes use of two on-chip caches to hold these</text>
<text top="627" left="81" width="359" height="12" font="3">watchpoints closer to the pipeline. The ﬁrst is a modiﬁed ver-</text>
<text top="642" left="81" width="359" height="12" font="3">sion of the range cache proposed by Tiwari et al. <a href="pdfxml.html#13">[40], </a>which</text>
<text top="657" left="81" width="359" height="12" font="3">eﬃciently encodes continuous regions of watched memory.</text>
<text top="672" left="81" width="359" height="12" font="3">The second is a bitmapped lookaside cache, which increases</text>
<text top="687" left="81" width="332" height="12" font="3">the number of cached WP ranges when they are small.</text>
<text top="702" left="99" width="341" height="12" font="3">By combining these mechanisms with the abilities to take</text>
<text top="717" left="81" width="359" height="12" font="3">fast WP faults and set WPs with user-level instructions, we</text>
<text top="732" left="81" width="359" height="12" font="3">can greatly accelerate tools that work on shadow data while</text>
<text top="747" left="81" width="359" height="12" font="3">remaining general enough to be useful for other memory-</text>
<text top="762" left="81" width="359" height="12" font="3">watching tasks. Our simulated results show, for instance,</text>
<text top="777" left="81" width="359" height="12" font="3">that a data race detector built using our technique can check</text>
<text top="792" left="81" width="359" height="12" font="3">read/write sets up to 9× faster than one built entirely with</text>
<text top="807" left="81" width="359" height="12" font="3">binary instrumentation and 3× faster than one using other</text>
<text top="822" left="81" width="245" height="12" font="3">ﬁne-grained memory protection systems.</text>
<text top="837" left="99" width="325" height="12" font="3">This paper presents the following novel contributions:</text>
<text top="866" left="89" width="6" height="11" font="2">•</text>
<text top="867" left="100" width="339" height="12" font="3">We design hardware that allows software to set a virtually</text>
<text top="882" left="100" width="283" height="12" font="3">unlimited number of byte-accurate watchpoints.</text>
<text top="896" left="89" width="6" height="11" font="2">•</text>
<text top="897" left="100" width="339" height="12" font="3">We study numerous dynamic software analysis tools and</text>
<text top="911" left="100" width="339" height="12" font="3">show how they can utilize watchpoints to run more</text>
<text top="926" left="100" width="166" height="12" font="3">accurately and much faster.</text>
<text top="940" left="89" width="6" height="11" font="2">•</text>
<text top="941" left="100" width="339" height="12" font="3">We demonstrate that this design performs better on a</text>
<text top="956" left="100" width="339" height="12" font="3">wide range of tools and applications than other state-of-</text>
<text top="971" left="100" width="247" height="12" font="3">the-art memory monitoring technologies.</text>
<text top="1001" left="99" width="341" height="12" font="3">We detail the design of our watchpoint hardware in</text>
<text top="1016" left="81" width="359" height="12" font="3">Section <a href="pdfxml.html#2">2 </a>and discuss software systems that could be built</text>
<text top="1031" left="81" width="359" height="12" font="3">with it in Section <a href="pdfxml.html#5">3. </a>We compare our system to previous</text>
<text top="1046" left="81" width="359" height="12" font="3">ﬁne-grain memory protection works while running a variety</text>
<text top="1061" left="81" width="359" height="12" font="3">of software analysis tasks in Section <a href="pdfxml.html#7">4. </a>Finally, we review</text>
<text top="1076" left="81" width="357" height="12" font="3">other related works in Section <a href="pdfxml.html#11">5 </a>and conclude in Section <a href="pdfxml.html#12">6.</a></text>
<text top="109" left="476" width="359" height="11" font="2">Table 1: Hardware Watchpoint Support in Modern ISAs.</text>
<text top="123" left="476" width="359" height="11" font="2">Most ISAs support a small number of hardware-assisted watch-</text>
<text top="136" left="476" width="359" height="11" font="2">points. While they reduce debugger overheads, their small num-</text>
<text top="149" left="476" width="346" height="11" font="2">bers and reach are usually inadequate for more complex tools.</text>
<text top="175" left="499" width="23" height="9" font="5">ISA</text>
<text top="175" left="555" width="11" height="9" font="5">#</text>
<text top="175" left="598" width="62" height="9" font="5">Known As</text>
<text top="175" left="721" width="76" height="9" font="5">Possible Size</text>
<text top="194" left="488" width="45" height="9" font="5">x86 [-64]</text>
<text top="194" left="558" width="6" height="9" font="5">4</text>
<text top="194" left="585" width="80" height="9" font="5">Debug Register</text>
<text top="194" left="691" width="84" height="9" font="5">1, 2, 4, [8] bytes</text>
<text top="210" left="490" width="40" height="9" font="5">ARMv7</text>
<text top="210" left="555" width="12" height="9" font="5">16</text>
<text top="210" left="585" width="80" height="9" font="5">Debug Register</text>
<text top="210" left="691" width="135" height="9" font="5">1-8 bytes or up to 2GB</text>
<text top="222" left="691" width="127" height="9" font="5">using low-order masking</text>
<text top="237" left="485" width="51" height="9" font="5">ePOWER</text>
<text top="237" left="558" width="6" height="9" font="5">2</text>
<text top="237" left="585" width="26" height="9" font="5">Data</text>
<text top="237" left="631" width="41" height="9" font="5">Address</text>
<text top="249" left="585" width="47" height="9" font="5">Compare</text>
<text top="237" left="691" width="135" height="9" font="5">1 byte or 64-bit address</text>
<text top="249" left="691" width="135" height="9" font="5">with any bit masked or</text>
<text top="262" left="691" width="70" height="9" font="5">range up to 2</text>
<text top="260" left="761" width="10" height="7" font="8">64</text>
<text top="262" left="776" width="27" height="9" font="5">bytes</text>
<text top="278" left="490" width="41" height="9" font="5">Itanium</text>
<text top="278" left="558" width="6" height="9" font="5">4</text>
<text top="278" left="585" width="87" height="9" font="5">Data Breakpoint</text>
<text top="290" left="585" width="43" height="9" font="5">Register</text>
<text top="278" left="691" width="135" height="9" font="5">1 byte to 64PB using low-</text>
<text top="290" left="691" width="74" height="9" font="5">order masking</text>
<text top="305" left="496" width="30" height="9" font="5">MIPS</text>
<text top="305" left="558" width="6" height="9" font="5">8</text>
<text top="305" left="585" width="65" height="9" font="5">WatchLo/Hi</text>
<text top="305" left="691" width="133" height="9" font="5">8 bytes, naturally aligned</text>
<text top="321" left="488" width="46" height="9" font="5">POWER</text>
<text top="321" left="558" width="6" height="9" font="5">1</text>
<text top="321" left="585" width="35" height="9" font="5">DABR</text>
<text top="321" left="691" width="47" height="9" font="5">1-8 bytes</text>
<text top="336" left="491" width="39" height="9" font="5">SPARC</text>
<text top="336" left="558" width="6" height="9" font="5">2</text>
<text top="336" left="585" width="87" height="9" font="5">Watchpoint Reg.</text>
<text top="336" left="691" width="47" height="9" font="5">1-8 bytes</text>
<text top="352" left="492" width="36" height="9" font="5">z/Arch</text>
<text top="352" left="558" width="6" height="9" font="5">1</text>
<text top="352" left="585" width="25" height="9" font="5">PER</text>
<text top="352" left="691" width="93" height="9" font="5">RO Range up to 2</text>
<text top="349" left="784" width="10" height="7" font="8">64</text>
<text top="352" left="799" width="27" height="9" font="5">bytes</text>
<text top="377" left="476" width="15" height="15" font="1">2.</text>
<text top="377" left="509" width="232" height="15" font="1">Fast Unlimited Watchpoints</text>
<text top="400" left="476" width="359" height="12" font="3">This section describes a system that allows software to set</text>
<text top="415" left="476" width="359" height="12" font="3">a virtually unlimited number of byte-accurate watchpoints.</text>
<text top="430" left="476" width="359" height="12" font="3">We ﬁrst review existing WP hardware and list what proper-</text>
<text top="445" left="476" width="359" height="12" font="3">ties are needed to eﬀectively accelerate a variety of software.</text>
<text top="460" left="476" width="299" height="12" font="3">We then present a design that meets these needs.</text>
<text top="487" left="476" width="20" height="12" font="3">2.1</text>
<text top="487" left="512" width="239" height="12" font="3">Existing HW Watchpoint Support</text>
<text top="508" left="476" width="359" height="12" font="3">Watchpoints, also known as data breakpoints, are debugging</text>
<text top="523" left="476" width="359" height="12" font="3">mechanisms that allow a developer to demarcate memory</text>
<text top="538" left="476" width="359" height="12" font="3">regions and take interrupts whenever they are accessed</text>
<text top="553" left="476" width="359" height="12" font="3"><a href="pdfxml.html#13">[22, 27]. </a>Using software to check each memory access can</text>
<text top="568" left="476" width="359" height="12" font="3">cause slowdowns, so most processors include some form of</text>
<text top="583" left="476" width="209" height="12" font="3">hardware support for watchpoints.</text>
<text top="598" left="493" width="341" height="12" font="3">As Wahbe discussed, existing support can be broken</text>
<text top="613" left="476" width="359" height="12" font="3">down into specialized hardware watchpoint mechanisms and</text>
<text top="628" left="476" width="359" height="12" font="3">virtual memory <a href="pdfxml.html#13">[43]. </a>The ﬁrst commonly takes the form of</text>
<text top="643" left="476" width="359" height="12" font="3">watchpoint registers that hold individual addresses and raise</text>
<text top="658" left="476" width="359" height="12" font="3">exceptions when these addresses are touched. Unfortunately,</text>
<text top="673" left="476" width="359" height="12" font="3">as Table <a href="pdfxml.html#2">1 </a>shows, no modern ISA oﬀers more than a small</text>
<text top="687" left="476" width="359" height="12" font="3">handful of these registers. This makes them diﬃcult (if not</text>
<text top="702" left="476" width="252" height="12" font="3">impossible) to use for many analyses <a href="pdfxml.html#12">[14].</a></text>
<text top="717" left="493" width="341" height="12" font="3">The second method marks pages containing watched data</text>
<text top="732" left="476" width="359" height="12" font="3">as unavailable or read-only in the virtual memory system.</text>
<text top="747" left="476" width="359" height="12" font="3">The kernel then checks the oﬀending address against a list</text>
<text top="762" left="476" width="359" height="12" font="3">of watchpoints during each page fault. Though this system</text>
<text top="777" left="476" width="359" height="12" font="3">has been implemented on existing processors <a href="pdfxml.html#12">[4, </a><a href="pdfxml.html#13">36], </a>it has</text>
<text top="792" left="476" width="295" height="12" font="3">a number of restrictions that limit its usefulness.</text>
<text top="807" left="493" width="341" height="12" font="3">Individual threads within a process cannot easily have</text>
<text top="822" left="476" width="359" height="12" font="3">diﬀerent VM watchpoints. Additionally, the large size of</text>
<text top="837" left="476" width="359" height="12" font="3">pages reduces their eﬀectiveness. Faults taken when access-</text>
<text top="852" left="476" width="359" height="12" font="3">ing unwatched data on pages that also contain watched data</text>
<text top="867" left="476" width="359" height="12" font="3">can result in unacceptable performance overheads; we mea-</text>
<text top="882" left="476" width="359" height="12" font="3">sured pathological cases on x86 Solaris that showed slow-</text>
<text top="897" left="476" width="359" height="12" font="3">downs of over 10,000×. Ho et al. also observed this problem</text>
<text top="912" left="476" width="359" height="12" font="3">and claimed that they “anticipate that using [ﬁner-granu-</text>
<text top="927" left="476" width="359" height="12" font="3">larity] techniques would greatly improve performance” <a href="pdfxml.html#13">[21].</a></text>
<text top="942" left="493" width="341" height="12" font="3">ECC memory can be used to set watchpoints at a ﬁner</text>
<text top="956" left="476" width="359" height="12" font="3">granularity <a href="pdfxml.html#13">[32, 34]. </a>By setting a value in memory with ECC</text>
<text top="971" left="476" width="359" height="12" font="3">enabled, then disabling ECC, writing a scrambled version of</text>
<text top="986" left="476" width="359" height="12" font="3">the data into the same location, and ﬁnally re-enabling error</text>
<text top="1001" left="476" width="359" height="12" font="3">correction, it is possible to take a fault whenever a watched</text>
<text top="1016" left="476" width="359" height="12" font="3">memory line is accessed. However, changing watchpoints, as</text>
<text top="1031" left="476" width="359" height="12" font="3">well as taking watchpoint faults, is extremely slow in such a</text>
<text top="1046" left="476" width="238" height="12" font="3">system. We do not explore this further.</text>
<text top="1061" left="493" width="341" height="12" font="3">In all, existing hardware is inadequate to support the</text>
<text top="1076" left="476" width="344" height="12" font="3">varied needs of the wide range of dynamic analysis tools.</text>
</page>
<page number="3" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="9" size="9" family="Times" color="#000000"/>
<text top="111" left="81" width="20" height="12" font="3">2.2</text>
<text top="111" left="117" width="257" height="12" font="3">Unlimited Watchpoint Requirements</text>
<text top="132" left="81" width="359" height="12" font="3">While this tells us what current systems do not oﬀer, we</text>
<text top="146" left="81" width="359" height="12" font="3">must still answer the question of what a WP system should</text>
<text top="161" left="81" width="359" height="12" font="3">oﬀer. Section <a href="pdfxml.html#5">3 </a>will detail watchpoint-based algorithms for</text>
<text top="176" left="81" width="359" height="12" font="3">numerous dynamic analysis systems, but in the vein of Appel</text>
<text top="191" left="81" width="359" height="12" font="3">and Li’s paper on virtual memory primitives <a href="pdfxml.html#12">[2], </a>we ﬁrst list</text>
<text top="206" left="81" width="284" height="12" font="3">the properties which should be made available:</text>
<text top="240" left="89" width="6" height="11" font="2">•</text>
<text top="241" left="100" width="339" height="12" font="3">Large number: Some systems watch gigabytes of data</text>
<text top="256" left="100" width="177" height="12" font="3">to observe program behavior.</text>
<text top="270" left="89" width="6" height="11" font="2">•</text>
<text top="271" left="100" width="339" height="12" font="3">Byte/word granularity: Many tools use watchpoints</text>
<text top="286" left="100" width="285" height="12" font="3">at a very ﬁne granularity to reduce false faults.</text>
<text top="300" left="89" width="6" height="11" font="2">•</text>
<text top="301" left="100" width="339" height="12" font="3">Fast fault handler: Some applications take many</text>
<text top="316" left="100" width="336" height="12" font="3">faults, so this would greatly increase their performance.</text>
<text top="330" left="89" width="6" height="11" font="2">•</text>
<text top="331" left="100" width="339" height="12" font="3">Fast watchpoint changes: Numerous tools frequently</text>
<text top="346" left="100" width="303" height="12" font="3">change WPs in response to the program’s actions.</text>
<text top="360" left="89" width="6" height="11" font="2">•</text>
<text top="361" left="100" width="339" height="12" font="3">Per-thread: Separate watchpoints on threads within a</text>
<text top="376" left="100" width="339" height="12" font="3">single process would allow tools to use watchpoints in</text>
<text top="391" left="100" width="273" height="12" font="3">parallel programs without taking false faults.</text>
<text top="405" left="89" width="6" height="11" font="2">•</text>
<text top="406" left="100" width="339" height="12" font="3">Set ranges: Many tools require the ability to watch</text>
<text top="421" left="100" width="339" height="12" font="3">large ranges of addresses without needing to mark every</text>
<text top="436" left="100" width="175" height="12" font="3">component byte individually.</text>
<text top="450" left="89" width="6" height="11" font="2">•</text>
<text top="451" left="100" width="339" height="12" font="3">Break ranges: It is also important to be able to quickly</text>
<text top="466" left="100" width="339" height="12" font="3">remove sections in the middle of ranges without rewriting</text>
<text top="480" left="100" width="339" height="12" font="3">every byte’s WP. This is often used to carve out a</text>
<text top="495" left="100" width="189" height="12" font="3">working set of unwatched data.</text>
<text top="532" left="81" width="20" height="12" font="3">2.3</text>
<text top="532" left="117" width="217" height="12" font="3">Eﬃcient Watchpoint Hardware</text>
<text top="553" left="81" width="359" height="12" font="3">This section describes a hardware mechanism that operates</text>
<text top="568" left="81" width="359" height="12" font="3">in parallel with the virtual memory system in order to</text>
<text top="583" left="81" width="359" height="12" font="3">deliver on these requirements. Each watchpoint is deﬁned</text>
<text top="598" left="81" width="359" height="12" font="3">by two bits that indicate whether it is read- and/or write-</text>
<text top="613" left="81" width="359" height="12" font="3">watched. To allow a large number of these watchpoints,</text>
<text top="628" left="81" width="359" height="12" font="3">the full list of watched addresses is stored in main memory.</text>
<text top="643" left="81" width="359" height="12" font="3">Accessing memory for each check would be prohibitively</text>
<text top="658" left="81" width="359" height="12" font="3">slow, so virtual addresses are ﬁrst sent from the address</text>
<text top="673" left="81" width="359" height="12" font="3">generation unit (AGU) to an on-chip WP cache that is</text>
<text top="687" left="81" width="359" height="12" font="3">accessed in parallel to the data translation lookaside buﬀer</text>
<text top="702" left="81" width="188" height="12" font="3">(DTLB), as shown in Figure <a href="pdfxml.html#3">2.</a></text>
<text top="717" left="99" width="341" height="12" font="3">To deliver these watchpoints at byte granularity , the</text>
<text top="732" left="81" width="359" height="12" font="3">cache compares each virtual address that the instruction</text>
<text top="747" left="81" width="359" height="12" font="3">touches and outputs a logical OR of their watched statuses.</text>
<text top="762" left="81" width="359" height="12" font="3">This check need not complete until the instruction attempts</text>
<text top="777" left="81" width="236" height="12" font="3">to commit, and so it may be pipelined.</text>
<text top="792" left="99" width="341" height="12" font="3">If the WP unit indicates a fault, a precise exception is</text>
<text top="807" left="81" width="359" height="12" font="3">raised upon attempting to commit the oﬀending instruction.</text>
<text top="822" left="81" width="359" height="12" font="3">This could either be a user-level fault, which is treated as</text>
<text top="837" left="81" width="359" height="12" font="3">a mispredicted branch, or a kernel fault. We assume the</text>
<text top="852" left="81" width="359" height="12" font="3">former in order provide a fast fault handler . Using such</text>
<text top="867" left="81" width="359" height="12" font="3">handlers for kernel-controlled watchpoints, or cross-process</text>
<text top="882" left="81" width="285" height="12" font="3">watchpoints, is beyond the scope of this paper.</text>
<text top="897" left="99" width="341" height="12" font="3">In order to yield fast watchpoint changes, it is impor-</text>
<text top="912" left="81" width="359" height="12" font="3">tant that the on-chip caches be able to hold dirty data and</text>
<text top="927" left="81" width="359" height="12" font="3">only write back to main memory on dirty evictions. This,</text>
<text top="942" left="81" width="359" height="12" font="3">and the fact that the watchpoints are stored as virtual ad-</text>
<text top="956" left="81" width="359" height="12" font="3">dresses, means that watchpoints can be changed with simple</text>
<text top="971" left="81" width="276" height="12" font="3">user-level instructions instead of system calls.</text>
<text top="986" left="99" width="341" height="12" font="3">In order to support per-thread (rather than per-core)</text>
<text top="1001" left="81" width="359" height="12" font="3">watchpoints, any dirty state in the WP cache will neces-</text>
<text top="1016" left="81" width="359" height="12" font="3">sarily be part of process state. This can be switched lazily,</text>
<text top="1031" left="81" width="359" height="12" font="3">only being saved if another process utilizing watchpoints is</text>
<text top="1046" left="81" width="359" height="12" font="3">loaded, to increase performance. Additionally, each core will</text>
<text top="1061" left="81" width="359" height="12" font="3">require a thread ID register so that individual threads can</text>
<text top="1076" left="81" width="227" height="12" font="3">be targeted with watchpoint changes.</text>
<text top="115" left="529" width="25" height="11" font="2">AGU</text>
<text top="162" left="504" width="22" height="11" font="2">L1D</text>
<text top="162" left="553" width="30" height="11" font="2">DTLB</text>
<text top="126" left="772" width="29" height="11" font="2">Main </text>
<text top="140" left="763" width="45" height="11" font="2">Memory </text>
<text top="154" left="775" width="22" height="11" font="2">WP </text>
<text top="168" left="764" width="41" height="11" font="2">Storage</text>
<text top="162" left="624" width="25" height="11" font="2">WLB</text>
<text top="150" left="677" width="38" height="11" font="2">Range </text>
<text top="164" left="678" width="34" height="11" font="2">Cache</text>
<text top="198" left="501" width="28" height="11" font="2">Data/</text>
<text top="212" left="505" width="20" height="11" font="2">Tag</text>
<text top="198" left="546" width="47" height="11" font="2">Physical </text>
<text top="212" left="546" width="43" height="11" font="2">Address</text>
<text top="205" left="635" width="56" height="9" font="9"><b>Watched?</b></text>
<text top="117" left="620" width="96" height="11" font="2">Watchpoint Cache</text>
<text top="240" left="476" width="359" height="11" font="2">Figure 2: Watchpoint Unit in the Pipeline. Because watch-</text>
<text top="253" left="476" width="359" height="11" font="2">points are set on virtual addresses, the WP system is accessed</text>
<text top="267" left="476" width="359" height="11" font="2">in parallel with the DTLB. This also allows WPs to be set with</text>
<text top="280" left="476" width="359" height="11" font="2">user-level instructions while not aﬀecting the CPU’s critical path.</text>
<text top="320" left="493" width="341" height="12" font="3">Watchpoints are stored on-chip in three diﬀerent forms.</text>
<text top="335" left="476" width="359" height="12" font="3">They are ﬁrst stored in a range cache (RC), which holds</text>
<text top="350" left="476" width="359" height="12" font="3">the start and end addresses of each cached watchpoint and</text>
<text top="365" left="476" width="359" height="12" font="3">status values that hold each range’s 2-bit watchpoint. This</text>
<text top="380" left="476" width="359" height="12" font="3">system, which is further explained in Section <a href="pdfxml.html#3">2.3.1, </a>helps</text>
<text top="395" left="476" width="241" height="12" font="3">support setting and breaking ranges.</text>
<text top="410" left="493" width="341" height="12" font="3">Small ranges can negatively impact the reach, or the</text>
<text top="425" left="476" width="359" height="12" font="3">number of addresses covered by all entries, of the RC. In this</text>
<text top="440" left="476" width="359" height="12" font="3">case, the WPs within a contiguous region of memory can be</text>
<text top="454" left="476" width="359" height="12" font="3">held in a single bitmap stored in main memory, rather than</text>
<text top="469" left="476" width="359" height="12" font="3">as multiple small ranges. The RC then stores the boundary</text>
<text top="484" left="476" width="359" height="12" font="3">addresses for the entire bitmapped region, and the status</text>
<text top="499" left="476" width="359" height="12" font="3">bits associated with that entry will point to the base of</text>
<text top="514" left="476" width="359" height="12" font="3">the bitmap. Accessing this bitmap would normally require</text>
<text top="529" left="476" width="359" height="12" font="3">a load from main memory, so we also include a Watchpoint</text>
<text top="544" left="476" width="359" height="12" font="3">Lookaside Buﬀer (WLB) that is searched in parallel with</text>
<text top="559" left="476" width="293" height="12" font="3">the RC. This is detailed further in Section <a href="pdfxml.html#4">2.3.2.</a></text>
<text top="574" left="493" width="341" height="12" font="3">Finally, because creating bitmaps can be slow (requiring</text>
<text top="589" left="476" width="359" height="12" font="3">kilobytes of data to be written to main memory), it can</text>
<text top="604" left="476" width="359" height="12" font="3">be useful to store small bitmaps directly on chip. By using</text>
<text top="619" left="476" width="359" height="12" font="3">the storage that normally holds a pointer to a bitmap, it</text>
<text top="634" left="476" width="359" height="12" font="3">is possible to also make an On-Chip Bitmap (OCBM) that</text>
<text top="649" left="476" width="359" height="12" font="3">stores the watchpoints for a region of memory that is larger</text>
<text top="664" left="476" width="359" height="12" font="3">than a single byte but smaller than a main memory bitmap.</text>
<text top="679" left="476" width="203" height="12" font="3">This is described in Section <a href="pdfxml.html#5">2.3.3.</a></text>
<text top="711" left="476" width="33" height="12" font="3">2.3.1</text>
<text top="711" left="524" width="91" height="12" font="3">Range Cache</text>
<text top="732" left="476" width="359" height="12" font="3">The ﬁrst mechanism for storing watchpoints within the core</text>
<text top="747" left="476" width="359" height="12" font="3">is a modiﬁed version of the range cache proposed by Tiwari</text>
<text top="762" left="476" width="359" height="12" font="3">et al. <a href="pdfxml.html#13">[40]. </a>They made the observation that “many dataﬂow</text>
<text top="777" left="476" width="359" height="12" font="3">tracking applications exhibit very signiﬁcant range locality,</text>
<text top="792" left="476" width="359" height="12" font="3">where long blocks of memory addresses all store the same tag</text>
<text top="807" left="476" width="359" height="12" font="3">value,” and we have found this statement even more accurate</text>
<text top="822" left="476" width="359" height="12" font="3">when dealing with 2-bit watchpoints rather than many-bit</text>
<text top="837" left="476" width="359" height="12" font="3">tags. This cache, shown as part of Figure <a href="pdfxml.html#4">3, </a>stores the</text>
<text top="852" left="476" width="359" height="12" font="3">boundary addresses for numerous ranges within the virtual</text>
<text top="867" left="476" width="359" height="12" font="3">memory space of a thread as well as the 2-bit watchpoint</text>
<text top="882" left="476" width="267" height="12" font="3">status associated with each of these regions.</text>
<text top="897" left="493" width="341" height="12" font="3">Virtual addresses are sent to the RC in parallel with</text>
<text top="912" left="476" width="359" height="12" font="3">DTLB lookups, and the boundary addresses of each access</text>
<text top="927" left="476" width="359" height="12" font="3">are compared with those of the cached ranges. When any</text>
<text top="942" left="476" width="359" height="12" font="3">address that a memory instruction is attempting to access</text>
<text top="956" left="476" width="359" height="12" font="3">overlaps with a range stored in the RC, the hardware checks</text>
<text top="971" left="476" width="359" height="12" font="3">that range’s watchpoint bits. If an overlapping range is</text>
<text top="986" left="476" width="359" height="12" font="3">marked as watched for this type of access, the instruction is</text>
<text top="1001" left="476" width="359" height="12" font="3">set to cause a watchpoint fault when it commits. This will</text>
<text top="1016" left="476" width="316" height="12" font="3">cause execution to jump to a software fault handler.</text>
<text top="1031" left="493" width="341" height="12" font="3">If there are no watchpoints set on a region of memory, the</text>
<text top="1046" left="476" width="359" height="12" font="3">RC will hold a region with R- and W-watched bits both ‘0’.</text>
<text top="1061" left="476" width="359" height="12" font="3">This means that if the range cache misses on any lookup, it</text>
<text top="1076" left="476" width="350" height="12" font="3">should attempt to retrieve that range from main memory.</text>
</page>
<page number="4" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="10" size="10" family="Times" color="#000000"/>
	<fontspec id="11" size="9" family="Times" color="#000000"/>
	<fontspec id="12" size="13" family="Times" color="#000000"/>
	<fontspec id="13" size="7" family="Times" color="#000000"/>
	<fontspec id="14" size="9" family="Times" color="#000000"/>
	<fontspec id="15" size="8" family="Times" color="#000000"/>
<text top="126" left="106" width="118" height="12" font="10">WP Lookaside Buffer</text>
<text top="126" left="551" width="77" height="12" font="10">Range Cache</text>
<text top="150" left="489" width="76" height="10" font="11">Start Address 1</text>
<text top="161" left="490" width="75" height="10" font="11">Comparator (≥)</text>
<text top="150" left="627" width="72" height="10" font="11">End Address 1</text>
<text top="161" left="626" width="75" height="10" font="11">Comparator (≤)</text>
<text top="163" left="525" width="0" height="24" font="12">. .</text>
<text top="176" left="525" width="0" height="19" font="12"> .</text>
<text top="163" left="661" width="0" height="24" font="12">. .</text>
<text top="176" left="661" width="0" height="19" font="12"> .</text>
<text top="201" left="489" width="76" height="10" font="11">Start Address n</text>
<text top="212" left="490" width="75" height="10" font="11">Comparator (≥)</text>
<text top="201" left="627" width="72" height="10" font="11">End Address n</text>
<text top="212" left="626" width="75" height="10" font="11">Comparator (≤)</text>
<text top="255" left="575" width="40" height="10" font="11">encoder</text>
<text top="249" left="630" width="20" height="10" font="11">Hit?</text>
<text top="128" left="661" width="47" height="9" font="13"><b>Instr. Start</b></text>
<text top="139" left="656" width="52" height="9" font="13"><b>&amp; End Addr</b></text>
<text top="128" left="482" width="47" height="9" font="13"><b>Instr. Start</b></text>
<text top="139" left="482" width="52" height="9" font="13"><b>&amp; End Addr</b></text>
<text top="272" left="507" width="56" height="10" font="11">Start Match</text>
<text top="283" left="509" width="53" height="10" font="11">End Match</text>
<text top="138" left="393" width="59" height="10" font="11">Cached WP</text>
<text top="184" left="393" width="59" height="10" font="11">Cached WP</text>
<text top="235" left="205" width="163" height="10" font="11">R-Watched W-Watched unused</text>
<text top="235" left="391" width="6" height="10" font="11">0</text>
<text top="235" left="436" width="6" height="10" font="11">0</text>
<text top="211" left="373" width="44" height="10" font="11">On-Chip </text>
<text top="224" left="376" width="34" height="10" font="11">Bitmap</text>
<text top="211" left="417" width="44" height="10" font="11">Off-Chip </text>
<text top="224" left="421" width="34" height="10" font="11">Bitmap</text>
<text top="219" left="281" width="72" height="10" font="11">Cached Status</text>
<text top="260" left="205" width="162" height="10" font="11">Pointer to Bitmap in Main Memory</text>
<text top="260" left="391" width="6" height="10" font="11">0</text>
<text top="260" left="436" width="6" height="10" font="11">1</text>
<text top="286" left="391" width="6" height="10" font="11">1</text>
<text top="286" left="436" width="6" height="10" font="11">0</text>
<text top="286" left="206" width="94" height="10" font="11">R W R W R W</text>
<text top="286" left="342" width="26" height="10" font="11">R W</text>
<text top="286" left="315" width="9" height="10" font="11">...</text>
<text top="141" left="95" width="131" height="10" font="11">Addr. Tag 64B WP Status</text>
<text top="198" left="95" width="131" height="10" font="11">Addr. Tag 64B WP Status</text>
<text top="126" left="744" width="76" height="12" font="10">Main Memory</text>
<text top="153" left="742" width="38" height="10" font="11">Ranges</text>
<text top="153" left="792" width="40" height="10" font="11">Bitmaps</text>
<text top="124" left="238" width="0" height="13" font="9"><b>In</b></text>
<text top="134" left="238" width="0" height="10" font="9"><b>s</b></text>
<text top="140" left="238" width="0" height="14" font="9"><b>tr</b></text>
<text top="148" left="238" width="0" height="16" font="9"><b>. A</b></text>
<text top="162" left="238" width="0" height="10" font="9"><b>d</b></text>
<text top="169" left="238" width="0" height="10" font="9"><b>d</b></text>
<text top="175" left="238" width="0" height="15" font="9"><b>re</b></text>
<text top="186" left="238" width="0" height="10" font="9"><b>s</b></text>
<text top="192" left="238" width="0" height="10" font="9"><b>s</b></text>
<text top="141" left="255" width="91" height="10" font="11">If Off-Chip Bitmap:</text>
<text top="154" left="264" width="64" height="10" font="11">Consult WLB</text>
<text top="168" left="255" width="25" height="10" font="11">Else:</text>
<text top="181" left="264" width="95" height="10" font="11">Output Cached WP</text>
<text top="162" left="351" width="6" height="10" font="14"><b>2</b></text>
<text top="238" left="669" width="44" height="10" font="11">On Miss:</text>
<text top="251" left="678" width="150" height="10" font="11">Fault to Backing Store Handler</text>
<text top="264" left="669" width="34" height="10" font="11">On Hit:</text>
<text top="277" left="678" width="152" height="10" font="11">Watch Fault Decided by Cache</text>
<text top="238" left="820" width="6" height="10" font="14"><b>1</b></text>
<text top="231" left="85" width="71" height="10" font="11">Parallel to RC:</text>
<text top="244" left="94" width="87" height="10" font="11">Check Watch Bits</text>
<text top="257" left="85" width="85" height="10" font="11">On Needed Miss:</text>
<text top="271" left="94" width="75" height="10" font="11">HW Loads Line</text>
<text top="284" left="94" width="59" height="10" font="11">from Bitmap</text>
<text top="282" left="181" width="6" height="10" font="14"><b>3</b></text>
<text top="143" left="420" width="0" height="24" font="12">. .</text>
<text top="156" left="420" width="0" height="19" font="12"> .</text>
<text top="147" left="155" width="0" height="24" font="12">. .</text>
<text top="161" left="155" width="0" height="24" font="12"> . </text>
<text top="174" left="155" width="0" height="15" font="12">.</text>
<text top="248" left="326" width="10" height="10" font="11">or</text>
<text top="273" left="326" width="10" height="10" font="11">or</text>
<text top="109" left="114" width="115" height="9" font="15"><b>Input Virtual Addresses</b></text>
<text top="109" left="358" width="115" height="9" font="15"><b>Input Virtual Addresses</b></text>
<text top="109" left="716" width="115" height="9" font="15"><b>Input Virtual Addresses</b></text>
<text top="316" left="81" width="753" height="11" font="2">Figure 3: Unlimited Watchpoint Architecture. This system uses a combination of a range cache, center, with bitmaps and a</text>
<text top="330" left="81" width="753" height="11" font="2">lookaside buﬀer, left, to accelerate accesses to watchpoints that are stored into main memory, right. (1) On a RC access miss, a software</text>
<text top="343" left="81" width="753" height="11" font="2">handler loads new ranges from main memory. A hit causes the watchpoint system to check the associated status entry. (2) This range</text>
<text top="357" left="81" width="753" height="11" font="2">could be a uniform watchpoint, an oﬀ-chip bitmap, or an on-chip bitmap. In the case of an oﬀ-chip bitmap, the output of the lookaside</text>
<text top="370" left="81" width="753" height="11" font="2">buﬀer, which is accessed in parallel to the RC, is consulted. (3) If the WLB misses, the pointer from the RC status entry is used by the</text>
<text top="383" left="81" width="324" height="11" font="2">hardware to load a line in from the main memory bitmap.</text>
<text top="418" left="99" width="341" height="12" font="3">The original RC design brought in 64 byte chunks from</text>
<text top="433" left="81" width="359" height="12" font="3">a two-level trie whenever it missed. We found this method</text>
<text top="448" left="81" width="359" height="12" font="3">ineﬃcient for our tools, as it required a large number of</text>
<text top="463" left="81" width="359" height="12" font="3">writes to save non-aligned ranges. Instead, our RC causes a</text>
<text top="478" left="81" width="359" height="12" font="3">fault to a software handler on a miss. This handler loads an</text>
<text top="493" left="81" width="359" height="12" font="3">entire range from the storage system in main memory. We</text>
<text top="508" left="81" width="359" height="12" font="3">implemented a backing store handler that keeps a balanced</text>
<text top="523" left="81" width="359" height="12" font="3">tree of non-overlapping ranges, which was modeled after the</text>
<text top="537" left="81" width="319" height="12" font="3">watchpoint data structure in the OpenSolaris kernel.</text>
<text top="552" left="99" width="341" height="12" font="3">Programs set watchpoints on their own memory space us-</text>
<text top="567" left="81" width="359" height="12" font="3">ing range-based instructions, which are described in Section</text>
<text top="582" left="81" width="359" height="12" font="3"><a href="pdfxml.html#5">2.3.4. </a>These instructions can set or remove ranges by directly</text>
<text top="597" left="81" width="359" height="12" font="3">inserting the new watchpoint tag into the range cache, which</text>
<text top="612" left="81" width="359" height="12" font="3">uses a dirty-bit write-back policy to avoid taking a fault on</text>
<text top="627" left="81" width="359" height="12" font="3">every WP change. The RC employs a pseudo-LRU replace-</text>
<text top="642" left="81" width="359" height="12" font="3">ment policy, which keeps track of the most-likely candidate</text>
<text top="657" left="81" width="359" height="12" font="3">for eviction. If the range cache overﬂows and the LRU entry</text>
<text top="672" left="81" width="359" height="12" font="3">is dirty, the cache will cause a user-level fault that reroutes</text>
<text top="687" left="81" width="291" height="12" font="3">execution to the software backing store handler.</text>
<text top="702" left="99" width="341" height="12" font="3">Updating a watchpoint range is more complicated than</text>
<text top="717" left="81" width="359" height="12" font="3">setting or removing, as it may require loading in ranges from</text>
<text top="732" left="81" width="348" height="12" font="3">the backing store to ﬁnd the value that is to be modiﬁed.</text>
<text top="771" left="81" width="33" height="12" font="3">2.3.2</text>
<text top="771" left="130" width="290" height="12" font="3">Bitmap and Watchpoint Lookaside Buﬀer</text>
<text top="792" left="81" width="359" height="12" font="3">The RC is designed to quickly handle large ranges of watch-</text>
<text top="807" left="81" width="359" height="12" font="3">points, and its write-back policy reduces the number of</text>
<text top="822" left="81" width="359" height="12" font="3">writes to main memory. However, its reach can be limited if</text>
<text top="837" left="81" width="359" height="12" font="3">it contains many short ranges. In the worst case, a 128-entry</text>
<text top="852" left="81" width="359" height="12" font="3">RC, which takes up an area roughly equal to 4KB of L1D,</text>
<text top="867" left="81" width="359" height="12" font="3">may only have a reach of 128 bytes. We utilize a second</text>
<text top="882" left="81" width="250" height="12" font="3">hardware structure to handle these cases.</text>
<text top="897" left="99" width="341" height="12" font="3">Bitmaps are a compact way of storing small watchpoint</text>
<text top="912" left="81" width="359" height="12" font="3">regions, because they only take 2 bits per byte within the</text>
<text top="927" left="81" width="359" height="12" font="3">region, as demonstrated in Figure <a href="pdfxml.html#5">4. </a>Instead of storing the</text>
<text top="942" left="81" width="359" height="12" font="3">start and end address for each small range, we therefore</text>
<text top="956" left="81" width="359" height="12" font="3">choose to sometimes store into the range cache the ﬁrst</text>
<text top="971" left="81" width="359" height="12" font="3">and last address of a large region whose small watchpoints</text>
<text top="986" left="81" width="359" height="12" font="3">are contained in a bitmap in memory. This increases the</text>
<text top="1001" left="81" width="359" height="12" font="3">required amount of status storage in the range cache, which</text>
<text top="1016" left="81" width="359" height="12" font="3">originally only held the read-watched and write-watched</text>
<text top="1031" left="81" width="359" height="12" font="3">bits. It instead requires 32 or 64 bits of storage to hold</text>
<text top="1046" left="81" width="359" height="12" font="3">the pointer to the bitmap and one bit to denote whether</text>
<text top="1061" left="81" width="359" height="12" font="3">an entry is a bitmap pointer or a range. The two watched</text>
<text top="1076" left="81" width="336" height="12" font="3">bits can be mapped onto the pointer bits to save space.</text>
<text top="418" left="493" width="341" height="12" font="3">We found it diﬃcult to design a hardware-based algo-</text>
<text top="433" left="476" width="359" height="12" font="3">rithm to decide when to change a collection of ranges into</text>
<text top="448" left="476" width="359" height="12" font="3">a bitmap. Doing so in an intelligent manner requires know-</text>
<text top="463" left="476" width="359" height="12" font="3">ing how many watchpoints are contained within a particular</text>
<text top="478" left="476" width="359" height="12" font="3">area of memory. This knowledge may best be gathered by</text>
<text top="493" left="476" width="359" height="12" font="3">the backing store software, as it can see the entire state of</text>
<text top="508" left="476" width="359" height="12" font="3">a process’s watchpoints. We therefore leave it to the range</text>
<text top="523" left="476" width="359" height="12" font="3">cache miss handler to decide when to toggle a region of mem-</text>
<text top="537" left="476" width="359" height="12" font="3">ory between a bitmap and ranges. The algorithm modeled</text>
<text top="552" left="476" width="359" height="12" font="3">in this paper moves a naturally aligned 4KB region from a</text>
<text top="567" left="476" width="359" height="12" font="3">range to a bitmap if the number of internal ranges exceeds</text>
<text top="582" left="476" width="359" height="12" font="3">an upper threshold of 16. The dirty eviction handler changes</text>
<text top="597" left="476" width="359" height="12" font="3">a bitmap back to ranges if this number falls below 4. This</text>
<text top="612" left="476" width="151" height="12" font="3">is illustrated in Figure <a href="pdfxml.html#5">5.</a></text>
<text top="627" left="493" width="341" height="12" font="3">While this mechanism increases the reach of the range</text>
<text top="642" left="476" width="359" height="12" font="3">cache, it could adversely aﬀect performance if every access</text>
<text top="657" left="476" width="359" height="12" font="3">to a bitmapped range required checking main memory. This</text>
<text top="672" left="476" width="359" height="12" font="3">is especially true because WPs are set on virtual addresses,</text>
<text top="687" left="476" width="359" height="12" font="3">meaning that each access to the bitmap would wait on</text>
<text top="702" left="476" width="359" height="12" font="3">the TLB. In order to accelerate this process, our system</text>
<text top="717" left="476" width="359" height="12" font="3">includes a Watchpoint Lookaside Buﬀer (WLB). This cache</text>
<text top="732" left="476" width="359" height="12" font="3">is accessed in parallel to the RC, and any watchpoint status</text>
<text top="747" left="476" width="359" height="12" font="3">it returns is consulted if the RC indicates that this location</text>
<text top="762" left="476" width="359" height="12" font="3">is stored in a bitmap. On a miss in the WLB, a 64-byte line</text>
<text top="777" left="476" width="359" height="12" font="3">of WP bits is loaded by a hardware engine from the bitmap</text>
<text top="792" left="476" width="359" height="12" font="3">pointed to by the RC entry. Changes to the watchpoints in</text>
<text top="806" left="476" width="259" height="12" font="3">a bitmapped region cause a WLB eviction.</text>
<text top="821" left="493" width="341" height="12" font="3">This WLB could be replaced with extended cache line</text>
<text top="836" left="476" width="359" height="12" font="3">bits, such as iWatcher uses to store its bitmapped watch-</text>
<text top="851" left="476" width="359" height="12" font="3">points <a href="pdfxml.html#13">[50]. </a>Sentry’s power-saving method of only storing</text>
<text top="866" left="476" width="359" height="12" font="3">unwatched lines in the L1 (and thus only checking the WLB</text>
<text top="881" left="476" width="359" height="12" font="3">on cache misses) may also be useful <a href="pdfxml.html#13">[38]. </a>We leave a more</text>
<text top="896" left="476" width="359" height="12" font="3">in-depth analysis of these tradeoﬀs for future work, and fo-</text>
<text top="911" left="476" width="359" height="12" font="3">cus on a system with a separate watchpoint cache, much like</text>
<text top="926" left="476" width="135" height="12" font="3">MemTracker uses <a href="pdfxml.html#13">[42].</a></text>
<text top="941" left="493" width="341" height="12" font="3">If a bitmapped range is evicted from the RC to main</text>
<text top="956" left="476" width="359" height="12" font="3">memory, the modeled software handler stores the entire</text>
<text top="971" left="476" width="359" height="12" font="3">range as a single entry in the balanced tree, along with the</text>
<text top="986" left="476" width="359" height="12" font="3">pointer. It then brings the entire bitmap range back into the</text>
<text top="1001" left="476" width="359" height="12" font="3">range cache on the next miss, though it may also need to</text>
<text top="1016" left="476" width="359" height="12" font="3">update the bitmap to handle changes that occurred in the</text>
<text top="1031" left="476" width="259" height="12" font="3">range cache but have not yet been evicted.</text>
</page>
<page number="5" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="16" size="7" family="Times" color="#000000"/>
<text top="112" left="228" width="185" height="9" font="5">Watchpoint Layout (128 bytes)</text>
<text top="112" left="528" width="42" height="9" font="5">Ranges</text>
<text top="112" left="665" width="44" height="9" font="5">Bitmap</text>
<text top="130" left="183" width="6" height="8" font="11">0</text>
<text top="130" left="206" width="6" height="8" font="11">1</text>
<text top="130" left="228" width="6" height="8" font="11">2</text>
<text top="130" left="250" width="6" height="8" font="11">3</text>
<text top="130" left="273" width="6" height="8" font="11">4</text>
<text top="130" left="295" width="6" height="8" font="11">5</text>
<text top="130" left="318" width="6" height="8" font="11">6</text>
<text top="130" left="340" width="6" height="8" font="11">7</text>
<text top="127" left="365" width="22" height="9" font="10">. . . .</text>
<text top="130" left="424" width="39" height="8" font="11">126 127</text>
<text top="130" left="401" width="17" height="8" font="11">125</text>
<text top="137" left="485" width="130" height="9" font="5">1 on-chip entry = 8 bytes</text>
<text top="137" left="633" width="102" height="9" font="5">256 bits = 32 bytes</text>
<text top="160" left="485" width="129" height="9" font="5">128 entries = 1024 bytes</text>
<text top="160" left="633" width="102" height="9" font="5">256 bits = 32 bytes</text>
<text top="177" left="485" width="105" height="9" font="5">4 entries = 32 bytes</text>
<text top="177" left="633" width="102" height="9" font="5">256 bits = 32 bytes</text>
<text top="216" left="81" width="753" height="11" font="2">Figure 4: Diﬀerent Watchpoint Storage Methods. This shows three examples of watched ranges. In the ﬁrst, a range cache can</text>
<text top="230" left="81" width="753" height="11" font="2">hold the entire region in a single on-chip entry. The second, however, would take 1KB of on-chip storage if it were held in a range cache,</text>
<text top="243" left="81" width="657" height="11" font="2">while a bitmap method would only take 32 bytes. The ﬁnal entry shows a break-even point between the two methods.</text>
<text top="324" left="159" width="21" height="8" font="16">Load </text>
<text top="335" left="155" width="29" height="8" font="16">Bitmap </text>
<text top="346" left="154" width="28" height="8" font="16">into RC</text>
<text top="283" left="225" width="29" height="8" font="16">Bitmap </text>
<text top="294" left="223" width="30" height="8" font="16">Region?</text>
<text top="283" left="152" width="37" height="8" font="16">RC Load  </text>
<text top="294" left="159" width="18" height="8" font="16">Miss</text>
<text top="324" left="352" width="43" height="8" font="16">&gt;16 Ranges</text>
<text top="335" left="334" width="80" height="8" font="16">in Nat. Aligned, 4KB </text>
<text top="346" left="358" width="30" height="8" font="16">Region?</text>
<text top="329" left="252" width="40" height="8" font="16">Transition </text>
<text top="340" left="253" width="36" height="8" font="16">to Bitmap</text>
<text top="330" left="305" width="14" height="8" font="16">Yes</text>
<text top="314" left="222" width="14" height="8" font="16">Yes</text>
<text top="281" left="279" width="11" height="8" font="16">No</text>
<text top="324" left="462" width="21" height="8" font="16">Load </text>
<text top="335" left="451" width="42" height="8" font="16">Range into </text>
<text top="346" left="465" width="12" height="8" font="16">RC</text>
<text top="330" left="426" width="11" height="8" font="16">No</text>
<text top="372" left="310" width="19" height="11" font="2">(a)</text>
<text top="324" left="528" width="21" height="8" font="16">Store </text>
<text top="335" left="521" width="35" height="8" font="16">Range in </text>
<text top="346" left="529" width="17" height="8" font="16">Tree</text>
<text top="283" left="594" width="29" height="8" font="16">Bitmap </text>
<text top="294" left="593" width="27" height="8" font="16">Range?</text>
<text top="283" left="520" width="36" height="8" font="16">RC Dirty </text>
<text top="294" left="522" width="31" height="8" font="16">Eviction</text>
<text top="316" left="737" width="21" height="8" font="16">Store </text>
<text top="327" left="727" width="42" height="8" font="16">Bitmapped </text>
<text top="338" left="727" width="42" height="8" font="16">Range into </text>
<text top="349" left="739" width="17" height="8" font="16">Tree</text>
<text top="283" left="676" width="39" height="8" font="16">&gt;4 Ranges</text>
<text top="294" left="676" width="40" height="8" font="16">in Bitmap?</text>
<text top="281" left="637" width="14" height="8" font="16">Yes</text>
<text top="312" left="683" width="11" height="8" font="16">No</text>
<text top="310" left="609" width="11" height="8" font="16">No</text>
<text top="284" left="732" width="14" height="8" font="16">Yes</text>
<text top="370" left="632" width="20" height="11" font="2">(b)</text>
<text top="400" left="81" width="753" height="11" font="2">Figure 5: Software Algorithm for Bitmapped Ranges. Because hardware has a myopic view of the global status of watchpoints,</text>
<text top="414" left="81" width="666" height="11" font="2">we rely on the software fault handlers to choose when a region of watchpoints should toggle between bitmap and range.</text>
<text top="438" left="81" width="33" height="12" font="3">2.3.3</text>
<text top="438" left="130" width="117" height="12" font="3">On-Chip Bitmap</text>
<text top="459" left="81" width="359" height="12" font="3">There are also situations where a collection of small ranges</text>
<text top="474" left="81" width="359" height="12" font="3">within a large region prematurely displace useful data from</text>
<text top="489" left="81" width="359" height="12" font="3">the range cache. Though the backing store handler may later</text>
<text top="504" left="81" width="359" height="12" font="3">ﬁx this by changing the region to a bitmapped one, we also</text>
<text top="519" left="81" width="359" height="12" font="3">devised a mechanism to better utilize the pointer bits in a</text>
<text top="534" left="81" width="359" height="12" font="3">range cache entry when it is not bitmapped. It is possible</text>
<text top="549" left="81" width="359" height="12" font="3">to store a small bitmap for a region ≤16 bytes (on a 32-</text>
<text top="563" left="81" width="359" height="12" font="3">bit machine) within these bits, allowing the RC to slightly</text>
<text top="578" left="81" width="359" height="12" font="3">increase its reach. This on-chip bitmap (OCBM) range is</text>
<text top="593" left="81" width="359" height="12" font="3">stored much like a normal range, with an arbitrary start</text>
<text top="608" left="81" width="359" height="12" font="3">and end address. However, unlike a uniformly tagged range,</text>
<text top="623" left="81" width="359" height="12" font="3">the watchpoint statuses of OCBM entries are stored as a</text>
<text top="638" left="81" width="359" height="12" font="3">bitmap in the range cache’s status tag bits, which normally</text>
<text top="653" left="81" width="359" height="12" font="3">hold either a pointer to a main memory bitmap or the 2-bit</text>
<text top="668" left="81" width="359" height="12" font="3">tag of a range. The low-order bits of the address are used to</text>
<text top="683" left="81" width="359" height="12" font="3">index into this bitmap, allowing a single range cache entry</text>
<text top="698" left="81" width="254" height="12" font="3">to hold up to 16 consecutive small ranges.</text>
<text top="713" left="99" width="341" height="12" font="3">Unlike the bitmaps stored in main memory, the transition</text>
<text top="728" left="81" width="359" height="12" font="3">to OCBM requires little knowledge. Simply put, if a range</text>
<text top="743" left="81" width="359" height="12" font="3">becomes small enough to be held in a single OCBM entry, it</text>
<text top="758" left="81" width="359" height="12" font="3">is converted to one by the hardware. Returning to a uniform</text>
<text top="773" left="81" width="359" height="12" font="3">range will occur when the hardware detects that all of the</text>
<text top="788" left="81" width="359" height="12" font="3">watchpoints within the OCBM are equal. If an OCBM is</text>
<text top="803" left="81" width="359" height="12" font="3">chosen to be written back to memory, our backing store</text>
<text top="818" left="81" width="359" height="12" font="3">handler will store it as individual ranges. If two OCBMs</text>
<text top="832" left="81" width="359" height="12" font="3">cover adjacent ranges, the hardware will merge them only if</text>
<text top="847" left="81" width="280" height="12" font="3">their total size would still result in an OCBM.</text>
<text top="876" left="81" width="33" height="12" font="3">2.3.4</text>
<text top="876" left="130" width="91" height="12" font="3">ISA Changes</text>
<text top="897" left="81" width="359" height="12" font="3">Interfacing with this watchpoint system requires modiﬁca-</text>
<text top="912" left="81" width="359" height="12" font="3">tions to the ISA. For instance, we must add instructions that</text>
<text top="927" left="81" width="359" height="12" font="3">can set or remove ranges from the RC, as well as instruc-</text>
<text top="942" left="81" width="359" height="12" font="3">tions that allow the backing store handler to directly talk to</text>
<text top="956" left="81" width="359" height="12" font="3">the RC hardware. Table <a href="pdfxml.html#6">2 </a>lists the instructions that must</text>
<text top="971" left="81" width="241" height="12" font="3">be added and describes what each does.</text>
<text top="986" left="99" width="341" height="12" font="3">The most complicated instruction semantics relate to</text>
<text top="1001" left="81" width="359" height="12" font="3">modifying watchpoints in multi-threaded programs. The</text>
<text top="1016" left="81" width="359" height="12" font="3">WLB, for example, must be able to respond to shootdown</text>
<text top="1031" left="81" width="359" height="12" font="3">requests in order to remain synchronized across multiple</text>
<text top="1046" left="81" width="359" height="12" font="3">threads. Most importantly, instructions must exist to add,</text>
<text top="1061" left="81" width="359" height="12" font="3">remove, and update ranges of watchpoints for sibling proces-</text>
<text top="1076" left="81" width="359" height="12" font="3">sors. To do this quickly, our system must send these requests</text>
<text top="438" left="476" width="359" height="12" font="3">without going through the OS. One method of doing this in-</text>
<text top="453" left="476" width="359" height="12" font="3">volves broadcasting to all cores a process ID (e.g., the CR3</text>
<text top="468" left="476" width="359" height="12" font="3">register in x86) and thread ID along with the request to</text>
<text top="483" left="476" width="359" height="12" font="3">perform a global update. Each core can then update its own</text>
<text top="498" left="476" width="359" height="12" font="3">cache entry if it matches the target process and thread ID.</text>
<text top="513" left="476" width="359" height="12" font="3">This instruction must be a memory fence, however, to main-</text>
<text top="528" left="476" width="359" height="12" font="3">tain consistency between watchpoints and normal requests</text>
<text top="543" left="476" width="359" height="12" font="3">to watched memory locations. After the remote threads up-</text>
<text top="558" left="476" width="359" height="12" font="3">date their watchpoint cache, they must also send back ac-</text>
<text top="572" left="476" width="359" height="12" font="3">knowledgments. If any target thread ID does not return an</text>
<text top="587" left="476" width="359" height="12" font="3">acknowledgment within some timeout period, it may not be</text>
<text top="602" left="476" width="359" height="12" font="3">running, and its watchpoints may be saved in memory. The</text>
<text top="617" left="476" width="359" height="12" font="3">source processor must then raise an interrupt and allow the</text>
<text top="632" left="476" width="322" height="12" font="3">OS to update the unscheduled process’s watchpoints.</text>
<text top="663" left="476" width="15" height="15" font="1">3.</text>
<text top="663" left="509" width="205" height="15" font="1">Watchpoint Applications</text>
<text top="686" left="476" width="359" height="12" font="3">This section analyzes potential applications for this watch-</text>
<text top="701" left="476" width="359" height="12" font="3">point system. We detail how each requires some subset of</text>
<text top="716" left="476" width="359" height="12" font="3">the requirements listed in Section <a href="pdfxml.html#2">2.1 </a>and then develop</text>
<text top="731" left="476" width="359" height="12" font="3">watchpoint-based algorithms that can accelerate each anal-</text>
<text top="746" left="476" width="359" height="12" font="3">ysis. Space limitations prevent us from detailing more than</text>
<text top="761" left="476" width="359" height="12" font="3">what we tested in our experiments, but Table <a href="pdfxml.html#7">3 </a>covers other</text>
<text top="776" left="476" width="306" height="12" font="3">tools, which are also brieﬂy discussed in Section <a href="pdfxml.html#11">5.</a></text>
<text top="801" left="476" width="20" height="12" font="3">3.1</text>
<text top="801" left="512" width="193" height="12" font="3">Dynamic Dataﬂow Analysis</text>
<text top="822" left="476" width="359" height="12" font="3">Dynamic dataﬂow analyses associate shadow values with</text>
<text top="837" left="476" width="359" height="12" font="3">program data, propagate them alongside the execution of</text>
<text top="852" left="476" width="359" height="12" font="3">the program, and perform a variety of checks on them to</text>
<text top="867" left="476" width="359" height="12" font="3">ﬁnd errors. This meta-data can represent myriad details</text>
<text top="882" left="476" width="359" height="12" font="3">about the associated memory location such as trustworthi-</text>
<text top="897" left="476" width="359" height="12" font="3">ness <a href="pdfxml.html#12">[12], </a>symbolic limits <a href="pdfxml.html#13">[24], </a>or identiﬁcation tags <a href="pdfxml.html#13">[29].</a></text>
<text top="912" left="476" width="359" height="12" font="3">Unfortunately, these systems suﬀer from high runtime over-</text>
<text top="927" left="476" width="359" height="12" font="3">heads, as every memory access must ﬁrst check its associated</text>
<text top="942" left="476" width="312" height="12" font="3">meta-data before calculating any propagation logic.</text>
<text top="956" left="493" width="341" height="12" font="3">Ho et al. described a method for dynamically disabling a</text>
<text top="971" left="476" width="359" height="12" font="3">taint analysis tool when it is not operating on tainted vari-</text>
<text top="986" left="476" width="359" height="12" font="3">ables, allowing the majority of memory operations to pro-</text>
<text top="1001" left="476" width="359" height="12" font="3">ceed without any analysis overheads <a href="pdfxml.html#13">[21]. </a>Pages that contain</text>
<text top="1016" left="476" width="359" height="12" font="3">any tainted data are marked unavailable in the virtual mem-</text>
<text top="1031" left="476" width="359" height="12" font="3">ory system. Programs will execute unencumbered when op-</text>
<text top="1046" left="476" width="359" height="12" font="3">erating on untainted data, but will cause a page fault if they</text>
<text top="1061" left="476" width="359" height="12" font="3">access data on a tainted page. At this point, the program</text>
<text top="1076" left="476" width="249" height="12" font="3">can be moved into the slow analysis tool.</text>
</page>
<page number="6" position="absolute" top="0" left="0" height="1188" width="918">
<text top="109" left="81" width="753" height="11" font="2">Table 2: ISA Additions for Unlimited Watchpoints. Watchpoint modiﬁcations must be memory fences, and instructions working</text>
<text top="123" left="81" width="753" height="11" font="2">on remote cores cause a shootdown in the remote WLB. Instructions used by the backing store handler can set all bits in a RC entry,</text>
<text top="136" left="81" width="223" height="11" font="2">and are also used during task switching.</text>
<text top="167" left="381" width="153" height="9" font="5">Watchpoint Modiﬁcations</text>
<text top="184" left="91" width="191" height="9" font="5">set local wp start, end, {r,w,rw,0}</text>
<text top="183" left="347" width="478" height="9" font="5">Adds a R/W/RW/not-watched range into this CPU’s RC. Overwrites any overlapping</text>
<text top="195" left="347" width="37" height="9" font="5">ranges.</text>
<text top="211" left="91" width="180" height="9" font="5">add/rm local wp start, end, {r,w}</text>
<text top="210" left="347" width="478" height="9" font="5">Updates an entry in the RC of this CPU. If anything between start and end is not in the</text>
<text top="222" left="347" width="345" height="9" font="5">RC, it must be read from the backing store to properly update it.</text>
<text top="238" left="91" width="224" height="9" font="5">set remote wp start, end, tid, {r,w,rw,0}</text>
<text top="238" left="347" width="322" height="9" font="5">Adds an entry into the RC of the CPU with TID register tid.</text>
<text top="254" left="91" width="213" height="9" font="5">add/rm remote wp start, end, tid, {r,w}</text>
<text top="253" left="347" width="328" height="9" font="5">Updates an entry in the RC of the CPU with TID register tid.</text>
<text top="272" left="390" width="135" height="9" font="5">Backing Store Handler</text>
<text top="289" left="91" width="80" height="9" font="5">read rc entry n</text>
<text top="288" left="347" width="62" height="9" font="5">Reads the n</text>
<text top="285" left="410" width="10" height="7" font="8">th</text>
<text top="288" left="425" width="400" height="9" font="5">entry of the RC (LRU order). This allows the oldest entries to be sent to the</text>
<text top="300" left="347" width="375" height="9" font="5">backing store. A bulk-read instruction could be used for task-switching.</text>
<text top="316" left="91" width="205" height="9" font="5">store rc entry start, end, status bits</text>
<text top="315" left="347" width="478" height="9" font="5">Allows writing an entire range (including bitmap and OCBM status bits) into a range cache</text>
<text top="327" left="347" width="283" height="9" font="5">entry. Used for reading in a watchpoint on a RC miss.</text>
<text top="346" left="371" width="173" height="9" font="5">Watchpoint System Interface</text>
<text top="363" left="91" width="93" height="9" font="5">enable/disable wp</text>
<text top="362" left="347" width="411" height="9" font="5">Enable or disable the watchpoint system on this core. Kernel-level instruction.</text>
<text top="378" left="91" width="80" height="9" font="5">set cpu tid tid</text>
<text top="378" left="347" width="295" height="9" font="5">Set the TID register on this CPU at thread switch time.</text>
<text top="394" left="91" width="152" height="9" font="5">enable/disable wp thread tid</text>
<text top="393" left="347" width="469" height="9" font="5">Toggle WP operation for any core with the same PID as this core’s and TID equal to tid.</text>
<text top="409" left="91" width="113" height="9" font="5">set handler addr addr</text>
<text top="409" left="347" width="478" height="9" font="5">Set the address to jump to when a watchpoint-related fault occurs. If faults are user-level,</text>
<text top="421" left="347" width="175" height="9" font="5">then this instruction is user-level.</text>
<text top="437" left="91" width="58" height="9" font="5">get cpu tid</text>
<text top="436" left="347" width="246" height="9" font="5">Find the value in this processor’s TID register.</text>
<text top="465" left="99" width="341" height="12" font="3">Ho et al. discussed the problem of false tainting, where</text>
<text top="480" left="81" width="359" height="12" font="3">the relatively coarse granularity of pages causes unneces-</text>
<text top="495" left="81" width="359" height="12" font="3">sary page faults when touching untainted data. Ideally,</text>
<text top="510" left="81" width="359" height="12" font="3">such a demand-driven taint analysis tool would utilize byte-</text>
<text top="525" left="81" width="359" height="12" font="3">accurate watchpoints. Additionally, although they partially</text>
<text top="540" left="81" width="359" height="12" font="3">mitigated the slowdowns caused by the lack of a fast fault</text>
<text top="555" left="81" width="359" height="12" font="3">handler by remaining inside their analysis tool for long peri-</text>
<text top="570" left="81" width="359" height="12" font="3">ods of time, this can limit performance. Their tool conserva-</text>
<text top="585" left="81" width="357" height="12" font="3">tively remains enabled while performing no useful analysis.</text>
<text top="600" left="99" width="341" height="12" font="3">A WP-based algorithm for this type of system can be</text>
<text top="615" left="81" width="359" height="12" font="3">summarized as setting RW watchpoints on any data that</text>
<text top="630" left="81" width="359" height="12" font="3">is tainted and running until a WP fault occurs. The fault</text>
<text top="645" left="81" width="359" height="12" font="3">indicates that a tainted value is either being written over</text>
<text top="660" left="81" width="359" height="12" font="3">or read from, and the propagation logic or instrumented</text>
<text top="674" left="81" width="359" height="12" font="3">code should be called from the WP handler. The tool should</text>
<text top="689" left="81" width="359" height="12" font="3">also remain enabled while tainted data exists in registers, as</text>
<text top="704" left="81" width="286" height="12" font="3">those values cannot be covered by watchpoints.</text>
<text top="741" left="81" width="20" height="12" font="3">3.2</text>
<text top="741" left="117" width="254" height="12" font="3">Deterministic Concurrent Execution</text>
<text top="762" left="81" width="359" height="12" font="3">Deterministic concurrent execution systems attempt to</text>
<text top="777" left="81" width="359" height="12" font="3">make more robust parallel programs by guaranteeing that</text>
<text top="792" left="81" width="359" height="12" font="3">the outputs of concurrent regions are the same each time a</text>
<text top="807" left="81" width="359" height="12" font="3">program is run with a particular input <a href="pdfxml.html#12">[5]. </a>This can be ac-</text>
<text top="822" left="81" width="359" height="12" font="3">complished by allowing parallel threads to run unhindered</text>
<text top="837" left="81" width="359" height="12" font="3">when they are not communicating, but only committing</text>
<text top="852" left="81" width="359" height="12" font="3">their memory speculatively. If one thread concurrently mod-</text>
<text top="867" left="81" width="359" height="12" font="3">iﬁes the data being used by another, they must be serialized</text>
<text top="882" left="81" width="100" height="12" font="3">in some manner.</text>
<text top="897" left="99" width="341" height="12" font="3">Grace, one example of this type of system, splits fork/join</text>
<text top="912" left="81" width="359" height="12" font="3">parallel programs into multiple processes and marks poten-</text>
<text top="927" left="81" width="359" height="12" font="3">tially shared heap regions as watched in the virtual memory</text>
<text top="942" left="81" width="359" height="12" font="3">system <a href="pdfxml.html#12">[6]. </a>Any time the program reads or writes a new</text>
<text top="956" left="81" width="359" height="12" font="3">heap page, a watchpoint fault is taken, whereupon the page</text>
<text top="971" left="81" width="359" height="12" font="3">is put into that process’s read or write set and marked as</text>
<text top="986" left="81" width="359" height="12" font="3">read-only or available, respectively. As the processes merge</text>
<text top="1001" left="81" width="359" height="12" font="3">while joining, any conﬂicting write updates cause one of the</text>
<text top="1016" left="81" width="210" height="12" font="3">threads to roll back and reexecute.</text>
<text top="1031" left="99" width="341" height="12" font="3">While Berger et al. demonstrated the eﬀectiveness of</text>
<text top="1046" left="81" width="359" height="12" font="3">this system for a collection of fork/join parallel programs,</text>
<text top="1061" left="81" width="359" height="12" font="3">using virtual memory watchpoints in such a way limits</text>
<text top="1076" left="81" width="359" height="12" font="3">the applicability of their system. First, it only works on</text>
<text top="465" left="476" width="359" height="12" font="3">programs that can easily be split into multiple processes,</text>
<text top="480" left="476" width="359" height="12" font="3">which can lead to performance and portability problems</text>
<text top="495" left="476" width="359" height="12" font="3">in some operating systems. Additionally, it can only look</text>
<text top="510" left="476" width="359" height="12" font="3">for conﬂicting accesses at the page granularity. While many</text>
<text top="525" left="476" width="359" height="12" font="3">developers work to limit false cache line sharing between</text>
<text top="540" left="476" width="359" height="12" font="3">threads, it is much less likely that they care to limit false</text>
<text top="555" left="476" width="359" height="12" font="3">sharing at the page granularity. Such a mismatch can lead</text>
<text top="570" left="476" width="359" height="12" font="3">to many unnecessary rollbacks, again reducing performance.</text>
<text top="585" left="493" width="341" height="12" font="3">Our watchpoint-based deterministic execution algorithm</text>
<text top="600" left="476" width="359" height="12" font="3">is similar to Grace, except that it works on a per-thread</text>
<text top="615" left="476" width="359" height="12" font="3">basis and sets watchpoints at a 64B cache line granularity.</text>
<text top="630" left="476" width="359" height="12" font="3">This could also be done at the byte granularity, but with</text>
<text top="645" left="476" width="105" height="12" font="3">higher overheads.</text>
<text top="681" left="476" width="20" height="12" font="3">3.3</text>
<text top="681" left="512" width="146" height="12" font="3">Data Race Detection</text>
<text top="702" left="476" width="359" height="12" font="3">Unordered accesses to shared memory locations by multiple</text>
<text top="717" left="476" width="359" height="12" font="3">threads, or data races, can allow variables to be changed</text>
<text top="732" left="476" width="359" height="12" font="3">in undesired orders, potentially causing data corruption</text>
<text top="747" left="476" width="359" height="12" font="3">and crashes <a href="pdfxml.html#13">[31]. </a>Dynamic data race detectors can help</text>
<text top="762" left="476" width="359" height="12" font="3">programmers build parallel programs by informing them</text>
<text top="777" left="476" width="338" height="12" font="3">whenever shared memory is accessed in a racy way <a href="pdfxml.html#13">[35].</a></text>
<text top="792" left="493" width="341" height="12" font="3">We previously showed a data race detection mechanism</text>
<text top="807" left="476" width="359" height="12" font="3">that operated on similar principles to demand-driven taint</text>
<text top="822" left="476" width="359" height="12" font="3">analysis, though it required the careful usage of performance</text>
<text top="837" left="476" width="359" height="12" font="3">monitoring hardware to observe cache events <a href="pdfxml.html#13">[19]. </a>That sys-</text>
<text top="852" left="476" width="359" height="12" font="3">tem could run into performance problems due to false shar-</text>
<text top="867" left="476" width="359" height="12" font="3">ing and may miss some races due to cache size limitations,</text>
<text top="882" left="476" width="119" height="12" font="3">among other issues.</text>
<text top="897" left="493" width="341" height="12" font="3">It is possible to build such a demand-driven analysis</text>
<text top="912" left="476" width="359" height="12" font="3">system using per-thread watchpoints. Similar to how Grace</text>
<text top="927" left="476" width="359" height="12" font="3">operates, all regions of shared memory are initially watched</text>
<text top="942" left="476" width="359" height="12" font="3">for each thread. As a thread executes, it will take a number</text>
<text top="956" left="476" width="359" height="12" font="3">of watchpoint faults in order to ﬁll its read and write sets in</text>
<text top="971" left="476" width="359" height="12" font="3">a byte-accurate manner. In our implementation, reads that</text>
<text top="986" left="476" width="359" height="12" font="3">take a watchpoint fault remove the local read watchpoint</text>
<text top="1001" left="476" width="359" height="12" font="3">and set a write watchpoint on all other threads (in order</text>
<text top="1016" left="476" width="359" height="12" font="3">to catch WAR sharing), while writes completely remove the</text>
<text top="1031" left="476" width="359" height="12" font="3">local watchpoint and set RW watchpoints on all other cores</text>
<text top="1046" left="476" width="359" height="12" font="3">(to catch RAW and WAW sharing). Any time an instruction</text>
<text top="1061" left="476" width="359" height="12" font="3">takes a WP fault, the software race detector can assume</text>
<text top="1076" left="476" width="359" height="12" font="3">that it was caused by inter-thread data sharing, and should</text>
</page>
<page number="7" position="absolute" top="0" left="0" height="1188" width="918">
<text top="109" left="81" width="753" height="11" font="2">Table 3: Applications of Watchpoints. This is a sample of software systems that could utilize hardware-supported watchpoints</text>
<text top="123" left="81" width="753" height="11" font="2">to perform more eﬃciently and accurately. High-level algorithms that focus on how such systems would interact with the watchpoint</text>
<text top="136" left="81" width="738" height="11" font="2">hardware are given for each, as well as an overview of the watchpoint capabilities that would be useful or needed for each algorithm.</text>
<text top="192" left="91" width="98" height="9" font="5">Software System</text>
<text top="192" left="337" width="130" height="9" font="5">High Level Algorithm</text>
<text top="203" left="622" width="0" height="9" font="5">Large</text>
<text top="211" left="634" width="0" height="9" font="5">Num</text>
<text top="182" left="634" width="0" height="9" font="5">b</text>
<text top="174" left="634" width="0" height="9" font="5">er</text>
<text top="201" left="655" width="0" height="9" font="5">Byte</text>
<text top="213" left="667" width="0" height="9" font="5">Gran</text>
<text top="183" left="667" width="0" height="9" font="5">ular</text>
<text top="199" left="687" width="0" height="9" font="5">F</text>
<text top="191" left="687" width="0" height="9" font="5">ast</text>
<text top="210" left="699" width="0" height="9" font="5">Handler</text>
<text top="199" left="720" width="0" height="9" font="5">F</text>
<text top="191" left="720" width="0" height="9" font="5">ast</text>
<text top="211" left="732" width="0" height="9" font="5">Changes</text>
<text top="197" left="752" width="0" height="9" font="5">P</text>
<text top="188" left="752" width="0" height="9" font="5">e</text>
<text top="182" left="752" width="0" height="9" font="5">r</text>
<text top="208" left="764" width="0" height="9" font="5">Thread</text>
<text top="196" left="785" width="0" height="9" font="5">Set</text>
<text top="208" left="797" width="0" height="9" font="5">Ranges</text>
<text top="204" left="818" width="0" height="9" font="5">Break</text>
<text top="208" left="830" width="0" height="9" font="5">Ranges</text>
<text top="235" left="91" width="82" height="9" font="5">Demand-Driven</text>
<text top="247" left="91" width="94" height="9" font="5">Dataﬂow Analysis</text>
<text top="236" left="208" width="189" height="9" font="5">Set shadowed values as RW watched.</text>
<text top="248" left="208" width="261" height="9" font="5">Enable analysis tool only on watchpoint faults.</text>
<text top="241" left="618" width="9" height="9" font="5">X</text>
<text top="241" left="650" width="9" height="9" font="5">X</text>
<text top="241" left="683" width="9" height="9" font="5">X</text>
<text top="241" left="715" width="9" height="9" font="5">X</text>
<text top="281" left="91" width="70" height="9" font="5">Deterministic</text>
<text top="293" left="91" width="52" height="9" font="5">Execution</text>
<text top="264" left="208" width="283" height="9" font="5">Start with shared memory RW watched in all threads.</text>
<text top="276" left="208" width="122" height="9" font="5">On local access fault:</text>
<text top="288" left="235" width="328" height="9" font="5">Check for write conflict between threads. If so, serialize.</text>
<text top="300" left="235" width="322" height="9" font="5">Unwatch (R or RW, depending on access) cache line locally.</text>
<text top="312" left="235" width="317" height="9" font="5">Rewatch cache lines on other threads after serialization.</text>
<text top="287" left="618" width="9" height="9" font="5">X</text>
<text top="287" left="748" width="9" height="9" font="5">X</text>
<text top="287" left="780" width="9" height="9" font="5">X</text>
<text top="287" left="813" width="9" height="9" font="5">X</text>
<text top="338" left="91" width="82" height="9" font="5">Demand-Driven</text>
<text top="350" left="91" width="55" height="9" font="5">Data Race</text>
<text top="362" left="91" width="50" height="9" font="5">Detection</text>
<text top="327" left="208" width="283" height="9" font="5">Start with shared memory RW watched in all threads.</text>
<text top="339" left="208" width="122" height="9" font="5">On local access fault:</text>
<text top="351" left="235" width="233" height="9" font="5">Run software race detector on this access.</text>
<text top="363" left="235" width="306" height="9" font="5">Unwatch (R or RW, depending on access) address locally.</text>
<text top="375" left="235" width="183" height="9" font="5">Rewatch address on other threads.</text>
<text top="350" left="618" width="9" height="9" font="5">X</text>
<text top="350" left="650" width="9" height="9" font="5">X</text>
<text top="350" left="683" width="9" height="9" font="5">X</text>
<text top="350" left="715" width="9" height="9" font="5">X</text>
<text top="350" left="748" width="9" height="9" font="5">X</text>
<text top="350" left="780" width="9" height="9" font="5">X</text>
<text top="350" left="813" width="9" height="9" font="5">X</text>
<text top="390" left="91" width="91" height="9" font="5">Bounds Checking</text>
<text top="390" left="208" width="378" height="9" font="5">Set W-watchpoints on canaries, return addresses, and heap meta-data.</text>
<text top="390" left="618" width="9" height="9" font="5">X</text>
<text top="390" left="650" width="9" height="9" font="5">X</text>
<text top="417" left="91" width="59" height="9" font="5">Speculative</text>
<text top="429" left="91" width="45" height="9" font="5">Program</text>
<text top="441" left="91" width="69" height="9" font="5">Optimization</text>
<text top="406" left="208" width="361" height="9" font="5">Mark data regions as W watched in speculative and normal threads.</text>
<text top="418" left="208" width="56" height="9" font="5">On faults:</text>
<text top="430" left="235" width="322" height="9" font="5">Save list of modified regions (perhaps larger than pages).</text>
<text top="442" left="235" width="195" height="9" font="5">Mark page available in this thread.</text>
<text top="454" left="208" width="345" height="9" font="5">Compare values in modified regions when verifying speculation.</text>
<text top="429" left="618" width="9" height="9" font="5">X</text>
<text top="429" left="748" width="9" height="9" font="5">X</text>
<text top="429" left="780" width="9" height="9" font="5">X</text>
<text top="429" left="813" width="9" height="9" font="5">X</text>
<text top="487" left="91" width="36" height="9" font="5">Hybrid</text>
<text top="499" left="91" width="71" height="9" font="5">Transactional</text>
<text top="511" left="91" width="43" height="9" font="5">Memory</text>
<text top="470" left="208" width="311" height="9" font="5">At start of transaction, set local memory as RW watched.</text>
<text top="482" left="208" width="122" height="9" font="5">On local access fault:</text>
<text top="494" left="235" width="183" height="9" font="5">Save original value for rollback.</text>
<text top="506" left="235" width="245" height="9" font="5">Check for conflicts with other transactions.</text>
<text top="518" left="235" width="300" height="9" font="5">Unwatch (R or RW, depending on access) address locally</text>
<text top="529" left="208" width="295" height="9" font="5">Unwatch memory for this thread on transaction commit.</text>
<text top="499" left="618" width="9" height="9" font="5">X</text>
<text top="499" left="683" width="9" height="9" font="5">X</text>
<text top="499" left="715" width="9" height="9" font="5">X</text>
<text top="499" left="748" width="9" height="9" font="5">X</text>
<text top="499" left="780" width="9" height="9" font="5">X</text>
<text top="499" left="813" width="9" height="9" font="5">X</text>
<text top="544" left="91" width="57" height="9" font="5">Semi-space</text>
<text top="556" left="91" width="44" height="9" font="5">Garbage</text>
<text top="568" left="91" width="52" height="9" font="5">Collection</text>
<text top="545" left="208" width="189" height="9" font="5">During from-space/to-space switch:</text>
<text top="557" left="235" width="361" height="9" font="5">Mark all memory in from-space as RW watched to executing threads.</text>
<text top="569" left="235" width="306" height="9" font="5">Update dereferenced pointer to be consistent on faults.</text>
<text top="556" left="618" width="9" height="9" font="5">X</text>
<text top="556" left="748" width="9" height="9" font="5">X</text>
<text top="556" left="780" width="9" height="9" font="5">X</text>
<text top="599" left="81" width="359" height="12" font="3">send the access through its slow race detection algorithm.</text>
<text top="614" left="81" width="359" height="12" font="3">A similar WP-based race detection method was recently</text>
<text top="628" left="81" width="359" height="12" font="3">demonstrated in DataCollider, though they are only able</text>
<text top="643" left="81" width="359" height="12" font="3">to concurrently watch four variables due to WP register</text>
<text top="658" left="81" width="95" height="12" font="3">limitations <a href="pdfxml.html#12">[16].</a></text>
<text top="673" left="99" width="341" height="12" font="3">This tool is a prime example of the need to break large</text>
<text top="688" left="81" width="359" height="12" font="3">ranges, as the program initially starts by watching large</text>
<text top="703" left="81" width="350" height="12" font="3">ranges and slowly splits them to form a local working set.</text>
<text top="736" left="81" width="15" height="15" font="1">4.</text>
<text top="736" left="114" width="104" height="15" font="1">Experiments</text>
<text top="759" left="81" width="359" height="12" font="3">Any slowdowns caused by issues such as WP cache misses</text>
<text top="774" left="81" width="359" height="12" font="3">should not outweigh the performance gains a WP system</text>
<text top="789" left="81" width="359" height="12" font="3">oﬀers software tools. To that end, this section presents</text>
<text top="804" left="81" width="359" height="12" font="3">experiments that evaluate the performance of our system</text>
<text top="819" left="81" width="359" height="12" font="3">and a collection of other ﬁne-grained memory protection</text>
<text top="834" left="81" width="359" height="12" font="3">systems when they are used to accelerate dynamic analysis</text>
<text top="849" left="81" width="33" height="12" font="3">tools.</text>
<text top="876" left="81" width="20" height="12" font="3">4.1</text>
<text top="876" left="117" width="139" height="12" font="3">Experimental Setup</text>
<text top="897" left="81" width="359" height="12" font="3">We implemented a high-level simulation environment using</text>
<text top="912" left="81" width="359" height="12" font="3">Pin <a href="pdfxml.html#13">[25] </a>running on x86-64 Linux hosts. The software anal-</text>
<text top="927" left="81" width="359" height="12" font="3">ysis tools were implemented as pintools and were used to</text>
<text top="942" left="81" width="359" height="12" font="3">analyze 32-bit x86 benchmark applications. These pintools</text>
<text top="956" left="81" width="359" height="12" font="3">communicated with a simulator that modeled the watch-</text>
<text top="971" left="81" width="359" height="12" font="3">point hardware. It also kept track of events that would cause</text>
<text top="986" left="81" width="359" height="12" font="3">slowdowns. The overheads of events that were fully exposed</text>
<text top="1001" left="81" width="359" height="12" font="3">to the pipeline (e.g. faults to the kernel) were calculated by</text>
<text top="1016" left="81" width="359" height="12" font="3">multiplying the event count by values derived from running</text>
<text top="1031" left="81" width="359" height="12" font="3">lmbench <a href="pdfxml.html#13">[28] </a>on a collection of x86 Linux systems. These</text>
<text top="1046" left="81" width="166" height="12" font="3">values are listed in Table <a href="pdfxml.html#8">4.</a></text>
<text top="1061" left="99" width="341" height="12" font="3">Events that are not fully exposed, such as the work</text>
<text top="1076" left="81" width="359" height="12" font="3">done by software handlers, were logged and run through a</text>
<text top="599" left="476" width="359" height="12" font="3">trace-based timing tool on a 2.4GHz Intel Core 2 processor</text>
<text top="614" left="476" width="359" height="12" font="3">running Red Hat Enterprise Linux 6.1. These actions are</text>
<text top="628" left="476" width="359" height="12" font="3">listed in Table <a href="pdfxml.html#8">5. </a>The runtime of the timing tool is recorded</text>
<text top="643" left="476" width="320" height="12" font="3">and used to derive the cycle overhead of such events.</text>
<text top="658" left="493" width="341" height="12" font="3">While this setup is likely to have inaccuracies (due to,</text>
<text top="673" left="476" width="359" height="12" font="3">for instance, caches and branch predictors being in diﬀer-</text>
<text top="688" left="476" width="359" height="12" font="3">ent states), it is still useful in giving rough estimates of the</text>
<text top="703" left="476" width="359" height="12" font="3">performance of numerous diﬀerent systems across a multi-</text>
<text top="718" left="476" width="359" height="12" font="3">tude of tools and benchmarks. It’s worth nothing that even</text>
<text top="733" left="476" width="359" height="12" font="3">“cycle-accurate” simulators have inaccuracies compared to</text>
<text top="748" left="476" width="359" height="12" font="3">real hardware <a href="pdfxml.html#13">[47]. </a>The larger testing space available to our</text>
<text top="763" left="476" width="331" height="12" font="3">fast simulation can still lead to useful design decisions.</text>
<text top="801" left="476" width="33" height="12" font="3">4.1.1</text>
<text top="801" left="524" width="192" height="12" font="3">Hardware Designs Modeled</text>
<text top="822" left="476" width="359" height="12" font="3">To compare our design to previous works that could also</text>
<text top="837" left="476" width="359" height="12" font="3">oﬀer watchpoints, we built models for a number of other</text>
<text top="852" left="476" width="359" height="12" font="3">hardware memory protection mechanisms. We assume that</text>
<text top="867" left="476" width="359" height="12" font="3">every system except virtual memory has user-level faults so</text>
<text top="882" left="476" width="359" height="12" font="3">as not to bias our results away from other hardware designs.</text>
<text top="897" left="493" width="341" height="12" font="3">Virtual Memory – This models the traditional way of</text>
<text top="912" left="476" width="359" height="12" font="3">oﬀering large numbers of watchpoints <a href="pdfxml.html#12">[2]. </a>Touching a page</text>
<text top="927" left="476" width="359" height="12" font="3">with watched data causes a page fault, whereupon the kernel</text>
<text top="942" left="476" width="359" height="12" font="3">looks through a list of byte-accurate watchpoints to decide</text>
<text top="956" left="476" width="359" height="12" font="3">if this was a true watchpoint fault. If so, a signal is sent</text>
<text top="971" left="476" width="359" height="12" font="3">to the user code. If not, the page is marked available, the</text>
<text top="986" left="476" width="359" height="12" font="3">next instruction single-stepped, and the page is then marked</text>
<text top="1001" left="476" width="359" height="12" font="3">unavailable again after the subsequent return to the kernel.</text>
<text top="1016" left="476" width="359" height="12" font="3">The overheads of this system can be estimated as: (# true</text>
<text top="1031" left="476" width="66" height="12" font="3">faults × (T</text>
<text top="1036" left="542" width="33" height="8" font="4">kernel</text>
<text top="1031" left="577" width="21" height="12" font="3">+ T</text>
<text top="1036" left="598" width="32" height="8" font="4">signal</text>
<text top="1031" left="631" width="143" height="12" font="3">)) + (# false faults × T</text>
<text top="1036" left="773" width="33" height="8" font="4">kernel</text>
<text top="1030" left="809" width="25" height="13" font="3">× 2)</text>
<text top="1046" left="476" width="134" height="12" font="3">+ (# WP changes × T</text>
<text top="1051" left="609" width="35" height="8" font="4">syscall</text>
<text top="1046" left="645" width="31" height="12" font="3">) + T</text>
<text top="1051" left="676" width="47" height="8" font="4">SW check</text>
<text top="1046" left="727" width="22" height="12" font="3">+ T</text>
<text top="1051" left="749" width="34" height="8" font="4">SW set</text>
<text top="1046" left="787" width="22" height="12" font="3">+ T</text>
<text top="1051" left="809" width="19" height="8" font="4">V M</text>
<text top="1046" left="830" width="4" height="12" font="3">.</text>
<text top="1061" left="493" width="341" height="12" font="3">MemTracker – This implements a design that has a</text>
<text top="1076" left="476" width="359" height="12" font="3">lookaside buﬀer that is separate from the L1D cache (called</text>
</page>
<page number="8" position="absolute" top="0" left="0" height="1188" width="918">
<text top="109" left="81" width="359" height="11" font="2">Table 4: Exposed Latency Values. These events are counted</text>
<text top="123" left="81" width="359" height="11" font="2">in our simulator, and each event is estimated to take the listed</text>
<text top="136" left="81" width="163" height="11" font="2">number of cycles, on average.</text>
<text top="167" left="152" width="34" height="9" font="5">Event</text>
<text top="167" left="252" width="82" height="9" font="5">Added Cycles</text>
<text top="167" left="360" width="44" height="9" font="5">Symbol</text>
<text top="187" left="138" width="63" height="9" font="5">Kernel fault</text>
<text top="187" left="284" width="18" height="9" font="5">700</text>
<text top="187" left="362" width="7" height="9" font="5">T</text>
<text top="190" left="369" width="31" height="7" font="8">kernel</text>
<text top="203" left="136" width="67" height="9" font="5">Syscall entry</text>
<text top="203" left="284" width="18" height="9" font="5">400</text>
<text top="203" left="361" width="7" height="9" font="5">T</text>
<text top="206" left="368" width="34" height="7" font="8">syscall</text>
<text top="218" left="122" width="95" height="9" font="5">Signal from kernel</text>
<text top="218" left="281" width="24" height="9" font="5">3000</text>
<text top="218" left="363" width="7" height="9" font="5">T</text>
<text top="222" left="370" width="30" height="7" font="8">signal</text>
<text top="234" left="116" width="106" height="9" font="5">User-level fault time</text>
<text top="234" left="287" width="12" height="9" font="5">20</text>
<text top="234" left="367" width="7" height="9" font="5">T</text>
<text top="238" left="374" width="21" height="7" font="8">user</text>
<text top="264" left="81" width="359" height="12" font="3">the “Taint L1” in FlexiTaint <a href="pdfxml.html#13">[41] </a>and “State L1” in Mem-</text>
<text top="279" left="81" width="359" height="12" font="3">Tracker <a href="pdfxml.html#13">[42]). </a>In these tests, the State L1 (SL1) was a 4KB,</text>
<text top="294" left="81" width="359" height="12" font="3">4-way set associative cache with 64-byte lines. The original</text>
<text top="309" left="81" width="359" height="12" font="3">MemTracker did not have user-level faults, so their backing</text>
<text top="324" left="81" width="359" height="12" font="3">store was a bitmap in main memory. Our initial tests showed</text>
<text top="339" left="81" width="359" height="12" font="3">that the vast majority of time was spent writing data to</text>
<text top="353" left="81" width="359" height="12" font="3">this bitmap, so we changed the system to use a software-</text>
<text top="368" left="81" width="359" height="12" font="3">controlled backing store handler similar to our design. The</text>
<text top="383" left="81" width="359" height="12" font="3">overheads of this system can be estimated as: ((# of faults</text>
<text top="398" left="81" width="131" height="12" font="3">+ # SL1 misses) × T</text>
<text top="403" left="212" width="22" height="8" font="4">user</text>
<text top="398" left="235" width="33" height="12" font="3">) + T</text>
<text top="403" left="268" width="47" height="8" font="4">SW check</text>
<text top="398" left="321" width="23" height="12" font="3">+ T</text>
<text top="403" left="344" width="34" height="8" font="4">SW set</text>
<text top="398" left="379" width="4" height="12" font="3">.</text>
<text top="413" left="99" width="341" height="12" font="3">Mondriaan Memory Protection – MMP utilizes a</text>
<text top="428" left="81" width="359" height="12" font="3">trie in main memory to store the watchpoints for individual</text>
<text top="443" left="81" width="359" height="12" font="3">bytes <a href="pdfxml.html#13">[46]. </a>Upper levels of the table can be set to mark large,</text>
<text top="458" left="81" width="359" height="12" font="3">aligned regions as watched in one action. The protection</text>
<text top="473" left="81" width="359" height="12" font="3">lookaside buﬀer (PLB) is 256 entries and can hold these</text>
<text top="488" left="81" width="359" height="12" font="3">higher-level entries (using low order don’t-care bits). We did</text>
<text top="503" left="81" width="359" height="12" font="3">not utilize the mini-SST optimization because Witchel later</text>
<text top="518" left="81" width="359" height="12" font="3">described how such entries can yield signiﬁcant slowdowns if</text>
<text top="533" left="81" width="359" height="12" font="3">permission changes are frequent <a href="pdfxml.html#13">[45]. </a>The overheads for this</text>
<text top="548" left="81" width="172" height="12" font="3">system are: (# of faults + T</text>
<text top="552" left="253" width="22" height="8" font="4">user</text>
<text top="548" left="276" width="33" height="12" font="3">) + T</text>
<text top="552" left="309" width="49" height="8" font="4">HW check</text>
<text top="548" left="364" width="23" height="12" font="3">+ T</text>
<text top="552" left="387" width="34" height="8" font="4">M LP T</text>
<text top="563" left="99" width="341" height="12" font="3">Range Cache – This system is a 128-entry range cache,</text>
<text top="578" left="81" width="359" height="12" font="3">where each entry holds 2 bits of WP data. Tiwari et al.</text>
<text top="593" left="81" width="359" height="12" font="3">estimated that a 128-entry range cache with 32-bit entries</text>
<text top="608" left="81" width="359" height="12" font="3">would take up nearly the same amount of space as 4KB of</text>
<text top="622" left="81" width="359" height="12" font="3">data cache <a href="pdfxml.html#13">[40]. </a>The OH is: ((# of faults + # RC misses</text>
<text top="637" left="81" width="133" height="12" font="3">+ # write-backs) × T</text>
<text top="642" left="214" width="22" height="8" font="4">user</text>
<text top="637" left="237" width="203" height="12" font="3">) + (complex range updates × 64</text>
<text top="652" left="81" width="68" height="12" font="3">cycles) + T</text>
<text top="657" left="149" width="47" height="8" font="4">SW check</text>
<text top="652" left="202" width="23" height="12" font="3">+ T</text>
<text top="657" left="225" width="34" height="8" font="4">SW set</text>
<text top="652" left="260" width="4" height="12" font="3">.</text>
<text top="667" left="99" width="341" height="12" font="3">RC + Bitmap – Our technique adds bitmapped ranges,</text>
<text top="682" left="81" width="359" height="12" font="3">OCBMs, and a 2-way set-associative, 2KB WLB to the range</text>
<text top="697" left="81" width="359" height="12" font="3">cache design. The size of the RC is reduced to 64 entries</text>
<text top="712" left="81" width="359" height="12" font="3">because of the extra area needed for these features. This</text>
<text top="727" left="81" width="359" height="12" font="3">system can have further overhead-causing events besides</text>
<text top="742" left="81" width="166" height="12" font="3">those of the range cache: (T</text>
<text top="747" left="247" width="49" height="8" font="4">HW check</text>
<text top="742" left="301" width="139" height="12" font="3">on WLB miss) + (time</text>
<text top="757" left="81" width="290" height="12" font="3">to decide to switch to/from bitmap ranges) + T</text>
<text top="762" left="371" width="35" height="8" font="4">bitmap</text>
<text top="757" left="407" width="4" height="12" font="3">.</text>
<text top="786" left="81" width="33" height="12" font="3">4.1.2</text>
<text top="786" left="130" width="149" height="12" font="3">Software Test Clients</text>
<text top="807" left="81" width="359" height="12" font="3">The software analyses discussed in Section <a href="pdfxml.html#5">3 </a>are utilized</text>
<text top="822" left="81" width="359" height="12" font="3">as clients for the simulated hardware watchpoint system.</text>
<text top="837" left="81" width="359" height="12" font="3">The overheads caused by the tools themselves are common</text>
<text top="852" left="81" width="359" height="12" font="3">amongst all watchpoint designs and are not modeled. In</text>
<text top="867" left="81" width="359" height="12" font="3">other words, the reported performance diﬀerences are rel-</text>
<text top="882" left="81" width="359" height="12" font="3">ative to the meta-data checks only, not the shadow propa-</text>
<text top="897" left="81" width="333" height="12" font="3">gation, serialization algorithms, or race detection logic.</text>
<text top="912" left="99" width="341" height="12" font="3">Demand-Driven Taint Analysis – This tool performs</text>
<text top="927" left="81" width="359" height="12" font="3">taint analysis on target applications, marking data read</text>
<text top="942" left="81" width="359" height="12" font="3">from disk and the network as tainted. As a baseline, we</text>
<text top="956" left="81" width="359" height="12" font="3">compare against two state-of-the-art analysis systems. The</text>
<text top="971" left="81" width="359" height="12" font="3">ﬁrst, MINEMU 0.3, is an extremely fast taint analysis tool</text>
<text top="986" left="81" width="359" height="12" font="3">that utilizes multiple non-portable techniques (such as using</text>
<text top="1001" left="81" width="359" height="12" font="3">SSE registers to hold taint bits) in order to run as fast as</text>
<text top="1016" left="81" width="359" height="12" font="3">possible <a href="pdfxml.html#12">[9]. </a>Because this system is a full taint analysis tool,</text>
<text top="1031" left="81" width="359" height="12" font="3">its measured overheads do include taint propagation and</text>
<text top="1046" left="81" width="359" height="12" font="3">checks. The second baseline system is Umbra, a more general</text>
<text top="1061" left="81" width="359" height="12" font="3">shadow memory system built on top of DynamoRio <a href="pdfxml.html#13">[49]. </a>Its</text>
<text top="1076" left="81" width="359" height="12" font="3">overheads come from calculating shadow value locations and</text>
<text top="109" left="476" width="359" height="11" font="2">Table 5: Pipelined Events. These are pipelined events that</text>
<text top="123" left="476" width="359" height="11" font="2">cause overlapping slowdowns. They are logged and their over-</text>
<text top="136" left="476" width="300" height="11" font="2">heads estimated using a trace-based timing simulator.</text>
<text top="167" left="599" width="34" height="9" font="5">Event</text>
<text top="167" left="748" width="44" height="9" font="5">Symbol</text>
<text top="187" left="520" width="193" height="9" font="5">Load watchpoints using SW handler.</text>
<text top="187" left="744" width="7" height="9" font="5">T</text>
<text top="190" left="751" width="44" height="7" font="8">SW check</text>
<text top="203" left="519" width="194" height="9" font="5">Store watchpoints using SW handler.</text>
<text top="203" left="750" width="7" height="9" font="5">T</text>
<text top="206" left="757" width="32" height="7" font="8">SW set</text>
<text top="218" left="528" width="176" height="9" font="5">Load watchpoints using hardware</text>
<text top="218" left="743" width="7" height="9" font="5">T</text>
<text top="222" left="750" width="46" height="7" font="8">HW check</text>
<text top="234" left="526" width="181" height="9" font="5">Change page table protection bits.</text>
<text top="234" left="757" width="7" height="9" font="5">T</text>
<text top="238" left="764" width="18" height="7" font="8">V M</text>
<text top="250" left="535" width="162" height="9" font="5">Create MLPT entries in MMP.</text>
<text top="250" left="749" width="7" height="9" font="5">T</text>
<text top="254" left="757" width="32" height="7" font="8">M LP T</text>
<text top="266" left="551" width="130" height="9" font="5">Write data into bitmaps.</text>
<text top="266" left="749" width="7" height="9" font="5">T</text>
<text top="270" left="756" width="33" height="7" font="8">bitmap</text>
<text top="294" left="476" width="359" height="12" font="3">accessing them on each memory operation. Similar to the</text>
<text top="309" left="476" width="359" height="12" font="3">tests done by Tiwari et al. <a href="pdfxml.html#13">[40], </a>we test these systems using</text>
<text top="324" left="476" width="248" height="12" font="3">the SPEC CPU2000 integer benchmarks.</text>
<text top="339" left="493" width="341" height="12" font="3">Deterministic Concurrent Execution – We test the</text>
<text top="354" left="476" width="359" height="12" font="3">deterministic execution tool in a similar manner to Grace by</text>
<text top="369" left="476" width="359" height="12" font="3">using the benchmark tests included in the Phoenix shared-</text>
<text top="384" left="476" width="359" height="12" font="3">memory MapReduce suite <a href="pdfxml.html#13">[33]. </a>We also tested the SPEC</text>
<text top="399" left="476" width="359" height="12" font="3">OMP2001 benchmarks, another set of programs with the</text>
<text top="414" left="476" width="333" height="12" font="3">fork-join parallelism that Grace is designed to support.</text>
<text top="429" left="493" width="341" height="12" font="3">Demand-Driven Data Race Detection – The default</text>
<text top="444" left="476" width="359" height="12" font="3">tool we compare against is a commercial data race detector</text>
<text top="459" left="476" width="359" height="12" font="3">that performs this sharing analysis in software. We test this</text>
<text top="474" left="476" width="359" height="12" font="3">system in a similar manner to our previous work <a href="pdfxml.html#13">[19] </a>by</text>
<text top="489" left="476" width="300" height="12" font="3">running the Phoenix <a href="pdfxml.html#13">[33] </a>and PARSEC <a href="pdfxml.html#12">[8] </a>suites.</text>
<text top="517" left="476" width="20" height="12" font="3">4.2</text>
<text top="517" left="512" width="181" height="12" font="3">Results for Taint Analysis</text>
<text top="538" left="476" width="359" height="12" font="3">Figure <a href="pdfxml.html#9">6 </a>details the average number of memory operations</text>
<text top="553" left="476" width="359" height="12" font="3">between each WP cache miss for all of the systems that use</text>
<text top="568" left="476" width="359" height="12" font="3">some cache mechanism (i.e., not virtual memory). Because</text>
<text top="583" left="476" width="359" height="12" font="3">these programs have large regions of unwatched data, this</text>
<text top="598" left="476" width="359" height="12" font="3">tool shows the power of the range cache to cover nearly</text>
<text top="613" left="476" width="359" height="12" font="3">the entire working set of a program. Similarly, because</text>
<text top="628" left="476" width="359" height="12" font="3">the MMP PLB can hold aligned ranges, it has a larger</text>
<text top="643" left="476" width="359" height="12" font="3">reach than MemTracker’s cache, which can only hold small</text>
<text top="658" left="476" width="359" height="12" font="3">sections of per-byte bitmaps. Nonetheless, Figure <a href="pdfxml.html#9">7 </a>shows</text>
<text top="673" left="476" width="359" height="12" font="3">that MMP has worse performance, on average, than MT.</text>
<text top="687" left="476" width="359" height="12" font="3">This is primarily because some benchmarks cause MMP to</text>
<text top="702" left="476" width="359" height="12" font="3">spend a great deal of time deciding whether to set or remove</text>
<text top="717" left="476" width="359" height="12" font="3">upper levels of the trie, in order to best utilize ranges in its</text>
<text top="732" left="476" width="32" height="12" font="3">PLB.</text>
<text top="747" left="493" width="341" height="12" font="3">The taint analysis tool rarely causes our hybrid system to</text>
<text top="762" left="476" width="359" height="12" font="3">transition from using normal to bitmapped ranges. Because</text>
<text top="777" left="476" width="359" height="12" font="3">the size of the RC is reduced from 128 to 64 entries, its miss</text>
<text top="792" left="476" width="359" height="12" font="3">rate is slightly higher than the RC-only system’s. The only</text>
<text top="807" left="476" width="359" height="12" font="3">counterexample is 255.vortex, which taints a large number</text>
<text top="822" left="476" width="359" height="12" font="3">of small regions. However, when WLB misses are taken into</text>
<text top="837" left="476" width="359" height="12" font="3">account (the line “RC+Bitmap” only accounts for range</text>
<text top="852" left="476" width="359" height="12" font="3">cache misses), the total hit rate drops precipitously. This is</text>
<text top="867" left="476" width="359" height="12" font="3">because the benchmark has a large number of WP changes,</text>
<text top="882" left="476" width="359" height="12" font="3">and each change into a bitmapped region causes a WLB</text>
<text top="897" left="476" width="51" height="12" font="3">eviction.</text>
<text top="912" left="493" width="341" height="12" font="3">Figure <a href="pdfxml.html#9">7 </a>compares the performance of the HW-assisted</text>
<text top="927" left="476" width="359" height="12" font="3">watchpoint systems against the two software-based shadow</text>
<text top="942" left="476" width="359" height="12" font="3">value analysis tools. The lower hit rate in the hybrid system</text>
<text top="956" left="476" width="359" height="12" font="3">means that it is about 7% slower than one with a larger</text>
<text top="971" left="476" width="359" height="12" font="3">RC. Nonetheless, the high hit rates of both systems mean</text>
<text top="986" left="476" width="359" height="12" font="3">that nearly every instruction that is not tainted suﬀers no</text>
<text top="1001" left="476" width="359" height="12" font="3">slowdown, yielding large speedups over the software analysis</text>
<text top="1016" left="476" width="359" height="12" font="3">tools. It is important to note, however, that MINEMU is</text>
<text top="1031" left="476" width="359" height="12" font="3">also performing taint propagation, overheads which we do</text>
<text top="1046" left="476" width="359" height="12" font="3">not analyze for our hardware systems. Nonetheless, using</text>
<text top="1061" left="476" width="359" height="12" font="3">hardware-supported watchpoints can still result in large</text>
<text top="1076" left="476" width="326" height="12" font="3">performance gains over an always-on tool like Umbra.</text>
</page>
<page number="9" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="17" size="7" family="Times" color="#000000"/>
<text top="183" left="102" width="25" height="8" font="16">1.E+00</text>
<text top="168" left="102" width="25" height="8" font="16">1.E+02</text>
<text top="153" left="102" width="25" height="8" font="16">1.E+04</text>
<text top="138" left="102" width="25" height="8" font="16">1.E+06</text>
<text top="123" left="102" width="25" height="8" font="16">1.E+08</text>
<text top="107" left="102" width="25" height="8" font="16">1.E+10</text>
<text top="195" left="142" width="31" height="8" font="16">164.gzip</text>
<text top="195" left="187" width="28" height="8" font="16">175.vpr</text>
<text top="195" left="231" width="28" height="8" font="16">176.gcc</text>
<text top="195" left="274" width="30" height="8" font="16">181.mcf</text>
<text top="195" left="315" width="81" height="8" font="16">186.crafty 197.parse</text>
<text top="195" left="406" width="118" height="8" font="16">252.eon 253.perlbmk 254.gap</text>
<text top="195" left="534" width="82" height="8" font="16">255.vortex 256.bzip2</text>
<text top="195" left="624" width="35" height="8" font="16">300.twolf</text>
<text top="195" left="711" width="37" height="8" font="16">GeoMean</text>
<text top="201" left="97" width="0" height="8" font="17"><b>M</b></text>
<text top="193" left="97" width="0" height="8" font="17"><b>e</b></text>
<text top="188" left="97" width="0" height="8" font="17"><b>m</b></text>
<text top="181" left="97" width="0" height="8" font="17"><b>O</b></text>
<text top="174" left="97" width="0" height="8" font="17"><b>p</b></text>
<text top="170" left="97" width="0" height="8" font="17"><b>s </b></text>
<text top="164" left="97" width="0" height="8" font="17"><b>P</b></text>
<text top="159" left="97" width="0" height="8" font="17"><b>e</b></text>
<text top="155" left="97" width="0" height="8" font="17"><b>r </b></text>
<text top="149" left="97" width="0" height="8" font="17"><b>C</b></text>
<text top="145" left="97" width="0" height="8" font="17"><b>a</b></text>
<text top="140" left="97" width="0" height="8" font="17"><b>ch</b></text>
<text top="131" left="97" width="0" height="8" font="17"><b>e</b></text>
<text top="127" left="97" width="0" height="8" font="17"><b> M</b></text>
<text top="117" left="97" width="0" height="8" font="17"><b>is</b></text>
<text top="111" left="97" width="0" height="8" font="17"><b>s</b></text>
<text top="119" left="764" width="12" height="8" font="16">MT</text>
<text top="133" left="764" width="20" height="8" font="16">MMP</text>
<text top="147" left="764" width="10" height="8" font="16">RC</text>
<text top="161" left="764" width="41" height="8" font="16">RC+Bitmap</text>
<text top="175" left="764" width="50" height="8" font="16">RC+B w/ WLB</text>
<text top="215" left="81" width="753" height="11" font="2">Figure 6: Memory Operations per Watchpoint Cache Miss for Taint Analysis. Most programs store a relatively small number</text>
<text top="229" left="81" width="753" height="11" font="2">of tainted regions, leading the range cache to have a very high hit rate (some of the benchmarks never miss). “RC+B w/ WLB” counts</text>
<text top="242" left="81" width="614" height="11" font="2">both range cache misses and the WLB misses, though the latter are ﬁlled much more quickly than the former.</text>
<text top="342" left="125" width="5" height="8" font="16">0</text>
<text top="332" left="125" width="5" height="8" font="16">1</text>
<text top="323" left="125" width="5" height="8" font="16">2</text>
<text top="313" left="125" width="5" height="8" font="16">3</text>
<text top="303" left="125" width="5" height="8" font="16">4</text>
<text top="294" left="125" width="5" height="8" font="16">5</text>
<text top="284" left="125" width="5" height="8" font="16">6</text>
<text top="274" left="125" width="5" height="8" font="16">7</text>
<text top="264" left="125" width="5" height="8" font="16">8</text>
<text top="354" left="144" width="31" height="8" font="16">164.gzip</text>
<text top="354" left="190" width="28" height="8" font="16">175.vpr</text>
<text top="354" left="233" width="28" height="8" font="16">176.gcc</text>
<text top="354" left="276" width="30" height="8" font="16">181.mcf</text>
<text top="354" left="316" width="82" height="8" font="16">186.crafty 197.parser</text>
<text top="354" left="407" width="117" height="8" font="16">252.eon 253.perlbmk 254.gap</text>
<text top="354" left="534" width="81" height="8" font="16">255.vortex 256.bzip2</text>
<text top="354" left="623" width="35" height="8" font="16">300.twolf</text>
<text top="354" left="710" width="36" height="8" font="16">GeoMean</text>
<text top="326" left="120" width="0" height="8" font="17"><b>S</b></text>
<text top="322" left="120" width="0" height="8" font="17"><b>lo</b></text>
<text top="315" left="120" width="0" height="8" font="17"><b>w</b></text>
<text top="308" left="120" width="0" height="8" font="17"><b>d</b></text>
<text top="303" left="120" width="0" height="8" font="17"><b>o</b></text>
<text top="298" left="120" width="0" height="8" font="17"><b>wn</b></text>
<text top="287" left="120" width="0" height="8" font="17"><b> (</b></text>
<text top="282" left="120" width="0" height="8" font="17"><b>x</b></text>
<text top="278" left="120" width="0" height="8" font="17"><b>)</b></text>
<text top="270" left="769" width="34" height="8" font="16">MINEMU</text>
<text top="281" left="769" width="25" height="8" font="16">Umbra</text>
<text top="292" left="769" width="13" height="8" font="16">VM</text>
<text top="303" left="769" width="12" height="8" font="16">MT</text>
<text top="315" left="769" width="20" height="8" font="16">MMP</text>
<text top="326" left="769" width="10" height="8" font="16">RC</text>
<text top="337" left="769" width="41" height="8" font="16">RC+Bitmap</text>
<text top="270" left="701" width="13" height="8" font="16">19x</text>
<text top="377" left="81" width="753" height="11" font="2">Figure 7: Performance of Demand-Driven Taint Analysis. The patterned are binary instrumentation systems that perform full</text>
<text top="390" left="81" width="753" height="11" font="2">taint analysis and shadow value lookup, respectively. The maximum slowdowns of the VM system are not shown, as they can go as high</text>
<text top="404" left="81" width="753" height="11" font="2">as 1400×. The RC + Bitmap solution performs poorly on 255.vortex because each WP change to a bitmapped region causes an eviction</text>
<text top="417" left="81" width="668" height="11" font="2">from the WLB, and these are quite frequent. Nonetheless, this system easily outperforms manual shadow value lookups.</text>
<text top="458" left="99" width="341" height="12" font="3">This performance beneﬁt is dampened in 255.vortex by</text>
<text top="473" left="81" width="359" height="12" font="3">its extremely low cache hit rates. All of the demand-driven</text>
<text top="488" left="81" width="359" height="12" font="3">analysis systems performed poorly for this benchmark, and</text>
<text top="503" left="81" width="359" height="12" font="3">would probably continue to do so even with high cache hit</text>
<text top="518" left="81" width="359" height="12" font="3">rates, since the software analysis tool would rarely be dis-</text>
<text top="533" left="81" width="359" height="12" font="3">abled – almost 10% of the memory operations in 255.vortex</text>
<text top="548" left="81" width="359" height="12" font="3">operate on tainted values. Demand-driven tools are poor at</text>
<text top="563" left="81" width="359" height="12" font="3">accelerating applications such as this, and would need mech-</text>
<text top="578" left="81" width="258" height="12" font="3">anisms such as sampling to run faster <a href="pdfxml.html#12">[18].</a></text>
<text top="604" left="81" width="20" height="12" font="3">4.3</text>
<text top="604" left="117" width="250" height="12" font="3">Results for Deterministic Execution</text>
<text top="625" left="81" width="359" height="12" font="3">Figures <a href="pdfxml.html#10">8 </a>and <a href="pdfxml.html#10">9 </a>show the cache miss rates and performance,</text>
<text top="640" left="81" width="359" height="12" font="3">respectively, of the WP-based deterministic execution sys-</text>
<text top="655" left="81" width="359" height="12" font="3">tem. The performance graph is normalized to a Grace-like</text>
<text top="670" left="81" width="359" height="12" font="3">system that removes watchpoints one page, rather than one</text>
<text top="685" left="81" width="359" height="12" font="3">cache line, at a time. The normalized performance of the</text>
<text top="700" left="81" width="311" height="12" font="3">more ﬁne-grained mechanisms will be lower than 1.</text>
<text top="715" left="99" width="341" height="12" font="3">Because this system operates on more watchpoints than</text>
<text top="730" left="81" width="359" height="12" font="3">the taint analysis tool, the cache hit rates are lower. Very</text>
<text top="745" left="81" width="359" height="12" font="3">few of the watchpoints used in this tool can be held in higher</text>
<text top="760" left="81" width="359" height="12" font="3">levels of the trie, so MMP’s PLB has a much worse hit rate.</text>
<text top="775" left="81" width="359" height="12" font="3">On average, MemTracker’s hit rate is higher than MMP’s</text>
<text top="790" left="81" width="359" height="12" font="3">due to its larger cache. Despite the increased number of</text>
<text top="805" left="81" width="359" height="12" font="3">watchpoints, the range cache maintains a high hit rate. This</text>
<text top="820" left="81" width="359" height="12" font="3">can partially be attributed to the tool using watchpoints of</text>
<text top="834" left="81" width="359" height="12" font="3">64 bytes in length at minimum, which increases the reach of</text>
<text top="849" left="81" width="263" height="12" font="3">the range cache in highly fragmented cases.</text>
<text top="864" left="99" width="341" height="12" font="3">As Figure <a href="pdfxml.html#10">9 </a>illustrates, attempting to use ﬁner-grained</text>
<text top="879" left="81" width="359" height="12" font="3">watchpoints in the virtual memory system reduces perfor-</text>
<text top="894" left="81" width="359" height="12" font="3">mance signiﬁcantly (it averages out to 670× slower than</text>
<text top="909" left="81" width="359" height="12" font="3">using 4KB watchpoints). All of the systems designed for</text>
<text top="924" left="81" width="359" height="12" font="3">ﬁne-grained watchpoints handle this change much better.</text>
<text top="939" left="81" width="359" height="12" font="3">The systems that utilize ranges execute at about 90% of the</text>
<text top="954" left="81" width="359" height="12" font="3">speed of the VM-based system that uses 4KB watchpoints,</text>
<text top="969" left="81" width="359" height="12" font="3">with the bitmapped range system edging slightly higher.</text>
<text top="984" left="81" width="359" height="12" font="3">Because this tool primarily works on ranges of data, both</text>
<text top="999" left="81" width="359" height="12" font="3">range-based systems perform better than the other hardware</text>
<text top="1014" left="81" width="240" height="12" font="3">systems that operate solely on bitmaps.</text>
<text top="1040" left="81" width="20" height="12" font="3">4.4</text>
<text top="1040" left="117" width="227" height="12" font="3">Results for Data Race Detection</text>
<text top="1061" left="81" width="359" height="12" font="3">The cache miss rate for a demand-driven data race detector</text>
<text top="1076" left="81" width="359" height="12" font="3">is shown in Figures <a href="pdfxml.html#10">10. </a>This tool deals with a much greater</text>
<text top="458" left="476" width="359" height="12" font="3">number of watchpoints, as it slowly unwatches data touched</text>
<text top="473" left="476" width="359" height="12" font="3">by individual threads at a byte granularity. The eﬀect this</text>
<text top="488" left="476" width="359" height="12" font="3">has on the range cache can be easily observed in the Phoenix</text>
<text top="503" left="476" width="359" height="12" font="3">suite, as it falls from 100,000 memory operations between</text>
<text top="518" left="476" width="359" height="12" font="3">each range cache miss (in Grace) to 10,000 in this tool. The</text>
<text top="533" left="476" width="359" height="12" font="3">PARSEC benchmark canneal is particularly egregious, as</text>
<text top="548" left="476" width="359" height="12" font="3">none of the hardware caches go more than an average of 100</text>
<text top="563" left="476" width="359" height="12" font="3">memory operations before missing. Because most of these</text>
<text top="578" left="476" width="359" height="12" font="3">benchmarks have a large number of relatively small ranges,</text>
<text top="593" left="476" width="359" height="12" font="3">however, this suite shows the beneﬁt of the bitmapped</text>
<text top="608" left="476" width="359" height="12" font="3">ranges. In PARSEC, the geometric mean of the range cache</text>
<text top="623" left="476" width="359" height="12" font="3">hit rate is 5× higher when small ranges can be stored as</text>
<text top="638" left="476" width="307" height="12" font="3">bitmaps, even though the RC itself is half the size.</text>
<text top="653" left="493" width="341" height="12" font="3">The performance of the hardware-assisted sharing detec-</text>
<text top="668" left="476" width="359" height="12" font="3">tors, shown in Figure <a href="pdfxml.html#10">11, </a>is almost always higher than when</text>
<text top="683" left="476" width="359" height="12" font="3">using software. In particular, the range based systems, even</text>
<text top="698" left="476" width="359" height="12" font="3">with low hit rates, can still outperform a software system</text>
<text top="713" left="476" width="359" height="12" font="3">that must check every memory access. The exception in can-</text>
<text top="727" left="476" width="359" height="12" font="3">neal, where range-based hardware systems suﬀer high over-</text>
<text top="742" left="476" width="359" height="12" font="3">heads from the backing store fault handler. In total, however,</text>
<text top="757" left="476" width="359" height="12" font="3">our hybrid system is able to demonstrate a 9× performance</text>
<text top="772" left="476" width="155" height="12" font="3">improvement, on average.</text>
<text top="801" left="476" width="20" height="12" font="3">4.5</text>
<text top="801" left="512" width="172" height="12" font="3">Experimental Takeaways</text>
<text top="822" left="476" width="359" height="12" font="3">On the whole, the beneﬁts of the range cache are pro-</text>
<text top="837" left="476" width="359" height="12" font="3">nounced. Its hit rate is signiﬁcantly higher than caches that</text>
<text top="852" left="476" width="359" height="12" font="3">only store WP bitmaps. Perhaps even more importantly, it</text>
<text top="867" left="476" width="359" height="12" font="3">acts as a write ﬁlter. Many of the slowdowns seen by Mem-</text>
<text top="882" left="476" width="359" height="12" font="3">Tracker are due to writing to the backing store repeatedly.</text>
<text top="897" left="476" width="359" height="12" font="3">In a similar vein, the algorithm for ﬁlling out the trie in</text>
<text top="912" left="476" width="359" height="12" font="3">MMP can take up a great deal of time when there are many</text>
<text top="927" left="476" width="359" height="12" font="3">WP changes, and breaking ranges apart can cause a large</text>
<text top="942" left="476" width="159" height="12" font="3">amount of memory traﬃc.</text>
<text top="956" left="493" width="341" height="12" font="3">Nonetheless, we’ve found that the addition of a bitmap</text>
<text top="971" left="476" width="359" height="12" font="3">system to the range cache is beneﬁcial when the watchpoints</text>
<text top="986" left="476" width="359" height="12" font="3">are small. There are numerous applications that create a</text>
<text top="1001" left="476" width="359" height="12" font="3">large number of small ranges. dedup within a race detector,</text>
<text top="1016" left="476" width="359" height="12" font="3">for instance, is signiﬁcantly helped by the increased reach of</text>
<text top="1031" left="476" width="359" height="12" font="3">the RC when using bitmapped ranges. We found, however,</text>
<text top="1046" left="476" width="359" height="12" font="3">that the WLB miss rate was quite high in many cases. This</text>
<text top="1061" left="476" width="359" height="12" font="3">is partially because writes to bitmapped regions currently</text>
<text top="1076" left="476" width="359" height="12" font="3">evict matching entries from the WLB. It is also the case that</text>
</page>
<page number="10" position="absolute" top="0" left="0" height="1188" width="918">
	<fontspec id="18" size="6" family="Times" color="#000000"/>
	<fontspec id="19" size="6" family="Times" color="#000000"/>
<text top="230" left="117" width="23" height="6" font="16">1E+00</text>
<text top="219" left="117" width="23" height="6" font="16">1E+01</text>
<text top="209" left="117" width="23" height="6" font="16">1E+02</text>
<text top="199" left="117" width="23" height="6" font="16">1E+03</text>
<text top="188" left="117" width="23" height="6" font="16">1E+04</text>
<text top="178" left="117" width="23" height="6" font="16">1E+05</text>
<text top="167" left="117" width="23" height="6" font="16">1E+06</text>
<text top="157" left="117" width="23" height="6" font="16">1E+07</text>
<text top="147" left="117" width="23" height="6" font="16">1E+08</text>
<text top="136" left="117" width="23" height="6" font="16">1E+09</text>
<text top="126" left="117" width="23" height="6" font="16">1E+10</text>
<text top="221" left="112" width="0" height="8" font="17"><b>M</b></text>
<text top="213" left="112" width="0" height="8" font="17"><b>e</b></text>
<text top="209" left="112" width="0" height="8" font="17"><b>m</b></text>
<text top="201" left="112" width="0" height="8" font="17"><b>O</b></text>
<text top="195" left="112" width="0" height="8" font="17"><b>p</b></text>
<text top="190" left="112" width="0" height="8" font="17"><b>s </b></text>
<text top="185" left="112" width="0" height="8" font="17"><b>P</b></text>
<text top="180" left="112" width="0" height="8" font="17"><b>e</b></text>
<text top="176" left="112" width="0" height="8" font="17"><b>r </b></text>
<text top="170" left="112" width="0" height="8" font="17"><b>C</b></text>
<text top="166" left="112" width="0" height="8" font="17"><b>a</b></text>
<text top="161" left="112" width="0" height="8" font="17"><b>ch</b></text>
<text top="153" left="112" width="0" height="8" font="17"><b>e</b></text>
<text top="148" left="112" width="0" height="8" font="17"><b> M</b></text>
<text top="138" left="112" width="0" height="8" font="17"><b>is</b></text>
<text top="132" left="112" width="0" height="8" font="17"><b>s</b></text>
<text top="293" left="181" width="101" height="11" font="2">(a) Phoenix Suite</text>
<text top="228" left="404" width="22" height="8" font="18">1E+00</text>
<text top="218" left="404" width="22" height="8" font="18">1E+01</text>
<text top="207" left="404" width="22" height="8" font="18">1E+02</text>
<text top="197" left="404" width="22" height="8" font="18">1E+03</text>
<text top="187" left="404" width="22" height="8" font="18">1E+04</text>
<text top="177" left="404" width="22" height="8" font="18">1E+05</text>
<text top="166" left="404" width="22" height="8" font="18">1E+06</text>
<text top="156" left="404" width="22" height="8" font="18">1E+07</text>
<text top="146" left="404" width="22" height="8" font="18">1E+08</text>
<text top="136" left="404" width="22" height="8" font="18">1E+09</text>
<text top="126" left="404" width="22" height="8" font="18">1E+10</text>
<text top="220" left="400" width="0" height="8" font="19"><b>M</b></text>
<text top="212" left="400" width="0" height="8" font="19"><b>e</b></text>
<text top="208" left="400" width="0" height="8" font="19"><b>m</b></text>
<text top="201" left="400" width="0" height="8" font="19"><b>O</b></text>
<text top="195" left="400" width="0" height="8" font="19"><b>p</b></text>
<text top="190" left="400" width="0" height="8" font="19"><b>s </b></text>
<text top="184" left="400" width="0" height="8" font="19"><b>P</b></text>
<text top="180" left="400" width="0" height="8" font="19"><b>e</b></text>
<text top="175" left="400" width="0" height="8" font="19"><b>r </b></text>
<text top="170" left="400" width="0" height="8" font="19"><b>C</b></text>
<text top="165" left="400" width="0" height="8" font="19"><b>a</b></text>
<text top="161" left="400" width="0" height="8" font="19"><b>ch</b></text>
<text top="153" left="400" width="0" height="8" font="19"><b>e</b></text>
<text top="148" left="400" width="0" height="8" font="19"><b> M</b></text>
<text top="138" left="400" width="0" height="8" font="19"><b>is</b></text>
<text top="133" left="400" width="0" height="8" font="19"><b>s</b></text>
<text top="131" left="785" width="12" height="8" font="18">MT</text>
<text top="151" left="785" width="20" height="8" font="18">MMP</text>
<text top="172" left="785" width="10" height="8" font="18">RC</text>
<text top="192" left="785" width="14" height="8" font="18">RC+</text>
<text top="203" left="785" width="26" height="8" font="18">Bitmap</text>
<text top="212" left="785" width="30" height="8" font="18">RC+B w/</text>
<text top="223" left="785" width="16" height="8" font="18">WLB</text>
<text top="292" left="544" width="118" height="11" font="2">(b) SPEC OMP2001</text>
<text top="308" left="81" width="753" height="11" font="2">Figure 8: Memory Operations per WP Cache Miss for Deterministic Execution. The increased number of WPs causes the</text>
<text top="321" left="81" width="753" height="11" font="2">RC to have lower hit rates than it had for taint analysis. Because watchpoints are set and removed on cache line sized regions, the</text>
<text top="335" left="81" width="753" height="11" font="2">addition of a bitmap is only somewhat useful. It does not, however, increase the reach of the system as a whole since the size of the RC</text>
<text top="348" left="81" width="579" height="11" font="2">is reduced. Nonetheless, both systems take many fewer misses than other watchpoint hardware systems.</text>
<text top="476" left="122" width="5" height="6" font="16"> -</text>
<text top="467" left="115" width="14" height="6" font="16"> 0.1</text>
<text top="457" left="115" width="14" height="6" font="16"> 0.2</text>
<text top="447" left="115" width="14" height="6" font="16"> 0.3</text>
<text top="437" left="115" width="14" height="6" font="16"> 0.4</text>
<text top="427" left="115" width="14" height="6" font="16"> 0.5</text>
<text top="417" left="115" width="14" height="6" font="16"> 0.6</text>
<text top="407" left="115" width="14" height="6" font="16"> 0.7</text>
<text top="397" left="115" width="14" height="6" font="16"> 0.8</text>
<text top="387" left="115" width="14" height="6" font="16"> 0.9</text>
<text top="378" left="115" width="14" height="6" font="16"> 1.0</text>
<text top="467" left="110" width="0" height="7" font="17"><b>P</b></text>
<text top="462" left="110" width="0" height="7" font="17"><b>e</b></text>
<text top="457" left="110" width="0" height="7" font="17"><b>r</b></text>
<text top="454" left="110" width="0" height="7" font="17"><b>fo</b></text>
<text top="446" left="110" width="0" height="7" font="17"><b>r</b></text>
<text top="442" left="110" width="0" height="7" font="17"><b>m</b></text>
<text top="435" left="110" width="0" height="7" font="17"><b>a</b></text>
<text top="430" left="110" width="0" height="7" font="17"><b>n</b></text>
<text top="425" left="110" width="0" height="7" font="17"><b>c</b></text>
<text top="421" left="110" width="0" height="7" font="17"><b>e</b></text>
<text top="416" left="110" width="0" height="7" font="17"><b> v</b></text>
<text top="410" left="110" width="0" height="7" font="17"><b>s</b></text>
<text top="406" left="110" width="0" height="7" font="17"><b> G</b></text>
<text top="398" left="110" width="0" height="7" font="17"><b>ra</b></text>
<text top="390" left="110" width="0" height="7" font="17"><b>c</b></text>
<text top="386" left="110" width="0" height="7" font="17"><b>e</b></text>
<text top="547" left="181" width="101" height="11" font="2">(a) Phoenix Suite</text>
<text top="476" left="411" width="5" height="7" font="16"> -</text>
<text top="466" left="404" width="13" height="7" font="16"> 0.1</text>
<text top="456" left="404" width="13" height="7" font="16"> 0.2</text>
<text top="446" left="404" width="13" height="7" font="16"> 0.3</text>
<text top="436" left="404" width="13" height="7" font="16"> 0.4</text>
<text top="426" left="404" width="13" height="7" font="16"> 0.5</text>
<text top="417" left="404" width="13" height="7" font="16"> 0.6</text>
<text top="407" left="404" width="13" height="7" font="16"> 0.7</text>
<text top="397" left="404" width="13" height="7" font="16"> 0.8</text>
<text top="387" left="404" width="13" height="7" font="16"> 0.9</text>
<text top="377" left="404" width="13" height="7" font="16"> 1.0</text>
<text top="464" left="400" width="0" height="6" font="17"><b>P</b></text>
<text top="460" left="400" width="0" height="6" font="17"><b>e</b></text>
<text top="455" left="400" width="0" height="6" font="17"><b>r</b></text>
<text top="452" left="400" width="0" height="6" font="17"><b>fo</b></text>
<text top="444" left="400" width="0" height="6" font="17"><b>r</b></text>
<text top="441" left="400" width="0" height="6" font="17"><b>m</b></text>
<text top="434" left="400" width="0" height="6" font="17"><b>a</b></text>
<text top="429" left="400" width="0" height="6" font="17"><b>n</b></text>
<text top="424" left="400" width="0" height="6" font="17"><b>c</b></text>
<text top="421" left="400" width="0" height="6" font="17"><b>e</b></text>
<text top="416" left="400" width="0" height="6" font="17"><b> v</b></text>
<text top="410" left="400" width="0" height="6" font="17"><b>s</b></text>
<text top="406" left="400" width="0" height="6" font="17"><b> G</b></text>
<text top="399" left="400" width="0" height="6" font="17"><b>ra</b></text>
<text top="391" left="400" width="0" height="6" font="17"><b>c</b></text>
<text top="387" left="400" width="0" height="6" font="17"><b>e</b></text>
<text top="382" left="787" width="13" height="7" font="16">VM</text>
<text top="402" left="787" width="12" height="7" font="16">MT</text>
<text top="422" left="787" width="20" height="7" font="16">MMP</text>
<text top="442" left="787" width="10" height="7" font="16">RC</text>
<text top="461" left="787" width="14" height="7" font="16">RC+</text>
<text top="472" left="787" width="26" height="7" font="16">Bitmap</text>
<text top="548" left="544" width="118" height="11" font="2">(b) SPEC OMP2001</text>
<text top="563" left="81" width="753" height="11" font="2">Figure 9: Deterministic Execution Performance: Cache Line vs. Page Granularity Watchpoints. The baseline system sets</text>
<text top="576" left="81" width="753" height="11" font="2">and removes watchpoints at the 4KB page granularity, while these systems operate on 64 byte lines. On average, both range-based</text>
<text top="590" left="81" width="485" height="11" font="2">systems operate at 90% of the baseline speed while maintaining more accurate checks.s</text>
<text top="723" left="125" width="23" height="6" font="16">1E+00</text>
<text top="709" left="125" width="23" height="6" font="16">1E+01</text>
<text top="694" left="125" width="23" height="6" font="16">1E+02</text>
<text top="680" left="125" width="23" height="6" font="16">1E+03</text>
<text top="665" left="125" width="23" height="6" font="16">1E+04</text>
<text top="651" left="125" width="23" height="6" font="16">1E+05</text>
<text top="636" left="125" width="23" height="6" font="16">1E+06</text>
<text top="622" left="125" width="23" height="6" font="16">1E+07</text>
<text top="717" left="121" width="0" height="8" font="17"><b>M</b></text>
<text top="709" left="121" width="0" height="8" font="17"><b>e</b></text>
<text top="704" left="121" width="0" height="8" font="17"><b>m</b></text>
<text top="697" left="121" width="0" height="8" font="17"><b>O</b></text>
<text top="690" left="121" width="0" height="8" font="17"><b>p</b></text>
<text top="685" left="121" width="0" height="8" font="17"><b>s </b></text>
<text top="680" left="121" width="0" height="8" font="17"><b>P</b></text>
<text top="675" left="121" width="0" height="8" font="17"><b>e</b></text>
<text top="670" left="121" width="0" height="8" font="17"><b>r </b></text>
<text top="665" left="121" width="0" height="8" font="17"><b>C</b></text>
<text top="660" left="121" width="0" height="8" font="17"><b>a</b></text>
<text top="655" left="121" width="0" height="8" font="17"><b>ch</b></text>
<text top="647" left="121" width="0" height="8" font="17"><b>e</b></text>
<text top="642" left="121" width="0" height="8" font="17"><b> M</b></text>
<text top="632" left="121" width="0" height="8" font="17"><b>is</b></text>
<text top="626" left="121" width="0" height="8" font="17"><b>s</b></text>
<text top="793" left="189" width="101" height="11" font="2">(a) Phoenix Suite</text>
<text top="722" left="409" width="22" height="8" font="18">1E+00</text>
<text top="707" left="409" width="22" height="8" font="18">1E+01</text>
<text top="693" left="409" width="22" height="8" font="18">1E+02</text>
<text top="678" left="409" width="22" height="8" font="18">1E+03</text>
<text top="664" left="409" width="22" height="8" font="18">1E+04</text>
<text top="650" left="409" width="22" height="8" font="18">1E+05</text>
<text top="635" left="409" width="22" height="8" font="18">1E+06</text>
<text top="621" left="409" width="22" height="8" font="18">1E+07</text>
<text top="714" left="404" width="0" height="7" font="19"><b>M</b></text>
<text top="706" left="404" width="0" height="7" font="19"><b>e</b></text>
<text top="702" left="404" width="0" height="7" font="19"><b>m</b></text>
<text top="695" left="404" width="0" height="7" font="19"><b>O</b></text>
<text top="689" left="404" width="0" height="7" font="19"><b>p</b></text>
<text top="684" left="404" width="0" height="7" font="19"><b>s </b></text>
<text top="679" left="404" width="0" height="7" font="19"><b>P</b></text>
<text top="674" left="404" width="0" height="7" font="19"><b>e</b></text>
<text top="670" left="404" width="0" height="7" font="19"><b>r </b></text>
<text top="665" left="404" width="0" height="7" font="19"><b>C</b></text>
<text top="660" left="404" width="0" height="7" font="19"><b>a</b></text>
<text top="656" left="404" width="0" height="7" font="19"><b>ch</b></text>
<text top="648" left="404" width="0" height="7" font="19"><b>e</b></text>
<text top="643" left="404" width="0" height="7" font="19"><b> M</b></text>
<text top="634" left="404" width="0" height="7" font="19"><b>is</b></text>
<text top="628" left="404" width="0" height="7" font="19"><b>s</b></text>
<text top="627" left="778" width="12" height="8" font="18">MT</text>
<text top="647" left="778" width="19" height="8" font="18">MMP</text>
<text top="667" left="778" width="9" height="8" font="18">RC</text>
<text top="687" left="778" width="14" height="8" font="18">RC+</text>
<text top="697" left="778" width="25" height="8" font="18">Bitmap</text>
<text top="707" left="778" width="30" height="8" font="18">RC+B w/</text>
<text top="717" left="778" width="16" height="8" font="18">WLB</text>
<text top="789" left="562" width="76" height="11" font="2">(b) PARSEC</text>
<text top="807" left="81" width="753" height="11" font="2">Figure 10: Memory Operations per WP Cache Miss for Data Race Detection. This system sets a large number of ﬁne-grained</text>
<text top="821" left="81" width="753" height="11" font="2">watchpoints, making the bitmap addition especially useful. It increases the number of instructions between each RC miss by over 5× in</text>
<text top="834" left="81" width="607" height="11" font="2">PARSEC. The total miss rate with WLB included is higher, but those are ﬁlled much faster than RC misses.</text>
<text top="964" left="133" width="5" height="6" font="18"> -</text>
<text top="947" left="131" width="6" height="6" font="18"> 5</text>
<text top="930" left="126" width="11" height="6" font="18"> 10</text>
<text top="913" left="126" width="11" height="6" font="18"> 15</text>
<text top="896" left="126" width="11" height="6" font="18"> 20</text>
<text top="880" left="126" width="11" height="6" font="18"> 25</text>
<text top="863" left="126" width="11" height="6" font="18"> 30</text>
<text top="932" left="123" width="0" height="8" font="19"><b>S</b></text>
<text top="928" left="123" width="0" height="8" font="19"><b>p</b></text>
<text top="923" left="123" width="0" height="8" font="19"><b>e</b></text>
<text top="919" left="123" width="0" height="8" font="19"><b>e</b></text>
<text top="914" left="123" width="0" height="8" font="19"><b>d</b></text>
<text top="909" left="123" width="0" height="8" font="19"><b>u</b></text>
<text top="905" left="123" width="0" height="8" font="19"><b>p</b></text>
<text top="900" left="123" width="0" height="8" font="19"><b> (</b></text>
<text top="895" left="123" width="0" height="8" font="19"><b>x</b></text>
<text top="891" left="123" width="0" height="8" font="19"><b>)</b></text>
<text top="1029" left="192" width="101" height="11" font="2">(a) Phoenix Suite</text>
<text top="965" left="418" width="5" height="7" font="18"> -</text>
<text top="948" left="416" width="6" height="7" font="18"> 5</text>
<text top="931" left="412" width="11" height="7" font="18"> 10</text>
<text top="914" left="412" width="11" height="7" font="18"> 15</text>
<text top="897" left="412" width="11" height="7" font="18"> 20</text>
<text top="880" left="412" width="11" height="7" font="18"> 25</text>
<text top="863" left="412" width="11" height="7" font="18"> 30</text>
<text top="932" left="408" width="0" height="8" font="19"><b>S</b></text>
<text top="928" left="408" width="0" height="8" font="19"><b>p</b></text>
<text top="924" left="408" width="0" height="8" font="19"><b>e</b></text>
<text top="919" left="408" width="0" height="8" font="19"><b>e</b></text>
<text top="915" left="408" width="0" height="8" font="19"><b>d</b></text>
<text top="910" left="408" width="0" height="8" font="19"><b>u</b></text>
<text top="905" left="408" width="0" height="8" font="19"><b>p</b></text>
<text top="900" left="408" width="0" height="8" font="19"><b> (</b></text>
<text top="896" left="408" width="0" height="8" font="19"><b>x</b></text>
<text top="892" left="408" width="0" height="8" font="19"><b>)</b></text>
<text top="869" left="779" width="13" height="7" font="18">VM</text>
<text top="889" left="779" width="12" height="7" font="18">MT</text>
<text top="909" left="779" width="20" height="7" font="18">MMP</text>
<text top="929" left="779" width="9" height="7" font="18">RC</text>
<text top="949" left="779" width="14" height="7" font="18">RC+</text>
<text top="960" left="779" width="26" height="7" font="18">Bitmap</text>
<text top="1029" left="562" width="76" height="11" font="2">(b) PARSEC</text>
<text top="1044" left="81" width="753" height="11" font="2">Figure 11: Performance of Demand-Driven Data Race Detection vs. Binary Instrumentation. Because the binary</text>
<text top="1057" left="81" width="753" height="11" font="2">instrumentation tool is slow, most of the systems see signiﬁcant speedups. The WLB miss handler is much faster than RC miss handler,</text>
<text top="1071" left="81" width="631" height="11" font="2">so the bitmapped range system is noticeably faster than the RC system, even though it takes many WLB misses.</text>
</page>
<page number="11" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="81" width="359" height="12" font="3">that bitmapped ranges are often enabled in sections of code</text>
<text top="126" left="81" width="359" height="12" font="3">that are diﬃcult to cache. This warrants future research to</text>
<text top="141" left="81" width="358" height="12" font="3">perhaps ﬁnd a better way to store these bitmapped ranges.</text>
<text top="155" left="99" width="341" height="12" font="3">Though we did not illustrate the tests we did on the</text>
<text top="170" left="81" width="359" height="12" font="3">OCBM, we found that it was a net beneﬁt, on average.</text>
<text top="185" left="81" width="359" height="12" font="3">However, its beneﬁt was generally measured in single-digit</text>
<text top="200" left="81" width="359" height="12" font="3">percentages, rather than the larger gains we often saw with</text>
<text top="215" left="81" width="141" height="12" font="3">the full bitmap system.</text>
<text top="230" left="99" width="341" height="12" font="3">Perhaps the most important area that could be improved</text>
<text top="245" left="81" width="359" height="12" font="3">in our system is the backing store handler. Range cache</text>
<text top="260" left="81" width="359" height="12" font="3">misses or overﬂows required hundreds to thousands of extra</text>
<text top="275" left="81" width="359" height="12" font="3">cycles to handle (depending on the size of backing store</text>
<text top="290" left="81" width="359" height="12" font="3">tree and the complexity of the insertion). With overheads</text>
<text top="305" left="81" width="359" height="12" font="3">this high, the range cache needs a particularly good hit</text>
<text top="320" left="81" width="359" height="12" font="3">rate to maintain high performance. One of the beneﬁts we</text>
<text top="335" left="81" width="359" height="12" font="3">found with the bitmapped ranges was that the WLB miss</text>
<text top="350" left="81" width="359" height="12" font="3">handler was simpler and faster. It is probably possible to</text>
<text top="365" left="81" width="359" height="12" font="3">build more eﬃcient backing store algorithms, such that they</text>
<text top="380" left="81" width="359" height="12" font="3">would switch between storage methods depending on the</text>
<text top="395" left="81" width="359" height="12" font="3">miss rate, eviction rate, and number of watchpoints in the</text>
<text top="410" left="81" width="45" height="12" font="3">system.</text>
<text top="424" left="99" width="341" height="12" font="3">In summary, the hardware-assisted watchpoint systems</text>
<text top="439" left="81" width="359" height="12" font="3">allowed sizable performance improvements in demand-</text>
<text top="454" left="81" width="359" height="12" font="3">driven tools. For the deterministic execution system, the</text>
<text top="469" left="81" width="359" height="12" font="3">ﬁner-grained watchpoints resulted in minor slowdowns, but</text>
<text top="484" left="81" width="359" height="12" font="3">allowed more accurate sharing analyses than can currently</text>
<text top="499" left="81" width="359" height="12" font="3">be performed at such a speed. This is the crux of the argu-</text>
<text top="514" left="81" width="359" height="12" font="3">ment that hardware-assisted watchpoints are a generalized</text>
<text top="529" left="81" width="228" height="12" font="3">mechanism to improve software tools.</text>
<text top="568" left="81" width="15" height="15" font="1">5.</text>
<text top="568" left="114" width="122" height="15" font="1">Related Works</text>
<text top="591" left="81" width="359" height="12" font="3">This section explores works related to watchpoints and their</text>
<text top="606" left="81" width="359" height="12" font="3">uses. We ﬁrst discuss hardware proposals that could be used</text>
<text top="621" left="81" width="359" height="12" font="3">to provide unlimited watchpoints, but which have limita-</text>
<text top="635" left="81" width="359" height="12" font="3">tions that keep them from being as general as we would</text>
<text top="650" left="81" width="359" height="12" font="3">like. We then list other applications that could potentially</text>
<text top="665" left="81" width="239" height="12" font="3">utilize an unlimited watchpoint system.</text>
<text top="696" left="81" width="20" height="12" font="3">5.1</text>
<text top="696" left="117" width="199" height="12" font="3">Memory Protection Systems</text>
<text top="717" left="81" width="359" height="12" font="3">There have been numerous proposals for hardware that</text>
<text top="732" left="81" width="359" height="12" font="3">provides watchpoint-like mechanisms. Capabilities, for in-</text>
<text top="747" left="81" width="359" height="12" font="3">stance, can be used to control software’s access to particular</text>
<text top="762" left="81" width="359" height="12" font="3">regions in memory <a href="pdfxml.html#12">[15]. </a>Few capability-based systems were</text>
<text top="777" left="81" width="359" height="12" font="3">built, and even fewer still exist. Most recent publications</text>
<text top="792" left="81" width="282" height="12" font="3">focus instead on ﬁne-grain memory protection.</text>
<text top="807" left="99" width="341" height="12" font="3">One of the most widely cited works in this area is Mon-</text>
<text top="822" left="81" width="359" height="12" font="3">driaan (also spelled Mondrian) Memory Protection <a href="pdfxml.html#13">[46].</a></text>
<text top="837" left="81" width="359" height="12" font="3">MMP was designed with ﬁne-grained inter-process protec-</text>
<text top="852" left="81" width="359" height="12" font="3">tion mechanisms in mind, and is optimized for applications</text>
<text top="867" left="81" width="359" height="12" font="3">that do not perform frequent updates. The protection infor-</text>
<text top="882" left="81" width="359" height="12" font="3">mation is stored in main memory and is cached in a protec-</text>
<text top="897" left="81" width="359" height="12" font="3">tion lookaside buﬀer (PLB). MMP utilized a ternary CAM</text>
<text top="912" left="81" width="359" height="12" font="3">for this cache, allowing naturally aligned ranges to be com-</text>
<text top="927" left="81" width="359" height="12" font="3">pactly stored. The ﬁrst method Witchel proposed for storing</text>
<text top="942" left="81" width="359" height="12" font="3">protection regions in memory was a sorted segment table</text>
<text top="956" left="81" width="359" height="12" font="3">(SST), a list sorted by starting address. Though this al-</text>
<text top="971" left="81" width="359" height="12" font="3">lows O(ln n) lookups and can eﬃciently store ranges, it is</text>
<text top="986" left="81" width="359" height="12" font="3">unsuitable for frequent updates. The second, a multi-level</text>
<text top="1001" left="81" width="359" height="12" font="3">permission table (MLPT), is a trie that holds a bitmap of</text>
<text top="1016" left="81" width="359" height="12" font="3">word-accurate permissions in its lowest level. It is beneﬁcial</text>
<text top="1031" left="81" width="359" height="12" font="3">to use upper levels of this table whenever possible in order</text>
<text top="1046" left="81" width="359" height="12" font="3">to increase the PLB’s reach. Checking ranges of permissions</text>
<text top="1061" left="81" width="359" height="12" font="3">in order to “promote” a region can cause signiﬁcant update</text>
<text top="1076" left="81" width="359" height="12" font="3">slowdowns, however. In general, MMP is designed to work</text>
<text top="111" left="476" width="359" height="12" font="3">with tools that, while needing memory protection, do not</text>
<text top="126" left="476" width="158" height="12" font="3">perform frequent updates.</text>
<text top="141" left="493" width="341" height="12" font="3">One common method of storing protection data is to put</text>
<text top="155" left="476" width="359" height="12" font="3">it alongside cache lines <a href="pdfxml.html#13">[30, 32, 50]. </a>iWatcher, for example,</text>
<text top="170" left="476" width="359" height="12" font="3">stores per-word watchpoints alongside the cache lines that</text>
<text top="185" left="476" width="359" height="12" font="3">contain the watched data <a href="pdfxml.html#13">[50]. </a>These bits are initially set</text>
<text top="200" left="476" width="359" height="12" font="3">by hardware and are temporarily stored into a victim ta-</text>
<text top="215" left="476" width="359" height="12" font="3">ble on cache evictions. The hardware falls back to virtual</text>
<text top="230" left="476" width="359" height="12" font="3">memory watchpoints if this table overﬂows. iWatcher can</text>
<text top="245" left="476" width="359" height="12" font="3">watch a small number of ranges, which must be pinned in</text>
<text top="260" left="476" width="359" height="12" font="3">physical memory. If this range hardware overﬂows, the sys-</text>
<text top="275" left="476" width="359" height="12" font="3">tem falls back to setting a large number of per-word watch-</text>
<text top="290" left="476" width="359" height="12" font="3">points. In general, this system is inadequate for tools that</text>
<text top="305" left="476" width="359" height="12" font="3">require more than a small number of large ranges. Of note,</text>
<text top="320" left="476" width="359" height="12" font="3">Zhou et al. correctly state the usefulness of user-level faults</text>
<text top="335" left="476" width="359" height="12" font="3">in handling frequently-touched watchpoints. UFO, a similar</text>
<text top="350" left="476" width="359" height="12" font="3">system, used watchpoints to accelerate speculative software</text>
<text top="365" left="476" width="359" height="12" font="3">optimization <a href="pdfxml.html#13">[30]. </a>Unfortunately, because it stores watch-</text>
<text top="380" left="476" width="359" height="12" font="3">points in memory by updating the ECC bits of individual</text>
<text top="395" left="476" width="359" height="12" font="3">lines, it does not allow large ranges to be quickly set or re-</text>
<text top="410" left="476" width="266" height="12" font="3">moved. SafeMem uses a similar scheme <a href="pdfxml.html#13">[32].</a></text>
<text top="424" left="493" width="341" height="12" font="3">MemTracker holds analysis meta-data (which is analo-</text>
<text top="439" left="476" width="359" height="12" font="3">gous to watchpoints) in a separate L1 cache, similar to our</text>
<text top="454" left="476" width="359" height="12" font="3">WLB. It also oﬀers the option of using a hardware state</text>
<text top="469" left="476" width="359" height="12" font="3">machine to perform meta-data propagation <a href="pdfxml.html#13">[42]. </a>This means</text>
<text top="484" left="476" width="359" height="12" font="3">that it can have even less overhead for some types of analyses</text>
<text top="499" left="476" width="359" height="12" font="3">than a system with a user-level fault handler. However, be-</text>
<text top="514" left="476" width="359" height="12" font="3">cause its meta-data is stored as a packed array in main mem-</text>
<text top="529" left="476" width="359" height="12" font="3">ory, it is time-consuming to set or remove watchpoints on</text>
<text top="544" left="476" width="359" height="12" font="3">large ranges. FlexiTaint, a follow-on work to MemTracker,</text>
<text top="559" left="476" width="147" height="12" font="3">has the same issues <a href="pdfxml.html#13">[41].</a></text>
<text top="574" left="493" width="341" height="12" font="3">In order to reduce the number of accesses to the memory</text>
<text top="589" left="476" width="359" height="12" font="3">protection hardware, Sentry stores its protection data at the</text>
<text top="604" left="476" width="359" height="12" font="3">cache line granularity <a href="pdfxml.html#13">[38]. </a>Every line in L1 is unwatched,</text>
<text top="619" left="476" width="359" height="12" font="3">and the on-chip protection structure is only checked on</text>
<text top="634" left="476" width="359" height="12" font="3">L1D misses. Their paper gives an excellent analysis of the</text>
<text top="649" left="476" width="359" height="12" font="3">type of hardware needed to perform watchpoints. However,</text>
<text top="664" left="476" width="359" height="12" font="3">their system has large overheads when performing frequent</text>
<text top="678" left="476" width="359" height="12" font="3">updates because it must go to a software handler on every</text>
<text top="693" left="476" width="246" height="12" font="3">change and evict cache lines accordingly.</text>
<text top="726" left="476" width="20" height="12" font="3">5.2</text>
<text top="726" left="512" width="195" height="12" font="3">Other Uses for Watchpoints</text>
<text top="747" left="476" width="359" height="12" font="3">Watchpoints can also be used to accelerate software systems</text>
<text top="762" left="476" width="359" height="12" font="3">beyond the three examined in the experiments. Table <a href="pdfxml.html#7">3 </a>lists</text>
<text top="777" left="476" width="296" height="12" font="3">algorithms for the tools discussed in this section.</text>
<text top="792" left="493" width="341" height="12" font="3">Hill et al. previously made an argument for deconstructed</text>
<text top="807" left="476" width="359" height="12" font="3">hardware transactional memory (TM) systems <a href="pdfxml.html#13">[20]. </a>They</text>
<text top="822" left="476" width="359" height="12" font="3">pushed for HTM additions that could be used for other</text>
<text top="837" left="476" width="359" height="12" font="3">things, like watchpoints; we instead argue that watchpoints</text>
<text top="852" left="476" width="359" height="12" font="3">can be used to make (among other things) faster TM sys-</text>
<text top="867" left="476" width="359" height="12" font="3">tems. A WP-based algorithm to accelerate software TM, as</text>
<text top="882" left="476" width="359" height="12" font="3">described by Baugh et al., sets WPs on data touched by</text>
<text top="897" left="476" width="359" height="12" font="3">transactional code; any time another thread touches this</text>
<text top="912" left="476" width="359" height="12" font="3">data, a conﬂict will be caught <a href="pdfxml.html#12">[3]. </a>If transactions are partic-</text>
<text top="927" left="476" width="359" height="12" font="3">ularly long, forcibly setting watchpoints after every memory</text>
<text top="942" left="476" width="359" height="12" font="3">access may be slow. In this case, carving working sets out</text>
<text top="956" left="476" width="359" height="12" font="3">of large watched regions (as we demonstrated for determin-</text>
<text top="971" left="476" width="359" height="12" font="3">istic execution and data race detection) may be faster, as</text>
<text top="986" left="476" width="359" height="12" font="3">the initial fault times are amortized across multiple memory</text>
<text top="1001" left="476" width="67" height="12" font="3">operations.</text>
<text top="1016" left="493" width="341" height="12" font="3">Beyond correctness and debugging analyses, speculative</text>
<text top="1031" left="476" width="359" height="12" font="3">parallelization systems allow some pieces of sequential code</text>
<text top="1046" left="476" width="359" height="12" font="3">to run concurrently, and only later check if the result was</text>
<text top="1061" left="476" width="359" height="12" font="3">indeed correct. In essence, watchpoints can be set on values</text>
<text top="1076" left="476" width="359" height="12" font="3">created by the speculative code so that they are veriﬁed</text>
</page>
<page number="12" position="absolute" top="0" left="0" height="1188" width="918">
<text top="111" left="81" width="359" height="12" font="3">before being used elsewhere in the program. Fast Track</text>
<text top="126" left="81" width="359" height="12" font="3">performs these checks in software using virtual memory</text>
<text top="141" left="81" width="102" height="12" font="3">watchpoints <a href="pdfxml.html#13">[23].</a></text>
<text top="155" left="99" width="341" height="12" font="3">Because they allow write faults to be taken on speciﬁed</text>
<text top="170" left="81" width="359" height="12" font="3">read-only regions of memory, watchpoints also enable secu-</text>
<text top="185" left="81" width="359" height="12" font="3">rity systems both as common as bounds checking <a href="pdfxml.html#12">[14] </a>and as</text>
<text top="200" left="81" width="359" height="12" font="3">esoteric as kernel rootkit protection <a href="pdfxml.html#13">[44]. </a>The latter requires</text>
<text top="215" left="81" width="359" height="12" font="3">little explanation, but it is useful to note that the authors</text>
<text top="230" left="81" width="359" height="12" font="3">lamented the “protection granularity gap,” or the inability</text>
<text top="245" left="81" width="190" height="12" font="3">to set ﬁne-grained watchpoints.</text>
<text top="260" left="99" width="341" height="12" font="3">Watchpoints can even be used, in a fashion, for garbage</text>
<text top="275" left="81" width="359" height="12" font="3">collection. A semi-space collector will move all reachable</text>
<text top="290" left="81" width="359" height="12" font="3">objects from one memory space to another at collection</text>
<text top="305" left="81" width="359" height="12" font="3">time <a href="pdfxml.html#12">[13, 17]. </a>To implement this eﬃciently, the program</text>
<text top="320" left="81" width="359" height="12" font="3">will continue to execute while data is moved, pausing if</text>
<text top="335" left="81" width="359" height="12" font="3">the program attempts to access data that has not yet been</text>
<text top="350" left="81" width="359" height="12" font="3">appropriately moved. Appel et al. did this by setting virtual</text>
<text top="365" left="81" width="359" height="12" font="3">memory watchpoints on each memory location that is to be</text>
<text top="380" left="81" width="359" height="12" font="3">moved <a href="pdfxml.html#12">[1]. </a>This is similar to the mechanism that Lyu et al.</text>
<text top="395" left="81" width="265" height="12" font="3">use to perform online software updates <a href="pdfxml.html#13">[26].</a></text>
<text top="426" left="81" width="15" height="15" font="1">6.</text>
<text top="426" left="114" width="239" height="15" font="1">Conclusion and Future Work</text>
<text top="449" left="81" width="359" height="12" font="3">In this paper we presented a hardware design that allows</text>
<text top="464" left="81" width="359" height="12" font="3">software to utilize a virtually unlimited number of low-</text>
<text top="478" left="81" width="359" height="12" font="3">overhead watchpoints. By combining the ability of a range</text>
<text top="493" left="81" width="359" height="12" font="3">cache to store long watched regions with a bitmap’s fast</text>
<text top="508" left="81" width="359" height="12" font="3">access and succinct encoding for small watchpoints, we were</text>
<text top="523" left="81" width="359" height="12" font="3">able to demonstrate an eﬀective system for a collection of</text>
<text top="538" left="81" width="359" height="12" font="3">software tools. We used this system to demonstrate that</text>
<text top="553" left="81" width="359" height="12" font="3">the software community can beneﬁt from generic primitives</text>
<text top="568" left="81" width="136" height="12" font="3">provided by hardware.</text>
<text top="583" left="99" width="341" height="12" font="3">Though our results show that a design of this nature is</text>
<text top="598" left="81" width="359" height="12" font="3">promising, a number of avenues for future research remain</text>
<text top="613" left="81" width="359" height="12" font="3">open. Our range cache’s software-controlled miss and evic-</text>
<text top="628" left="81" width="359" height="12" font="3">tion handler would be unusable without fast fault support.</text>
<text top="643" left="81" width="359" height="12" font="3">It may therefore be advantageous to look into hardware de-</text>
<text top="658" left="81" width="359" height="12" font="3">signs for operating on the backing store. There are also open</text>
<text top="673" left="81" width="359" height="12" font="3">questions as to the best algorithms for moving from ranges to</text>
<text top="688" left="81" width="359" height="12" font="3">bitmaps (and vice-versa). We presented a simple algorithm</text>
<text top="703" left="81" width="359" height="12" font="3">that showed decent results, but it is probably not optimal</text>
<text top="718" left="81" width="220" height="12" font="3">either in its runtime or its decisions.</text>
<text top="733" left="99" width="341" height="12" font="3">Finally, there are potentially promising research results</text>
<text top="747" left="81" width="359" height="12" font="3">into new types of software tools that could be built on top</text>
<text top="762" left="81" width="359" height="12" font="3">of watchpoint systems. Software developers and researchers</text>
<text top="777" left="81" width="359" height="12" font="3">have been valiantly extending the uses of the virtual memory</text>
<text top="792" left="81" width="359" height="12" font="3">system for decades. This ingenuity may very well yield novel</text>
<text top="807" left="81" width="359" height="12" font="3">uses for a byte-granularity watchpoint system in the future.</text>
<text top="838" left="81" width="148" height="15" font="1">Acknowledgments</text>
<text top="861" left="81" width="359" height="12" font="3">We wish to thank Debapriya Chatterjee, Andrea Pellegrini,</text>
<text top="876" left="81" width="359" height="12" font="3">and the anonymous reviewers, whose suggestions greatly</text>
<text top="891" left="81" width="359" height="12" font="3">improved this work, as well as Evelyn Duesterwald from</text>
<text top="906" left="81" width="359" height="12" font="3">IBM Research, for assistance in the ﬁnal revision. Thanks</text>
<text top="921" left="81" width="359" height="12" font="3">also to Qin Zhao for providing the Umbra code used in</text>
<text top="936" left="81" width="359" height="12" font="3">our experiments. The authors acknowledge the support of</text>
<text top="951" left="81" width="359" height="12" font="3">the Gigascale Systems Research Center, one of ﬁve research</text>
<text top="966" left="81" width="359" height="12" font="3">centers funded under the Focus Center Research Program,</text>
<text top="981" left="81" width="296" height="12" font="3">a Semiconductor Research Corporation program.</text>
<text top="1012" left="81" width="88" height="15" font="1">References</text>
<text top="1034" left="87" width="352" height="11" font="2">[1] A. W. Appel, J. R. Ellis, and K. Li. Real-time Concurrent</text>
<text top="1048" left="106" width="334" height="11" font="2">Collection on Stock Multiprocessors. In the Proc. of the Con-</text>
<text top="1061" left="106" width="334" height="11" font="2">ference on Programming Language Design and Implementa-</text>
<text top="1075" left="106" width="105" height="11" font="2">tion (PLDI), 1988.</text>
<text top="112" left="482" width="163" height="11" font="2">[2] A. W. Appel and K. Li.</text>
<text top="112" left="657" width="177" height="11" font="2">Virtual Memory Primitives for</text>
<text top="125" left="501" width="334" height="11" font="2">User Programs. In the Proc. of the International Conference</text>
<text top="139" left="501" width="334" height="11" font="2">on Architectural Support for Programming Languages and</text>
<text top="152" left="501" width="206" height="11" font="2">Operating Systems (ASPLOS), 1991.</text>
<text top="171" left="482" width="352" height="11" font="2">[3] L. Baugh, N. Neelakantam, and C. Zilles. Using Hardware</text>
<text top="185" left="501" width="334" height="11" font="2">Memory Protection to Build a High-Performance, Strongly-</text>
<text top="198" left="501" width="334" height="11" font="2">Atomic Hybrid Transactional Memory. In the Proc. of the In-</text>
<text top="212" left="501" width="334" height="11" font="2">ternational Symposium on Computer Architecture (ISCA),</text>
<text top="225" left="501" width="29" height="11" font="2">2008.</text>
<text top="245" left="482" width="352" height="11" font="2">[4] B. Beander. VAX DEBUG: An Interactive, Symbolic, Mul-</text>
<text top="258" left="501" width="334" height="11" font="2">tilingual Debugger. In the Proc. of the Software Engineering</text>
<text top="272" left="501" width="239" height="11" font="2">Symposium on High-level Debugging, 1983.</text>
<text top="291" left="482" width="352" height="11" font="2">[5] T. Bergan, J. Devietti, N. Hunt, and L. Ceze. The Determin-</text>
<text top="304" left="501" width="334" height="11" font="2">istic Execution Hammer: How Well Does it Actually Pound</text>
<text top="318" left="501" width="334" height="11" font="2">Nails? In the Workshop on Determinism and Correctness in</text>
<text top="331" left="501" width="213" height="11" font="2">Parallel Programming (WoDet), 2011.</text>
<text top="351" left="482" width="352" height="11" font="2">[6] E. D. Berger, T. Yang, T. Liu, and G. Novark. Grace: Safe</text>
<text top="364" left="501" width="334" height="11" font="2">Multithreaded Programming for C/C++. In the Proc. of the</text>
<text top="378" left="501" width="334" height="11" font="2">International Conference on Object-Oriented Programming,</text>
<text top="391" left="501" width="318" height="11" font="2">Systems, Languages, and Applications (OOPSLA), 2009.</text>
<text top="411" left="482" width="352" height="11" font="2">[7] A. Bessey, K. Block, B. Chelf, A. Chou, B. Fulton, S. Hallem,</text>
<text top="424" left="501" width="334" height="11" font="2">C. Henri-Gros, A. Kamsky, S. McPeak, and D. Engler. A</text>
<text top="437" left="501" width="334" height="11" font="2">Few Billion Lines of Code Later: Using Static Analysis to</text>
<text top="451" left="501" width="334" height="11" font="2">Find Bugs in the Real World. Communications of the ACM,</text>
<text top="464" left="501" width="155" height="11" font="2">53(2):66–75, February 2010.</text>
<text top="484" left="482" width="282" height="11" font="2">[8] C. Bienia, S. Kumar, J. P. Singh, and K. Li.</text>
<text top="484" left="776" width="59" height="11" font="2">The PAR-</text>
<text top="497" left="501" width="334" height="11" font="2">SEC Benchmark Suite: Characterization and Architectural</text>
<text top="511" left="501" width="334" height="11" font="2">Implications. In the Proc. of the International Conference on</text>
<text top="524" left="501" width="334" height="11" font="2">Parallel Architectures and Compilation Techniques (PACT),</text>
<text top="538" left="501" width="29" height="11" font="2">2008.</text>
<text top="557" left="482" width="352" height="11" font="2">[9] E. Bosman, A. Slowinska, and H. Bos. Minemu: The World’s</text>
<text top="570" left="501" width="334" height="11" font="2">Fastest Taint Tracker. In the Proc. of the International Sym-</text>
<text top="584" left="501" width="334" height="11" font="2">posium on Recent Advances in Intrusion Detection (RAID),</text>
<text top="597" left="501" width="29" height="11" font="2">2011.</text>
<text top="617" left="476" width="359" height="11" font="2">[10] S. Chaudhry, R. Cypher, M. Ekman, M. Karlsson, A. Landin,</text>
<text top="630" left="501" width="225" height="11" font="2">S. Yip, H. Zeﬀer, and M. Tremblay.</text>
<text top="630" left="745" width="89" height="11" font="2">Rock: A High-</text>
<text top="644" left="501" width="334" height="11" font="2">Performance Sparc CMT Processor. IEEE Micro, 29(2):6–16,</text>
<text top="657" left="501" width="29" height="11" font="2">2009.</text>
<text top="677" left="476" width="359" height="11" font="2">[11] S. Chaudhry, R. Cypher, M. Ekman, M. Karlsson, A. Landin,</text>
<text top="690" left="501" width="334" height="11" font="2">S. Yip, H. Zeﬀer, and M. Tremblay. Simultaneous Speculative</text>
<text top="703" left="501" width="334" height="11" font="2">Threading: A Novel Pipeline Architecture Implemented in</text>
<text top="717" left="501" width="334" height="11" font="2">Sun’s ROCK Processor. In the Proc. of the International</text>
<text top="730" left="501" width="296" height="11" font="2">Symposium on Computer Architecture (ISCA), 2009.</text>
<text top="750" left="476" width="359" height="11" font="2">[12] S. Chen, J. Xu, N. Nakka, Z. Kalbarczyk, and R. K. Iyer.</text>
<text top="763" left="501" width="334" height="11" font="2">Defeating Memory Corruption Attacks via Pointer Tainted-</text>
<text top="777" left="501" width="334" height="11" font="2">ness Detection. In the Proc. of the International Conference</text>
<text top="790" left="501" width="289" height="11" font="2">on Dependable Systems and Networks (DSN), 2005.</text>
<text top="810" left="476" width="359" height="11" font="2">[13] C. J. Cheney. A Nonrecursive List Compacting Algorithm.</text>
<text top="823" left="501" width="334" height="11" font="2">Communications of the ACM, 13(11):677–678, November</text>
<text top="836" left="501" width="29" height="11" font="2">1970.</text>
<text top="856" left="476" width="359" height="11" font="2">[14] T. Chiueh. Fast Bounds Checking Using Debug Registers.</text>
<text top="869" left="501" width="334" height="11" font="2">In the Proc. of the International Conference on High Per-</text>
<text top="883" left="501" width="334" height="11" font="2">formance Embedded Architectures &amp; Compilers (HiPEAC),</text>
<text top="896" left="501" width="29" height="11" font="2">2008.</text>
<text top="916" left="476" width="359" height="11" font="2">[15] D. R. Ditzel. Architectural Support for Programming Lan-</text>
<text top="929" left="501" width="334" height="11" font="2">guages in the X-Tree Processor. In Spring COMPCON, 1980.</text>
<text top="949" left="476" width="359" height="11" font="2">[16] J. Erickson, M. Musuvathi, S. Burckhardt, and K. Olynyk.</text>
<text top="962" left="501" width="334" height="11" font="2">Eﬀective Data-Race Detection for the Kernel. In the Proc.</text>
<text top="975" left="501" width="334" height="11" font="2">of the Symposium on Operating Systems Design and Imple-</text>
<text top="989" left="501" width="140" height="11" font="2">mentation (OSDI), 2010.</text>
<text top="1008" left="476" width="241" height="11" font="2">[17] R. R. Fenichel and J. C. Yochelson.</text>
<text top="1008" left="731" width="103" height="11" font="2">A LISP Garbage-</text>
<text top="1022" left="501" width="334" height="11" font="2">Collector for Virtual-Memory Computer Systems. Commu-</text>
<text top="1035" left="501" width="309" height="11" font="2">nications of the ACM, 12(11):611–612, November 1969.</text>
<text top="1055" left="476" width="359" height="11" font="2">[18] J. L. Greathouse, C. LeBlanc, T. Austin, and V. Bertacco.</text>
<text top="1068" left="501" width="334" height="11" font="2">Highly Scalable Distributed Dataﬂow Analysis. In the Proc.</text>
</page>
<page number="13" position="absolute" top="0" left="0" height="1188" width="918">
<text top="112" left="106" width="334" height="11" font="2">of the Symposium on Code Generation and Optimization</text>
<text top="125" left="106" width="76" height="11" font="2">(CGO), 2011.</text>
<text top="145" left="81" width="359" height="11" font="2">[19] J. L. Greathouse, Z. Ma, M. I. Frank, R. Peri, and T. Austin.</text>
<text top="158" left="106" width="334" height="11" font="2">Demand-Driven Software Race Detection using Hardware</text>
<text top="171" left="106" width="129" height="11" font="2">Performance Counters.</text>
<text top="171" left="248" width="192" height="11" font="2">In the Proc. of the International</text>
<text top="185" left="106" width="296" height="11" font="2">Symposium on Computer Architecture (ISCA), 2011.</text>
<text top="204" left="81" width="359" height="11" font="2">[20] M. D. Hill, D. Hower, K. E. Moore, M. M. Swift, H. Volos,</text>
<text top="218" left="106" width="104" height="11" font="2">and D. A. Wood.</text>
<text top="218" left="223" width="216" height="11" font="2">A Case for Deconstructing Hardware</text>
<text top="231" left="106" width="334" height="11" font="2">Transactional Memory Systems. Technical report, University</text>
<text top="245" left="106" width="159" height="11" font="2">of Wisconsin-Madison, 2007.</text>
<text top="264" left="81" width="359" height="11" font="2">[21] A. Ho, M. Fetterman, C. Clark, A. Warﬁeld, and S. Hand.</text>
<text top="278" left="106" width="334" height="11" font="2">Practical Taint-Based Protection using Demand Emulation.</text>
<text top="291" left="106" width="334" height="11" font="2">In the Proc. of the European Conference on Computer Sys-</text>
<text top="304" left="106" width="123" height="11" font="2">tems (EuroSys), 2006.</text>
<text top="324" left="81" width="359" height="11" font="2">[22] M. S. Johnson. Some Requirements for Architectural Sup-</text>
<text top="337" left="106" width="334" height="11" font="2">port of Software Debugging. In the Proc. of the International</text>
<text top="351" left="106" width="334" height="11" font="2">Conference on Architectural Support for Programming Lan-</text>
<text top="364" left="106" width="272" height="11" font="2">guages and Operating Systems (ASPLOS), 1982.</text>
<text top="384" left="81" width="280" height="11" font="2">[23] K. Kelsey, T. Bai, C. Ding, and C. Zhang.</text>
<text top="384" left="374" width="65" height="11" font="2">Fast Track:</text>
<text top="397" left="106" width="334" height="11" font="2">A Software System for Speculative Program Optimization.</text>
<text top="411" left="106" width="334" height="11" font="2">In the Proc. of the Symposium on Code Generation and</text>
<text top="424" left="106" width="154" height="11" font="2">Optimization (CGO), 2009.</text>
<text top="443" left="81" width="359" height="11" font="2">[24] E. Larson and T. Austin. High Coverage Detection of Input-</text>
<text top="457" left="106" width="334" height="11" font="2">Related Security Faults. In the Proc. of the USENIX Security</text>
<text top="470" left="106" width="100" height="11" font="2">Symposium, 2003.</text>
<text top="490" left="81" width="359" height="11" font="2">[25] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,</text>
<text top="503" left="106" width="334" height="11" font="2">G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood. Pin:</text>
<text top="517" left="106" width="334" height="11" font="2">Building Customized Program Analysis Tools with Dynamic</text>
<text top="530" left="106" width="334" height="11" font="2">Instrumentation. In the Proc. of the Conference on Program-</text>
<text top="544" left="106" width="327" height="11" font="2">ming Language Design and Implementation (PLDI), 2005.</text>
<text top="563" left="81" width="359" height="11" font="2">[26] J. Lyu, Y. Kim, Y. Kim, and I. Lee. A Procedure-Based</text>
<text top="576" left="106" width="334" height="11" font="2">Dynamic Software Update. In the Proc. of the International</text>
<text top="590" left="106" width="334" height="11" font="2">Conference on Dependable Systems and Networks (DSN),</text>
<text top="603" left="106" width="29" height="11" font="2">2001.</text>
<text top="623" left="81" width="359" height="11" font="2">[27] R. E. McLear, D. M. Scheibelhut, and E. Tammaru. Guide-</text>
<text top="636" left="106" width="334" height="11" font="2">lines for Creating a Debuggable Processor. In the Proc. of</text>
<text top="650" left="106" width="334" height="11" font="2">the International Conference on Architectural Support for</text>
<text top="663" left="106" width="334" height="11" font="2">Programming Languages and Operating Systems (ASPLOS),</text>
<text top="677" left="106" width="29" height="11" font="2">1982.</text>
<text top="696" left="81" width="179" height="11" font="2">[28] L. McVoy and C. Staelin.</text>
<text top="696" left="276" width="164" height="11" font="2">lmbench: Portable Tools for</text>
<text top="709" left="106" width="334" height="11" font="2">Performance Analysis. In the Proc. of the USENIX Annual</text>
<text top="723" left="106" width="155" height="11" font="2">Technical Conference, 1996.</text>
<text top="742" left="81" width="359" height="11" font="2">[29] S. Mysore, B. Mazloom, B. Agrawal, and T. Sherwood.</text>
<text top="756" left="106" width="334" height="11" font="2">Understanding and Visualizing Full Systems with Data Flow</text>
<text top="769" left="106" width="334" height="11" font="2">Tomography. In the Proc. of the International Conference</text>
<text top="783" left="106" width="334" height="11" font="2">on Architectural Support for Programming Languages and</text>
<text top="796" left="106" width="206" height="11" font="2">Operating Systems (ASPLOS), 2008.</text>
<text top="816" left="81" width="201" height="11" font="2">[30] N. Neelakantam and C. Zilles.</text>
<text top="816" left="294" width="146" height="11" font="2">UFO: A General-Purpose</text>
<text top="829" left="106" width="334" height="11" font="2">User-Mode Memory Protection Technique for Application</text>
<text top="842" left="106" width="24" height="11" font="2">Use.</text>
<text top="842" left="145" width="295" height="11" font="2">Technical report, University of Illinois at Urbana-</text>
<text top="856" left="106" width="100" height="11" font="2">Champaign, 2007.</text>
<text top="875" left="81" width="359" height="11" font="2">[31] R. H. B. Netzer and B. P. Miller. What Are Race Conditions?</text>
<text top="889" left="106" width="334" height="11" font="2">Some Issues and Formalizations. ACM Letters on Program-</text>
<text top="902" left="106" width="306" height="11" font="2">ming Languages and Systems, 1(1):74–88, March 1992.</text>
<text top="922" left="81" width="192" height="11" font="2">[32] F. Qin, S. Lu, and Y. Zhou.</text>
<text top="922" left="284" width="155" height="11" font="2">SafeMem: Exploiting ECC-</text>
<text top="935" left="106" width="334" height="11" font="2">Memory for Detecting Memory Leaks and Memory Corrup-</text>
<text top="949" left="106" width="334" height="11" font="2">tion During Produciton Runs. In the Proc. of the Interna-</text>
<text top="962" left="106" width="334" height="11" font="2">tional Symposium on High-Performance Computer Architec-</text>
<text top="975" left="106" width="111" height="11" font="2">ture (HPCA), 2005.</text>
<text top="995" left="81" width="359" height="11" font="2">[33] C. Ranger, R. Raghuraman, A. Penmetsa, G. Bradski, and</text>
<text top="1008" left="106" width="78" height="11" font="2">C. Kozyrakis.</text>
<text top="1008" left="196" width="244" height="11" font="2">Evaluating MapReduce for Multi-core and</text>
<text top="1022" left="106" width="334" height="11" font="2">Multiprocessor Systems. In the Proc. of the International</text>
<text top="1035" left="106" width="334" height="11" font="2">Symposium on High-Performance Computer Architecture</text>
<text top="1049" left="106" width="84" height="11" font="2">(HPCA), 2007.</text>
<text top="112" left="476" width="359" height="11" font="2">[34] I. Schoinas, B. Falsaﬁ, A. R. Lebeck, S. K. Reinhardt, J. R.</text>
<text top="125" left="501" width="334" height="11" font="2">Larus, and D. A. Wood. Fine-grain Access Control for Dis-</text>
<text top="139" left="501" width="334" height="11" font="2">tributed Shared Memory. In the Proc. of the International</text>
<text top="152" left="501" width="334" height="11" font="2">Conference on Architectural Support for Programming Lan-</text>
<text top="165" left="501" width="272" height="11" font="2">guages and Operating Systems (ASPLOS), 1994.</text>
<text top="185" left="476" width="359" height="11" font="2">[35] E. Schonberg. On-The-Fly Detection of Access Anomalies.</text>
<text top="198" left="501" width="334" height="11" font="2">In the Proc. of the Conference on Programming Language</text>
<text top="212" left="501" width="238" height="11" font="2">Design and Implementation (PLDI), 1989.</text>
<text top="231" left="476" width="359" height="11" font="2">[36] E. Schrock. Watchpoints 101. <a href="http://blogs.oracle.com/eschrock/entry/watchpoints_101">http://blogs.oracle.com/</a></text>
<text top="246" left="501" width="255" height="10" font="2"><a href="http://blogs.oracle.com/eschrock/entry/watchpoints_101">eschrock/entry/watchpoints_101, </a>July 2004.</text>
<text top="264" left="476" width="199" height="11" font="2">[37] J. Seward and N. Nethercote.</text>
<text top="264" left="688" width="147" height="11" font="2">Using Valgrind to Detect</text>
<text top="278" left="501" width="334" height="11" font="2">Undeﬁned Value Errors with Bit-precision. In the Proc. of</text>
<text top="291" left="501" width="276" height="11" font="2">the USENIX Annual Technical Conference, 2005.</text>
<text top="310" left="476" width="359" height="11" font="2">[38] A. Shriraman and S. Dwarkadas. Sentry: Light-Weight Aux-</text>
<text top="324" left="501" width="334" height="11" font="2">iliary Memory Access Control. In the Proc. of the Interna-</text>
<text top="337" left="501" width="332" height="11" font="2">tional Symposium on Computer Architecture (ISCA), 2010.</text>
<text top="357" left="476" width="359" height="11" font="2">[39] B. Sprunt. The Basics of Performance-Monitoring Hardware.</text>
<text top="370" left="501" width="177" height="11" font="2">IEEE Micro, 22(4):64–71, 2002.</text>
<text top="390" left="476" width="359" height="11" font="2">[40] M. Tiwari, B. Agrawal, S. Mysore, J. Valamehr, and T. Sher-</text>
<text top="403" left="501" width="334" height="11" font="2">wood. A Small Cache of Large Ranges: Hardware Methods</text>
<text top="417" left="501" width="334" height="11" font="2">for Eﬃciently Searching, Storing, and Updating Big Dataﬂow</text>
<text top="430" left="501" width="334" height="11" font="2">Tags. In the Proc. of the International Symposium on Mi-</text>
<text top="443" left="501" width="178" height="11" font="2">croarchitecture (MICRO), 2008.</text>
<text top="463" left="476" width="359" height="11" font="2">[41] G. Venkataramani, I. Doudalis, Y. Solihin, and M. Prvulovic.</text>
<text top="476" left="501" width="334" height="11" font="2">FlexiTaint: A Programmable Accelerator for Dynamic Taint</text>
<text top="490" left="501" width="334" height="11" font="2">Propagation. In the Proc. of the International Symposium on</text>
<text top="503" left="501" width="323" height="11" font="2">High-Performance Computer Architecture (HPCA), 2008.</text>
<text top="523" left="476" width="359" height="11" font="2">[42] G. Venkataramani, B. Roemer, Y. Solihin, and M. Prvulovic.</text>
<text top="536" left="501" width="334" height="11" font="2">MemTracker: Eﬃcient and Programmable Support for Mem-</text>
<text top="550" left="501" width="334" height="11" font="2">ory Access Monitoring and Debugging. In the Proc. of the</text>
<text top="563" left="501" width="334" height="11" font="2">International Symposium on High-Performance Computer</text>
<text top="576" left="501" width="156" height="11" font="2">Architecture (HPCA), 2007.</text>
<text top="596" left="476" width="86" height="11" font="2">[43] R. Wahbe.</text>
<text top="596" left="575" width="157" height="11" font="2">Eﬃcient Data Breakpoints.</text>
<text top="596" left="745" width="89" height="11" font="2">In the Proc. of</text>
<text top="609" left="501" width="334" height="11" font="2">the International Conference on Architectural Support for</text>
<text top="623" left="501" width="334" height="11" font="2">Programming Languages and Operating Systems (ASPLOS),</text>
<text top="636" left="501" width="29" height="11" font="2">1992.</text>
<text top="656" left="476" width="359" height="11" font="2">[44] Z. Wang, X. Jiang, W. Cui, and P. Ning. Countering Kernel</text>
<text top="669" left="501" width="334" height="11" font="2">Rootkits with Lightweight Hook Protection. In the Proc. of</text>
<text top="683" left="501" width="334" height="11" font="2">the Conference on Computer and Communications Security</text>
<text top="696" left="501" width="73" height="11" font="2">(CCS), 2009.</text>
<text top="715" left="476" width="359" height="11" font="2">[45] E. Witchel. Considerations for Mondriaan-like Systems. In</text>
<text top="729" left="501" width="334" height="11" font="2">the Workshop on Duplicating, Deconstructing, and Debunk-</text>
<text top="742" left="501" width="111" height="11" font="2">ing (WDDD), 2009.</text>
<text top="762" left="476" width="359" height="11" font="2">[46] E. Witchel, J. Cates, and K. Asanovic. Mondrian Memory</text>
<text top="775" left="501" width="62" height="11" font="2">Protection.</text>
<text top="775" left="574" width="260" height="11" font="2">In the Proc. of the International Conference</text>
<text top="789" left="501" width="334" height="11" font="2">on Architectural Support for Programming Languages and</text>
<text top="802" left="501" width="206" height="11" font="2">Operating Systems (ASPLOS), 2002.</text>
<text top="821" left="476" width="359" height="11" font="2">[47] M. T. Yourst. PTLsim: A Cycle Accurate Full System x86-</text>
<text top="835" left="501" width="334" height="11" font="2">64 Microarchitectural Simulator. In the Proc. of the Interna-</text>
<text top="848" left="501" width="334" height="11" font="2">tional Symposium on Performance Analysis of Systems and</text>
<text top="862" left="501" width="143" height="11" font="2">Software (ISPASS), 2007.</text>
<text top="881" left="476" width="359" height="11" font="2">[48] M. Zagha, B. Larson, S. Turner, and M. Itzkowitz. Perfor-</text>
<text top="895" left="501" width="334" height="11" font="2">mance Analysis Using the MIPS R10000 Performance Coun-</text>
<text top="908" left="501" width="334" height="11" font="2">ters. In the Proc. of the ACM/IEEE Conference on Super-</text>
<text top="922" left="501" width="94" height="11" font="2">computing, 1996.</text>
<text top="941" left="476" width="359" height="11" font="2">[49] Q. Zhao, D. Bruening, and S. Amarasinghe. Umbra: Eﬃ-</text>
<text top="954" left="501" width="334" height="11" font="2">cient and Scalable Memory Shadowing. In the Proc. of the</text>
<text top="968" left="501" width="334" height="11" font="2">Symposium on Code Generation and Optimization (CGO),</text>
<text top="981" left="501" width="29" height="11" font="2">2010.</text>
<text top="1001" left="476" width="359" height="11" font="2">[50] P. Zhou, F. Qin, W. Liu, Y. Zhou, and J. Torrellas. iWatcher:</text>
<text top="1014" left="501" width="334" height="11" font="2">Eﬃcient Architectural Support for Software Debugging. In</text>
<text top="1028" left="501" width="334" height="11" font="2">the Proc. of the International Symposium on Computer Ar-</text>
<text top="1041" left="501" width="136" height="11" font="2">chitecture (ISCA), 2004.</text>
</page>
</pdf2xml>
